<!DOCTYPE html><head><meta charset="UTF-8"><title>List of tutorials | RACCOON</title><link rel="icon" type="image/x-icon" href="../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="ab68d235-1f44-4353-94bf-d2d93b94ea9e" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="7f997af0-14a4-4cc6-be6e-bf5dd4af1e1c" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="db517b5a-53cf-4a8a-ab03-bb571177ee73" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="74ba36a0-3f08-4255-91f5-f9d2e69bbb2e" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="a9051101-32cd-4685-ba8e-2ef881e08033"><i class="material-icons">menu</i></a><ul class="sidenav" id="a9051101-32cd-4685-ba8e-2ef881e08033"><li><a href="#!" class="dropdown-trigger" data-target="f582e256-c4da-4b67-b7a8-51ee7a163523" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9294e792-a11e-45a0-9bb4-388a5b88e1f8" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b2f2f384-eedb-42a1-b807-ae0169486cac" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="806bd5ab-99e6-4c59-9e53-ca5dad20f2a3" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="ab68d235-1f44-4353-94bf-d2d93b94ea9e"><li><a href="../getting_started/install.html">Install RACCOON</a></li><li><a href="../getting_started/update.html">Update RACCOON</a></li><li><a href="../getting_started/running.html">Running your first model</a></li><li><a href="../getting_started/paraview.html">Visualization</a></li><li><a href="../getting_started/ide.html">Code development</a></li><li><a href="../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="7f997af0-14a4-4cc6-be6e-bf5dd4af1e1c"><li><a href="01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="09_three_point_bending.html">9. Three-point bending</a></li><li><a href="10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="12_nucleation.html">12. Crack nucleation</a></li><li><a href="13_traction_separation.html">13. Traction separation law</a></li><li><a href="14_klexpansion.html">14. Random field generation</a></li><li><a href="15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="db517b5a-53cf-4a8a-ab03-bb571177ee73"><li><a href="../theory/intro.html">Introduction</a></li><li><a href="../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../theory/minimization.html">The minimization problem</a></li><li><a href="../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="74ba36a0-3f08-4255-91f5-f9d2e69bbb2e"><li><a href="../modules/index.html">Physics modules</a></li><li><a href="../syntax/index.html">Complete syntax</a></li><li><a href="../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="f582e256-c4da-4b67-b7a8-51ee7a163523"><li><a href="../getting_started/install.html">Install RACCOON</a></li><li><a href="../getting_started/update.html">Update RACCOON</a></li><li><a href="../getting_started/running.html">Running your first model</a></li><li><a href="../getting_started/paraview.html">Visualization</a></li><li><a href="../getting_started/ide.html">Code development</a></li><li><a href="../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="9294e792-a11e-45a0-9bb4-388a5b88e1f8"><li><a href="01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="09_three_point_bending.html">9. Three-point bending</a></li><li><a href="10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="12_nucleation.html">12. Crack nucleation</a></li><li><a href="13_traction_separation.html">13. Traction separation law</a></li><li><a href="14_klexpansion.html">14. Random field generation</a></li><li><a href="15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="b2f2f384-eedb-42a1-b807-ae0169486cac"><li><a href="../theory/intro.html">Introduction</a></li><li><a href="../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../theory/minimization.html">The minimization problem</a></li><li><a href="../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="806bd5ab-99e6-4c59-9e53-ca5dad20f2a3"><li><a href="../modules/index.html">Physics modules</a></li><li><a href="../syntax/index.html">Complete syntax</a></li><li><a href="../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="6c3310d6-ed1a-4e6e-90bb-9ee4789c8a85" data-section-level="1" data-section-text="List of tutorials"><h1 id="list-of-tutorials">List of tutorials</h1><ul class="browser-default"><li><p><a href="01_small_deformation_elasticity.html">1. Small deformation</a> </p></li><li><p><a href="02_mode1_brittle_fracture.html">2. Mode-I fracture</a> </p></li><li><p><a href="03_mode2_brittle_fracture.html">3. Mode-II fracture</a> </p></li><li><p><a href="04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a> </p></li><li><p><a href="05_soil_desiccation.html">5. Soil desiccation</a> </p></li><li><p><a href="06_large_deformation_elasticity.html">6. Large deformation</a> </p></li><li><p><a href="07_elastoplasticity.html">7. Elastoplasticity</a> </p></li><li><p><a href="08_ductile_fracture.html">8. Ductile fracture</a> </p></li><li><p><a href="09_three_point_bending.html">9. Three-point bending</a> </p></li><li><p><a href="10_quenching_bibeam.html">10. Quenching of bi-beam</a> </p></li><li><p><a href="11_adaptivity.html">11. Adaptivity</a> </p></li><li><p><a href="12_nucleation.html">12. Crack nucleation</a> </p></li><li><p><a href="13_traction_separation.html">13. Traction separation law</a> </p></li><li><p><a href="14_klexpansion.html">14. Random field generation by KL expansion</a> </p></li><li><p><a href="15_mosaic_patches.html">15. Mosaic field generation (patches)</a></p></li></ul><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Before you proceed</div><div class="card-content"><div class="moose-alert-content"><p>All tutorials are written assuming that you are reasonably familiar with MOOSE. If you find most of the tutorials difficult to follow, please refer to <a href="https://mooseframework.inl.gov/">the official MOOSE website</a> for learning resources.</p></div></div></div></section><section id="ace6b513-5f98-472f-a3f7-27418101a87c" data-section-level="1" data-section-text="Tutorial 14 : Random field generation by KL expansion"><h1 id="tutorial-14-random-field-generation-by-kl-expansion">Tutorial 14: Random field generation by KL expansion</h1><p>In this tutorial, we will generate a spatially varied material property field with a controlled correlation length.</p><p>The generated field is ready to be used in <a href="05_soil_desiccation.html">Tutorial 5</a>.</p><section id="cd871d9c-ff8b-4858-9256-6249a53e731f" data-section-level="2" data-section-text="Step 0 : required packages"><h2 id="step-0-required-packages">Step 0: required packages</h2><p><code>Boost</code> is required for patch generation. While your Conda MOOSE environment is active, install boost by running:</p><pre style="max-height:350px;"><code class="language-text">
conda install boost
</code></pre></section><section id="5ae60c53-42b5-4d53-8e38-63b38e433c2c" data-section-level="2" data-section-text="Step 1 : build the Karhunen - Lo è ve expansions"><h2 id="step-1-build-the-karhunen-lo-ve-expansions">Step 1: build the Karhunen-Loève expansions</h2><p>For this step, navigate to folder <code>factorize/</code>. </p><p>In <code>klexpansion.C</code>:</p><p>Line 52 provided the mesh for the kl expansion construction (this mesh does not have to be identical to the mesh for the physical problem).</p><pre style="max-height:350px;"><code class="language-text">
MeshTools::Generation::build_square(mesh, 50, 50, 0, 100, 0, 100, QUAD4);
</code></pre><p>builds a 2d square mesh occupying coordinate [0,100]x[0,100], and discretizing by 50x50 QUAD4 elements. This mesh has to be fine enough to fully resolve the correlation length. You need at least 4 nodes per correlation length.<br>Guides on generating other types of meshes <a href="https://libmesh.github.io/doxygen/namespacelibMesh_1_1MeshTools_1_1Generation.html">MeshTools:Generation</a><br>Can also read in a mesh by <code>mesh.read(&quot;YourMesh&quot;);</code> </p><p>Line 207-208:</p><pre style="max-height:350px;"><code class="language-text">
  PSE covariance_x(10, 100);
  PSE covariance_y(10, 100);
</code></pre><p>defines the kernel type (PSE or PE), correlation length <span class="moose-katex-inline-equation" id="moose-equation-1c3d88c8-c49e-4ea8-9c63-8c97879db1af"><script>var element = document.getElementById("moose-equation-1c3d88c8-c49e-4ea8-9c63-8c97879db1af");katex.render("L=10", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> (or any value given by the user), and periodicity <span class="moose-katex-inline-equation" id="moose-equation-286fdd34-b182-459d-961e-6ba00465d4eb"><script>var element = document.getElementById("moose-equation-286fdd34-b182-459d-961e-6ba00465d4eb");katex.render("p=100", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> (the size of the domain). Kernels are defined in <code>covariance_functions.h</code></p><p>To compile this code</p><pre style="max-height:350px;"><code class="language-text">
make
#  To clean old output and runtime files, run make clean
</code></pre><p>After a successful compilation, run the executable by</p><pre style="max-height:350px;"><code class="language-text">
./klexpansion-opt
</code></pre><p>or in parallel, by</p><pre style="max-height:350px;"><code class="language-text">
mpiexec -n NumberofTasks ./klexpansion-opt 
</code></pre><p>Once it is complete, the KL expansions needed for random field sampling will be stored in a new exodus file. By default this is <code>basis.e</code>.</p></section><section id="a052315c-13fc-4c41-848a-e46527bd3756" data-section-level="2" data-section-text="Step 2 : sampling the random field"><h2 id="step-2-sampling-the-random-field">Step 2: sampling the random field</h2><p>For this step, navigate to <code>sample/</code></p><p>In code <code>sample.C</code>:</p><p>Line 47</p><pre style="max-height:350px;"><code class="language-text">
mesh.read(&quot;../factorize/basis.e&quot;);
</code></pre><p>reads the KL expansions generated in step 1. Update this line as needed, and keep line 53 reading the same mesh as line 47.</p><p>Line 78-80:</p><pre style="max-height:350px;"><code class="language-text">
  std::vector&lt;Real&gt; Gc; # the name of field  1
  std::vector&lt;Real&gt; psic; # the name of field  2
  compute_correlated_Gamma_fields(Xi_1, Xi_2, Gc, 8e-4, 0.03, psic, 3e-5, 0.03, 0);
</code></pre><p>Field <span class="moose-katex-inline-equation" id="moose-equation-be755541-038b-4a4d-8405-fa87e51f166f"><script>var element = document.getElementById("moose-equation-be755541-038b-4a4d-8405-fa87e51f166f");katex.render("G_c", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> will be generated with mean <span class="moose-katex-inline-equation" id="moose-equation-492eb908-a6e8-4a28-8d70-0d6888c6dcee"><script>var element = document.getElementById("moose-equation-492eb908-a6e8-4a28-8d70-0d6888c6dcee");katex.render("8e-4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and coefficient of variation <span class="moose-katex-inline-equation" id="moose-equation-8eba1d90-135f-4d42-a776-c64b7ff3aadf"><script>var element = document.getElementById("moose-equation-8eba1d90-135f-4d42-a776-c64b7ff3aadf");katex.render("0.03", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>. Field <span class="moose-katex-inline-equation" id="moose-equation-f4cc4964-45a3-445e-a87d-9aa84498d96f"><script>var element = document.getElementById("moose-equation-f4cc4964-45a3-445e-a87d-9aa84498d96f");katex.render("\\psi_c", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> will be generated with mean <span class="moose-katex-inline-equation" id="moose-equation-d2b1f8a2-d982-4c84-8205-5e55101f28d2"><script>var element = document.getElementById("moose-equation-d2b1f8a2-d982-4c84-8205-5e55101f28d2");katex.render("3e-5", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and COV <span class="moose-katex-inline-equation" id="moose-equation-3c22cd5a-eae3-4f8c-914f-7141949165e9"><script>var element = document.getElementById("moose-equation-3c22cd5a-eae3-4f8c-914f-7141949165e9");katex.render("0.03", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>. The correlation between the two fields is <span class="moose-katex-inline-equation" id="moose-equation-5d73b356-1557-4ac2-bfd4-ac8d372b7e9d"><script>var element = document.getElementById("moose-equation-5d73b356-1557-4ac2-bfd4-ac8d372b7e9d");katex.render("0", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</p><p>To compile the code</p><pre style="max-height:350px;"><code class="language-text">
make
</code></pre><p>To sample a random field</p><pre style="max-height:350px;"><code class="language-text">
./sample-opt
</code></pre><p>The tutorial code generates a new field with the default name <code>fields.e</code>.<br>Each time you run <code>./sample-opt</code>, a different field is generated with an updated random seed.</p></section><section id="8603e6ba-679c-4837-ac85-09af0ce0bc65" data-section-level="2" data-section-text="Example fields"><h2 id="example-fields">Example fields</h2><p>Below is a set of example random fields generated using different kernels, correlation lengths, and geometries.</p><div class="card moose-float" style="display:block;margin:auto;width:60%;" id="example"><div class="card-content"><picture class="materialboxed moose-image"><img src="../media/randomfield_examples.png" alt="randomfield_examples"></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 1: </span><span class="moose-caption-text" id="example">Samples of the (non-Gaussian) random field, generated with mean and coefficient of variation set to 1.0 and 3\%, respectively, for the sake of illustration. Here, <span class="moose-katex-inline-equation" id="moose-equation-49ff52bd-5a09-49e0-a010-a4f12fbada43"><script>var element = document.getElementById("moose-equation-49ff52bd-5a09-49e0-a010-a4f12fbada43");katex.render("L^* =L/a", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the normalized correlation length on the rectangular domain. <a href="#ZENG2025105170">Zeng et al. (2025)</a></span></p></div></div></section><section id="7cb870b6-0503-40a7-82fc-aa2139829564" data-section-level="2" data-section-text="Related source code"><h2 id="related-source-code">Related source code</h2><ul class="browser-default"><li><p><a class="moose-source-filename tooltipped modal-trigger" href="#74f65425-fa27-4e52-b9aa-61d32d6f5a90">Factorization</a> </p></li><li><p><a class="moose-source-filename tooltipped modal-trigger" href="#754b38cf-0b09-416e-9f12-2e93db2806ea">Sampling</a></p></li></ul><div class="moose-content-pagination" style="margin-top:24px;margin-bottom:24px;"><a href="13_traction_separation.html" class="moose-content-previous btn">Previous<i class="material-icons left">arrow_back</i></a><a href="15_mosaic_patches.html" class="moose-content-next btn">Next<i class="material-icons right">arrow_forward</i></a></div></section><section id="47b59dea-5037-4fbe-92fd-0a3b529af79b" data-section-level="2" data-section-text="References"><h2 id="references">References</h2><div class="moose-bibliography"><ol><li id="ZENG2025105170">Bo&nbsp;Zeng, Johann Guilleminot, and John&nbsp;E. Dolbow.
Examining crack nucleation under spatially uniform stress states with a complete phase-field model for fracture.
<em>Theoretical and Applied Fracture Mechanics</em>, pages 105170, 2025.
URL: <a href="https://www.sciencedirect.com/science/article/pii/S0167844225003283">https://www.sciencedirect.com/science/article/pii/S0167844225003283</a>, <a href="https://doi.org/https://doi.org/10.1016/j.tafmec.2025.105170">doi:https://doi.org/10.1016/j.tafmec.2025.105170</a>.<a href="#e8e7bb1d-fc6b-45c2-9220-01a8badf43b5" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="e8e7bb1d-fc6b-45c2-9220-01a8badf43b5"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{ZENG2025105170,
    author = "Zeng, Bo and Guilleminot, Johann and Dolbow, John E.",
    title = "Examining crack nucleation under spatially uniform stress states with a complete phase-field model for fracture",
    journal = "Theoretical and Applied Fracture Mechanics",
    pages = "105170",
    year = "2025",
    issn = "0167-8442",
    doi = "https://doi.org/10.1016/j.tafmec.2025.105170",
    url = "https://www.sciencedirect.com/science/article/pii/S0167844225003283",
    keywords = "Phase-field for fracture, Material strength, Nucleation, Quenching"
}
</code></pre></div></div></li></ol></div></section></section><div class="moose-modal modal" id="74f65425-fa27-4e52-b9aa-61d32d6f5a90"><div class="modal-content"><h4>(tutorials/klexpansion/factorize/klexpansion.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the RACCOON application
// being developed at Dolbow lab at Duke University
// http://dolbow.pratt.duke.edu

// libMesh include files.
#include &quot;libmesh/libmesh.h&quot;
#include &quot;libmesh/mesh.h&quot;
#include &quot;libmesh/mesh_generation.h&quot;
#include &quot;libmesh/exodusII_io.h&quot;
#include &quot;libmesh/eigen_system.h&quot;
#include &quot;libmesh/equation_systems.h&quot;
#include &quot;libmesh/slepc_eigen_solver.h&quot;
#include &quot;libmesh/fe.h&quot;
#include &quot;libmesh/quadrature_gauss.h&quot;
#include &quot;libmesh/dense_matrix.h&quot;
#include &quot;libmesh/sparse_matrix.h&quot;
#include &quot;libmesh/numeric_vector.h&quot;
#include &quot;libmesh/dof_map.h&quot;
#include &quot;libmesh/enum_eigen_solver_type.h&quot;
#include &quot;libmesh/petsc_matrix.h&quot;
#include &quot;slepcsys.h&quot;

#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

#include &quot;augment_sparsity_to_dense.h&quot;
#include &quot;covariance_functions.h&quot;

// Bring in everything from the libMesh namespace
using namespace libMesh;

// Function prototype.  This is the function that will assemble
// the eigen system.
void assembly(EquationSystems &amp; es);

int
main(int argc, char ** argv)
{
  // Check for proper usage.
  if (argc != 1)
    libmesh_error_msg(&quot;\nUsage: &quot; &lt;&lt; argv[0]);

  // Initialize libMesh and the dependent libraries.
  LibMeshInit init(argc, argv);

  // Create a mesh, with dimension to be overridden later, on the
  // default MPI communicator.
  // Use the internal mesh generator to create a uniform
  // 2D grid on a square.
  Mesh mesh(init.comm());
  MeshTools::Generation::build_square(mesh, 50, 50, 0, 100, 0, 100, QUAD4);
  mesh.print_info();

  // Create an equation systems object.
  EquationSystems equation_systems(mesh);

  // Create a EigenSystem named &quot;Eigensystem&quot; and (for convenience)
  // use a reference to the system we create.
  EigenSystem &amp; eigen_system = equation_systems.add_system&lt;EigenSystem&gt;(&quot;Eigensystem&quot;);
  eigen_system.assemble_before_solve = false;

  // Declare the system variables.
  // Adds the variable &quot;v&quot; to &quot;Eigensystem&quot;.
  // By default this is FIRST, LAGRANGE
  eigen_system.add_variable(&quot;v&quot;);

  // Augment the sparsity to dense since we are assemblying an integral equation.
  // In general you don&#x27;t need to do this if your equation doesn&#x27;t contain nonlocal contribution.
  std::shared_ptr&lt;AugmentSparsityToDense&gt; augment_sparsity(new AugmentSparsityToDense(mesh));
  eigen_system.get_dof_map().add_coupling_functor(augment_sparsity);

  // Set necessary parameters used in EigenSystem::solve(),
  // i.e. the number of requested eigenpairs nev and the number
  // of basis vectors ncv used in the solution algorithm. Note that
  // ncv &gt;= nev must hold and ncv &gt;= 2*nev is recommended.
  // Here we guess 1/10 eigenvalues will give us a good spectrum.
  equation_systems.parameters.set&lt;unsigned int&gt;(&quot;eigenpairs&quot;) = mesh.n_nodes();
  equation_systems.parameters.set&lt;unsigned int&gt;(&quot;basis vectors&quot;) = mesh.n_nodes();

  // You may optionally change the default eigensolver used by SLEPc.
  // The Krylov-Schur method is mathematically equivalent to implicitly
  // restarted Arnoldi, the method of Arpack, so there is currently no
  // point in using SLEPc with Arpack.
  // ARNOLDI     = default in SLEPc 2.3.1 and earlier
  // KRYLOVSCHUR default in SLEPc 2.3.2 and later
  // eigen_system.eigen_solver-&gt;set_eigensolver_type(KRYLOVSCHUR);

  // Set the solver tolerance and the maximum number of iterations.
  equation_systems.parameters.set&lt;Real&gt;(&quot;linear solver tolerance&quot;) = pow(TOLERANCE, 5. / 3.);
  equation_systems.parameters.set&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;) = 1000;

  // Set the type of the problem, here we deal with
  // a generalized Hermitian problem.
  eigen_system.set_eigenproblem_type(GHEP);

  // Initialize the data structures for the equation system.
  libMesh::out &lt;&lt; &quot;Initializing equation system...&quot;;
  equation_systems.init();
  libMesh::out &lt;&lt; &quot;complete&quot; &lt;&lt; std::endl;
  equation_systems.print_info();

  // Assemly
  assembly(equation_systems);

  // Solve the system &quot;Eigensystem&quot;.
  // We request eigenpairs with largest real eigenvalues.
  // As a result, eigenvalues will be sorted with descending real eigenvalues.
  libMesh::out &lt;&lt; &quot;Solving the generalized eigen system...&quot;;
  // PetscOptionsSetValue(PETSC_NULL, &quot;-eps_largest_real&quot;, PETSC_NULL);
  PetscOptionsSetValue(PETSC_NULLPTR, &quot;-eps_largest_real&quot;, PETSC_NULLPTR);
  eigen_system.solve();
  libMesh::out &lt;&lt; &quot;complete\n&quot; &lt;&lt; std::endl;

  // Get the number of converged eigen pairs.
  unsigned int nconv = eigen_system.get_n_converged();

  ExodusII_IO exo(mesh);
  Real eigval_prev = std::numeric_limits&lt;Real&gt;::max();
  Real eigval_sum = 0;
  unsigned int eigval_num;
  Real TOL = 1e-6;
  for (eigval_num = 0; eigval_num &lt; nconv; eigval_num++)
  {
    std::pair&lt;Real, Real&gt; eigval = eigen_system.get_eigenpair(eigval_num);
    exo.write_timestep(&quot;basis.e&quot;, equation_systems, eigval_num + 1, (Real)eigval_num);
    exo.write_global_data({eigval.first}, {&quot;d&quot;});
    if (eigval.first &lt; eigval_sum * TOL &amp;&amp; std::abs(eigval.first - eigval_prev) &gt; 1e-12)
    {
      libMesh::out &lt;&lt; &quot;converged with &quot; &lt;&lt; eigval_num &lt;&lt; &quot; eigenvalues.&quot; &lt;&lt; std::endl;
      break;
    }
    eigval_sum += eigval.first;
    eigval_prev = eigval.first;
  }
  libMesh::out &lt;&lt; &quot;Wrote &quot; &lt;&lt; eigval_num &lt;&lt; &quot; eigenvalues and eigenvectors.&quot; &lt;&lt; std::endl;

  return EXIT_SUCCESS;
}

void
assembly(EquationSystems &amp; es)
{
  libMesh::out &lt;&lt; &quot;Assemblying the eigen system&quot; &lt;&lt; std::endl;

  // Get a constant reference to the mesh object and the mesh dimension
  const MeshBase &amp; mesh = es.get_mesh();
  const unsigned int dim = mesh.mesh_dimension();

  // Get a reference to our system.
  // Get a constant reference to the Finite Element type
  // for the first (and only) variable in the system.
  EigenSystem &amp; eigen_system = es.get_system&lt;EigenSystem&gt;(&quot;Eigensystem&quot;);
  FEType fe_type = eigen_system.get_dof_map().variable_type(0);

  // A reference to the two system matrices
  SparseMatrix&lt;Number&gt; &amp; matrix_A = *eigen_system.matrix_A;
  SparseMatrix&lt;Number&gt; &amp; matrix_B = *eigen_system.matrix_B;

  // Build a Finite Element object of the specified type.  Since the
  // FEBase::build() member dynamically creates memory we will
  // store the object as a std::unique_ptr&lt;FEBase&gt;.  This can be thought
  // of as a pointer that will clean up after itself.
  std::unique_ptr&lt;FEBase&gt; fe(FEBase::build(dim, fe_type));
  std::unique_ptr&lt;FEBase&gt; fe_remote(FEBase::build(dim, fe_type));

  // A  Gauss quadrature rule for numerical integration.
  // Use the default quadrature order.
  QGauss qrule(dim, fe_type.default_quadrature_order());

  // Tell the finite element object to use our quadrature rule.
  fe-&gt;attach_quadrature_rule(&amp;qrule);
  fe_remote-&gt;attach_quadrature_rule(&amp;qrule);

  // The element Jacobian * quadrature weight at each integration point.
  const std::vector&lt;Real&gt; &amp; JxW = fe-&gt;get_JxW();
  const std::vector&lt;Real&gt; &amp; JxW_remote = fe_remote-&gt;get_JxW();

  // The element shape functions evaluated at the quadrature points.
  const std::vector&lt;std::vector&lt;Real&gt;&gt; &amp; phi = fe-&gt;get_phi();
  const std::vector&lt;std::vector&lt;Real&gt;&gt; &amp; phi_remote = fe_remote-&gt;get_phi();

  // The element shape function gradients evaluated at the quadrature
  // points.
  const std::vector&lt;std::vector&lt;RealGradient&gt;&gt; &amp; dphi = fe-&gt;get_dphi();

  // A reference to the DofMap object for this system.  The DofMap
  // object handles the index translation from node and element numbers
  // to degree of freedom numbers.
  const DofMap &amp; dof_map = eigen_system.get_dof_map();

  // The element mass and stiffness matrices.
  DenseMatrix&lt;Number&gt; Me;
  DenseMatrix&lt;Number&gt; Ke;

  // This vector will hold the degree of freedom indices for
  // the element.  These define where in the global system
  // the element degrees of freedom get mapped.
  std::vector&lt;dof_id_type&gt; dof_indices;
  std::vector&lt;dof_id_type&gt; dof_indices_remote;

  // Get quadrature point in the mapped space
  const std::vector&lt;Point&gt; &amp; q_points = fe-&gt;get_xyz();
  const std::vector&lt;Point&gt; &amp; q_points_remote = fe_remote-&gt;get_xyz();

  // Before we do the element loop, construct a covariance kernel
  PSE covariance_x(10, 100);
  PSE covariance_y(10, 100);

  // Now we will loop over all the elements in the mesh that
  // live on the local processor. We will compute the element
  // matrix and right-hand-side contribution.  In case users
  // later modify this program to include refinement, we will
  // be safe and will only consider the active elements;
  // hence we use a variant of the active_elem_iterator.
  unsigned int total = mesh.n_active_local_elem();
  unsigned int count = 0;
  Real progress_prev = 0;
  for (const auto &amp; elem : mesh.active_local_element_ptr_range())
  {
    // Get the degree of freedom indices for the
    // current element.  These define where in the global
    // matrix and right-hand-side this element will
    // contribute to.
    dof_map.dof_indices(elem, dof_indices);

    // Compute the element-specific data for the current
    // element.  This involves computing the location of the
    // quadrature points (q_point) and the shape functions
    // (phi, dphi) for the current element.
    fe-&gt;reinit(elem);

    // Zero the element matrices before
    // summing them.  We use the resize member here because
    // the number of degrees of freedom might have changed from
    // the last element.  Note that this will be the case if the
    // element type is different (i.e. the last element was a
    // triangle, now we are on a quadrilateral).
    const unsigned int n_dofs = cast_int&lt;unsigned int&gt;(dof_indices.size());
    Me.resize(n_dofs, n_dofs);

    // Now loop over the quadrature points.  This handles
    // the numeric integration.
    //
    // We will build the element matrix.  This involves
    // a double loop to integrate the test functions (i) against
    // the trial functions (j).
    for (unsigned int qp = 0; qp &lt; qrule.n_points(); qp++)
      for (unsigned int i = 0; i &lt; n_dofs; i++)
        for (unsigned int j = 0; j &lt; n_dofs; j++)
          Me(i, j) += JxW[qp] * phi[i][qp] * phi[j][qp];

    matrix_B.add_matrix(Me, dof_indices);

    for (unsigned int qp = 0; qp &lt; qrule.n_points(); qp++)
      for (unsigned int i = 0; i &lt; n_dofs; i++)
        for (const auto &amp; elem_remote : mesh.active_element_ptr_range())
        {
          dof_map.dof_indices(elem_remote, dof_indices_remote);
          fe_remote-&gt;reinit(elem_remote);
          const unsigned int n_dofs_remote = cast_int&lt;unsigned int&gt;(dof_indices_remote.size());
          Ke.resize(n_dofs, n_dofs_remote);
          for (unsigned int qp_remote = 0; qp_remote &lt; qrule.n_points(); qp_remote++)
          {
            Point lag = q_points[qp] - q_points_remote[qp_remote];
            Real R = covariance_x.covariance(std::abs(lag(0))) *
                     covariance_y.covariance(std::abs(lag(1)));
            for (unsigned int j = 0; j &lt; n_dofs_remote; j++)
              Ke(i, j) +=
                  R * phi[i][qp] * JxW[qp] * phi_remote[j][qp_remote] * JxW_remote[qp_remote];
          }
          matrix_A.add_matrix(Ke, dof_indices, dof_indices_remote);
        }

    count++;
    Real progress = (Real)count / total;
    if (progress &gt;= progress_prev + 0.1)
    {
      libMesh::out &lt;&lt; &quot;Assemblying the eigen system progress &quot; &lt;&lt; (progress_prev + 0.1) * 100 &lt;&lt; &quot;%&quot;
                   &lt;&lt; std::endl;
      progress_prev += 0.1;
    }
  }

  libMesh::out &lt;&lt; &quot;Assemblying the eigen system complete.\n&quot; &lt;&lt; std::endl;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="754b38cf-0b09-416e-9f12-2e93db2806ea"><div class="modal-content"><h4>(tutorials/klexpansion/sample/sample.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the RACCOON application
// being developed at Dolbow lab at Duke University
// http://dolbow.pratt.duke.edu

// libMesh include files.
#include &quot;libmesh/libmesh.h&quot;
#include &quot;libmesh/mesh.h&quot;
#include &quot;libmesh/exodusII_io.h&quot;
#include &quot;libmesh/exodusII_io_helper.h&quot;

#include &lt;boost/math/distributions.hpp&gt;
#include &lt;ctime&gt;
#include &lt;random&gt;

// Bring in everything from the libMesh namespace
using namespace libMesh;

std::vector&lt;Real&gt; sample_gaussian(const std::vector&lt;Real&gt; &amp; eigvals,
                                  const std::vector&lt;std::vector&lt;Real&gt;&gt; &amp; eigvecs,
                                  std::default_random_engine &amp; generator);

void compute_correlated_Gamma_fields(const std::vector&lt;Real&gt; &amp; Xi_1,
                                     const std::vector&lt;Real&gt; &amp; Xi_2,
                                     std::vector&lt;Real&gt; &amp; P_1,
                                     Real mean_1,
                                     Real CV_1,
                                     std::vector&lt;Real&gt; &amp; P_2,
                                     Real mean_2,
                                     Real CV_2,
                                     Real rho);

int
main(int argc, char ** argv)
{
  // Check for proper usage.
  if (argc != 1)
    libmesh_error_msg(&quot;\nUsage: &quot; &lt;&lt; argv[0]);

  // Initialize libMesh and the dependent libraries.
  LibMeshInit init(argc, argv);

  if (init.comm().size() &gt; 1)
    libmesh_error_msg(&quot;Parallel sampling is not supported, use 1 processor only.&quot;);

  // Read the mesh
  Mesh mesh(init.comm());
  mesh.read(&quot;../factorize/basis.e&quot;);

  // Read the eigenpairs
  std::vector&lt;Real&gt; eigvals;
  std::vector&lt;std::vector&lt;Real&gt;&gt; eigvecs;

  ExodusII_IO basis(mesh);
  basis.read(&quot;../factorize/basis.e&quot;);
  ExodusII_IO_Helper &amp; basis_helper = basis.get_exio_helper();
  for (int i = 1; i &lt; basis.get_num_time_steps(); i++)
  {
    // read eigenvalue
    std::vector&lt;Real&gt; eigval;
    basis.read_global_variable({&quot;d&quot;}, i, eigval);
    eigvals.push_back(eigval[0]);

    // read eigenvector
    basis_helper.read_nodal_var_values(&quot;v&quot;, i);
    std::vector&lt;Real&gt; vecOfValues;
    for (auto elem : basis_helper.nodal_var_values)
      vecOfValues.push_back(elem.second);
    eigvecs.push_back(vecOfValues);
  }

  // sample Gaussian fields
  std::default_random_engine generator;
  generator.seed(std::time(NULL));
  std::vector&lt;Real&gt; Xi_1 = sample_gaussian(eigvals, eigvecs, generator);
  std::vector&lt;Real&gt; Xi_2 = sample_gaussian(eigvals, eigvecs, generator);

  // transform to marginal Gamma fields
  std::vector&lt;Real&gt; Gc;
  std::vector&lt;Real&gt; psic;
  compute_correlated_Gamma_fields(Xi_1, Xi_2, Gc, 8e-4, 0.03, psic, 3e-5, 0.03, 0);

  // write random field
  ExodusII_IO fields(mesh);
  fields.write(&quot;fields.e&quot;);
  ExodusII_IO_Helper &amp; fields_helper = fields.get_exio_helper();
  fields_helper.initialize_nodal_variables({&quot;Gc&quot;, &quot;psic&quot;});
  fields_helper.write_nodal_values(1, Gc, 1);
  fields_helper.write_nodal_values(2, psic, 1);

  return EXIT_SUCCESS;
}

std::vector&lt;Real&gt;
sample_gaussian(const std::vector&lt;Real&gt; &amp; eigvals,
                const std::vector&lt;std::vector&lt;Real&gt;&gt; &amp; eigvecs,
                std::default_random_engine &amp; generator)
{
  unsigned int ndof = eigvecs[0].size();
  std::vector&lt;Real&gt; Xi(ndof);
  std::normal_distribution&lt;Real&gt; distribution(0.0, 1.0);

  for (unsigned int i = 0; i &lt; eigvals.size(); i++)
  {
    Real eta = distribution(generator);
    for (unsigned int j = 0; j &lt; ndof; j++)
      Xi[j] += std::sqrt(eigvals[i]) * eta * eigvecs[i][j];
  }

  return Xi;
}

void
compute_correlated_Gamma_fields(const std::vector&lt;Real&gt; &amp; Xi_1,
                                const std::vector&lt;Real&gt; &amp; Xi_2,
                                std::vector&lt;Real&gt; &amp; P_1,
                                Real mean_1,
                                Real CV_1,
                                std::vector&lt;Real&gt; &amp; P_2,
                                Real mean_2,
                                Real CV_2,
                                Real rho)
{
  unsigned int ndof = Xi_1.size();

  // Normal distribution
  auto normal = boost::math::normal_distribution&lt;Real&gt;(0, 1);

  // Gamma distribution for the first field
  Real std_1 = CV_1 * mean_1;
  Real var_1 = std_1 * std_1;
  Real theta_1 = var_1 / mean_1;
  Real k_1 = mean_1 / theta_1;

  // Gamma distribution for the second field
  Real std_2 = CV_2 * mean_2;
  Real var_2 = std_2 * std_2;
  Real theta_2 = var_2 / mean_2;
  Real k_2 = mean_2 / theta_2;

  // Transform into the first field
  P_1.resize(ndof);
  for (unsigned int i = 0; i &lt; ndof; i++)
    P_1[i] = theta_1 * boost::math::gamma_p_inv&lt;Real, Real&gt;(k_1, boost::math::cdf(normal, Xi_1[i]));

  // Transform into the first field
  P_2.resize(ndof);
  for (unsigned int i = 0; i &lt; ndof; i++)
    P_2[i] = theta_2 *
             boost::math::gamma_p_inv&lt;Real, Real&gt;(
                 k_2, boost::math::cdf(normal, rho * Xi_1[i] + std::sqrt(1 - rho * rho) * Xi_2[i]));
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../js/init.js"></script><script type="text/javascript" src="../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../js/sqa_moose.js"></script>
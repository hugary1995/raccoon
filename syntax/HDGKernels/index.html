<!DOCTYPE html><head><meta charset="UTF-8"><title>HDG Kernels | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="a5ee8829-1279-4e31-b9d6-223915b1fbd0" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="dbfacc0b-0214-47df-a1e3-cbca61cb5d28" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="e32f2230-fde0-44a7-bad9-e19f2a751f8d" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="a21fd4f6-a733-42c0-8109-2f07c1aa1c7e" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="898bcd10-7fbb-4bc8-91b3-df8e60610806"><i class="material-icons">menu</i></a><ul class="sidenav" id="898bcd10-7fbb-4bc8-91b3-df8e60610806"><li><a href="#!" class="dropdown-trigger" data-target="9b512f86-604a-4fc3-935d-c46ad8117b63" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="464e6ff2-28f0-437f-bc41-d3477511fe75" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="becc8428-8b2e-4ed7-8444-49ed582ab8af" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9ed67345-88a4-4be5-8d72-9f5e2e286ed3" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="a5ee8829-1279-4e31-b9d6-223915b1fbd0"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="dbfacc0b-0214-47df-a1e3-cbca61cb5d28"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="e32f2230-fde0-44a7-bad9-e19f2a751f8d"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="a21fd4f6-a733-42c0-8109-2f07c1aa1c7e"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="9b512f86-604a-4fc3-935d-c46ad8117b63"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="464e6ff2-28f0-437f-bc41-d3477511fe75"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="becc8428-8b2e-4ed7-8444-49ed582ab8af"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="9ed67345-88a4-4be5-8d72-9f5e2e286ed3"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="574cf4a2-e6d6-4e4e-897f-e4b0c3b0496f" data-section-level="1" data-section-text="HDG Kernels"><h1 id="hdg-kernels">HDG Kernels</h1><p>HDG kernels are an advanced systems that should only be developed by users with a fair amount of finite element experience. For background on hybridization, we encourage the user to read (<a href="#cockburn2009unified">Cockburn et al., 2009</a>) which presents a unified framework for considering hybridization of discontinuous Galerkin, mixed, and continuous Galerkin methods for elliptic problems. (<a href="#cockburn2008superconvergent">Cockburn et al., 2008</a>) presents a single-face hybridizable discontinuous Galerkin (HDG) method for an elliptic problem, in which a non-zero stabilization term is added to only one face of a given element. (<a href="#nguyen2010hybridizable">Nguyen et al., 2010</a>) presents an HDG method for Stokes flow. (<a href="#nguyen2011implicit">Nguyen et al., 2011</a>) extends HDG to Navier-Stokes. More HDG literature may be found by looking at the research of Bernardo Cockburn, his former postdoc Sander Rhebergen, and Rhebergen&#x27;s former postdoc Tamas Horvath. Work by Tan Bui-Thanh on upwind HDG methods, like in (<a href="#bui2015godunov">Bui-Thanh, 2015</a>) is also worth noting.</p><p>A hybridized finite element formulation starts with some primal finite element discretization. Then some continuity property of the finite element space is broken. For instance Raviart-Thomas finite elements may be used to solve a mixed formulation description of a Poisson problem. The Raviart-Thomas elements ensure continuity of the normal component of the vector field across element faces. We break that continuity in the finite element space used in the hybridized method and instead introduce degrees of freedom, that live only on the mesh skeleton (the faces of the mesh), that are responsible for ensuring the continuity that was lost by breaking the finite element space. In libMesh/MOOSE implementation terms, when hybridizing the Raviart-Thomas description of the Poisson problem, we change from using a <code>RAVIART_THOMAS</code> basis to an <code>L2_RAVIART_THOMAS</code> basis and introduce a <code>SIDE_HIERARCHIC</code> variable whose degrees of freedom live on the mesh skeleton. We will refer to the variables that exist &quot;before&quot; the hybridization as primal variables and the variable(s) that live on the mesh skeleton as Lagrange multipliers (LMs) or dual variable(s).</p><p>We note that some classes of HDG methods, such as the LDG method in (<a href="#cockburn2008superconvergent">Cockburn et al., 2008</a>), have the gradient as an independent primal variable. With these methods, for diffusion or diffusion-dominated problems, the primal gradient and primal scalar variable fields can be used to postprocess a scalar field that converges with order <span class="moose-katex-inline-equation" id="moose-equation-e4c1a016-947b-4464-b53d-7ee959989c78"><script>var element = document.getElementById("moose-equation-e4c1a016-947b-4464-b53d-7ee959989c78");katex.render("k + 2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> in the <span class="moose-katex-inline-equation" id="moose-equation-5f95abd0-2024-4fa8-9d85-cffb51fd211f"><script>var element = document.getElementById("moose-equation-5f95abd0-2024-4fa8-9d85-cffb51fd211f");katex.render("L^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> norm, where <span class="moose-katex-inline-equation" id="moose-equation-35fdf7e2-421c-4c06-8300-87763cff19c5"><script>var element = document.getElementById("moose-equation-35fdf7e2-421c-4c06-8300-87763cff19c5");katex.render("k", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the polynomial order of the primal scalar variable. However, as advection becomes dominant, the higher order convergence is lost and consequently so is the value of having the gradient as an independent variable. In advection-dominated cases, interior penalty HDG methods, such as that outlined in (<a href="#rhebergen2017analysis">Rhebergen and Wells, 2017</a>), may be a good choice.</p><section id="47c5c237-dbf4-40b7-bef7-ce983fc0641b" data-section-level="2" data-section-text="Implementation in MOOSE"><h2 id="implementation-in-moose">Implementation in MOOSE</h2><p>HDG kernels derive from <a href="../Kernels/index.html">Kernels</a>. However, they add additional interfaces: <code>computeResidualOnSide</code> and <code>computeJacobianOnSide</code> which must be overridden and <code>computeResidualAndJacobianOnSide</code> which may be optionally overridden if the HDG kernel developer wishes to enable the ability to compute the residual and Jacobian together. These interfaces will be called on internal faces on a per-element basis. This means that a given internal face will be visited twice, once from each element side. External boundary condition integration occurs with standard boundary condition classes, see <a href="../BCs/index.html">BCs System</a>.</p><p>There are currently two HDG implementations in MOOSE: L-HDG and IP-HDG. Both L-HDG and IP-HDG kernel classes inherit from <code>HDGKernel</code> but that is where their similarity ends. L-HDG currently implements physics monolithically, e.g. the L-HDG discretization of the Navier-Stokes equations, both mass and momentum, is contained entirely within a single kernel. However, the MOOSE IP-HDG implementation is modular; like is typically the case in MOOSE, there is a single kernel object per PDE term. So for a 2D setup of the Navier-Stokes equations, there are five kernels. Two advection kernels for the x- and y-momentum component equations, two stress kernel (which contains both viscous stress and pressure) for the x- and y-momentum component equations, and one advection kernel for the mass equation.</p><p>This difference in kernel design naturally has consequences for boundary conditions. The monolithic kernel design for L-HDG leads to monolithic boundary conditions. Modularity for IP-HDG kernels means modular boundary conditions, e.g. a user may end up specifying multiple integrated boundary conditions on a single boundary like is done in</p><pre style="max-height:350px;"><code class="language-moose">[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../BCs/index.html&quot;}&gt;&gt;&gt;]
  [dirichlet_diff]
    type = DiffusionIPHDGDirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Weakly imposes Dirichlet boundary conditions for a hybridized discretization of a diffusion equation&quot;, &quot;href&quot;: &quot;../../source/bcs/DiffusionIPHDGDirichletBC.html&quot;}&gt;&gt;&gt;
    functor&lt;&lt;&lt;{&quot;description&quot;: &quot;The Dirichlet value for the primal variable. A functor is any of the following: a variable, a functor material property, a function, a postprocessor or a number.&quot;}&gt;&gt;&gt; = exact
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = &#x27;left right top bottom&#x27;
  []
  [dirichlet_adv]
    type = AdvectionIPHDGDirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Weakly imposes Dirichlet boundary conditions for a hybridized discretization of an advection equation&quot;, &quot;href&quot;: &quot;../../source/bcs/AdvectionIPHDGDirichletBC.html&quot;}&gt;&gt;&gt;
    functor&lt;&lt;&lt;{&quot;description&quot;: &quot;The Dirichlet value for the primal variable. A functor is any of the following: a variable, a functor material property, a function, a postprocessor or a number.&quot;}&gt;&gt;&gt; = exact
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = &#x27;left right top bottom&#x27;
    coeff&lt;&lt;&lt;{&quot;description&quot;: &quot;A constant coefficient. This could be something like a density&quot;}&gt;&gt;&gt; = 1
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#d0104ac4-bd2f-485e-bd11-483a75a253d8">(moose/test/tests/hdgkernels/ip-advection-diffusion/mms-advection-diffusion.i)</a><p>In the future we may make L-HDG design more modular, although the monolithic approach does have the advantage of less required user input. However, less user input may also be achieved in the future by leveraging the <a href="/Physics/index.md">Physics</a><a href="../Physics/index.html">Physics system</a>. </p></section><section id="40bd0ba8-cb86-4183-895b-86c9b3018573" data-section-level="2" data-section-text="References"><h2 id="references">References</h2><div class="moose-bibliography"><ol><li id="bui2015godunov">Tan Bui-Thanh.
From godunov to a unified hybridized discontinuous galerkin framework for partial differential equations.
<em>Journal of Computational Physics</em>, 295:114–146, 2015.<a href="#bf0a1999-b15e-46ef-955e-cc367ee5e54b" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="bf0a1999-b15e-46ef-955e-cc367ee5e54b"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{bui2015godunov,
    author = "Bui-Thanh, Tan",
    title = "From Godunov to a unified hybridized discontinuous Galerkin framework for partial differential equations",
    journal = "Journal of Computational Physics",
    volume = "295",
    pages = "114--146",
    year = "2015",
    publisher = "Elsevier"
}
</code></pre></div></div></li><li id="cockburn2008superconvergent">Bernardo Cockburn, Bo&nbsp;Dong, and Johnny Guzm<span class="bibtex-protected">á</span>n.
A superconvergent ldg-hybridizable galerkin method for second-order elliptic problems.
<em>Mathematics of Computation</em>, 77(264):1887–1916, 2008.<a href="#f412a0b0-0c10-4425-ad20-affc090f9aab" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="f412a0b0-0c10-4425-ad20-affc090f9aab"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{cockburn2008superconvergent,
    author = "Cockburn, Bernardo and Dong, Bo and Guzm{\'a}n, Johnny",
    title = "A superconvergent LDG-hybridizable Galerkin method for second-order elliptic problems",
    journal = "Mathematics of Computation",
    volume = "77",
    number = "264",
    pages = "1887--1916",
    year = "2008"
}
</code></pre></div></div></li><li id="cockburn2009unified">Bernardo Cockburn, Jayadeep Gopalakrishnan, and Raytcho Lazarov.
Unified hybridization of discontinuous galerkin, mixed, and continuous galerkin methods for second order elliptic problems.
<em>SIAM Journal on Numerical Analysis</em>, 47(2):1319–1365, 2009.<a href="#28b146bf-6461-433d-b411-beb8710b72f2" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="28b146bf-6461-433d-b411-beb8710b72f2"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{cockburn2009unified,
    author = "Cockburn, Bernardo and Gopalakrishnan, Jayadeep and Lazarov, Raytcho",
    title = "Unified hybridization of discontinuous Galerkin, mixed, and continuous Galerkin methods for second order elliptic problems",
    journal = "SIAM Journal on Numerical Analysis",
    volume = "47",
    number = "2",
    pages = "1319--1365",
    year = "2009",
    publisher = "SIAM"
}
</code></pre></div></div></li><li id="nguyen2010hybridizable">Ngoc&nbsp;Cuong Nguyen, Jaime Peraire, and Bernardo Cockburn.
A hybridizable discontinuous galerkin method for stokes flow.
<em>Computer Methods in Applied Mechanics and Engineering</em>, 199(9-12):582–597, 2010.<a href="#d3e1d42d-0bbd-4192-9e87-5323a554beb7" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="d3e1d42d-0bbd-4192-9e87-5323a554beb7"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{nguyen2010hybridizable,
    author = "Nguyen, Ngoc Cuong and Peraire, Jaime and Cockburn, Bernardo",
    title = "A hybridizable discontinuous Galerkin method for Stokes flow",
    journal = "Computer Methods in Applied Mechanics and Engineering",
    volume = "199",
    number = "9-12",
    pages = "582--597",
    year = "2010",
    publisher = "Elsevier"
}
</code></pre></div></div></li><li id="nguyen2011implicit">Ngoc&nbsp;Cuong Nguyen, Jaume Peraire, and Bernardo Cockburn.
An implicit high-order hybridizable discontinuous galerkin method for the incompressible navier–stokes equations.
<em>Journal of Computational Physics</em>, 230(4):1147–1170, 2011.<a href="#053f6e6e-f97b-4b8b-9567-503be979962b" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="053f6e6e-f97b-4b8b-9567-503be979962b"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{nguyen2011implicit,
    author = "Nguyen, Ngoc Cuong and Peraire, Jaume and Cockburn, Bernardo",
    title = "An implicit high-order hybridizable discontinuous Galerkin method for the incompressible Navier--Stokes equations",
    journal = "Journal of Computational Physics",
    volume = "230",
    number = "4",
    pages = "1147--1170",
    year = "2011",
    publisher = "Elsevier"
}
</code></pre></div></div></li><li id="rhebergen2017analysis">Sander Rhebergen and Garth&nbsp;N Wells.
Analysis of a hybridized/interface stabilized finite element method for the stokes equations.
<em>SIAM Journal on Numerical Analysis</em>, 55(4):1982–2003, 2017.<a href="#45e1c0ab-1acb-4253-a15d-8afca5ab7170" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="45e1c0ab-1acb-4253-a15d-8afca5ab7170"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{rhebergen2017analysis,
    author = "Rhebergen, Sander and Wells, Garth N",
    title = "Analysis of a hybridized/interface stabilized finite element method for the Stokes equations",
    journal = "SIAM Journal on Numerical Analysis",
    volume = "55",
    number = "4",
    pages = "1982--2003",
    year = "2017",
    publisher = "SIAM"
}
</code></pre></div></div></li></ol></div></section></section><div class="moose-modal modal" id="d0104ac4-bd2f-485e-bd11-483a75a253d8"><div class="modal-content"><h4>(moose/test/tests/hdgkernels/ip-advection-diffusion/mms-advection-diffusion.i)</h4><pre style="max-height:350px;"><code class="language-moose">diff = 2
a = 2

[GlobalParams]
  variable = u
  face_variable = side_u
  diffusivity = ${diff}
  alpha = 10
  velocity = vel
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  elem_type = TRI6
[]

[Variables]
  [u]
    order = FIRST
    family = L2_LAGRANGE
  []
  [side_u]
    order = FIRST
    family = LAGRANGE
  []
[]

[Kernels]
  [ffn]
    type = BodyForce
    variable = u
    function = forcing
  []
[]

[HDGKernels]
  [diff]
    type = DiffusionIPHDGKernel
  []
  [adv]
    type = AdvectionIPHDGKernel
    coeff = 1
  []
[]

[BCs]
  [dirichlet_diff]
    type = DiffusionIPHDGDirichletBC
    functor = exact
    boundary = &#x27;left right top bottom&#x27;
  []
  [dirichlet_adv]
    type = AdvectionIPHDGDirichletBC
    functor = exact
    boundary = &#x27;left right top bottom&#x27;
    coeff = 1
  []
[]

[Materials]
  [vel]
    type = ADGenericConstantVectorMaterial
    prop_names = &#x27;vel&#x27;
    prop_values = &#x27;${a} ${fparse 2*a} 0&#x27;
  []
[]

[Functions]
  [exact]
    type = ParsedFunction
    expression = &#x27;sin(x)*cos(y)&#x27;
  []
  [forcing]
    type = ParsedFunction
    expression = &#x27;-2*a*sin(x)*sin(y) + a*cos(x)*cos(y) + 2*diff*sin(x)*cos(y)&#x27;
    symbol_names = &#x27;a diff&#x27;
    symbol_values = &#x27;${a} ${diff}&#x27;
  []
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-10
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  solve_type = NEWTON
[]

[Outputs]
  csv = true
[]

[Postprocessors]
  [h]
    type = AverageElementSize
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  []
  [L2u]
    type = ElementL2Error
    variable = u
    function = exact
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
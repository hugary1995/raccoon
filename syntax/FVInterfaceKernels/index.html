<!DOCTYPE html><head><meta charset="UTF-8"><title>FVInterfaceKernels System | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="9a0ca424-acc7-44b4-a7ab-3b88a6ad3d7f" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="509120b8-4408-462b-99ec-ab817f8860e4" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1804898b-5e79-4501-87b2-f1c168de1918" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="4497a60a-5e02-4e8c-9c21-9f42e901be59" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="2041a4bc-99fe-4946-9419-37572a7311f0"><i class="material-icons">menu</i></a><ul class="sidenav" id="2041a4bc-99fe-4946-9419-37572a7311f0"><li><a href="#!" class="dropdown-trigger" data-target="54fb8518-edf5-4e72-ac30-77650b756b59" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="70762f65-e39b-4a4a-a56d-d1589128e437" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f530e529-ac87-41c9-8584-89950bc3b7d8" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="90093052-24d4-498a-bdf5-8e1c8c4cc6f5" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="9a0ca424-acc7-44b4-a7ab-3b88a6ad3d7f"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="509120b8-4408-462b-99ec-ab817f8860e4"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="1804898b-5e79-4501-87b2-f1c168de1918"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="4497a60a-5e02-4e8c-9c21-9f42e901be59"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="54fb8518-edf5-4e72-ac30-77650b756b59"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="70762f65-e39b-4a4a-a56d-d1589128e437"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="f530e529-ac87-41c9-8584-89950bc3b7d8"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="90093052-24d4-498a-bdf5-8e1c8c4cc6f5"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="e26029d2-e98c-418a-a738-5de1ff590b5c" data-section-level="1" data-section-text="FVInterfaceKernels System"><h1 id="fvinterfacekernels-system">FVInterfaceKernels System</h1><p>For an overview of MOOSE FV please see <a href="../../finite_volumes/fv_design.html">Finite Volume Design Decisions in MOOSE</a>.</p><p><code>FVInterfaceKernels</code> are meant to communicate data at interfaces between subdomains. An <code>FVInterfaceKernel</code> may contribute to the residuals/Jacobians of a single variable, specified with the parameter <code>variable1</code>, or to multiple variables by also using the <code>variable2</code> parameter. There are two additional critical/required parameters: <code>subdomain1</code> and <code>subdomain2</code>. In cases for which an <code>FVInterfaceKernel</code> is operating on two variables, <code>subdomain1</code> should correspond to the subdomain(s) neighboring the <code>boundary</code> parameter that <code>variable1</code> lives on, and similarly for <code>subdomain2</code> and <code>variable2</code>. By checking the <code>subdomain</code> parameters against the subdomain IDs of the <code>FaceInfo::elem</code> and <code>FaceInfo::neighbor</code> members a <code>FVInterfaceKernel</code> developer can be sure that they are fetching and using sensical data. For instance, a developer may want to create an <code>FVInterfaceKernel</code> that uses <code>prop1</code> on the <code>subdomain1</code> side of the <code>boundary</code> and <code>prop2</code> on the <code>subdomain2</code> side of the boundary. However, MOOSE only provides these APIs for fetching material properties: <code>get(AD)MaterialProperty</code> and <code>getNeighbor(AD)MaterialProperty</code>. The return value of <code>get(AD)MaterialProperty</code> will always correspond to a material property evaluation on the <code>FaceInfo::elem</code> side of a (inter)face, while the return value of <code>getNeighbor(AD)MaterialProperty</code> will always correspond to a material property evaluation on the <code>FaceInfo::neighbor</code> side of a (inter)face. However, when moving along an interface, it is possible that the <code>FaceInfo::elem</code> side of the interface is sometimes the <code>subdomain1</code> side and sometimes the <code>subdomain2</code> side. So making use of the <code>subdomain</code> parameters, we provide a protected method called <code>elemIsOne()</code> that returns a boolean indicating whether the <code>FaceInfo::elem</code> side of the interface corresponds to the <code>subdomain1</code> side of the interface. This allows the developer to write code like the following:</p><pre style="max-height:350px;"><code class="language-text">
FVFooInterface::FVFooInterface(const InputParameters &amp; params)
  : FVInterfaceKernel(params),
    _coeff1_elem(getADMaterialProperty&lt;Real&gt;(&quot;coeff1&quot;)),
    _coeff2_elem(getADMaterialProperty&lt;Real&gt;(&quot;coeff2&quot;)),
    _coeff1_neighbor(getNeighborADMaterialProperty&lt;Real&gt;(&quot;coeff1&quot;)),
    _coeff2_neighbor(getNeighborADMaterialProperty&lt;Real&gt;(&quot;coeff2&quot;))
{
}

ADReal
FVFooInterface::computeQpResidual()
{
  const auto &amp; coef_elem = elemIsOne() ? _coeff1_elem : _coeff2_elem;
  const auto &amp; coef_neighbor = elemIsOne() ? _coeff2_neighbor : _coeff1_neighbor;

  /// Code that uses coef_elem and coef_neighbor
}
</code></pre><p>and have confidence that they have good data in <code>coef_elem</code> and <code>coef_neighbor</code> and have clarity about what is happening in their code.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>When using an FVInterfaceKernel which connects variables that belong to different nonlinear systems, create two kernels with flipped variable and material property parameters. The reason behind this is that the interface kernel will only contribute to the system which <code>variable1</code> belongs to. For an example, see:</p><pre style="max-height:350px;"><code class="language-moose">[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../Mesh/index.html&quot;}&gt;&gt;&gt;]
  [gmg]
    type = CartesianMeshGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;This CartesianMeshGenerator creates a non-uniform Cartesian mesh.&quot;, &quot;href&quot;: &quot;../../source/meshgenerators/CartesianMeshGenerator.html&quot;}&gt;&gt;&gt;
    dim&lt;&lt;&lt;{&quot;description&quot;: &quot;The dimension of the mesh to be generated&quot;}&gt;&gt;&gt; = 1
    ix&lt;&lt;&lt;{&quot;description&quot;: &quot;Number of grids in all intervals in the X direction (default to all one)&quot;}&gt;&gt;&gt; = &#x27;50 50&#x27;
    dx&lt;&lt;&lt;{&quot;description&quot;: &quot;Intervals in the X direction&quot;}&gt;&gt;&gt; = &#x27;1 1&#x27;
    subdomain_id&lt;&lt;&lt;{&quot;description&quot;: &quot;Block IDs (default to all zero)&quot;}&gt;&gt;&gt; = &#x27;0 1&#x27;
  []
  [sds]
    type = SideSetsBetweenSubdomainsGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;MeshGenerator that creates a sideset composed of the nodes located between two or more subdomains.&quot;, &quot;href&quot;: &quot;../../source/meshgenerators/SideSetsBetweenSubdomainsGenerator.html&quot;}&gt;&gt;&gt;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh we want to modify&quot;}&gt;&gt;&gt; = gmg
    new_boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary names to create on the supplied subdomain&quot;}&gt;&gt;&gt; = &#x27;between&#x27;
    paired_block&lt;&lt;&lt;{&quot;description&quot;: &quot;The paired set of blocks for which to draw a sideset between&quot;}&gt;&gt;&gt; = &#x27;1&#x27;
    primary_block&lt;&lt;&lt;{&quot;description&quot;: &quot;The primary set of blocks for which to draw a sideset between&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
  []
[]

[Problem&lt;&lt;&lt;{&quot;href&quot;: &quot;../Problem/index.html&quot;}&gt;&gt;&gt;]
  nl_sys_names = &#x27;u v&#x27;
  error_on_jacobian_nonzero_reallocation = true
[]

[Variables&lt;&lt;&lt;{&quot;href&quot;: &quot;../Variables/index.html&quot;}&gt;&gt;&gt;]
  [u]
    type = MooseVariableFVReal&lt;&lt;&lt;{&quot;description&quot;: &quot;Base class for Moose variables. This should never be the terminal object type&quot;, &quot;href&quot;: &quot;../../source/variables/MooseVariableFV.html&quot;}&gt;&gt;&gt;
    solver_sys&lt;&lt;&lt;{&quot;description&quot;: &quot;If this variable is a solver variable, this is the solver system to which it should be added.&quot;}&gt;&gt;&gt; = &#x27;u&#x27;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  []
  [v]
    type = MooseVariableFVReal&lt;&lt;&lt;{&quot;description&quot;: &quot;Base class for Moose variables. This should never be the terminal object type&quot;, &quot;href&quot;: &quot;../../source/variables/MooseVariableFV.html&quot;}&gt;&gt;&gt;
    solver_sys&lt;&lt;&lt;{&quot;description&quot;: &quot;If this variable is a solver variable, this is the solver system to which it should be added.&quot;}&gt;&gt;&gt; = &#x27;v&#x27;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 1
  []
[]

[FVKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../FVKernels/index.html&quot;}&gt;&gt;&gt;]
  [diff_u]
    type = FVDiffusion&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes residual for diffusion operator for finite volume method.&quot;, &quot;href&quot;: &quot;../../source/fvkernels/FVDiffusion.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = u
    coeff&lt;&lt;&lt;{&quot;description&quot;: &quot;diffusion coefficient. A functor is any of the following: a variable, a functor material property, a function, a postprocessor or a number.&quot;}&gt;&gt;&gt; = 3.0
  []
  [force_u]
    type = FVBodyForce&lt;&lt;&lt;{&quot;description&quot;: &quot;Demonstrates the multiple ways that scalar values can be introduced into finite volume kernels, e.g. (controllable) constants, functions, and postprocessors.&quot;, &quot;href&quot;: &quot;../../source/fvkernels/FVBodyForce.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = u
    function&lt;&lt;&lt;{&quot;description&quot;: &quot;A function that describes the body force&quot;}&gt;&gt;&gt; = 5
  []
  [diff_v]
    type = FVDiffusion&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes residual for diffusion operator for finite volume method.&quot;, &quot;href&quot;: &quot;../../source/fvkernels/FVDiffusion.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = v
    coeff&lt;&lt;&lt;{&quot;description&quot;: &quot;diffusion coefficient. A functor is any of the following: a variable, a functor material property, a function, a postprocessor or a number.&quot;}&gt;&gt;&gt; = 1.0
  []
  [force_v]
    type = FVBodyForce&lt;&lt;&lt;{&quot;description&quot;: &quot;Demonstrates the multiple ways that scalar values can be introduced into finite volume kernels, e.g. (controllable) constants, functions, and postprocessors.&quot;, &quot;href&quot;: &quot;../../source/fvkernels/FVBodyForce.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = v
    function&lt;&lt;&lt;{&quot;description&quot;: &quot;A function that describes the body force&quot;}&gt;&gt;&gt; = 5
  []
[]

[FVInterfaceKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;index.html&quot;}&gt;&gt;&gt;]
  [diff_ik]
    type = FVDiffusionInterface&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the residual for diffusion operator across an interface for the finite volume method.&quot;, &quot;href&quot;: &quot;../../source/fviks/FVDiffusionInterface.html&quot;}&gt;&gt;&gt;
    variable1&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the first variable that this interface kernel applies to&quot;}&gt;&gt;&gt; = u
    variable2&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the second variable that this interface kernel applies to. If not supplied, variable1 will be used.&quot;}&gt;&gt;&gt; = v
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = &#x27;between&#x27;
    coeff1&lt;&lt;&lt;{&quot;description&quot;: &quot;The diffusion coefficient on the 1st subdomain&quot;}&gt;&gt;&gt; = 3
    coeff2&lt;&lt;&lt;{&quot;description&quot;: &quot;The diffusion coefficient on the 2nd subdomain&quot;}&gt;&gt;&gt; = 1
    subdomain1&lt;&lt;&lt;{&quot;description&quot;: &quot;The subdomains on the 1st side of the boundary.&quot;}&gt;&gt;&gt; = 0
    subdomain2&lt;&lt;&lt;{&quot;description&quot;: &quot;The subdomains on the 2nd side of the boundary.&quot;}&gt;&gt;&gt; = 1
  []
  [diff_ik_v]
    type = FVDiffusionInterface&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the residual for diffusion operator across an interface for the finite volume method.&quot;, &quot;href&quot;: &quot;../../source/fviks/FVDiffusionInterface.html&quot;}&gt;&gt;&gt;
    variable1&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the first variable that this interface kernel applies to&quot;}&gt;&gt;&gt; = v
    variable2&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the second variable that this interface kernel applies to. If not supplied, variable1 will be used.&quot;}&gt;&gt;&gt; = u
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = &#x27;between&#x27;
    coeff1&lt;&lt;&lt;{&quot;description&quot;: &quot;The diffusion coefficient on the 1st subdomain&quot;}&gt;&gt;&gt; = 1
    coeff2&lt;&lt;&lt;{&quot;description&quot;: &quot;The diffusion coefficient on the 2nd subdomain&quot;}&gt;&gt;&gt; = 3
    subdomain1&lt;&lt;&lt;{&quot;description&quot;: &quot;The subdomains on the 1st side of the boundary.&quot;}&gt;&gt;&gt; = 1
    subdomain2&lt;&lt;&lt;{&quot;description&quot;: &quot;The subdomains on the 2nd side of the boundary.&quot;}&gt;&gt;&gt; = 0
  []
[]

[FVBCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../FVBCs/index.html&quot;}&gt;&gt;&gt;]
  [left_u]
    type = FVDirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Defines a Dirichlet boundary condition for finite volume method.&quot;, &quot;href&quot;: &quot;../../source/fvbcs/FVDirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this boundary condition applies to&quot;}&gt;&gt;&gt; = u
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;value to enforce at the boundary face&quot;}&gt;&gt;&gt; = 0
  []
  [right_v]
    type = FVDirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Defines a Dirichlet boundary condition for finite volume method.&quot;, &quot;href&quot;: &quot;../../source/fvbcs/FVDirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this boundary condition applies to&quot;}&gt;&gt;&gt; = v
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;value to enforce at the boundary face&quot;}&gt;&gt;&gt; = 1
  []
[]

[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [u]
    type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
    nl_sys&lt;&lt;&lt;{&quot;description&quot;: &quot;The nonlinear system whose linearization this preconditioner should be applied to.&quot;}&gt;&gt;&gt; = u
    petsc_options&lt;&lt;&lt;{&quot;description&quot;: &quot;Singleton PETSc options&quot;}&gt;&gt;&gt; = &#x27;-snes_monitor&#x27;
    petsc_options_iname&lt;&lt;&lt;{&quot;description&quot;: &quot;Names of PETSc name/value pairs&quot;}&gt;&gt;&gt; = &#x27;-pc_type -pc_hypre_type&#x27;
    petsc_options_value&lt;&lt;&lt;{&quot;description&quot;: &quot;Values of PETSc name/value pairs (must correspond with \&quot;petsc_options_iname\&quot;&quot;}&gt;&gt;&gt; = &#x27;hypre boomeramg&#x27;
  []
  [v]
    type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
    nl_sys&lt;&lt;&lt;{&quot;description&quot;: &quot;The nonlinear system whose linearization this preconditioner should be applied to.&quot;}&gt;&gt;&gt; = v
    petsc_options&lt;&lt;&lt;{&quot;description&quot;: &quot;Singleton PETSc options&quot;}&gt;&gt;&gt; = &#x27;-snes_monitor&#x27;
    petsc_options_iname&lt;&lt;&lt;{&quot;description&quot;: &quot;Names of PETSc name/value pairs&quot;}&gt;&gt;&gt; = &#x27;-pc_type -pc_hypre_type&#x27;
    petsc_options_value&lt;&lt;&lt;{&quot;description&quot;: &quot;Values of PETSc name/value pairs (must correspond with \&quot;petsc_options_iname\&quot;&quot;}&gt;&gt;&gt; = &#x27;hypre boomeramg&#x27;
  []
[]

[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = SteadySolve2
  solve_type = &#x27;NEWTON&#x27;
  first_nl_sys_to_solve = &#x27;u&#x27;
  second_nl_sys_to_solve = &#x27;v&#x27;
  number_of_iterations = 200
  nl_abs_tol = 1e-10
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../Outputs/index.html&quot;}&gt;&gt;&gt;]
  print_nonlinear_residuals&lt;&lt;&lt;{&quot;description&quot;: &quot;Enable printing of nonlinear residuals to the screen (Console)&quot;}&gt;&gt;&gt; = false
  print_linear_residuals&lt;&lt;&lt;{&quot;description&quot;: &quot;Enable printing of linear residuals to the screen (Console)&quot;}&gt;&gt;&gt; = false
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#e19f2c11-0f06-4225-a5a0-0d3b157eeabd">(moose/test/tests/fviks/diffusion/multisystem.i)</a><p></p></div></div></div></section><div class="moose-modal modal" id="e19f2c11-0f06-4225-a5a0-0d3b157eeabd"><div class="modal-content"><h4>(moose/test/tests/fviks/diffusion/multisystem.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  [gmg]
    type = CartesianMeshGenerator
    dim = 1
    ix = &#x27;50 50&#x27;
    dx = &#x27;1 1&#x27;
    subdomain_id = &#x27;0 1&#x27;
  []
  [sds]
    type = SideSetsBetweenSubdomainsGenerator
    input = gmg
    new_boundary = &#x27;between&#x27;
    paired_block = &#x27;1&#x27;
    primary_block = &#x27;0&#x27;
  []
[]

[Problem]
  nl_sys_names = &#x27;u v&#x27;
  error_on_jacobian_nonzero_reallocation = true
[]

[Variables]
  [u]
    type = MooseVariableFVReal
    solver_sys = &#x27;u&#x27;
    block = 0
  []
  [v]
    type = MooseVariableFVReal
    solver_sys = &#x27;v&#x27;
    block = 1
  []
[]

[FVKernels]
  [diff_u]
    type = FVDiffusion
    variable = u
    coeff = 3.0
  []
  [force_u]
    type = FVBodyForce
    variable = u
    function = 5
  []
  [diff_v]
    type = FVDiffusion
    variable = v
    coeff = 1.0
  []
  [force_v]
    type = FVBodyForce
    variable = v
    function = 5
  []
[]

[FVInterfaceKernels]
  [diff_ik]
    type = FVDiffusionInterface
    variable1 = u
    variable2 = v
    boundary = &#x27;between&#x27;
    coeff1 = 3
    coeff2 = 1
    subdomain1 = 0
    subdomain2 = 1
  []
  [diff_ik_v]
    type = FVDiffusionInterface
    variable1 = v
    variable2 = u
    boundary = &#x27;between&#x27;
    coeff1 = 1
    coeff2 = 3
    subdomain1 = 1
    subdomain2 = 0
  []
[]

[FVBCs]
  [left_u]
    type = FVDirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right_v]
    type = FVDirichletBC
    variable = v
    boundary = right
    value = 1
  []
[]

[Preconditioning]
  [u]
    type = SMP
    nl_sys = u
    petsc_options = &#x27;-snes_monitor&#x27;
    petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
    petsc_options_value = &#x27;hypre boomeramg&#x27;
  []
  [v]
    type = SMP
    nl_sys = v
    petsc_options = &#x27;-snes_monitor&#x27;
    petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
    petsc_options_value = &#x27;hypre boomeramg&#x27;
  []
[]

[Executioner]
  type = SteadySolve2
  solve_type = &#x27;NEWTON&#x27;
  first_nl_sys_to_solve = &#x27;u&#x27;
  second_nl_sys_to_solve = &#x27;v&#x27;
  number_of_iterations = 200
  nl_abs_tol = 1e-10
[]

[Outputs]
  print_nonlinear_residuals = false
  print_linear_residuals = false
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
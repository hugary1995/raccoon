<!DOCTYPE html><head><meta charset="UTF-8"><title>Postprocessor System | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="dc0971e6-37a4-4353-a2f1-f8c110154eaf" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d7508cff-c35d-4076-9114-3c337d486092" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="c29035c0-bee8-49bc-bc87-730f73d1dde6" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="00d7e5c9-0822-4faa-b176-0a823c0ba91f" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="3c62d4ce-ef1c-49fa-bf83-d0bf2644bfba"><i class="material-icons">menu</i></a><ul class="sidenav" id="3c62d4ce-ef1c-49fa-bf83-d0bf2644bfba"><li><a href="#!" class="dropdown-trigger" data-target="0913c8d1-cf44-4fe8-9419-314569d018d5" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1184fb7f-6ae9-4380-a8d9-228d677a65c0" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="fa9b9bce-34b6-47e3-946f-9440d469e0e1" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="5f2065e1-bc5c-4167-98bb-161d280ace48" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="dc0971e6-37a4-4353-a2f1-f8c110154eaf"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="d7508cff-c35d-4076-9114-3c337d486092"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="c29035c0-bee8-49bc-bc87-730f73d1dde6"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="00d7e5c9-0822-4faa-b176-0a823c0ba91f"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="0913c8d1-cf44-4fe8-9419-314569d018d5"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="1184fb7f-6ae9-4380-a8d9-228d677a65c0"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="fa9b9bce-34b6-47e3-946f-9440d469e0e1"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="5f2065e1-bc5c-4167-98bb-161d280ace48"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="f3049307-79ed-4e21-b184-cc353227a92a" data-section-level="1" data-section-text="Postprocessor System"><h1 id="postprocessor-system">Postprocessor System</h1><p>A postprocessor is an object that computes a single scalar (<code>Real</code>) value, such as a value sampled from the solution at a point in the domain, or an integral/average over some subdomain or boundary. This value may be used purely for output purposes, or it may be retrieved by other systems via the <code>getPostprocessorValue</code> method, which is available in most MOOSE objects. Furthermore, postprocessors are also <a href="../Functors/index.html">functors</a>, which allows them to be retrieved into various objects via the <code>getFunctor&lt;Real&gt;</code> method.</p><p>MOOSE includes a large number of postprocessors within the framework, the complete list is provided in <a href="index.html#available-objects">Available Objects list</a> section.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>The <a href="../Reporters/index.html">Reporter System</a> is a newer, more flexible system for computing aggregate values. It is recommended that new objects for aggregate calculations use the Reporter system.</p></div></div></div><section id="011279cf-e27e-44f2-93ac-5fca28fcdaf8" data-section-level="2" data-section-text="Example Input File"><h2 id="example-input-file">Example Input File</h2><p>The following input file snippet demonstrates the use of the <a href="../../source/postprocessors/ElementExtremeValue.html">ElementExtremeValue</a> to compute the minimum and maximum of the solution variable &quot;u&quot;.</p><pre style="max-height:350px;"><code class="language-moose">[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;index.html&quot;}&gt;&gt;&gt;]
  [max]
    type = ElementExtremeValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Finds either the min or max elemental value of a variable over the domain.&quot;, &quot;href&quot;: &quot;../../source/postprocessors/ElementExtremeValue.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on&quot;}&gt;&gt;&gt; = u
  []
  [min]
    type = ElementExtremeValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Finds either the min or max elemental value of a variable over the domain.&quot;, &quot;href&quot;: &quot;../../source/postprocessors/ElementExtremeValue.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on&quot;}&gt;&gt;&gt; = u
    value_type&lt;&lt;&lt;{&quot;description&quot;: &quot;Type of extreme value to return. &#x27;max&#x27; returns the maximum value. &#x27;min&#x27; returns the minimum value. &#x27;max_abs&#x27; returns the maximum of the absolute value.&quot;}&gt;&gt;&gt; = min
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#5ed64e1c-a3c0-4ed4-af68-4a25778192ee">(moose/test/tests/postprocessors/element_extreme_value/element_extreme_value.i)</a><p>This snippet is a part of a test that may be executed using the MOOSE test application as follows.</p><pre style="max-height:350px;"><code class="language-bash">
cd ~/projects/moose/test
make -j8
cd tests/postprocessors/element_extreme_value
~/projects/moose/test/moose_test-opt -i element_extreme_value.i
</code></pre><p>The data from this calculation is reported in the terminal output by default and if <a href="../../source/outputs/Exodus.html">Exodus</a> output is enabled the values will automatically be included in the output file. It is also possible to export the data to a comma separated value (csv) file by enabling the <a href="../../source/outputs/CSV.html">CSV</a> object within the <a href="../Outputs/index.html">Outputs</a> block.</p><pre style="max-height:350px;"><code class="language-bash">
Postprocessor Values:
+----------------+----------------+----------------+
| time           | max            | min            |
+----------------+----------------+----------------+
|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |
|   1.000000e+00 |   9.788675e-01 |   2.113249e-02 |
+----------------+----------------+----------------+
</code></pre></section><section id="af656206-3791-42f3-8961-97cfc3d1b377" data-section-level="2" data-section-text="Coupling Example Code"><h2 id="coupling-example-code">Coupling Example Code</h2><p>The values computed within a Postprocessor object may be used within other objects that inherit from the <a href="../../source/interfaces/PostprocessorInterface.html">PostprocessorInterface</a>, which is nearly every system within MOOSE. For example, the <a href="../../source/bcs/PostprocessorNeumannBC.html">PostprocessorNeumannBC</a> object allows for a Neumann boundary condition to be set to a value computed from a postprocessor; this object will be used as example to demonstrate how coupling is performed.</p><p>To understand how the coupling is coded it is beneficial to first see how the coupling is defined via the input file. The following input file snippet shows that a <a href="../../source/postprocessors/PointValue.html">PointValue</a> postprocessor is created and named &quot;right_pp&quot; and the <a href="../../source/bcs/PostprocessorNeumannBC.html">PostprocessorNeumannBC</a> uses this value to set the boundary condition.</p><pre style="max-height:350px;"><code class="language-moose">[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;index.html&quot;}&gt;&gt;&gt;]
  [right_pp]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;0.5 0.5 0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = aux
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial&#x27;
  []
[]

[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../BCs/index.html&quot;}&gt;&gt;&gt;]
  [left]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = u
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0
  []
  [right]
    type = PostprocessorNeumannBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Neumann boundary condition with value prescribed by a Postprocessor value.&quot;, &quot;href&quot;: &quot;../../source/bcs/PostprocessorNeumannBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = u
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    postprocessor&lt;&lt;&lt;{&quot;description&quot;: &quot;The postprocessor to use for value of the gradient on the boundary.&quot;}&gt;&gt;&gt; = right_pp
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#f29ef91f-7a91-46c6-b0c4-c64ba9574cf3">(moose/test/tests/bcs/pp_neumann/pp_neumann.i)</a><p>This first step of coding this type of coupling begins by adding the necessary input file syntax to the object that requires a postprocessor value, PostprocessorNeumannBC in this example. In all MOOSE objects input file syntax is governed by the validParams function of an object. To add the ability to couple a postprocessor, simply add a new parameter using the <code>PostprocessorName</code> type, as shown below. Notice, that the add parameters call includes a default value that makes the use of the postprocessor optional.</p><pre style="max-height:350px;"><code class="language-cpp">
#include &quot;PostprocessorNeumannBC.h&quot;

registerMooseObject(&quot;MooseApp&quot;, PostprocessorNeumannBC);

InputParameters
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#f7eb3842-e0aa-4dd5-a484-0d74b120ed25">(moose/framework/src/bcs/PostprocessorNeumannBC.C)</a><p>The actual postprocessor value must be assigned to a member variable of the class, thus in the header a member variable must be created, which should always be a constant reference to a <code>PostprocessorValue</code> type. Since this is a reference it must be initialized, this occurs in the source file by calling the <code>getPostprocessorValue</code> method and providing the name used in the validParams function. The following snippets show declaration of the reference in the header and the initialization of this reference in the source file.  The <code>_value</code> member variable is then available for use anywhere inside the object, for the case of the boundary condition it is utilized in the computation of the residual.</p><pre style="max-height:350px;"><code class="language-cpp">  const PostprocessorValue &amp; _value;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#a2973da3-d67a-4239-a5ca-8de86cf98445">(moose/framework/include/bcs/PostprocessorNeumannBC.h)</a><pre style="max-height:350px;"><code class="language-cpp">PostprocessorNeumannBC::validParams()
{
  InputParameters params = IntegratedBC::validParams();
  params.addClassDescription(
      &quot;Neumann boundary condition with value prescribed by a Postprocessor value.&quot;);
  params.addParam&lt;PostprocessorName&gt;(
      &quot;postprocessor&quot;, 0.0, &quot;The postprocessor to use for value of the gradient on the boundary.&quot;);
  return params;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#ca9b23c3-38d8-43de-8c39-fae9da440fb1">(moose/framework/src/bcs/PostprocessorNeumannBC.C)</a><section id="254bedb8-8046-4540-802a-6a46dfe7e6f0" data-section-level="3" data-section-text="Coupling to other values"><h3 id="coupling-to-other-values">Coupling to other values</h3><p>Just as Postprocessor values can be used in other objects, Postprocessors themselves can couple to Functions and Scalar Variables. See the following example that couples a scalar variable into a Postprocessor:</p><pre style="max-height:350px;"><code class="language-moose">[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;index.html&quot;}&gt;&gt;&gt;]
  [./totalFlux]
    type = ScalarCoupledPostprocessor
    variable = u
    coupled_scalar = scalar_variable
    boundary = left
  [../]
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#059c10c7-d800-4d5d-a9e3-5f1951c38358">(moose/test/tests/postprocessors/scalar_coupled_postprocessor/scalar_coupled_postprocessor_test.i)</a></section></section><section id="63c9d141-9276-4b57-a389-588e5ae09cb8" data-section-level="2" data-section-text="Creating a Object Postprocessor"><h2 id="creating-a-object">Creating a <code>Postprocessor</code> Object</h2><p>In general, every Postprocessor object has two methods that must be defined &quot;execute&quot; and &quot;getValue&quot;.</p><p>First, consider the execute method. This method is called by MOOSE at different time depending on the type of postprocessor object. Therefore, when creating a Postprocessor object the new object should inherit from one of the following C++ classes:</p><ul class="browser-default"><li><p><strong>GeneralPostprocessor</strong>: &quot;execute&quot; is called once on each execution flag. </p></li><li><p><strong>NodalPostprocessor</strong>: &quot;execute&quot; is called for each <strong>node</strong> within the mesh on each execution flag. </p></li><li><p><strong>ElementalPostprocessor</strong>: &quot;execute&quot; is called for each <strong>element</strong> within the mesh on each execution  flag. </p></li><li><p><strong>InternalSidePostprocessor</strong>: &quot;execute&quot; is called for each <strong>side</strong>, that is not on a boundary,  within the mesh on each execution flag. </p></li><li><p><strong>SidePostprocessor</strong>: &quot;execute&quot; is called for each <strong>side</strong>, that is on a boundary, within the mesh  on each execution flag.</p></li></ul><p>The use of execution flags is discussed in the <a href="index.html#execute-on">Execute On</a> section.</p><p>The getValue method is responsible for returning the value of the postprocessor object, this value is what is used by all objects that are coupled to the postprocessor. In some cases the necessary communication is performed within this method, but in general this following is preferred.</p><section id="45d0a8b1-0d6a-43b3-b5be-2db2ed00c87d" data-section-level="3" data-section-text="Parallel Considerations"><h3 id="parallel-considerations">Parallel Considerations</h3><p>When creating a postprocessor it is often necessary to perform some parallel communication to ensure that the value being computed is correct across processes and threads. Three additional methods exists for making this process as simple as possible.</p><ul class="browser-default"><li><p><code>initialize</code>: This is called prior to the execution of the postprocessor and should be used  to setup the object to be in a known state. It is important to point out that execution  in this context includes all calls to the execute method. For example, for a <code>NodalPostprocessor</code>  object the initialize method is called and then the execute method is called for all nodes. </p></li><li><p><code>finalize</code>: This is called after the execution of the postprocessor and is intended to perform  communication to prepare the object for the call to the getValue method. </p></li><li><p><code>threadJoin</code>: This is called after the execution of the postprocessor and is intended to perform  aggregation for shared memory parallelism.</p></li></ul><p>To understand the use of these methods the <a href="../../source/postprocessors/AverageNodalVariableValue.html">AverageNodalVariableValue</a> postprocessor shall be used as an example. As the name suggests this postprocessor computes the average of the value of a variable at the nodes. To perform this calculation the variable values from each node are summed as is the number of values within the execute method. Then the getValue method returns the average by returning the sum divided by the count. The following snippet shows the these two methods: the <code>_u[_qp]</code> is the value of the variable at the current node that comes from a shared base class and  <code>_sum</code> and <code>_n</code> are a member variables defined within class for performing the calculation.</p><pre style="max-height:350px;"><code class="language-cpp">void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue() const
{
  return _sum / _n;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#eb9bd6c9-7ccd-4c6d-8480-ebe0f46048da">(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</a><p>In parallel, the calls to the execute method occur on each process or thread on a subset of the domain, in this case nodes. Therefore, the computed values must be combined to get the actual summations required to compute the average value. The first step is to setup the state of this calculation within the initialize method, which in this example sets the <code>_sum</code> and <code>_n</code> member variables to zero.</p><pre style="max-height:350px;"><code class="language-cpp">void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#5ca15609-7cac-4771-bde2-6af17ca4cdcb">(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</a><p>After the aforementioned execute method is called for each node the computed values for <code>_sum</code> and <code>_n</code> must be aggregated from across processes to the root processes. For this problem a gather operation is required to collect the values computed on all processes to the root process. This is accomplished via the <code>gatherSum</code> method.</p><pre style="max-height:350px;"><code class="language-cpp">void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#59cc1c8c-7a17-4594-a44d-cdcb3dff2c03">(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</a><p>Of course, the type of communication necessary depends on the calculation being performed. The <a href="../../source/userobjects/UserObject.html">UserObject</a> base class includes helper methods for common parallel communications functions.</p><p>The initialize and finalize methods are utilized to aggregate for message passing (MPI) based parallelism. For shared memory parallelism the threadJoin method is used. This method is called, like finalize, after execution is complete and includes a single argument. This argument is a reference to a UserObject, which is a base class of Postprocessor objects. The purpose of this method is to enable the aggregation for the Postprocessor objects that were executed on other threads to the object on the root thread. For the AverageNodalVariableValue postprocessor the values for <code>_sum</code> and <code>_n</code> on the root process object are updated to include the these same values from the other threads.</p><pre style="max-height:350px;"><code class="language-cpp">void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const auto &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#657b0585-7df1-4c15-b28b-3de1010fd91c">(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</a></section></section><section id="aa8750fc-afe5-4cbb-b441-43d4ccc3a12c" data-section-level="2" data-section-text="Execute On ..."><h2 id="execute-on">Execute On...</h2><p>Postprocessor objects inherit from the <a href="../../source/interfaces/SetupInterface.html">SetupInterface</a> that allows the objects to execute and varying and multiple times during a simulation, such as during initialization and at the end of each time step. Refer to the <a href="../../source/interfaces/SetupInterface.html">SetupInterface</a> for additional information.</p></section><section id="2a931757-79b9-4751-a021-3642b23d68d1" data-section-level="2" data-section-text="Using Old and Older values"><h2 id="using-old-and-older-values">Using Old and Older values</h2><p>MOOSE maintains previously computed values in the postprocessor system for using lagged information in a computation. Both the previous time step&#x27;s value and the value computed two steps back may be retrieved. One reason you might use older values is to break cyclic dependencies. MOOSE does not consider a dependence on an old value when considering the order of evaluation among objects with dependencies.</p></section><section id="5092d16a-e21f-4616-a44f-eecd86dcedb8" data-section-level="2" data-section-text="Restore on Rejected Timesteps"><h2 id="restore-on-rejected-timesteps">Restore on Rejected Timesteps</h2><p>When a timestep is rejected due to a failed solve, a failed multiapp solve, or any other reason, the timestep is usually repeated, usually with a smaller timestep size. Before performing the solve on the repeated timestep, postprocessors are restored to their old values, in order to facilitate a fresh attempt at the timestep.</p></section><section id="3b5d1a44-12aa-4b2f-bf04-3f57891c6839" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageMaterialProperty.html">ADElementAverageMaterialProperty</a>Computes the average of a material property over a volume.</li><li class="collection-item"><a href="../../source/postprocessors/ElementExtremeFunctorValue.html">ADElementExtremeFunctorValue</a>Finds either the min or max elemental value of a functor over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/ElementExtremeMaterialProperty.html">ADElementExtremeMaterialProperty</a>Determines the minimum or maximum of a material property over a volume.</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralFunctorPostprocessor.html">ADElementIntegralFunctorPostprocessor</a>Computes a volume integral of the specified functor</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralMaterialProperty.html">ADElementIntegralMaterialProperty</a>Compute the integral of the material property over the domain</li><li class="collection-item"><a href="../../source/postprocessors/ElementL2FunctorError.html">ADElementL2FunctorError</a>Computes L2 error between an &#x27;approximate&#x27; functor and an &#x27;exact&#x27; functor</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceDiffusiveFluxAverage.html">ADInterfaceDiffusiveFluxAverage</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceDiffusiveFluxIntegral.html">ADInterfaceDiffusiveFluxIntegral</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="../../source/postprocessors/SideAdvectiveFluxIntegral.html">ADSideAdvectiveFluxIntegral</a>Computes the volumetric advected quantity through a sideset.</li><li class="collection-item"><a href="../../source/postprocessors/SideAverageMaterialProperty.html">ADSideAverageMaterialProperty</a>Computes the average of a material property over a side set.</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxAverage.html">ADSideDiffusiveFluxAverage</a>Computes the average of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxIntegral.html">ADSideDiffusiveFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxAverage.html">ADSideFluxAverage</a>Computes the average of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxIntegral.html">ADSideFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideIntegralFunctorPostprocessor.html">ADSideIntegralFunctorPostprocessor</a>Computes a surface integral of the specified functor, using the single-sided face argument, which usually means that the functor will be evaluated from a single side of the surface, not interpolated between both sides.</li><li class="collection-item"><a href="../../source/postprocessors/SideIntegralMaterialProperty.html">ADSideIntegralMaterialProperty</a>Compute the integral of a scalar material property component over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxIntegral.html">ADSideVectorDiffusivityFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/AreaPostprocessor.html">AreaPostprocessor</a>Computes the &quot;area&quot; or dimension - 1 &quot;volume&quot; of a given boundary or boundaries in your mesh.</li><li class="collection-item"><a href="../../source/postprocessors/AverageElementSize.html">AverageElementSize</a>Computes the average element size.</li><li class="collection-item"><a href="../../source/postprocessors/AverageNodalVariableValue.html">AverageNodalVariableValue</a>Computes the average value of a field by sampling all nodal solutions on the domain or within a subdomain</li><li class="collection-item"><a href="../../source/postprocessors/AverageVariableChange.html">AverageVariableChange</a>Computes the volume-weighted L1 or L2 norm of the change of a variable over a time step or between nonlinear iterations.</li><li class="collection-item"><a href="../../source/postprocessors/AxisymmetricCenterlineAverageValue.html">AxisymmetricCenterlineAverageValue</a>Computes the average value of a variable on a sideset located along the centerline of an axisymmetric model.</li><li class="collection-item"><a href="../../source/postprocessors/ChainControlDataPostprocessor.html">ChainControlDataPostprocessor</a>Gets a Real or bool chain control value.</li><li class="collection-item"><a href="../../source/postprocessors/ChangeOverFixedPointPostprocessor.html">ChangeOverFixedPointPostprocessor</a>Computes the change or relative change in a post-processor value over a single or multiple fixed point iterations</li><li class="collection-item"><a href="../../source/postprocessors/ChangeOverTimePostprocessor.html">ChangeOverTimePostprocessor</a>Computes the change or relative change in a post-processor value over a timestep or the entire transient</li><li class="collection-item"><a href="../../source/postprocessors/ChangeOverTimestepPostprocessor.html">ChangeOverTimestepPostprocessor</a>Computes the change or relative change in a post-processor value over a timestep or the entire transient</li><li class="collection-item"><a href="../../source/postprocessors/ConstantPostprocessor.html">ConstantPostprocessor</a>Postprocessor that holds a constant value</li><li class="collection-item"><a href="../../source/postprocessors/CumulativeValuePostprocessor.html">CumulativeValuePostprocessor</a>Creates a cumulative sum of a Postprocessor value with time.</li><li class="collection-item"><a href="../../source/postprocessors/DifferencePostprocessor.html">DifferencePostprocessor</a>Computes the difference between two postprocessors</li><li class="collection-item"><a href="../../source/postprocessors/DiscreteVariableResidualNorm.html">DiscreteVariableResidualNorm</a>Computes a discrete norm for a block-restricted variable residual.</li><li class="collection-item"><a href="../../source/postprocessors/ElementArrayL2Norm.html">ElementArrayL2Norm</a>Evaluates L2-norm of a component of an array variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageMaterialProperty.html">ElementAverageMaterialProperty</a>Computes the average of a material property over a volume.</li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageSecondTimeDerivative.html">ElementAverageSecondTimeDerivative</a>Computes the element averaged second derivative of variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageTimeDerivative.html">ElementAverageTimeDerivative</a>Computes a volume integral of the time derivative of a given variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageValue.html">ElementAverageValue</a>Computes the volumetric average of a variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementExtremeFunctorValue.html">ElementExtremeFunctorValue</a>Finds either the min or max elemental value of a functor over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/ElementExtremeMaterialProperty.html">ElementExtremeMaterialProperty</a>Determines the minimum or maximum of a material property over a volume.</li><li class="collection-item"><a href="../../source/postprocessors/ElementExtremeValue.html">ElementExtremeValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/ElementH1Error.html">ElementH1Error</a>Computes the H1 error between a variable and a function</li><li class="collection-item"><a href="../../source/postprocessors/ElementH1SemiError.html">ElementH1SemiError</a>Returns the gradient difference norm part of the H1 error</li><li class="collection-item"><a href="../../source/postprocessors/ElementHCurlError.html">ElementHCurlError</a>Returns the H(curl)-norm of the difference between a pair of computed and analytical vector-valued solutions.</li><li class="collection-item"><a href="../../source/postprocessors/ElementHCurlSemiError.html">ElementHCurlSemiError</a>Returns the H(curl)-seminorm of the difference between a pair of computed and analytical vector-valued solutions.</li><li class="collection-item"><a href="../../source/postprocessors/ElementHDivError.html">ElementHDivError</a>Returns the H(div)-norm of the difference between a pair of computed and analytical vector-valued solutions.</li><li class="collection-item"><a href="../../source/postprocessors/ElementHDivSemiError.html">ElementHDivSemiError</a>Returns the H(div)-seminorm of the difference between a pair of computed and analytical vector-valued solutions.</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralArrayVariablePostprocessor.html">ElementIntegralArrayVariablePostprocessor</a>Integral of one component of an array variable.</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralFunctorPostprocessor.html">ElementIntegralFunctorPostprocessor</a>Computes a volume integral of the specified functor</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralMaterialProperty.html">ElementIntegralMaterialProperty</a>Compute the integral of the material property over the domain</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralVariablePostprocessor.html">ElementIntegralVariablePostprocessor</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementL1Error.html">ElementL1Error</a>Computes L1 error between an elemental field variable and an analytical function.</li><li class="collection-item"><a href="../../source/postprocessors/ElementL2Difference.html">ElementL2Difference</a>Computes the element-wise L2 difference between the current variable and a coupled variable.</li><li class="collection-item"><a href="../../source/postprocessors/ElementL2Error.html">ElementL2Error</a>Computes L2 error between a field variable and an analytical function</li><li class="collection-item"><a href="../../source/postprocessors/ElementL2FunctorError.html">ElementL2FunctorError</a>Computes L2 error between an &#x27;approximate&#x27; functor and an &#x27;exact&#x27; functor</li><li class="collection-item"><a href="../../source/postprocessors/ElementL2Norm.html">ElementL2Norm</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementMaxLevelPostProcessor.html">ElementMaxLevelPostProcessor</a>Computes the maximum element adaptivity level (for either h or p refinement).</li><li class="collection-item"><a href="../../source/postprocessors/ElementSidesL2Norm.html">ElementSidesL2Norm</a>Computes the L2 norm of a variable over element sides.</li><li class="collection-item"><a href="../../source/postprocessors/ElementVectorL2Error.html">ElementVectorL2Error</a>Returns the L2-norm of the difference between a pair of computed and analytical vector-valued solutions.</li><li class="collection-item"><a href="../../source/postprocessors/ElementW1pError.html">ElementW1pError</a>Computes the W1p norm of the difference between a variable and an analytic solution, as a function</li><li class="collection-item"><a href="../../source/postprocessors/ElementalVariableValue.html">ElementalVariableValue</a>Outputs an elemental variable value at a particular location</li><li class="collection-item"><a href="../../source/postprocessors/EmptyPostprocessor.html">EmptyPostprocessor</a>A postprocessor object that returns a value of zero.</li><li class="collection-item"><a href="../../source/postprocessors/FindValueOnLine.html">FindValueOnLine</a>Find a specific target value along a sampling line. The variable values along the line should change monotonically. The target value is searched using a bisection algorithm.</li><li class="collection-item"><a href="../../source/postprocessors/FunctionElementAverage.html">FunctionElementAverage</a>Computes the average of a function over a volume.</li><li class="collection-item"><a href="../../source/postprocessors/FunctionElementIntegral.html">FunctionElementIntegral</a>Integrates a function over elements</li><li class="collection-item"><a href="../../source/postprocessors/FunctionSideAverage.html">FunctionSideAverage</a>Computes the average of a function over a boundary.</li><li class="collection-item"><a href="../../source/postprocessors/FunctionSideIntegral.html">FunctionSideIntegral</a>Computes the integral of a function over a boundary.</li><li class="collection-item"><a href="../../source/postprocessors/FunctionValuePostprocessor.html">FunctionValuePostprocessor</a>Computes the value of a supplied function at a single point (scalable)</li><li class="collection-item"><a href="../../source/postprocessors/GreaterThanLessThanPostprocessor.html">GreaterThanLessThanPostprocessor</a>Count number of DOFs of a non-linear variable that are greater than or less than a given threshold</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceAverageVariableValuePostprocessor.html">InterfaceAverageVariableValuePostprocessor</a>Computes the average value of a variable on an interface. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceDiffusiveFluxAverage.html">InterfaceDiffusiveFluxAverage</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceDiffusiveFluxIntegral.html">InterfaceDiffusiveFluxIntegral</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceIntegralVariableValuePostprocessor.html">InterfaceIntegralVariableValuePostprocessor</a>Add access to variables and their gradient on an interface.</li><li class="collection-item"><a href="../../source/postprocessors/InternalSideIntegralVariablePostprocessor.html">InternalSideIntegralVariablePostprocessor</a>Computes an integral on internal sides of the specified variable</li><li class="collection-item"><a href="../../source/postprocessors/LinearCombinationPostprocessor.html">LinearCombinationPostprocessor</a>Computes a linear combination between an arbitrary number of post-processors</li><li class="collection-item"><a href="../../source/postprocessors/MatrixSymmetryCheck.html">MatrixSymmetryCheck</a>Report whether a matrix is symmetric or not.</li><li class="collection-item"><a href="../../source/postprocessors/MemoryUsage.html">MemoryUsage</a>Memory usage statistics for the running simulation.</li><li class="collection-item"><a href="../../source/postprocessors/NearestNodeNumber.html">NearestNodeNumber</a>Outputs the nearest node number to a point</li><li class="collection-item"><a href="../../source/postprocessors/NodalExtremeValue.html">NodalExtremeValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/NodalL2Error.html">NodalL2Error</a>The L2-norm of the difference between a variable and a function computed at nodes.</li><li class="collection-item"><a href="../../source/postprocessors/NodalL2Norm.html">NodalL2Norm</a>Computes the nodal L2-norm of the coupled variable, which is defined by summing the square of its value at every node and taking the square root.</li><li class="collection-item"><a href="../../source/postprocessors/NodalMaxValue.html">NodalMaxValue</a>Computes the maximum (over all the nodal values) of a variable.</li><li class="collection-item"><a href="../../source/postprocessors/NodalMaxValueId.html">NodalMaxValueId</a>Finds the node id with the maximum nodal value across all postprocessors.</li><li class="collection-item"><a href="../../source/postprocessors/NodalMaxValueId.html">NodalProxyMaxValue</a>Finds the node id with the maximum nodal value across all postprocessors.</li><li class="collection-item"><a href="../../source/postprocessors/NodalSum.html">NodalSum</a>Computes the sum of all of the nodal values of the specified variable. Note: This object sets the default &quot;unique_node_execute&quot; flag to true to avoid double counting nodes between shared blocks.</li><li class="collection-item"><a href="../../source/postprocessors/NodalVariableValue.html">NodalVariableValue</a>Outputs values of a nodal variable at a particular location</li><li class="collection-item"><a href="../../source/postprocessors/NumDOFs.html">NumDOFs</a>Return the number of Degrees of freedom from either the NL, Aux or both systems.</li><li class="collection-item"><a href="../../source/postprocessors/NumElements.html">NumElements</a>Return the number of active or total elements in the simulation.</li><li class="collection-item"><a href="../../source/postprocessors/NumElements.html">NumElems</a>Return the number of active or total elements in the simulation.</li><li class="collection-item"><a href="../../source/postprocessors/NumFailedTimeSteps.html">NumFailedTimeSteps</a>Collects the number of failed time steps from the time stepper.</li><li class="collection-item"><a href="../../source/postprocessors/NumFixedPointIterations.html">NumFixedPointIterations</a>Returns the number of fixed point iterations taken by the executioner.</li><li class="collection-item"><a href="../../source/postprocessors/NumLinearIterations.html">NumLinearIterations</a>Compute the number of linear iterations.</li><li class="collection-item"><a href="../../source/postprocessors/NumMeshDivisions.html">NumMeshDivisions</a>Return the number of divisions/regions from a MeshDivision object.</li><li class="collection-item"><a href="../../source/postprocessors/NumNodes.html">NumNodes</a>Returns the total number of nodes in a simulation (works with DistributedMesh)</li><li class="collection-item"><a href="../../source/postprocessors/NumNonlinearIterations.html">NumNonlinearIterations</a>Outputs the number of nonlinear iterations</li><li class="collection-item"><a href="../../source/postprocessors/NumFixedPointIterations.html">NumPicardIterations</a>Returns the number of fixed point iterations taken by the executioner.</li><li class="collection-item"><a href="../../source/postprocessors/NumPositions.html">NumPositions</a>Return the number of Positions from a Positions object.</li><li class="collection-item"><a href="../../source/postprocessors/NumRelationshipManagers.html">NumRelationshipManagers</a>Return the number of relationship managers active.</li><li class="collection-item"><a href="../../source/postprocessors/NumResidualEvaluations.html">NumResidualEvaluations</a>Returns the total number of residual evaluations performed.</li><li class="collection-item"><a href="../../source/postprocessors/NumTimeSteps.html">NumTimeSteps</a>Reports the timestep number</li><li class="collection-item"><a href="../../source/postprocessors/NumVars.html">NumVars</a>Return the number of variables from either the NL, Aux, or both systems.</li><li class="collection-item"><a href="../../source/postprocessors/ParsedPostprocessor.html">ParsedPostprocessor</a>Computes a parsed expression with post-processors</li><li class="collection-item"><a href="../../source/postprocessors/PercentChangePostprocessor.html">PercentChangePostprocessor</a>Computes the percent change of a postprocessor value compared to the value at the previous timestep.</li><li class="collection-item"><a href="../../source/postprocessors/PerfGraphData.html">PerfGraphData</a>Retrieves performance information about a section from the PerfGraph.</li><li class="collection-item"><a href="../../source/postprocessors/PointValue.html">PointValue</a>Compute the value of a variable at a specified location</li><li class="collection-item"><a href="../../source/postprocessors/PostprocessorComparison.html">PostprocessorComparison</a>Compares two post-processors and produces a boolean value</li><li class="collection-item"><a href="../../source/postprocessors/PseudoTimestep.html">PseudoTimestep</a>Computes pseudo-time steps for obtaining steady-state solutions through a pseudo transient process.</li><li class="collection-item"><a href="../../source/postprocessors/Receiver.html">Receiver</a>Reports the value stored in this processor, which is usually filled in by another object. The Receiver does not compute its own value.</li><li class="collection-item"><a href="../../source/postprocessors/RelativeDifferencePostprocessor.html">RelativeDifferencePostprocessor</a>Computes the absolute value of the relative difference between 2 post-processor values.</li><li class="collection-item"><a href="../../source/postprocessors/RelativeSolutionDifferenceNorm.html">RelativeSolutionDifferenceNorm</a>Computes the relative norm of the solution difference of two consecutive time steps.</li><li class="collection-item"><a href="../../source/postprocessors/Residual.html">Residual</a>Report the non-linear residual.</li><li class="collection-item"><a href="../../source/postprocessors/ScalarL2Error.html">ScalarL2Error</a>Compute L2 error of a scalar variable using analytic function.</li><li class="collection-item"><a href="../../source/postprocessors/ScalarVariable.html">ScalarVariable</a>Returns the value of a scalar variable as a postprocessor value.</li><li class="collection-item"><a href="../../source/postprocessors/ScalePostprocessor.html">ScalePostprocessor</a>Scales a post-processor by a value</li><li class="collection-item"><a href="../../source/postprocessors/SideAdvectiveFluxIntegral.html">SideAdvectiveFluxIntegral</a>Computes the volumetric advected quantity through a sideset.</li><li class="collection-item"><a href="../../source/postprocessors/SideAverageFunctorPostprocessor.html">SideAverageFunctorPostprocessor</a>Computes the average of a functor over a side set.</li><li class="collection-item"><a href="../../source/postprocessors/SideAverageMaterialProperty.html">SideAverageMaterialProperty</a>Computes the average of a material property over a side set.</li><li class="collection-item"><a href="../../source/postprocessors/SideAverageValue.html">SideAverageValue</a>Computes the average value of a variable on a sideset. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxAverage.html">SideDiffusiveFluxAverage</a>Computes the average of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxIntegral.html">SideDiffusiveFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideExtremeValue.html">SideExtremeValue</a>Finds either the min or max variable value of a variable over a boundary.</li><li class="collection-item"><a href="../../source/postprocessors/SideFVFluxBCIntegral.html">SideFVFluxBCIntegral</a>Computes the side integral of different finite volume flux boundary conditions.</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxAverage.html">SideFluxAverage</a>Computes the average of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxIntegral.html">SideFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideIntegralFunctorPostprocessor.html">SideIntegralFunctorPostprocessor</a>Computes a surface integral of the specified functor, using the single-sided face argument, which usually means that the functor will be evaluated from a single side of the surface, not interpolated between both sides.</li><li class="collection-item"><a href="../../source/postprocessors/SideIntegralMaterialProperty.html">SideIntegralMaterialProperty</a>Compute the integral of a scalar material property component over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/SideIntegralVariablePostprocessor.html">SideIntegralVariablePostprocessor</a>Computes a surface integral of the specified variable</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxIntegral.html">SideVectorDiffusivityFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/TagVectorSum.html">TagVectorSum</a>Computes the sum of components of the requested tagged vector</li><li class="collection-item"><a href="../../source/postprocessors/TimeExtremeValue.html">TimeExtremeValue</a>A postprocessor for reporting the extreme value of another postprocessor over time.</li><li class="collection-item"><a href="../../source/postprocessors/TimeIntegratedPostprocessor.html">TimeIntegratedPostprocessor</a>Integrate a Postprocessor value over time using trapezoidal rule.</li><li class="collection-item"><a href="../../source/postprocessors/TimePostprocessor.html">TimePostprocessor</a>Reports the current time</li><li class="collection-item"><a href="../../source/postprocessors/TimestepSize.html">TimestepSize</a>Reports the timestep size</li><li class="collection-item"><a href="../../source/postprocessors/TimeIntegratedPostprocessor.html">TotalVariableValue</a>Integrate a Postprocessor value over time using trapezoidal rule.</li><li class="collection-item"><a href="../../source/postprocessors/VariableInnerProduct.html">VariableInnerProduct</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="../../source/postprocessors/VariableResidual.html">VariableResidual</a>Computes the L2 norm of the residual of a single variable in the solution vector.</li><li class="collection-item"><a href="../../source/postprocessors/VectorPostprocessorComparison.html">VectorPostprocessorComparison</a>Compares two vector post-processors of equal size and produces a boolean value</li><li class="collection-item"><a href="../../source/postprocessors/VectorPostprocessorComponent.html">VectorPostprocessorComponent</a>Returns the value of the specified component of a VectorPostprocessor</li><li class="collection-item"><a href="../../source/postprocessors/VectorPostprocessorReductionValue.html">VectorPostprocessorReductionValue</a>Takes a VectorPostprocessor and performs a reduction operation on it (max, min, sum, average) and stores as postprocessor.</li><li class="collection-item"><a href="../../source/postprocessors/VolumePostprocessor.html">VolumePostprocessor</a>Computes the volume of a specified block</li><li class="collection-header">Phase Field App</li><li class="collection-item"><a href="../../source/postprocessors/AverageGrainVolume.html">AverageGrainVolume</a>Calculate average grain area in a polycrystal</li><li class="collection-item"><a href="../../source/postprocessors/DiscreteNucleationData.html">DiscreteNucleationData</a>Output diagnostic data on a DiscreteNucleationInserter</li><li class="collection-item"><a href="../../source/postprocessors/DiscreteNucleationTimeStep.html">DiscreteNucleationTimeStep</a>Return a time step limit for nucleation event to be used by IterationAdaptiveDT</li><li class="collection-item"><a href="../../source/postprocessors/FauxGrainTracker.html">FauxGrainTracker</a>Fake grain tracker object for cases where the number of grains is equal to the number of order parameters.</li><li class="collection-item"><a href="../../source/userobjects/FauxPolycrystalVoronoi.html">FauxPolycrystalVoronoi</a>Random Voronoi tessellation polycrystal when the number of order parameters equal to the number of grains</li><li class="collection-item"><a href="../../source/postprocessors/FeatureFloodCount.html">FeatureFloodCount</a>The object is able to find and count &quot;connected components&quot; in any solution field or number of solution fields. A primary example would be to count &quot;bubbles&quot;.</li><li class="collection-item"><a href="../../source/postprocessors/FeatureVolumeFraction.html">FeatureVolumeFraction</a>Computes the total feature volume fraction from a vectorpostprocessor computing the feature volume</li><li class="collection-item"><a href="../../source/postprocessors/GrainBoundaryArea.html">GrainBoundaryArea</a>Calculate total grain boundary length in 2D and area in 3D</li><li class="collection-item"><a href="../../source/postprocessors/GrainTracker.html">GrainTracker</a>Grain Tracker object for running reduced order parameter simulations without grain coalescence.</li><li class="collection-item"><a href="../../source/postprocessors/GrainTrackerElasticity.html">GrainTrackerElasticity</a>Grain Tracker object for running reduced order parameter simulations without grain coalescence.</li><li class="collection-item"><a href="../../source/postprocessors/ObtainAvgContactAngle.html">ObtainAvgContactAngle</a>Obtain contact angle</li><li class="collection-item"><a href="../../source/postprocessors/PFCElementEnergyIntegral.html">PFCElementEnergyIntegral</a>Computes the integral of the energy from the temperature. Note that the kb factor is missing.</li><li class="collection-item"><a href="../../source/userobjects/PolycrystalCircles.html">PolycrystalCircles</a>Polycrystal circles generated from a vector input or read from a file</li><li class="collection-item"><a href="../../source/userobjects/PolycrystalEBSD.html">PolycrystalEBSD</a>Object for setting up a polycrystal structure from an EBSD Datafile</li><li class="collection-item"><a href="../../source/userobjects/PolycrystalHex.html">PolycrystalHex</a>Perturbed hexagonal polycrystal</li><li class="collection-item"><a href="../../source/userobjects/PolycrystalVoronoi.html">PolycrystalVoronoi</a>Random Voronoi tessellation polycrystal (used by PolycrystalVoronoiAction)</li><li class="collection-item"><a href="../../source/postprocessors/WeightedVariableAverage.html">WeightedVariableAverage</a>Average a variable value using a weight mask given by a material property.</li><li class="collection-header">raccoon App</li><li class="collection-item"><a href="../../source/postprocessors/ExternalWork.html">ExternalWork</a>This class computes the total external work. The power expenditure (rate of external work) is defined as <span class="moose-katex-inline-equation" id="moose-equation-9a356498-ceec-416c-ad94-d1c99db9d493"><script>var element = document.getElementById("moose-equation-9a356498-ceec-416c-ad94-d1c99db9d493");katex.render("\\mathcal{P}^\\text{ext} = \\int_\\bodyboundary \\bft \\cdot \\dot{\\bs{\\phi}} \\diff{A}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>. The power expenditure is integrated in time to get the total work.</li><li class="collection-item"><a href="../../source/postprocessors/KineticEnergy.html">KineticEnergy</a>This class computes the total kinetic energy of the form <span class="moose-katex-inline-equation" id="moose-equation-53b826f9-11db-4f2e-bc37-d18b1428d4a5"><script>var element = document.getElementById("moose-equation-53b826f9-11db-4f2e-bc37-d18b1428d4a5");katex.render("\\int_\\body 0.5\\rho \\dot{u} \\cdot \\dot{u} \\diff{V}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="../../source/postprocessors/LargeDeformationJIntegral.html">LargeDeformationJIntegral</a>This class computes the J integral for a phase-field model of fracture</li><li class="collection-item"><a href="../../source/postprocessors/PhaseFieldJIntegral.html">PhaseFieldJIntegral</a>Compute the J integral for a phase-field model of fracture</li><li class="collection-item"><a href="../../source/postprocessors/SolutionChangeNorm.html">SolutionChangeNorm</a>This class computes the solution change (L2) norm of selected variables.</li><li class="collection-header">Ray Tracing App</li><li class="collection-item"><a href="../../source/postprocessors/RayDataValue.html">RayDataValue</a>Obtains a value from the data or aux data of a Ray after tracing has been completed.</li><li class="collection-item"><a href="../../source/postprocessors/RayIntegralValue.html">RayIntegralValue</a>Obtains the integrated value accumulated into a Ray from an IntegralRayKernel-derived class.</li><li class="collection-item"><a href="../../source/postprocessors/RayTracingStudyResult.html">RayTracingStudyResult</a>Gets a result from a RayTracingStudy.</li><li class="collection-header">Heat Transfer App</li><li class="collection-item"><a href="../../source/postprocessors/ConvectiveHeatTransferSideIntegral.html">ADConvectiveHeatTransferSideIntegral</a>Computes the total convective heat transfer across a boundary.</li><li class="collection-item"><a href="../../source/postprocessors/ConvectiveHeatTransferSideIntegral.html">ConvectiveHeatTransferSideIntegral</a>Computes the total convective heat transfer across a boundary.</li><li class="collection-item"><a href="../../source/postprocessors/ExposedSideAverageValue.html">ExposedSideAverageValue</a>Computes the average value of a variable on the exposed portion of a sideset. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="../../source/postprocessors/GrayLambertSurfaceRadiationPP.html">GrayLambertSurfaceRadiationPP</a>This postprocessor allows to extract radiosity, heat flux density, and temperature from the GrayLambertSurfaceRadiationBase object.</li><li class="collection-item"><a href="../../source/postprocessors/HomogenizedThermalConductivity.html">HomogenizedThermalConductivity</a>Postprocessor for asymptotic expansion homogenization for thermal conductivity</li><li class="collection-item"><a href="../../source/postprocessors/ThermalConductivity.html">ThermalConductivity</a>Computes the effective thermal conductivity averaged on a boundary.</li><li class="collection-item"><a href="../../source/postprocessors/ViewFactorPP.html">ViewFactorPP</a>This postprocessor allows to extract view factors from ViewFactor userobjects.</li><li class="collection-header">Solid Mechanics App</li><li class="collection-item"><a href="../../source/postprocessors/Mass.html">ADMass</a>Computes the mass of the solid as the integral of the density material property</li><li class="collection-item"><a href="../../source/postprocessors/MaterialTensorAverage.html">ADMaterialTensorAverage</a>Computes the average of a RankTwoTensor component over a volume.</li><li class="collection-item"><a href="../../source/postprocessors/MaterialTensorIntegral.html">ADMaterialTensorIntegral</a>This postprocessor computes an element integral of a component of a material tensor as specified by the user-supplied indices</li><li class="collection-item"><a href="../../source/postprocessors/SidesetReaction.html">ADSidesetReaction</a>Computes the integrated reaction force in a user-specified direction on a sideset from the surface traction</li><li class="collection-item"><a href="../../source/postprocessors/AnalysisStepNumber.html">AnalysisStepNumber</a>Outputs the current analysis step number.</li><li class="collection-item"><a href="../../source/postprocessors/AsymptoticExpansionHomogenizationElasticConstants.html">AsymptoticExpansionHomogenizationElasticConstants</a>Postprocessor for asymptotic expansion homogenization for elasticity</li><li class="collection-item"><a href="../../source/postprocessors/CavityPressurePostprocessor.html">CavityPressurePostprocessor</a>Interfaces with the CavityPressureUserObject to store the initial number of moles of a gas contained within an internal volume.</li><li class="collection-item"><a href="../../source/postprocessors/CrackFrontData.html">CrackFrontData</a>Determines which nodes are along the crack front</li><li class="collection-item"><a href="../../source/postprocessors/CriticalTimeStep.html">CriticalTimeStep</a>Computes and reports the critical time step for the explicit solver.</li><li class="collection-item"><a href="../../source/postprocessors/Mass.html">Mass</a>Computes the mass of the solid as the integral of the density material property</li><li class="collection-item"><a href="../../source/postprocessors/MaterialTensorAverage.html">MaterialTensorAverage</a>Computes the average of a RankTwoTensor component over a volume.</li><li class="collection-item"><a href="../../source/postprocessors/MaterialTensorIntegral.html">MaterialTensorIntegral</a>This postprocessor computes an element integral of a component of a material tensor as specified by the user-supplied indices</li><li class="collection-item"><a href="../../source/postprocessors/MaterialTimeStepPostprocessor.html">MaterialTimeStepPostprocessor</a>This postprocessor estimates a timestep that reduces the increment change in a material property below a given threshold.</li><li class="collection-item"><a href="../../source/postprocessors/NormalBoundaryDisplacement.html">NormalBoundaryDisplacement</a>This postprocessor computes the normal displacement on a given set of boundaries.</li><li class="collection-item"><a href="../../source/postprocessors/PolarMomentOfInertia.html">PolarMomentOfInertia</a>Compute the polar moment of inertia of a sideset w.r.t. a point and a direction</li><li class="collection-item"><a href="../../source/postprocessors/SidesetReaction.html">SidesetReaction</a>Computes the integrated reaction force in a user-specified direction on a sideset from the surface traction</li><li class="collection-item"><a href="../../source/postprocessors/TorqueReaction.html">TorqueReaction</a>TorqueReaction calculates the torque in 2D and 3Dabout a user-specified axis of rotation centeredat a user-specified origin.</li></ul></section><section id="d7489d6f-5e75-4dbd-b207-183bfde06db5" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/AddPostprocessorAction.html">AddPostprocessorAction</a>Add a Postprocessor object to the simulation.</li></ul></section></section><div class="moose-modal modal" id="5ed64e1c-a3c0-4ed4-af68-4a25778192ee"><div class="modal-content"><h4>(moose/test/tests/postprocessors/element_extreme_value/element_extreme_value.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = u
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  []
[]

[Postprocessors]
  [max]
    type = ElementExtremeValue
    variable = u
  []
  [min]
    type = ElementExtremeValue
    variable = u
    value_type = min
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="f29ef91f-7a91-46c6-b0c4-c64ba9574cf3"><div class="modal-content"><h4>(moose/test/tests/bcs/pp_neumann/pp_neumann.i)</h4><pre style="max-height:350px;"><code class="language-moose"># NOTE: This file is used within the documentation, so please do not change names within the file
# without checking that associated documentation is not affected, see syntax/Postprocessors/index.md.
[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [u]
  []
[]

[AuxVariables]
  [aux]
    initial_condition = 5
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = u
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = PostprocessorNeumannBC
    variable = u
    boundary = right
    postprocessor = right_pp
  []
[]

[Postprocessors]
  [right_pp]
    type = PointValue
    point = &#x27;0.5 0.5 0&#x27;
    variable = aux
    execute_on = &#x27;initial&#x27;
  []
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="f7eb3842-e0aa-4dd5-a484-0d74b120ed25"><div class="modal-content"><h4>(moose/framework/src/bcs/PostprocessorNeumannBC.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;PostprocessorNeumannBC.h&quot;

registerMooseObject(&quot;MooseApp&quot;, PostprocessorNeumannBC);

InputParameters
PostprocessorNeumannBC::validParams()
{
  InputParameters params = IntegratedBC::validParams();
  params.addClassDescription(
      &quot;Neumann boundary condition with value prescribed by a Postprocessor value.&quot;);
  params.addParam&lt;PostprocessorName&gt;(
      &quot;postprocessor&quot;, 0.0, &quot;The postprocessor to use for value of the gradient on the boundary.&quot;);
  return params;
}

PostprocessorNeumannBC::PostprocessorNeumannBC(const InputParameters &amp; parameters)
  : IntegratedBC(parameters), _value(getPostprocessorValue(&quot;postprocessor&quot;))
{
}

Real
PostprocessorNeumannBC::computeQpResidual()
{
  return -_test[_i][_qp] * _value;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="a2973da3-d67a-4239-a5ca-8de86cf98445"><div class="modal-content"><h4>(moose/framework/include/bcs/PostprocessorNeumannBC.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;IntegratedBC.h&quot;

/**
 * Implements a constant Neumann BC where grad(u) is a equal to a postprocessor on the boundary.
 * Uses the term produced from integrating the diffusion operator by parts.
 */
class PostprocessorNeumannBC : public IntegratedBC
{
public:
  /**
   * Factory constructor, takes parameters so that all derived classes can be built using the same
   * constructor.
   */
  static InputParameters validParams();

  PostprocessorNeumannBC(const InputParameters &amp; parameters);

protected:
  virtual Real computeQpResidual() override;

  /// Value of grad(u) on the boundary.
  const PostprocessorValue &amp; _value;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ca9b23c3-38d8-43de-8c39-fae9da440fb1"><div class="modal-content"><h4>(moose/framework/src/bcs/PostprocessorNeumannBC.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;PostprocessorNeumannBC.h&quot;

registerMooseObject(&quot;MooseApp&quot;, PostprocessorNeumannBC);

InputParameters
PostprocessorNeumannBC::validParams()
{
  InputParameters params = IntegratedBC::validParams();
  params.addClassDescription(
      &quot;Neumann boundary condition with value prescribed by a Postprocessor value.&quot;);
  params.addParam&lt;PostprocessorName&gt;(
      &quot;postprocessor&quot;, 0.0, &quot;The postprocessor to use for value of the gradient on the boundary.&quot;);
  return params;
}

PostprocessorNeumannBC::PostprocessorNeumannBC(const InputParameters &amp; parameters)
  : IntegratedBC(parameters), _value(getPostprocessorValue(&quot;postprocessor&quot;))
{
}

Real
PostprocessorNeumannBC::computeQpResidual()
{
  return -_test[_i][_qp] * _value;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="059c10c7-d800-4d5d-a9e3-5f1951c38358"><div class="modal-content"><h4>(moose/test/tests/postprocessors/scalar_coupled_postprocessor/scalar_coupled_postprocessor_test.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  ny = 5
  xmax = 1
  ymax = 1
  elem_type = QUAD4
[]

[Variables]
  [./u]
    initial_condition = 1
  [../]
  [./scalar_variable]
    family = SCALAR
    order = FIRST
    initial_condition = 2
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[ScalarKernels]
  [./td1]
    type = ODETimeDerivative
    variable = scalar_variable
  [../]
[]

[BCs]
  [./leftDirichlet]
      type = DirichletBC
      variable = u
      boundary = &#x27;left&#x27;
      value = 1
  [../]
  [./rightDirichlet]
      type = DirichletBC
      variable = u
      boundary = &#x27;right&#x27;
      value = 0
  [../]
[]

[Postprocessors]
  [./totalFlux]
    type = ScalarCoupledPostprocessor
    variable = u
    coupled_scalar = scalar_variable
    boundary = left
  [../]
[]

[Executioner]
  type = Transient
  dt = 1
  num_steps = 1
  solve_type = JFNK
  l_max_its = 30
  l_tol = 1e-6
  nl_max_its = 20
  nl_rel_tol = 1e-5
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="eb9bd6c9-7ccd-4c6d-8480-ebe0f46048da"><div class="modal-content"><h4>(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AverageNodalVariableValue.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;SubProblem.h&quot;

registerMooseObject(&quot;MooseApp&quot;, AverageNodalVariableValue);

InputParameters
AverageNodalVariableValue::validParams()
{
  InputParameters params = NodalVariablePostprocessor::validParams();

  params.addClassDescription(&quot;Computes the average value of a field by sampling all nodal &quot;
                             &quot;solutions on the domain or within a subdomain&quot;);
  return params;
}

AverageNodalVariableValue::AverageNodalVariableValue(const InputParameters &amp; parameters)
  : NodalVariablePostprocessor(parameters), _sum(0), _n(0)
{
}

// doco-init-start
void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
// doco-init-end

// doco-execute-get-start
void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue() const
{
  return _sum / _n;
}
// doco-execute-get-end

// doco-final-start
void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
// doco-final-end

// doco-thread-start
void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const auto &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
// doco-thread-end
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="5ca15609-7cac-4771-bde2-6af17ca4cdcb"><div class="modal-content"><h4>(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AverageNodalVariableValue.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;SubProblem.h&quot;

registerMooseObject(&quot;MooseApp&quot;, AverageNodalVariableValue);

InputParameters
AverageNodalVariableValue::validParams()
{
  InputParameters params = NodalVariablePostprocessor::validParams();

  params.addClassDescription(&quot;Computes the average value of a field by sampling all nodal &quot;
                             &quot;solutions on the domain or within a subdomain&quot;);
  return params;
}

AverageNodalVariableValue::AverageNodalVariableValue(const InputParameters &amp; parameters)
  : NodalVariablePostprocessor(parameters), _sum(0), _n(0)
{
}

// doco-init-start
void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
// doco-init-end

// doco-execute-get-start
void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue() const
{
  return _sum / _n;
}
// doco-execute-get-end

// doco-final-start
void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
// doco-final-end

// doco-thread-start
void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const auto &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
// doco-thread-end
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="59cc1c8c-7a17-4594-a44d-cdcb3dff2c03"><div class="modal-content"><h4>(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AverageNodalVariableValue.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;SubProblem.h&quot;

registerMooseObject(&quot;MooseApp&quot;, AverageNodalVariableValue);

InputParameters
AverageNodalVariableValue::validParams()
{
  InputParameters params = NodalVariablePostprocessor::validParams();

  params.addClassDescription(&quot;Computes the average value of a field by sampling all nodal &quot;
                             &quot;solutions on the domain or within a subdomain&quot;);
  return params;
}

AverageNodalVariableValue::AverageNodalVariableValue(const InputParameters &amp; parameters)
  : NodalVariablePostprocessor(parameters), _sum(0), _n(0)
{
}

// doco-init-start
void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
// doco-init-end

// doco-execute-get-start
void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue() const
{
  return _sum / _n;
}
// doco-execute-get-end

// doco-final-start
void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
// doco-final-end

// doco-thread-start
void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const auto &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
// doco-thread-end
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="657b0585-7df1-4c15-b28b-3de1010fd91c"><div class="modal-content"><h4>(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AverageNodalVariableValue.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;SubProblem.h&quot;

registerMooseObject(&quot;MooseApp&quot;, AverageNodalVariableValue);

InputParameters
AverageNodalVariableValue::validParams()
{
  InputParameters params = NodalVariablePostprocessor::validParams();

  params.addClassDescription(&quot;Computes the average value of a field by sampling all nodal &quot;
                             &quot;solutions on the domain or within a subdomain&quot;);
  return params;
}

AverageNodalVariableValue::AverageNodalVariableValue(const InputParameters &amp; parameters)
  : NodalVariablePostprocessor(parameters), _sum(0), _n(0)
{
}

// doco-init-start
void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
// doco-init-end

// doco-execute-get-start
void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue() const
{
  return _sum / _n;
}
// doco-execute-get-end

// doco-final-start
void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
// doco-final-end

// doco-thread-start
void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const auto &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
// doco-thread-end
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
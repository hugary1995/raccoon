<!DOCTYPE html><head><meta charset="UTF-8"><title>RayBCs | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="049b4f64-3262-4b63-ae52-298e52cc3ecf" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="3b6f838b-4b56-472d-b6ad-b9148568e378" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9e43023b-1036-43fc-8ffc-7b2530b875b6" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="4fe305eb-1244-40f0-b5bf-841e7e5e6671" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="9fae91a7-1d13-47ac-8786-ae368c87bd46"><i class="material-icons">menu</i></a><ul class="sidenav" id="9fae91a7-1d13-47ac-8786-ae368c87bd46"><li><a href="#!" class="dropdown-trigger" data-target="86238e12-ccd7-432c-af9a-07157a3ef512" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="31b261a5-8c0c-440c-be1c-5a8ec4dcedef" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="2ae2bfa3-06fa-4c04-a56f-4f205d0bc7d9" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="70968ee4-0e96-45e9-bf10-04dbe06d89f0" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="049b4f64-3262-4b63-ae52-298e52cc3ecf"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="3b6f838b-4b56-472d-b6ad-b9148568e378"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="9e43023b-1036-43fc-8ffc-7b2530b875b6"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="4fe305eb-1244-40f0-b5bf-841e7e5e6671"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="86238e12-ccd7-432c-af9a-07157a3ef512"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="31b261a5-8c0c-440c-be1c-5a8ec4dcedef"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="2ae2bfa3-06fa-4c04-a56f-4f205d0bc7d9"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="70968ee4-0e96-45e9-bf10-04dbe06d89f0"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="11a321c3-0141-4e56-b840-8c3aa93ec145" data-section-level="1" data-section-text="RayBCs"><h1 id="raybcs">RayBCs</h1><p>A RayBC operates on a <a href="../../source/raytracing/Ray.html">Ray</a> in the <a href="../../modules/ray_tracing/index.html">Ray Tracing Module</a> that has intersected a boundary (both external and internal boundaries are supported). The base object is the <a href="../../source/raybcs/RayBoundaryConditionBase.html">RayBoundaryConditionBase</a>.</p><p>Common use cases for a RayBC are as follows:</p><ul class="browser-default"><li><p>Killing a <a href="../../source/raytracing/Ray.html">Ray</a> on a boundary (see <a href="index.html#killing-the-ray">Killing the Ray</a> and <a href="../../source/raybcs/KillRayBC.html">KillRayBC</a>). </p></li><li><p>Changing the direction of a <a href="../../source/raytracing/Ray.html">Ray</a> on a boundary, for example, reflecting the <a href="../../source/raytracing/Ray.html">Ray</a> (see <a href="index.html#changing-the-ray-trajectory">Changing the Ray Trajectory</a> and <a href="../../source/raybcs/ReflectRayBC.html">ReflectRayBC</a>). </p></li><li><p>Creating another <a href="../../source/raytracing/Ray.html">Ray</a> on a boundary mid-trace (see <a href="index.html#creating-a-new-ray">Creating a New Ray</a>)</p></li></ul><div class="card moose-alert moose-alert-tip"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">school</i><span class="moose-alert-title-brand">tip</span></div><div class="card-content"><div class="moose-alert-content"><p>The use of RayBCs is considered <strong>advanced</strong> use of the <a href="../../modules/ray_tracing/index.html">Ray Tracing Module</a>. For simple use cases like line sources (see <a href="../../modules/ray_tracing/examples/line_sources.html">Using Line Sources</a>) and line integrals (see <a href="../../modules/ray_tracing/examples/line_integrals.html">Computing Line Integrals</a>), RayBCs are not required.</p></div></div></div><p>Support is not currently available for contributing to residuals and Jacobians with RayBCs, nor is support for accessing coupled variables and materials on element sides in a RayBC. This support is planned in the future and will be implemented as a need arises.</p><section id="cde93bb4-0073-4cec-9699-cec4c19eafc2" data-section-level="2" data-section-text="Using a RayBC"><h2 id="using-a-raybc">Using a RayBC</h2><p>The method that is called on each intersected boundary along the trajectory of a <a href="../../source/raytracing/Ray.html">Ray</a> in a RayBC is <code>onBoundary()</code>. This method is to be overridden to specialize the on-boundary operation. For information on the <code>num_applying</code> parameter, see <a href="index.html#hitting-multiple-boundaries">Hitting Multiple Boundaries</a>.</p><p>The significant information pertaining to the trace that is available within <code>onBoundary()</code> is as follows:</p><ul class="browser-default"><li><p><code>currentRay()</code> - The current <a href="../../source/raytracing/Ray.html">Ray</a> being operated on that has intersected the boundary. </p></li><li><p><code>_current_elem</code> - The element that the <a href="../../source/raytracing/Ray.html">Ray</a> has intersected on the boundary. </p></li><li><p><code>_current_intersected_side</code> - The side of <code>_current_elem</code> that the <a href="../../source/raytracing/Ray.html">Ray</a> has intersected on the boundary. </p></li><li><p><code>_current_intersection_point</code> - The point on <code>_current_elem</code> on <code>_current_intersected_side</code> that the <a href="../../source/raytracing/Ray.html">Ray</a> has intersected on the boundary. </p></li><li><p><code>_current_intersected_extrema</code> - The extrema (element vertex or edge, see <a href="../../source/raytracing/ElemExtrema.html">ElemExtrema</a> for more information) intersected on <code>_current_intersected_side</code> at <code>_current_intersection_point</code> on <code>_current_elem</code>, if any. </p></li><li><p><code>_current_bnd_id</code> - The ID of the boundary that the <a href="../../source/raytracing/Ray.html">Ray</a> has intersected. </p></li><li><p><code>_current_subdomain_id</code> - The subdomain ID of the <code>_current_elem</code>.</p></li></ul><p>See the <a href="../../source/raytracing/Ray.html">Ray</a> documentation for what members are available for use during tracing.</p></section><section id="fac5b0e5-2f1e-47f2-90f4-350a562da55b" data-section-level="2" data-section-text="Killing the Ray"><h2 id="killing-the-ray">Killing the Ray</h2><p>A RayBC can stop a <a href="../../source/raytracing/Ray.html">Ray</a> from being traced, as is done in <a href="../../source/raybcs/KillRayBC.html">KillRayBC</a>:</p><pre style="max-height:350px;"><code class="language-cpp">void
KillRayBC::onBoundary(const unsigned int /* num_applying */)
{
  // After RayBCs are completed, ray-&gt;shouldContinue() is checked and this will kill the Ray
  currentRay()-&gt;setShouldContinue(false);
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#3e7da863-098f-41bc-82f3-177656de49b7">(moose/modules/ray_tracing/src/raybcs/KillRayBC.C)</a><p>Similarly, you can check if another RayBC has set to kill a <a href="../../source/raytracing/Ray.html">Ray</a> after this segment with:</p><pre style="max-height:350px;"><code class="language-text">
const bool ended = currentRay().shouldContinue();
</code></pre><p>After all RayBCs are executed at a point, if <code>!shouldContinue()</code>, the trace for the <a href="../../source/raytracing/Ray.html">Ray</a> will end.</p></section><section id="a2118b82-2bf9-41e6-803c-1e51fdd56914" data-section-level="2" data-section-text="Changing the Ray Trajectory"><h2 id="changing-the-ray-trajectory">Changing the Ray Trajectory</h2><p>A <a href="../../source/raytracing/Ray.html">Ray</a> that is currently being traced can have its trajectory changed on a boundary by a RayBC. The following conditions are imposed on a <a href="../../source/raytracing/Ray.html">Ray</a> with such a trajectory change:</p><ul class="browser-default"><li><p>It must be continuing (<code>currentRay()-&gt;shouldContinue() == true</code>). </p></li><li><p>It must have moved some before hitting the boundary (<code>currentRay()-&gt;distance() &gt; 0</code>). </p></li><li><p>The <a href="../../source/raytracing/Ray.html">Ray</a> cannot have had its end point set by <code>Ray::setStartingEndPoint()</code>. That is, if the user set a specific end point for the <a href="../../source/raytracing/Ray.html">Ray</a> (which internally sets its maximum distance to the straight-line distance from the start to the end), its trajectory can never be changed. </p></li><li><p>The new direction must be entrant into <code>_current_elem</code> on <code>_current_intersected_side</code> (the dot product of the outward normal of the side and the direction of the <a href="../../source/raytracing/Ray.html">Ray</a> must be negative).</p></li></ul><p>To change the trajectory of a <a href="../../source/raytracing/Ray.html">Ray</a> within a RayBC, the method <code>changeRayDirection()</code> is to be called with the new direction of the Ray. For example:</p><pre style="max-height:350px;"><code class="language-text">
const Point some_direction(1, 0, 0); // must be entrant!
changeRayDirection(some_direction);
</code></pre><p>Note on the optional parameter <code>const bool skip_changed_check</code> in <code>changeRayDirection()</code>. By default, only one RayBC is allowed to change the trajectory of a <a href="../../source/raytracing/Ray.html">Ray</a> that is being traced that intersects a boundary. Said optional parameter sets this requirement. There exist cases when it is appropriate to change the trajectory of a <a href="../../source/raytracing/Ray.html">Ray</a> multiple times at a point. See <a href="index.html#hitting-multiple-boundaries">Hitting Multiple Boundaries</a> for more information.</p></section><section id="1036a008-c253-4893-b416-c589dad79c08" data-section-level="2" data-section-text="Hitting Multiple Boundaries"><h2 id="hitting-multiple-boundaries">Hitting Multiple Boundaries</h2><p>When hitting an element vertex in 2D and 3D or an element edge in 3D, it is possible to intersect multiple boundaries at the same point. This is supported and <code>onBoundary()</code> will be called once on each of the boundaries that are hit for every RayBC that is defined on said boundaries.</p><p>The <code>onBoundary()</code> method passes a single argument, <code>num_applying</code>. This argument denotes how many of the <em>same</em> RayBC object are being applied at a point. To explain the necessity of <code>num_applying</code>, consider the following problem:</p><ul class="browser-default"><li><p>Two-dimensional domain with the boundaries <code>left</code>, <code>right</code>, <code>top</code>, and <code>bottom</code>. </p></li><li><p>A single <a href="../../source/raybcs/ReflectRayBC.html">ReflectRayBC</a> object is defined on all of the boundaries of the problem. That is, whenever a <a href="../../source/raytracing/Ray.html">Ray</a> hits any of the boundaries it will be reflected in a specular manner. </p></li><li><p>One of the traced rays perfectly hits the top-right corner of the domain, at which both the <code>top</code> and <code>right</code> boundaries exist.</p></li></ul><p>The correct specular reflection (inwards to the domain) can be achieved by applying a specular reflection on each of the boundaries, as seen below in Figure 1.</p><div class="card moose-float" style="width:90%;"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/ray_tracing/raybc_multiple_reflect.png" alt="Figure 1: Example specular reflection on two boundaries."></img></picture><p class="moose-caption"><span class="moose-caption-text">Figure 1: Example specular reflection on two boundaries.</span></p></div></div><p> Recall that the act of changing a <a href="../../source/raytracing/Ray.html">Ray</a> direction, achieved by <code>changeRayDirection()</code>, takes an optional parameter <code>const bool skip_changed_check</code>. In this case, where we want to apply the same <a href="../../source/raybcs/ReflectRayBC.html">ReflectRayBC</a> twice, we pass in <code>num_applying &gt; 1</code> as the argument to <code>skip_changed_check</code> to <em>allow</em> the changing of a <a href="../../source/raytracing/Ray.html">Ray</a> trajectory multiple times if the same <a href="../../source/raybcs/ReflectRayBC.html">ReflectRayBC</a> is applied more than once. This is done in <a href="../../source/raybcs/ReflectRayBC.html">ReflectRayBC</a> as follows:</p><pre style="max-height:350px;"><code class="language-cpp">void
ReflectRayBC::onBoundary(const unsigned int num_applying)
{
  if (_warn_non_planar &amp;&amp; _study.sideIsNonPlanar(_current_elem, _current_intersected_side))
    mooseWarning(&quot;A Ray is being reflected on a non-planar side.\n\n&quot;,
                 &quot;Ray tracing on elements with non-planar faces is an approximation.\n\n&quot;,
                 &quot;The normal used to compute the reflected direction is computed at\n&quot;,
                 &quot;the side centroid and may not be valid for a non-planar side.\n\n&quot;,
                 &quot;To disable this warning, set RayKernels/&quot;,
                 name(),
                 &quot;/warn_non_planar=false.\n\n&quot;,
                 currentRay()-&gt;getInfo());

  // No need to do anything if the Ray&#x27;s gonna die anyway
  if (!currentRay()-&gt;shouldContinue())
    return;

  // The direction this Ray reflects off this boundary
  const auto &amp; normal = _study.getSideNormal(_current_elem, _current_intersected_side, _tid);
  const auto reflected_direction = reflectedDirection(currentRay()-&gt;direction(), normal);

  // Change it! Note here the usage of num_applying: if we are at a corner with a reflecting
  // boundary condition on both sides, we want to allow both boundary conditions to reflect the Ray.
  // Therefore, we skip the check that another RayBC has changed the Ray&#x27;s trajectory when we are
  // applying multiple of the same ReflectRayBC at different boundaries at the same point to allow
  // this. Note that this double (or triple in 3D) reflection will only be allowed when the same
  // ReflectRayBC object is on both boundaries.
  changeRayDirection(reflected_direction, /* skip_changed_check = */ num_applying &gt; 1);
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#719551f4-7e4a-4400-bf14-0b8bc73e7a65">(moose/modules/ray_tracing/src/raybcs/ReflectRayBC.C)</a></section><section id="a1449c46-bfa9-4aa5-89b2-b4e7b890bcd2" data-section-level="2" data-section-text="Creating a New Ray"><h2 id="creating-a-new-ray">Creating a New Ray</h2><p>It is possible to generate another <a href="../../source/raytracing/Ray.html">Ray</a> to be traced from within a RayBC.</p><p>First, acquire a new <a href="../../source/raytracing/Ray.html">Ray</a> using the <code>acquireRay()</code> method (for more information on acquiring <a href="../../source/raytracing/Ray.html">Rays</a>, see <a href="../../source/userobjects/RayTracingStudy.html#ray-pool">Ray Pool</a>), which takes an argument that is the direction for the new <a href="../../source/raytracing/Ray.html">Ray</a>. For example:</p><pre style="max-height:350px;"><code class="language-text">
const Point some_direction(1, 0, 0); // must be entrant on _current_intersected_side!
std::shared_ptr&lt;Ray&gt; ray = acquireRay(some_direction);
</code></pre><p>The acquired <a href="../../source/raytracing/Ray.html">Ray</a> will be initialized with the following:</p><ul class="browser-default"><li><p>Zeroed data and aux data, sized as registered by the <code>RayTracingStudy</code>. </p></li><li><p>A starting element that is <code>_current_elem</code>. </p></li><li><p>An incoming side that is <code>_current_intersected_side</code>. </p></li><li><p>A starting point that is <code>_current_intersected_point</code>. </p></li><li><p>A direction as set by the user. </p></li><li><p>A unique ID.</p></li></ul><p>After the <a href="../../source/raytracing/Ray.html">Ray</a> has been acquired, you may modify its data members as desired before setting it to be traced. Once the <a href="../../source/raytracing/Ray.html">Ray</a> is modified as desired, do the following to insert it into the buffer to be traced:</p><pre style="max-height:350px;"><code class="language-text">
moveRayToBuffer(ray);
</code></pre></section></section><div class="moose-modal modal" id="3e7da863-098f-41bc-82f3-177656de49b7"><div class="modal-content"><h4>(moose/modules/ray_tracing/src/raybcs/KillRayBC.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;KillRayBC.h&quot;

registerMooseObject(&quot;RayTracingApp&quot;, KillRayBC);

InputParameters
KillRayBC::validParams()
{
  auto params = GeneralRayBC::validParams();
  params.addClassDescription(&quot;A RayBC that kills a Ray on a boundary.&quot;);
  return params;
}

KillRayBC::KillRayBC(const InputParameters &amp; params) : GeneralRayBC(params) {}

void
KillRayBC::onBoundary(const unsigned int /* num_applying */)
{
  // After RayBCs are completed, ray-&gt;shouldContinue() is checked and this will kill the Ray
  currentRay()-&gt;setShouldContinue(false);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="719551f4-7e4a-4400-bf14-0b8bc73e7a65"><div class="modal-content"><h4>(moose/modules/ray_tracing/src/raybcs/ReflectRayBC.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ReflectRayBC.h&quot;

// Local includes
#include &quot;RayTracingStudy.h&quot;

registerMooseObject(&quot;RayTracingApp&quot;, ReflectRayBC);

InputParameters
ReflectRayBC::validParams()
{
  auto params = GeneralRayBC::validParams();

  params.addParam&lt;bool&gt;(
      &quot;warn_non_planar&quot;,
      true,
      &quot;Whether or not to emit a warning if a Ray is being reflected on a non-planar side&quot;);

  params.addClassDescription(&quot;A RayBC that reflects a Ray in a specular manner on a boundary.&quot;);

  return params;
}

ReflectRayBC::ReflectRayBC(const InputParameters &amp; params)
  : GeneralRayBC(params), _warn_non_planar(getParam&lt;bool&gt;(&quot;warn_non_planar&quot;))
{
}

void
ReflectRayBC::onBoundary(const unsigned int num_applying)
{
  if (_warn_non_planar &amp;&amp; _study.sideIsNonPlanar(_current_elem, _current_intersected_side))
    mooseWarning(&quot;A Ray is being reflected on a non-planar side.\n\n&quot;,
                 &quot;Ray tracing on elements with non-planar faces is an approximation.\n\n&quot;,
                 &quot;The normal used to compute the reflected direction is computed at\n&quot;,
                 &quot;the side centroid and may not be valid for a non-planar side.\n\n&quot;,
                 &quot;To disable this warning, set RayKernels/&quot;,
                 name(),
                 &quot;/warn_non_planar=false.\n\n&quot;,
                 currentRay()-&gt;getInfo());

  // No need to do anything if the Ray&#x27;s gonna die anyway
  if (!currentRay()-&gt;shouldContinue())
    return;

  // The direction this Ray reflects off this boundary
  const auto &amp; normal = _study.getSideNormal(_current_elem, _current_intersected_side, _tid);
  const auto reflected_direction = reflectedDirection(currentRay()-&gt;direction(), normal);

  // Change it! Note here the usage of num_applying: if we are at a corner with a reflecting
  // boundary condition on both sides, we want to allow both boundary conditions to reflect the Ray.
  // Therefore, we skip the check that another RayBC has changed the Ray&#x27;s trajectory when we are
  // applying multiple of the same ReflectRayBC at different boundaries at the same point to allow
  // this. Note that this double (or triple in 3D) reflection will only be allowed when the same
  // ReflectRayBC object is on both boundaries.
  changeRayDirection(reflected_direction, /* skip_changed_check = */ num_applying &gt; 1);
}

Point
ReflectRayBC::reflectedDirection(const Point &amp; direction, const Point &amp; normal)
{
  mooseAssert(MooseUtils::absoluteFuzzyEqual(direction.norm(), 1.), &quot;Direction not normalized&quot;);
  mooseAssert(MooseUtils::absoluteFuzzyEqual(normal.norm(), 1.), &quot;Normal not normalized&quot;);

  Point reflected_direction = direction;
  reflected_direction -= 2.0 * (reflected_direction * normal) * normal;
  return reflected_direction / reflected_direction.norm();
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
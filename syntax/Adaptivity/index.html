<!DOCTYPE html><head><meta charset="UTF-8"><title>Adaptivity System | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="57cd1749-8ad4-4720-9de8-d954f71320d3" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="75bf6675-8898-4aa6-b5b0-926edd5134ff" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="e631e657-13a5-44a5-8fb7-475833f8b9ae" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="69bee565-6caf-4f35-a2f5-c186a5ebdcfb" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="2f7fc4c1-fe48-41ea-8aed-0558df7e41d7"><i class="material-icons">menu</i></a><ul class="sidenav" id="2f7fc4c1-fe48-41ea-8aed-0558df7e41d7"><li><a href="#!" class="dropdown-trigger" data-target="ab9357cb-fda3-477c-807a-8c80d1524034" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="aa4659c4-220e-4d3e-bcb9-49a487fcfac6" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="11538331-b129-445a-9d0d-b9068d577a6f" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="100ec0db-4f37-4146-9448-1502f45a7713" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="57cd1749-8ad4-4720-9de8-d954f71320d3"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="75bf6675-8898-4aa6-b5b0-926edd5134ff"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="e631e657-13a5-44a5-8fb7-475833f8b9ae"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="69bee565-6caf-4f35-a2f5-c186a5ebdcfb"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="ab9357cb-fda3-477c-807a-8c80d1524034"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="aa4659c4-220e-4d3e-bcb9-49a487fcfac6"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="11538331-b129-445a-9d0d-b9068d577a6f"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="100ec0db-4f37-4146-9448-1502f45a7713"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="28dc0a1e-71cf-41af-b6d9-aaf15d3e5595" data-section-level="1" data-section-text="Adaptivity System"><h1 id="adaptivity-system">Adaptivity System</h1><p>MOOSE employs <span class="moose-katex-inline-equation" id="moose-equation-f73df1a9-453b-48ff-8ddc-35b1ce1d3a67"><script>var element = document.getElementById("moose-equation-f73df1a9-453b-48ff-8ddc-35b1ce1d3a67");katex.render("h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>-adaptivity and <span class="moose-katex-inline-equation" id="moose-equation-33b8bd0e-9cd6-435e-a068-448db01b3108"><script>var element = document.getElementById("moose-equation-33b8bd0e-9cd6-435e-a068-448db01b3108");katex.render("p", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>-adaptivity to automatically refine or coarsen the mesh in regions of high or low estimated solution error, respectively. The idea is to concentrate degrees of freedom (DOFs) where the error is highest, while reducing DOFs where the solution is already well-captured. This is achieved through splitting and joining elements from the original mesh based on an error <a href="Indicators/index.html"><code>Indicator</code></a>. Once an error has been computed, a <a href="Markers/index.html"><code>Marker</code></a> is used to decide which elements to refine or coarsen. Mesh adaptivity can be employed with both <code>Steady</code> and <code>Transient</code> Executioners.</p><section id="a6927a32-d69a-4964-9159-577bd2ba8eb4" data-section-level="2" data-section-text="Refinement Patterns"><h2 id="refinement-patterns">Refinement Patterns</h2><p>MOOSE employs &quot;self-similar&quot;, isotropic refinement patterns, as shown in the figure. When an element is marked for refinement, it is split into elements of the same type. For example, when using Quad4 elements, four &quot;child&quot; elements are created when the element is refined. Coarsening happens in reverse, children are deleted and the &quot;parent&quot; element is reactivated. The original mesh starts at refinement level 0. Each time an element is split, the children are assigned a refinement level one higher than their parents.</p><div class="card moose-float"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/framework/adaptivity.png" alt="Self-similar refinement pattern utilized by MOOSE for adaptivity for 1D linear,                2D quadrilateral, and 3D hexahedron elements."></img></picture><p class="moose-caption"><span class="moose-caption-text">Self-similar refinement pattern utilized by MOOSE for adaptivity for 1D linear,                2D quadrilateral, and 3D hexahedron elements.</span></p></div></div></section><section id="b9a62631-9062-4c79-83a1-edf572642dbd" data-section-level="2" data-section-text="P - Refinement"><h2 id="p-refinement">P-Refinement</h2><p>P-refinement can be selected by setting <code>adaptivity_type = p</code> in the <code>Adaptivity</code> block (whether using the older <a href="../Executioner/Adaptivity/index.html">Executioner/Adaptivity</a> syntax which uses libMesh error estimators or the newer top-level <code>Adaptivity</code> block (referenced by this page) using the <code>Indicators</code> and <code>Markers</code> introduced towards the beginning of this page). P-refinement level mismatches are not supported for continuous, non-hierarchic finite element families. Additionally, p-refinement of <code>NEDELEC_ONE</code> and <code>RAVIART_THOMAS</code> elements is not supported. Consequently, by default we disable p-refinement of the following bases: <code>LAGRANGE</code>, <code>NEDELEC_ONE</code>, <code>RAVIART_THOMAS</code>, <code>LAGRANGE_VEC</code>, <code>CLOUGH</code>, <code>BERNSTEIN</code>, and <code>RATIONAL_BERNSTEIN</code>. Users can control what families are disabled for p-refinement by setting the <code>disable_p_refinement_for_families</code> parameter.</p></section><section id="9a556914-108a-46ea-bc11-584374e30d0c" data-section-level="2" data-section-text="HP - Refinement"><h2 id="hp-refinement">HP-Refinement</h2><p>MOOSE includes experimental HP refinement capability. HP refinement can be selected by setting <code>adaptivity_type = hp</code> in the <code>Adaptivity</code> block. HP-refinement works by performing a coarsening test on elements just flagged for h-refinement (using libMesh error indicators or the <code>Indicator</code>/<code>Marker</code> systems). The coarsening test coarsens in both h and p and notes whichever changes the solution more. If p shows a larger solution change (after doing some weighting based on how many degrees of freedom are added) <em>and</em> the solution is sufficiently smooth as determined by decay rates of Legendre coefficients, then we switch the element refinement choice from h to p. As noted in the documentation for the <code>HPCoarsenTest</code> class, more development is likely required to produce optimal hp meshes.</p></section><section id="ccbf276b-5b80-4917-840d-cceee5360180" data-section-level="2" data-section-text="Cycles and Intervals"><h2 id="cycles-and-intervals">Cycles and Intervals</h2><p>MOOSE normally performs one adaptivity step per solve. However, developers have the ability to increase or decrease the amount of adaptivity performed through the &quot;cycles&quot; and &quot;interval&quot; parameters.</p><p>The &quot;cycles&quot; parameter can be set to perform multiple adaptivity cycles for a single solve. This is useful for cases where one would like to resolve a sharp feature in a single step, such as in the case of an introduced nucleus.</p><pre style="max-height:350px;"><code class="language-moose">[./Adaptivity&lt;&lt;&lt;{&quot;href&quot;: &quot;index.html&quot;}&gt;&gt;&gt;]
  refine_fraction = 0.3
  max_h_level&lt;&lt;&lt;{&quot;description&quot;: &quot;Maximum number of times a single element can be refined. If 0 then infinite.&quot;}&gt;&gt;&gt; = 7
  cycles_per_step&lt;&lt;&lt;{&quot;description&quot;: &quot;The number of adaptive steps to use when on each timestep during a Transient simulation.&quot;}&gt;&gt;&gt; = 2
[../]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#9de6f079-e094-4fd8-949d-3befba7af1a7">(moose/test/tests/mesh/adapt/adapt_test_cycles.i)</a><p>The &quot;interval&quot; parameter can be set to decrease the amount of adaptivity is performed so that it is performed on every _nth_ step. This can sometimes help to speed up your simulation as adaptivity can be somewhat expensive to perform.</p><pre style="max-height:350px;"><code class="language-moose">[./Adaptivity&lt;&lt;&lt;{&quot;href&quot;: &quot;index.html&quot;}&gt;&gt;&gt;]
  interval&lt;&lt;&lt;{&quot;description&quot;: &quot;The number of time steps betweeen each adaptivity phase&quot;}&gt;&gt;&gt; = 2
  refine_fraction = 0.2
  coarsen_fraction = 0.3
  max_h_level&lt;&lt;&lt;{&quot;description&quot;: &quot;Maximum number of times a single element can be refined. If 0 then infinite.&quot;}&gt;&gt;&gt; = 4
[../]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#9a6ac9fb-8898-4606-af42-dd9c110f213c">(moose/test/tests/mesh/adapt/interval.i)</a></section><section id="5c408159-7c41-458f-8074-dd63cbd731ab" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="429bafd7-4d14-41fa-ba15-1af9fc6929f2" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">active</span><span class="moose-parameter-header-default">__all__ </span><span class="moose-parameter-header-description">If specified only the blocks named will be visited and made active</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>__all__ </p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>If specified only the blocks named will be visited and made active</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">adaptivity_type</span><span class="moose-parameter-header-default">h</span><span class="moose-parameter-header-description">Select between h, p or hp mesh adaptivity</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>h</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>h, p, hp</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Select between h, p or hp mesh adaptivity</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">cycles_per_step</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">The number of adaptive steps to use when on each timestep during a Transient simulation.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The number of adaptive steps to use when on each timestep during a Transient simulation.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">inactive</span><span class="moose-parameter-header-description">If specified blocks matching these identifiers will be skipped.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>If specified blocks matching these identifiers will be skipped.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">interval</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">The number of time steps betweeen each adaptivity phase</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-doc-range"><span>Range:</span>interval>0</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The number of time steps betweeen each adaptivity phase</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">marker</span><span class="moose-parameter-header-description">The name of the Marker to use to actually adapt the mesh.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MarkerName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the Marker to use to actually adapt the mesh.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">max_h_level</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">Maximum number of times a single element can be refined. If 0 then infinite.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Maximum number of times a single element can be refined. If 0 then infinite.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">recompute_markers_during_cycles</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Recompute markers during adaptivity cycles</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Recompute markers during adaptivity cycles</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">start_time</span><span class="moose-parameter-header-default">-1.79769e+308</span><span class="moose-parameter-header-description">The time that adaptivity will be active after.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>-1.79769e+308</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The time that adaptivity will be active after.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">steps</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The number of adaptive steps to use when doing a Steady simulation.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The number of adaptive steps to use when doing a Steady simulation.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">stop_time</span><span class="moose-parameter-header-default">1.79769e+308</span><span class="moose-parameter-header-description">The time after which adaptivity will no longer be active.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1.79769e+308</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The time after which adaptivity will no longer be active.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="ff28bd57-be70-4ec6-becb-2d8a7e7ff1f1" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="fbf4b1fa-5768-47ac-a859-9ba6ecf02d00" data-section-level="3" data-section-text="Initial Adaptivity Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">initial_marker</span><span class="moose-parameter-header-description">The name of the Marker to use to adapt the mesh during initial refinement.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MarkerName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the Marker to use to adapt the mesh during initial refinement.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">initial_steps</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The number of adaptive steps to do based on the initial condition.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The number of adaptive steps to do based on the initial condition.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Initial Adaptivity Parameters</h3></summary></details></section></section><section id="f48bb9a3-9241-42a5-931f-931498e00c92" data-section-level="2" data-section-text="Available Subsystems"><h2 id="available-subsystems">Available Subsystems</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="Indicators/index.html">Indicators</a></li><li class="collection-item"><a href="Markers/index.html">Markers</a></li></ul></section></section><div class="moose-modal modal" id="9de6f079-e094-4fd8-949d-3befba7af1a7"><div class="modal-content"><h4>(moose/test/tests/mesh/adapt/adapt_test_cycles.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  type = GeneratedMesh
  nx = 2
  ny = 2
  dim = 2
  uniform_refine = 3
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;udiff uconv uie vdiff&#x27;

  [./udiff]
    type = Diffusion
    variable = u
  [../]

  [./uconv]
    type = Convection
    variable = u
    velocity = &#x27;20 1 0&#x27;
  [../]

  [./uie]
    type = TimeDerivative
    variable = u
  [../]

  [./vdiff]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  active = &#x27;uleft uright vleft vright&#x27;

  [./uleft]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./uright]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./vleft]
    type = DirichletBC
    variable = v
    boundary = 3
    value = 1
  [../]

  [./vright]
    type = DirichletBC
    variable = v
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 2
  dt = .1

  [./Adaptivity]
    refine_fraction = 0.3
    max_h_level = 7
    cycles_per_step = 2
  [../]
[]

[Outputs]
  file_base = out_cycles
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="9a6ac9fb-8898-4606-af42-dd9c110f213c"><div class="modal-content"><h4>(moose/test/tests/mesh/adapt/interval.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  type = GeneratedMesh
  nx = 2
  ny = 2
  dim = 2
  uniform_refine = 3
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;udiff uconv uie vdiff vconv vie&#x27;

  [./udiff]
    type = Diffusion
    variable = u
  [../]

  [./uconv]
    type = Convection
    variable = u
    velocity = &#x27;10 1 0&#x27;
  [../]

  [./uie]
    type = TimeDerivative
    variable = u
  [../]

  [./vdiff]
    type = Diffusion
    variable = v
  [../]

  [./vconv]
    type = Convection
    variable = v
    velocity = &#x27;-10 1 0&#x27;
  [../]

  [./vie]
    type = TimeDerivative
    variable = v
  [../]
[]

[BCs]
  active = &#x27;uleft uright vleft vright&#x27;

  [./uleft]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./uright]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./vleft]
    type = DirichletBC
    variable = v
    boundary = 3
    value = 1
  [../]

  [./vright]
    type = DirichletBC
    variable = v
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 4
  dt = .1

  [./Adaptivity]
    interval = 2
    refine_fraction = 0.2
    coarsen_fraction = 0.3
    max_h_level = 4
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
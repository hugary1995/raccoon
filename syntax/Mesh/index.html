<!DOCTYPE html><head><meta charset="UTF-8"><title>Mesh System | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="84f081c8-cae9-498e-b001-e14b616de516" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d44d6010-7a19-4a3c-90ec-4695b5807c66" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="62e0ab55-3f28-446f-b402-b30dd3e1813d" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="82e8fd1e-d5ef-4a16-b116-4615cdbb3f94" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="8b5e6d57-fe12-48d8-8832-922969b87540"><i class="material-icons">menu</i></a><ul class="sidenav" id="8b5e6d57-fe12-48d8-8832-922969b87540"><li><a href="#!" class="dropdown-trigger" data-target="981bd9b4-b8bc-40c4-b3f6-91b4d7bc6465" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="3d22bbe8-bf18-4f67-93c0-73a5b8383974" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="7a304deb-e128-4106-84b4-a5666c96f4ea" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1c1aa100-68cc-40a3-8c4a-53946ab9f68f" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="84f081c8-cae9-498e-b001-e14b616de516"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="d44d6010-7a19-4a3c-90ec-4695b5807c66"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="62e0ab55-3f28-446f-b402-b30dd3e1813d"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="82e8fd1e-d5ef-4a16-b116-4615cdbb3f94"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="981bd9b4-b8bc-40c4-b3f6-91b4d7bc6465"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="3d22bbe8-bf18-4f67-93c0-73a5b8383974"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="7a304deb-e128-4106-84b4-a5666c96f4ea"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="1c1aa100-68cc-40a3-8c4a-53946ab9f68f"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="5b672753-09a2-4b97-9fd1-631382a42b83" data-section-level="1" data-section-text="Mesh System"><h1 id="mesh-system">Mesh System</h1><section id="02292cb3-22fe-4d55-aa29-789e4850473f" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p>There are two primary ways of creating a mesh for use in a MOOSE simulation: &quot;offline generation&quot; through a tool like <a href="https://cubit.sandia.gov/">CUBIT</a> from <a href="http://www.sandia.gov/">Sandia National Laboratories</a>, and &quot;online generation&quot; through programmatic interfaces. CUBIT is useful for creating complex geometries, and can be licensed from Coreform for a fee depending on the type of organization and work being performed. Other mesh generators can work as long as they output a file format that is supported by the <a href="../../source/mesh/FileMesh.html">FileMesh</a> object.</p></section><section id="798e5ad1-b259-4f4e-bc4e-5a61749d3b89" data-section-level="2" data-section-text="Example Syntax and Mesh Objects"><h2 id="example-syntax-and-mesh-objects">Example Syntax and Mesh Objects</h2><p>Mesh settings are applied with the <code>[Mesh]</code> section in input files, for example the basic input file syntax for generating a simple square mesh is shown below. For additional information on the other types of Mesh objects refer to the individual object pages listed below.</p><pre style="max-height:350px;"><code class="language-moose">[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;index.html&quot;}&gt;&gt;&gt;]
  [./square]
    type = GeneratedMeshGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Create a line, square, or cube mesh with uniformly spaced or biased elements.&quot;, &quot;href&quot;: &quot;../../source/meshgenerators/GeneratedMeshGenerator.html&quot;}&gt;&gt;&gt;
    nx&lt;&lt;&lt;{&quot;description&quot;: &quot;Number of elements in the X direction&quot;}&gt;&gt;&gt; = 2
    ny&lt;&lt;&lt;{&quot;description&quot;: &quot;Number of elements in the Y direction&quot;}&gt;&gt;&gt; = 2
    dim&lt;&lt;&lt;{&quot;description&quot;: &quot;The dimension of the mesh to be generated&quot;}&gt;&gt;&gt; = 2
  [../]
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#3282c5a5-9371-4b01-b835-754c2af0b0ae">(moose/test/tests/auxkernels/solution_aux/build.i)</a></section><section id="17a62bb7-1fba-4e71-83c3-86c4f9385f09" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/meshgenerators/AddMetaDataGenerator.html">AddMetaDataGenerator</a>This mesh generator assigns extraneous mesh metadata to the input mesh</li><li class="collection-item"><a href="../../source/meshgenerators/AdvancedExtruderGenerator.html">AdvancedExtruderGenerator</a>Extrudes a 1D mesh into 2D, or a 2D mesh into 3D, can have a variable height for each elevation, variable number of layers within each elevation, variable growth factors of axial element sizes within each elevation and remap subdomain_ids, boundary_ids and element extra integers within each elevation as well as interface boundaries between neighboring elevation layers.</li><li class="collection-item"><a href="../../source/meshgenerators/AllSideSetsByNormalsGenerator.html">AllSideSetsByNormalsGenerator</a>Adds sidesets to the entire mesh based on unique normals.</li><li class="collection-item"><a href="../../source/meshgenerators/AnnularMeshGenerator.html">AnnularMeshGenerator</a>For rmin&gt;0: creates an annular mesh of QUAD4 elements. For rmin=0: creates a disc mesh of QUAD4 and TRI3 elements. Boundary sidesets are created at rmax and rmin, and given these names. If dmin!<u>0 and dmax!</u>360, a sector of an annulus or disc is created. In this case boundary sidesets are also created at dmin and dmax, and given these names</li><li class="collection-item"><a href="../../source/meshgenerators/BlockDeletionGenerator.html">BlockDeletionGenerator</a>Mesh generator which removes elements from the specified subdomains</li><li class="collection-item"><a href="../../source/meshgenerators/BlockToMeshConverterGenerator.html">BlockToMeshConverterGenerator</a>Converts one or more blocks (subdomains) from a mesh into a stand-alone mesh with a single block in it.</li><li class="collection-item"><a href="../../source/meshgenerators/Boundary2DDelaunayGenerator.html">Boundary2DDelaunayGenerator</a>Mesh generator that convert a 2D surface given as one or a few boundaries of a 3D mesh into a 2D mesh using Delaunay triangulation.</li><li class="collection-item"><a href="../../source/meshgenerators/BoundaryDeletionGenerator.html">BoundaryDeletionGenerator</a>Mesh generator which removes side sets</li><li class="collection-item"><a href="../../source/meshgenerators/BoundaryElementConversionGenerator.html">BoundaryElementConversionGenerator</a>Convert the elements involved in a set of external boundaries to ensure that the boundary set only contains TRI3 elements</li><li class="collection-item"><a href="../../source/meshgenerators/BoundaryLayerSubdomainGenerator.html">BoundaryLayerSubdomainGenerator</a>Changes the subdomain ID of elements near the specified boundary(ies).</li><li class="collection-item"><a href="../../source/meshgenerators/BoundingBoxNodeSetGenerator.html">BoundingBoxNodeSetGenerator</a>Assigns all of the nodes either inside or outside of a bounding box to a new nodeset.</li><li class="collection-item"><a href="../../source/meshgenerators/BreakBoundaryOnSubdomainGenerator.html">BreakBoundaryOnSubdomainGenerator</a>Break boundaries based on the subdomains to which their sides are attached. Naming convention for the new boundaries will be the old boundary name plus &quot;_to_&quot; plus the subdomain name</li><li class="collection-item"><a href="../../source/meshgenerators/BreakMeshByBlockGenerator.html">BreakMeshByBlockGenerator</a>Break the mesh at interfaces between blocks. New nodes will be generated so elements on each side of the break are no longer connected.</li><li class="collection-item"><a href="../../source/meshgenerators/BreakMeshByElementGenerator.html">BreakMeshByElementGenerator</a>Break all element-element interfaces in the specified subdomains.</li><li class="collection-item"><a href="../../source/meshgenerators/CartesianMeshGenerator.html">CartesianMeshGenerator</a>This CartesianMeshGenerator creates a non-uniform Cartesian mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/CircularBoundaryCorrectionGenerator.html">CircularBoundaryCorrectionGenerator</a>This CircularBoundaryCorrectionGenerator object is designed to correct full or partial circular boundaries in a 2D mesh to preserve areas.</li><li class="collection-item"><a href="../../source/meshgenerators/CoarsenBlockGenerator.html">CoarsenBlockGenerator</a>Mesh generator which coarsens one or more blocks in an existing mesh. The coarsening algorithm works best for regular meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/CombinerGenerator.html">CombinerGenerator</a>Combine multiple meshes (or copies of one mesh) together into one (disjoint) mesh.  Can optionally translate those meshes before combining them.</li><li class="collection-item"><a href="../../source/meshgenerators/ConcentricCircleMeshGenerator.html">ConcentricCircleMeshGenerator</a>This ConcentricCircleMeshGenerator source code is to generate concentric circle meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/CutMeshByLevelSetGenerator.html">CutMeshByLevelSetGenerator</a>This CutMeshByLevelSetGenerator object is designed to trim the input mesh by removing all the elements on outside the give level set with special processing on the elements crossed by the cutting surface to ensure a smooth cross-section. The output mesh only consists of TET4 elements.</li><li class="collection-item"><a href="../../source/meshgenerators/CutMeshByPlaneGenerator.html">CutMeshByPlaneGenerator</a>This CutMeshByPlaneGenerator object is designed to trim the input mesh by removing all the elements on one side of a given plane with special processing on the elements crossed by the cutting plane to ensure a smooth cross-section. The output mesh only consists of TET4 elements.</li><li class="collection-item"><a href="../../source/meshgenerators/DeleteElementsNearMeshGenerator.html">DeleteElementsNearMeshGenerator</a>Removes elements lying &quot;near&quot; another mesh. The proximity is examined by the distance from the element&#x27;s centroid to the faces of elements of the &quot;proximity_mesh&quot;</li><li class="collection-item"><a href="../../source/meshgenerators/DistributedRectilinearMeshGenerator.html">DistributedRectilinearMeshGenerator</a>Create a line, square, or cube mesh with uniformly spaced or biased elements.</li><li class="collection-item"><a href="../../source/meshgenerators/ElementGenerator.html">ElementGenerator</a>Generates individual elements given a list of nodal positions.</li><li class="collection-item"><a href="../../source/meshgenerators/ElementOrderConversionGenerator.html">ElementOrderConversionGenerator</a>Mesh generator which converts orders of elements</li><li class="collection-item"><a href="../../source/meshgenerators/SubdomainPerElementGenerator.html">ElementSubdomainIDGenerator</a>Allows the user to assign each element the subdomain ID of their choice</li><li class="collection-item"><a href="../../source/meshgenerators/ElementsToSimplicesConverter.html">ElementsToSimplicesConverter</a>Splits all non-simplex elements in a mesh into simplices.</li><li class="collection-item"><a href="../../source/meshgenerators/ElementsToTetrahedronsConverter.html">ElementsToTetrahedronsConverter</a>This ElementsToTetrahedronsConverter object is designed to convert all the elements in a 3D mesh consisting only linear elements into TET4 elements.</li><li class="collection-item"><a href="../../source/meshgenerators/ExamplePatchMeshGenerator.html">ExamplePatchMeshGenerator</a>Creates 2D or 3D patch meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/BreakMeshByElementGenerator.html">ExplodeMeshGenerator</a>Break all element-element interfaces in the specified subdomains.</li><li class="collection-item"><a href="../../source/meshgenerators/ExtraNodesetGenerator.html">ExtraNodesetGenerator</a>Creates a new node set and a new boundary made with the nodes the user provides.</li><li class="collection-item"><a href="../../source/meshgenerators/AdvancedExtruderGenerator.html">FancyExtruderGenerator</a>Extrudes a 1D mesh into 2D, or a 2D mesh into 3D, can have a variable height for each elevation, variable number of layers within each elevation, variable growth factors of axial element sizes within each elevation and remap subdomain_ids, boundary_ids and element extra integers within each elevation as well as interface boundaries between neighboring elevation layers.</li><li class="collection-item"><a href="../../source/meshgenerators/FileMeshGenerator.html">FileMeshGenerator</a>Read a mesh from a file.</li><li class="collection-item"><a href="../../source/meshgenerators/FillBetweenCurvesGenerator.html">FillBetweenCurvesGenerator</a>This FillBetweenCurvesGenerator object is designed to generate a transition layer to connect two boundaries of two input meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/FillBetweenPointVectorsGenerator.html">FillBetweenPointVectorsGenerator</a>This FillBetweenPointVectorsGenerator object is designed to generate a transition layer with two sides containing different numbers of nodes.</li><li class="collection-item"><a href="../../source/meshgenerators/FillBetweenSidesetsGenerator.html">FillBetweenSidesetsGenerator</a>This FillBetweenSidesetsGenerator object is designed to generate a transition layer to connect two boundaries of two input meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/FlipSidesetGenerator.html">FlipSidesetGenerator</a>A Mesh Generator which flips a given sideset</li><li class="collection-item"><a href="../../source/meshgenerators/GeneratedMeshGenerator.html">GeneratedMeshGenerator</a>Create a line, square, or cube mesh with uniformly spaced or biased elements.</li><li class="collection-item"><a href="../../source/meshgenerators/ImageMeshGenerator.html">ImageMeshGenerator</a>Generated mesh with the aspect ratio of a given image stack.</li><li class="collection-item"><a href="../../source/meshgenerators/ImageSubdomainGenerator.html">ImageSubdomainGenerator</a>Samples an image at the coordinates of each element centroid, using the resulting pixel color value as each element&#x27;s subdomain ID</li><li class="collection-item"><a href="../../source/meshgenerators/LowerDBlockFromSidesetGenerator.html">LowerDBlockFromSidesetGenerator</a>Adds lower dimensional elements on the specified sidesets.</li><li class="collection-item"><a href="../../source/meshgenerators/MeshCollectionGenerator.html">MeshCollectionGenerator</a>Collects multiple meshes into a single (unconnected) mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/MeshDiagnosticsGenerator.html">MeshDiagnosticsGenerator</a>Runs a series of diagnostics on the mesh to detect potential issues such as unsupported features</li><li class="collection-item"><a href="../../source/meshgenerators/MeshExtruderGenerator.html">MeshExtruderGenerator</a>Takes a 1D or 2D mesh and extrudes the entire structure along the specified axis increasing the dimensionality of the mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/MeshRepairGenerator.html">MeshRepairGenerator</a>Mesh generator to perform various improvement / fixing operations on an input mesh</li><li class="collection-item"><a href="../../source/meshgenerators/MoveNodeGenerator.html">MoveNodeGenerator</a>Modifies the position of one or more nodes</li><li class="collection-item"><a href="../../source/meshgenerators/NodeSetsFromSideSetsGenerator.html">NodeSetsFromSideSetsGenerator</a>Mesh generator which constructs node sets from side sets</li><li class="collection-item"><a href="../../source/meshgenerators/OrientedSubdomainBoundingBoxGenerator.html">OrientedSubdomainBoundingBoxGenerator</a>Defines a subdomain inside or outside of a bounding box with arbitrary orientation.</li><li class="collection-item"><a href="../../source/meshgenerators/OverlayMeshGenerator.html">OverlayMeshGenerator</a>Creates a Cartesian mesh overlaying the input mesh region.</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedCurveGenerator.html">ParsedCurveGenerator</a>This ParsedCurveGenerator object is designed to generate a mesh of a curve that consists of EDGE2, EDGE3, or EDGE4 elements.</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedElementDeletionGenerator.html">ParsedElementDeletionGenerator</a>Removes elements such that the parsed expression is evaluated as strictly positive. The parameters of the parsed expression can be the X,Y,Z coordinates of the element vertex average (must be &#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27; in the expression), the element volume (must be &#x27;volume&#x27; in the expression) and the element id (&#x27;id&#x27; in the expression).</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedExtraElementIDGenerator.html">ParsedExtraElementIDGenerator</a>Uses a parsed expression to set an extra element id for elements (via their centroids).</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedGenerateNodeset.html">ParsedGenerateNodeset</a>A MeshGenerator that adds nodes to a nodeset if the node satisfies the <code>expression</code> expression.</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedGenerateSideset.html">ParsedGenerateSideset</a>A MeshGenerator that adds element sides to a sideset if the centroid of the side satisfies the <code>combinatorial_geometry</code> expression.</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedNodeTransformGenerator.html">ParsedNodeTransformGenerator</a>Applies a transform to a the x,y,z coordinates of a Mesh</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedSubdomainIDsGenerator.html">ParsedSubdomainIDsGenerator</a>Uses a parsed expression to determine the subdomain ids of included elements.</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedSubdomainMeshGenerator.html">ParsedSubdomainMeshGenerator</a>Uses a parsed expression (<code>combinatorial_geometry</code>) to determine if an element (via its centroid) is inside the region defined by the expression and assigns a new block ID.</li><li class="collection-item"><a href="../../source/meshgenerators/ExamplePatchMeshGenerator.html">PatchMeshGenerator</a>Creates 2D or 3D patch meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/PatternedMeshGenerator.html">PatternedMeshGenerator</a>Creates a 2D mesh from a specified set of unique &#x27;tiles&#x27; meshes and a two-dimensional pattern.</li><li class="collection-item"><a href="../../source/meshgenerators/PlaneDeletionGenerator.html">PlaneDeletionGenerator</a>Removes elements lying &#x27;above&#x27; the plane (in the direction of the normal).</li><li class="collection-item"><a href="../../source/meshgenerators/PlaneIDMeshGenerator.html">PlaneIDMeshGenerator</a>Adds an extra element integer that identifies planes in a mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/PolyLineMeshFollowingNodeSetGenerator.html">PolyLineMeshFollowingNodeSetGenerator</a>Generates a polyline (open ended or looped) of Edge elements by marching along a nodeeset and trying to be as close as possible to the nodes of the nodeset</li><li class="collection-item"><a href="../../source/meshgenerators/PolyLineMeshGenerator.html">PolyLineMeshGenerator</a>Generates meshes from edges connecting a list of points.</li><li class="collection-item"><a href="../../source/meshgenerators/ProjectSideSetOntoLevelSetGenerator.html">ProjectSideSetOntoLevelSetGenerator</a>Projects a sideset onto a surface defined by a level set and creates a surface mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/RefineBlockGenerator.html">RefineBlockGenerator</a>Mesh generator which refines one or more blocks in an existing mesh</li><li class="collection-item"><a href="../../source/meshgenerators/RefineSidesetGenerator.html">RefineSidesetGenerator</a>Mesh generator which refines one or more sidesets</li><li class="collection-item"><a href="../../source/meshgenerators/RenameBlockGenerator.html">RenameBlockGenerator</a>Changes the block IDs and/or block names for a given set of blocks defined by either block ID or block name. The changes are independent of ordering. The merging of blocks is supported.</li><li class="collection-item"><a href="../../source/meshgenerators/RenameBoundaryGenerator.html">RenameBoundaryGenerator</a>Changes the boundary IDs and/or boundary names for a given set of boundaries defined by either boundary ID or boundary name. The changes are independent of ordering. The merging of boundaries is supported.</li><li class="collection-item"><a href="../../source/meshgenerators/RinglebMeshGenerator.html">RinglebMeshGenerator</a>Creates a mesh for the Ringleb problem.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetExtruderGenerator.html">SideSetExtruderGenerator</a>Takes a 1D or 2D mesh and extrudes a selected sideset along the specified axis.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsAroundSubdomainGenerator.html">SideSetsAroundSubdomainGenerator</a>Adds element faces that are on the exterior of the given block to the sidesets specified</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsBetweenSubdomainsGenerator.html">SideSetsBetweenSubdomainsGenerator</a>MeshGenerator that creates a sideset composed of the nodes located between two or more subdomains.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsFromBoundingBoxGenerator.html">SideSetsFromBoundingBoxGenerator</a>Defines new sidesets using currently-defined sideset IDs inside or outside of a bounding box.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsFromNodeSetsGenerator.html">SideSetsFromNodeSetsGenerator</a>Mesh generator which constructs side sets from node sets</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsFromNormalsGenerator.html">SideSetsFromNormalsGenerator</a>Adds a new named sideset to the mesh for all faces matching the specified normal.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsFromPointsGenerator.html">SideSetsFromPointsGenerator</a>Adds a new sideset starting at the specified point containing all connected element faces with the same normal.</li><li class="collection-item"><a href="../../source/meshgenerators/SmoothMeshGenerator.html">SmoothMeshGenerator</a>Utilizes the specified smoothing algorithm to attempt to improve mesh quality.</li><li class="collection-item"><a href="../../source/meshgenerators/SphereMeshGenerator.html">SphereMeshGenerator</a>Generate a 3-D sphere mesh centered on the origin</li><li class="collection-item"><a href="../../source/meshgenerators/SpiralAnnularMeshGenerator.html">SpiralAnnularMeshGenerator</a>Creates an annular mesh based on TRI3 or TRI6 elements on several rings.</li><li class="collection-item"><a href="../../source/meshgenerators/StackGenerator.html">StackGenerator</a>Use the supplied meshes and stitch them on top of each other</li><li class="collection-item"><a href="../../source/meshgenerators/StitchBoundaryMeshGenerator.html">StitchBoundaryMeshGenerator</a>Allows a pair of boundaries to be stitched together.</li><li class="collection-item"><a href="../../source/meshgenerators/StitchMeshGenerator.html">StitchMeshGenerator</a>Allows multiple mesh files to be stitched together to form a single mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/StitchMeshGenerator.html">StitchedMeshGenerator</a>Allows multiple mesh files to be stitched together to form a single mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/SubdomainBoundingBoxGenerator.html">SubdomainBoundingBoxGenerator</a>Changes the subdomain ID of elements either (XOR) inside or outside the specified box to the specified ID.</li><li class="collection-item"><a href="../../source/meshgenerators/SubdomainIDGenerator.html">SubdomainIDGenerator</a>Sets all the elements of the input mesh to a unique subdomain ID.</li><li class="collection-item"><a href="../../source/meshgenerators/SubdomainPerElementGenerator.html">SubdomainPerElementGenerator</a>Allows the user to assign each element the subdomain ID of their choice</li><li class="collection-item"><a href="../../source/meshgenerators/SymmetryTransformGenerator.html">SymmetryTransformGenerator</a>Applies a symmetry transformation to the entire mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/TiledMeshGenerator.html">TiledMeshGenerator</a>Use the supplied mesh and create a tiled grid by repeating this mesh in the x, y, and z directions.</li><li class="collection-item"><a href="../../source/meshgenerators/TransfiniteMeshGenerator.html">TransfiniteMeshGenerator</a>Creates a QUAD4 mesh given a set of corner vertices and edge types. The edge type can be either LINE, CIRCARC, DISCRETE or PARSED, with LINE as the default option. For the non-default options the user needs to specify additional parameters via the edge_parameter option as follows: for CIRCARC the deviation of the midpoint from an arccircle, for DISCRETE a set of points, or a paramterization via the PARSED option. Opposite edges may have different distributions s long as the number of points is identical. Along opposite edges a different point distribution can be prescribed via the options bias_x or bias_y for opposing edges.</li><li class="collection-item"><a href="../../source/meshgenerators/TransformGenerator.html">TransformGenerator</a>Applies a linear transform to the entire mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/UniqueExtraIDMeshGenerator.html">UniqueExtraIDMeshGenerator</a>Add a new extra element integer ID by finding unique combinations of the existing extra element integer ID values</li><li class="collection-item"><a href="../../source/meshgenerators/XYDelaunayGenerator.html">XYDelaunayGenerator</a>Triangulates meshes within boundaries defined by input meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/XYMeshLineCutter.html">XYMeshLineCutter</a>This XYMeshLineCutter object is designed to trim the input mesh by removing all the elements on one side of a given straight line with special processing on the elements crossed by the cutting line to ensure a smooth cross-section.</li><li class="collection-item"><a href="../../source/meshgenerators/XYZDelaunayGenerator.html">XYZDelaunayGenerator</a>Creates tetrahedral 3D meshes within boundaries defined by input meshes.</li><li class="collection-item"><a href="../../source/mesh/AnnularMesh.html">AnnularMesh</a>For rmin&gt;0: creates an annular mesh of QUAD4 elements.  For rmin=0: creates a disc mesh of QUAD4 and TRI3 elements.  Boundary sidesets are created at rmax and rmin, and given these names.  If dmin!<u>0 and dmax!</u>360, a sector of an annulus or disc is created.  In this case boundary sidesets are also created a dmin and dmax, and given these names</li><li class="collection-item"><a href="../../source/mesh/ConcentricCircleMesh.html">ConcentricCircleMesh</a>This ConcentricCircleMesh source code is to generate concentric circle meshes.</li><li class="collection-item"><a href="../../source/mesh/FileMesh.html">FileMesh</a>Read a mesh from a file.</li><li class="collection-item"><a href="../../source/mesh/GeneratedMesh.html">GeneratedMesh</a>Create a line, square, or cube mesh with uniformly spaced or biased elements.</li><li class="collection-item"><a href="../../source/mesh/ImageMesh.html">ImageMesh</a>Generated mesh with the aspect ratio of a given image stack.</li><li class="collection-item"><a href="../../source/mesh/MeshGeneratorMesh.html">MeshGeneratorMesh</a>Mesh generated using mesh generators</li><li class="collection-item"><a href="../../source/mesh/PatternedMesh.html">PatternedMesh</a>Creates a 2D mesh from a specified set of unique &#x27;tiles&#x27; meshes and a two-dimensional pattern.</li><li class="collection-item"><a href="../../source/mesh/RinglebMesh.html">RinglebMesh</a>Creates a mesh for the Ringleb problem.</li><li class="collection-item"><a href="../../source/mesh/SpiralAnnularMesh.html">SpiralAnnularMesh</a>Creates an annual mesh based on TRI3 elements (it can also be TRI6 elements) on several rings.</li><li class="collection-item"><a href="../../source/mesh/StitchedMesh.html">StitchedMesh</a>Reads in all of the given meshes and stitches them all together into one mesh.</li><li class="collection-item"><a href="../../source/mesh/TiledMesh.html">TiledMesh</a>Use the supplied mesh and create a tiled grid by repeating this mesh in the x,y, and z directions.</li><li class="collection-header">Heat Transfer App</li><li class="collection-item"><a href="../../source/meshgenerators/PatchSidesetGenerator.html">PatchSidesetGenerator</a>Divides the given sideset into smaller patches of roughly equal size.</li><li class="collection-header">Phase Field App</li><li class="collection-item"><a href="../../source/meshgenerators/EBSDMeshGenerator.html">EBSDMeshGenerator</a>Mesh generated from a specified DREAM.3D EBSD data file.</li><li class="collection-item"><a href="../../source/meshgenerators/SphereSurfaceMeshGenerator.html">SphereSurfaceMeshGenerator</a>Generated sphere mesh - a two dimensional manifold embedded in three dimensional space</li><li class="collection-item"><a href="../../source/mesh/EBSDMesh.html">EBSDMesh</a>Mesh generated from a specified DREAM.3D EBSD data file.</li></ul></section><section id="48b36788-d021-48fe-b107-b4954890e980" data-section-level="2" data-section-text="Available Subsystems"><h2 id="available-subsystems">Available Subsystems</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="BatchMeshGeneratorAction/index.html">BatchMeshGeneratorAction</a></li><li class="collection-item"><a href="Partitioner/index.html">Partitioner</a></li></ul></section><section id="bdcd8493-e496-4cab-916b-dede3aaeacb6" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/CreateDisplacedProblemAction.html">CreateDisplacedProblemAction</a>Create a Problem object that utilizes displacements.</li><li class="collection-item"><a href="../../source/actions/DisplayGhostingAction.html">DisplayGhostingAction</a>Action to setup AuxVariables and AuxKernels to display ghosting when running in parallel</li><li class="collection-item"><a href="../../source/actions/ElementIDOutputAction.html">ElementIDOutputAction</a>Action for copying extra element IDs into auxiliary variables for output.</li><li class="collection-item"><a href="../../source/actions/SetupMeshAction.html">SetupMeshAction</a>Add or create Mesh object to the simulation.</li><li class="collection-item"><a href="../../source/actions/SetupMeshCompleteAction.html">SetupMeshCompleteAction</a>Perform operations on the mesh in preparation for a simulation.</li><li class="collection-item"><a href="../../source/actions/AddMeshGeneratorAction.html">AddMeshGeneratorAction</a>Add a MeshGenerator object to the simulation.</li></ul></section><section id="3b623f09-6671-45cb-ac0f-72c9ac203069" data-section-level="2" data-section-text="MeshGenerator System"><h2 id="meshgenerator-system">MeshGenerator System</h2><p>The MeshGenerator System is useful for programmatically constructing a mesh. This includes generating the mesh from a serious of points and connectivity, adding features on the fly, linearly transforming the mesh, stitching together pieces of meshes, etc. There are several built-in generators but this system is also extendable. MeshGenerators may or may not consumer the output from other generators and produce a single mesh. They can be chained together through dependencies so that complex meshes may be built up from a series of simple processes.</p><section id="3d887014-55cb-4a0e-8f99-8570412080bb" data-section-level="3" data-section-text="Mesh Generator development"><h3 id="mesh-generator-development">Mesh Generator development</h3><p>Mesh generator developers should call <code>mesh-&gt;unset_is_prepared()</code> at the end of the <code>generate</code> routine unless they are confident that their mesh is indeed prepared. Examples of actions that render the mesh unprepared are</p><ul class="browser-default"><li><p>Translating, rotating, or scaling the mesh. This will conceptually change the mesh bounding box, invalidate the point locator, and potentially change the spatial dimension of the mesh (e.g. rotating a line from the x-axis into the xy plane, etc.) </p></li><li><p>Adding elements. These elements will need their neighbor links set in order for things like finite volume to work </p></li><li><p>Changing element subdomains. This will invalidate the mesh subdomain cached data on the <code>libMesh::MeshBase</code> object </p></li><li><p>Changing boundary IDs. This invalidates global data (e.g. data aggregated across all processes) in the <code>libMesh::BoundaryInfo</code> object</p></li></ul><p>When in doubt, the mesh is likely not prepared. Calling <code>unset_is_prepared</code> is a defensive action that at worst will incur an unnecessary <code>prepare_for_use</code>, which may slow down the simulation setup, and at best may save follow-on mesh generators or simulation execution from undesirable behavior.</p></section><section id="1c004f54-948e-4261-b9a4-2539fa8ca2f8" data-section-level="3" data-section-text="DAG and final mesh selection"><h3 id="final">DAG and final mesh selection</h3><p>When chaining together several MeshGenerators, you are implicitly creating a DAG (directed acyclic graph). MOOSE evaluates and generates the individual objects to build up your final mesh. If your input file has multiple end points, (e.g. B-&gt;A and C-&gt;A) then MOOSE will issue an error and terminate. Generally, it doesn&#x27;t make sense to have multiple end points since the output of one would simply be discarded anyway. It is possible to force the selection of a particular end point by using the <a href="#94be9c55-c1fc-41e0-9c00-04109f6872ba" class="moose-modal-link modal-trigger">&quot;final_generator&quot;</a> parameter in the Mesh block. This parameter can be used on any generator whether there is ambiguity or not in the generator dependencies.</p></section></section><section id="034aa30e-517c-483b-9512-d7c5917d53e7" data-section-level="2" data-section-text="Outputting The Mesh"><h2 id="outputting-the-mesh">Outputting The Mesh</h2><p>Since MOOSE contains a lot of ability to read/generate/modify meshes - it&#x27;s often useful to be able to run all of the Mesh related portions of the input file and then output the mesh.  This mesh can then be viewed (such as with Peacock) or used in other MOOSE input files for further combination/modification.</p><p>This can be achieved by using the command line option <code>--mesh-only</code>.  By default <code>--mesh-only</code> will write a mesh file with <code>_in.e</code> (the opposite of the <code>_out.e</code> that is appended from the output system) appended to the input file name.  You can also optionally provide a mesh filename to write out using <code>--mesh-only output_file.e</code>. When using the <code>--mesh-only</code> option, by default any extra element integers defined on the mesh will also be outputted to the output Exodus file. To prevent extra element ids from being output, the parameter <code>output_extra_element_ids</code> should be set to <code>false</code> in the <code>[Outputs]</code> block of the input file as shown below:</p><pre style="max-height:350px;"><code class="language-text">
[Outputs]
  [out]
    type = Exodus
    output_extra_element_ids = false
  []
[]
</code></pre><p>Alternatively, if only a subset of extra element ids should be outputted to the Exodus file, the parameter <code>extra_element_ids_to_output</code> should be set in the <code>[Outputs]</code> block of the input file like so:</p><pre style="max-height:350px;"><code class="language-text">
[Outputs]
  [out]
    type = Exodus
    output_extra_element_ids = true
    extra_element_ids_to_output = &#x27;id_to_output1 id_to_output2 ...&#x27;
  []
[]
</code></pre><p>Here are a couple of examples showing the usage of <code>--mesh-only</code>:</p><pre style="max-height:350px;"><code class="language-text">
# Will run all mesh related sections in input_file.i and write out input_file_in.e
./myapp-opt -i input_file.i --mesh-only

# Will do the same but write out mesh_file.e
./myapp-opt -i input_file.i --mesh-only mesh_file.e

# Run in parallel and write out parallel checkpoint format (which can be read as a split)
mpiexec -n 3 ./myapp-opt -i input_file.i Mesh/parallel_type=distributed --mesh-only mesh_file.cpr
</code></pre></section><section id="6aa02219-e42c-45b5-9131-7a45ece2d93e" data-section-level="2" data-section-text="Named Entity Support"><h2 id="named-entity-support">Named Entity Support</h2><p>Human-readable names can be assigned to blocks, sidesets, and nodesets. These names will be automatically read in and can be used throughout the input file. Mesh generators such as CUBIT will generally provide the capability internally.  Any parameter that takes entity IDs in the input file will accept either numbers or &quot;names&quot;. Names can also be assigned to IDs on-the-fly in existing meshes to ease input file maintenance (see example). On-the-fly names will also be written to Exodus/XDA/XDR files. An illustration for mesh in exodus file format.</p><pre style="max-height:350px;"><code class="language-moose">[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;index.html&quot;}&gt;&gt;&gt;]
  file = three_block.e

  # These names will be applied on the fly to the
  # mesh so that they can be used in the input file
  # In addition they will show up in the output file
  block_id&lt;&lt;&lt;{&quot;description&quot;: &quot;IDs of the block id/name pairs&quot;}&gt;&gt;&gt; = &#x27;1 2 3&#x27;
  block_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Names of the block id/name pairs (must correspond with \&quot;block_id\&quot;&quot;}&gt;&gt;&gt; = &#x27;wood steel copper&#x27;

  boundary_id&lt;&lt;&lt;{&quot;description&quot;: &quot;IDs of the boundary id/name pairs&quot;}&gt;&gt;&gt; = &#x27;1 2&#x27;
  boundary_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Names of the boundary id/name pairs (must correspond with \&quot;boundary_id\&quot;&quot;}&gt;&gt;&gt; = &#x27;left right&#x27;
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#f237b30a-fc7d-4c89-9ebc-fbaf5701478e">(moose/test/tests/mesh/named_entities/name_on_the_fly.i)</a></section><section id="c7bad896-49f4-4355-93ce-b388a615c0d8" data-section-level="2" data-section-text="Replicated and Distributed Mesh"><h2 id="replicated-and-distributed-mesh">Replicated and Distributed Mesh</h2><p>The core of the mesh capabilities are derived from <a href="http://libmesh.github.io/">libMesh</a>, which has two underlying parallel mesh formats: &quot;replicated&quot; and &quot;distributed&quot;.</p><p>The replicated mesh format is the default format for MOOSE and is the most appropriate format to utilize for nearly all simulations. In parallel, the replicated format generates or reads the complete mesh on all processors and keeps the complete mesh on all processors for the duration of the simulation allowing for efficient access to the geometry elements.</p><p>The distributed mesh format is useful when the mesh data structure dominates memory usage. Only the pieces of the mesh &quot;owned&quot; by a processor are actually kept on the processor during the simulation. Note, however, that even for distributed meshes, if the mesh is not generated or read in a split fashion, the mesh will still initially be generated or read in its entirety on all processors, thus requiring sufficient memory on each processor for this to happen, before each processor then deletes all elements it does not own relieving memory pressure. If the mesh is too large to fit on a single processor, the user can either split-generate the mesh using, e.g. <a href="../../source/meshgenerators/DistributedRectilinearMeshGenerator.html">DistributedRectilinearMeshGenerator</a>, or split the mesh prior to reading it in as explained <a href="index.html#mesh-splitting">below</a>.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>Both the &quot;replicated&quot; and &quot;distributed&quot; mesh formats are parallel with respect to the execution of the finite element assembly and solve. In both types the solution data is distributed, which is the portion of the simulation that usually dominates memory demands.</p></div></div></div><section id="7a16b4a8-b87f-4522-90a7-30a91e8fc49b" data-section-level="3" data-section-text="Distributed Mesh Output Format ( Nemesis )"><h3 id="distributed-mesh-output-format-nemesis">Distributed Mesh Output Format (Nemesis)</h3><p>When running a simulation with <code>DistributedMesh</code> it is generally desirable to avoid serializing the mesh to the first rank for output. In the largest case this may cause your simulation to run out of memory, in smaller cases, it may just cause unnecessary communication to serialize your parallel data structure. The solution is to use &quot;nemesis&quot; output.</p><p>Nemesis creates separate Exodus files that are automatically read by Paraview and displayed as if a normal Exodus mesh had been output. The output files have the following naming convention:</p><pre style="max-height:350px;"><code class="language-text">
&lt;filename&gt;.e.&lt;num_processors&gt;.&lt;rank&gt;

# For example, on a 4 processor run, you can expect filenames like this:
out.e.4.0
out.e.4.1
out.e.4.2
out.e.4.3
</code></pre></section></section><section id="41e10f00-73cc-44f3-92e2-640706cc6c18" data-section-level="2" data-section-text="Mesh splitting"><h2 id="mesh-splitting">Mesh splitting</h2><p>For large meshes, MOOSE provides the ability to pre-split a mesh for use in the &quot;distributed&quot; format/mode. To split and use a mesh for distributed runs:</p><pre style="max-height:350px;"><code class="language-text">
// For input files with a file-based mesh:
$ moose-app-opt -i your_input-file.i --split-mesh 500,1000,2000 // comma-separated list of split configurations
Splitting 500 ways...
    - writing 500 files per process...
Splitting 1000 ways...
    - writing 1000 files per process...
...

// MOOSE automatically selects the pre-split mesh configuration based on MPI processes
$ mpiexec -n 1000 moose-app-opt -i your_input-file.i --use-split
</code></pre><p>For more details see &quot;<a href="splitting.html">Mesh Splitting</a>&quot;.</p></section><section id="d278a6dd-119b-47bf-86a3-64c458f1410b" data-section-level="2" data-section-text="Displaced Mesh"><h2 id="displaced-mesh">Displaced Mesh</h2><p>Calculations can take place in either the initial mesh configuration or, when requested, the &quot;displaced&quot; configuration. To enable displacements, provide a vector of displacement variable names for each spatial dimension in the &#x27;displacements&#x27; parameters within the Mesh block.</p><pre style="max-height:350px;"><code class="language-moose">[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;index.html&quot;}&gt;&gt;&gt;]
  type = FileMesh
  file = truss_2d.e
  displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The variables corresponding to the x y z displacements of the mesh.  If this is provided then the displacements will be taken into account during the computation. Creation of the displaced mesh can be suppressed even if this is set by setting &#x27;use_displaced_mesh = false&#x27;.&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y&#x27;
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#3511101d-7728-443d-80ab-923bca386776">(moose/modules/solid_mechanics/test/tests/truss/truss_2d.i)</a><p>Once enabled, any object that should operate on the displaced configuration should set the &quot;use_displaced_mesh&quot; to true. For example, the following snippet enables the computation of a <a href="../Postprocessors/index.html">Postprocessor</a> with and without the displaced configuration.</p><pre style="max-height:350px;"><code class="language-moose">[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [./without]
    type = ElementIntegralVariablePostprocessor&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes a volume integral of the specified variable&quot;, &quot;href&quot;: &quot;../../source/postprocessors/ElementIntegralVariablePostprocessor.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object operates on&quot;}&gt;&gt;&gt; = c
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = initial
  [../]
  [./with]
    type = ElementIntegralVariablePostprocessor&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes a volume integral of the specified variable&quot;, &quot;href&quot;: &quot;../../source/postprocessors/ElementIntegralVariablePostprocessor.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object operates on&quot;}&gt;&gt;&gt; = c
    use_displaced_mesh&lt;&lt;&lt;{&quot;description&quot;: &quot;Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.&quot;}&gt;&gt;&gt; = true
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = initial
  [../]
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#41c01252-2c51-48d8-a386-9b5df0dcce70">(moose/test/tests/postprocessors/displaced_mesh/elemental.i)</a></section><section id="c691b2cc-b89d-497c-b098-ed4554e34dfa" data-section-level="2" data-section-text="Mixed Dimension Meshes"><h2 id="mixed-dimension-meshes">Mixed Dimension Meshes</h2><p>MOOSE will function properly when running simulations on meshes containing mixed dimension elements (e.g. 1D and 2D, 1D and 3D, etc.). Residual calculation, material evaluation, etc should all work properly.</p><pre style="max-height:350px;"><code class="language-moose">[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;index.html&quot;}&gt;&gt;&gt;]
  file = 1d_3d.e
  # 1d_3d.e contains HEX8 and BEAM2 elements - no additional input file
  # changes are necessary to handle mixed-dim meshes.
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#1804adf5-8f21-4d94-adfc-180198231192">(moose/test/tests/mesh/mixed_dim/1d_3d.i)</a></section><section id="0285ea53-5ea2-4d64-8cf1-6fd85829290c" data-section-level="2" data-section-text="Unique IDs"><h2 id="unique-ids">Unique IDs</h2><p>There are two &quot;first-class&quot; id types for each mesh entity (elements or nodes): &quot;id and unique_id&quot;. Both the id and unique_id field are unique numbers for the current active set of mesh entities. Active entities are those that are currently representing the domain but doesn&#x27;t include &quot;coarse parents&quot; of some elements that may become active during a coarsening step. The difference however is that unique_ids are never reused, but ids <strong>might</strong> be. Generally the id is &quot;good-enough&quot; for almost all use, but if you need guarantees that an element id is never recycled (because it might be a key to an important map), you should use unique_id.</p></section><section id="34fbc6b9-b7a5-4665-820c-b366739ebbbc" data-section-level="2" data-section-text="Periodic Node Map"><h2 id="periodic-node-map">Periodic Node Map</h2><p>The MooseMesh object has a method for building a map (technically a multimap) of paired periodic nodes in the simulation. This map provides a quick lookup of all paired nodes on a periodic boundary. in the 2D and 3D cases each corner node will map to 2 or 3 other nodes (respectively).</p></section><section id="8ff00498-6ab2-423c-94f6-b1707b661888" data-section-level="2" data-section-text="Extra integer IDs"><h2 id="extra-integer-ids">Extra integer IDs</h2><p>Extra integer IDs for all the elements of a mesh can be useful for handling complicated material assignment, performing specific calculations on groups of elements, etc. Often times, we do not want to use subdomain IDs for these tasks because otherwise too many subdomains could be needed, and in turn large penalty on run-time performance could be introduced.</p><p>MooseMesh<a href="../../source/mesh/MooseMesh.html">MooseMesh</a> has a parameter <code>extra_integers</code> to allow users to introduce more integer IDs for elements each identified with a name in the parameter. When this parameter is specified, extra integers will be made available for all elements through <code>Assembly</code> in MOOSE objects such as kernels, aux kernels, materials, initial conditions, element user objects, etc. To retrieve the integer on an element, one needs to simply call</p><pre style="max-height:350px;"><code class="language-text">
getElementID(integer_name_parameter, comp),
</code></pre><p>within the initialization list of your constructor. <code>integer_name_parameter</code> is the name of the parameter in type of <code>std::vector&lt;ExtraElementIDName&gt;</code> of this object listing all integer names. <code>comp</code> is the index into the integer names if multiple are specified for <code>integer_name_parameter</code>. It is noticed that the returned value of this function call must be in type of <code>const dof_id_type &amp;</code>, which is used to refer the value set by MOOSE in <code>Assembly</code>. The returned reference should be held in a class member variable for later use. Based on this ID, one can proceed with any particular operations, for example, choosing a different set of data for evaluating material properties.</p><p>IDs can be assigned to the mesh elements with <code>MeshGenerators</code> in a similar way to assigning subdomain IDs. We note that the element IDs are part of the mesh and will be initialized properly for restart/recover.</p></section><section id="a6d62bd4-defb-4eec-88d9-d27896a22770" data-section-level="2" data-section-text="Mesh meta data"><h2 id="mesh-meta-data">Mesh meta data</h2><p>Mesh generators can declare mesh meta data, which can be obtained later in Actions or in UserObjects. Mesh meta data can only be declared in the constructors of mesh generators so that they can be restarted without re-running mesh generators. Mesh meta data can be useful for setting up specific postprocessors, kernels, etc. that require certain geometry information. Mesh meta data are not possible or extremely hard to be derived directly from libMesh mesh object. A simple example of mesh meta data is the <code>num_elements_x</code> provided by <a href="../../source/meshgenerators/GeneratedMeshGenerator.html">GeneratedMeshGenerator</a>, which can be used as an indicator for a mesh regular in x direction.</p></section><section id="82805788-9be2-4f17-8d28-de6fffa697d0" data-section-level="2" data-section-text="Debugging in - MOOSE mesh generation"><h2 id="troubleshooting">Debugging in-MOOSE mesh generation</h2><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>The MOOSE mesh generation tutorial is the most comprehensive resource on learning how to mesh within MOOSE. We summarize here only a few techniques.</p></div></div></div><p>Mesh generation in MOOSE is a sequential tree-based process. Mesh generators are executed sorted by dependencies, and the output of each generator may be fed to multiple other generators. To succeed in this process, you must decompose the creation of the mesh into many individual steps. To debug this process, one can:</p><ul class="browser-default"><li><p>use the <code>show_info(=true)</code> input parameter on each mesh generator. This will output numerous pieces of metadata about the mesh at each stage of the generation process. You can check there if all the subdomains that you expected at this stage are present in the mesh and if they are of the expected size, both in terms of number of elements but also bounding box. </p></li><li><p>use the <code>output</code> input parameter on the mesh generator right before the problematic stage. This will output the mesh, by default using the <a href="../../source/outputs/Exodus.html">Exodus</a> format with the name <code>&lt;mesh_generator_name&gt;_in.e</code>, so you may visualize it before it gets acted upon by the next mesh generator(s).</p></li></ul><p>For a narrow selection of mesh issues, listed in its documentation, the <a href="../../source/meshgenerators/MeshDiagnosticsGenerator.html">MeshDiagnosticsGenerator</a> may be used to detect unsupported features in meshes.</p></section><section id="3749ae53-4c02-4a81-bcc2-28fb8596f23c" data-section-level="2" data-section-text="Examining meshes"><h2 id="examination">Examining meshes</h2><p>The results of finite element/volume simulations are highly dependent on the quality of the mesh(es) used. It happens regularly that results are excellent and meeting all predictions using a regular Cartesian grid mesh, but significantly deteriorate or do not converge on the real system mesh, often created outside MOOSE.</p><p>We point out in this section a few things to look for. - Sidesets in MOOSE are oriented. If you place a Neumann/flux boundary condition on a sideset, the direction of   the flux will depend on the orientation of the sideset. - MOOSE generally does not support non-conformal meshes for regular kernels, except when they arise from online mesh refinement.   When inspecting your mesh, you should not see any hanging nodes or surfaces not exactly touching. If you are using such   a mesh, you <strong>MUST</strong> use interface kernels, mortar or other advanced numerical treatments. - Many physics will give better results with high element quality and smooth distributions of element volumes.   You may examine the spatial distribution of these quantities using the <a href="../../source/auxkernels/ElementQualityAux.html">ElementQualityAux</a> and <a href="../../source/auxkernels/VolumeAux.html">VolumeAux</a>   respectively.</p></section><section id="ac286f6a-7560-4dca-932c-68443b6b5f8b" data-section-level="2" data-section-text="Coordinate Systems"><h2 id="coordinate_systems">Coordinate Systems</h2><p>The following are the coordinate systems currently available in MOOSE:</p><ul class="browser-default"><li><p><code>XYZ</code>: 3D Cartesian. </p></li><li><p><code>RZ</code>: 2D axisymmetric coordinates. </p></li><li><p><code>RSPHERICAL</code>: 1D spherical coordinates with the origin at <span class="moose-katex-inline-equation" id="moose-equation-a39a1d58-b726-4b21-b77d-b21268056fa6"><script>var element = document.getElementById("moose-equation-a39a1d58-b726-4b21-b77d-b21268056fa6");katex.render("(0,0,0)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</p></li></ul><p>Coordinate systems may be specified in the input file or within code.</p><section id="0b615fba-4032-487e-b4cd-a52de47d8559" data-section-level="3" data-section-text="Specifying coordinate systems in the input file"><h3 id="specifying-coordinate-systems-in-the-input-file">Specifying coordinate systems in the input file</h3><p>In an input file, coordinate systems may be specified in the <a href="index.html">Mesh</a> block. First, <a href="#6649ba5c-5bc4-45a4-82d9-6aa2fc937d5c" class="moose-modal-link modal-trigger">&quot;coord_type&quot;</a> is used to specify the coordinate system type. If you would like to use multiple coordinate systems in your application, you can supply multiple entries in this parameter. Then you must specify <a href="#91e1ba18-3eb0-40f0-a634-314298049047" class="moose-modal-link modal-trigger">&quot;coord_block&quot;</a> to specify the corresponding blocks to which each coordinate system applies.</p><p>If the <code>RZ</code> coordinate system is used, there are two options for how to specify the coordinate axis(es) in an input file:</p><ul class="browser-default"><li><p>Specify <a href="#121b4e42-693d-4064-92f6-deb495bf2693" class="moose-modal-link modal-trigger">&quot;rz_coord_axis&quot;</a> to choose a single <code>RZ</code> coordinate system, using the <span class="moose-katex-inline-equation" id="moose-equation-45418a06-2dc6-4640-9175-2598d8bafcb4"><script>var element = document.getElementById("moose-equation-45418a06-2dc6-4640-9175-2598d8bafcb4");katex.render("\\hat{x}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> or <span class="moose-katex-inline-equation" id="moose-equation-5989302a-a76c-4ced-8afe-ce1b4459b358"><script>var element = document.getElementById("moose-equation-5989302a-a76c-4ced-8afe-ce1b4459b358");katex.render("\\hat{y}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> direction and starting at <span class="moose-katex-inline-equation" id="moose-equation-44ff61a8-81dc-4936-8cfa-a4c2af058450"><script>var element = document.getElementById("moose-equation-44ff61a8-81dc-4936-8cfa-a4c2af058450");katex.render("(0,0,0)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>. If the former is used, then the axial coordinate is <span class="moose-katex-inline-equation" id="moose-equation-5f6996f7-3844-46d3-8e91-c146072b0952"><script>var element = document.getElementById("moose-equation-5f6996f7-3844-46d3-8e91-c146072b0952");katex.render("x", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, and the radial coordinate is <span class="moose-katex-inline-equation" id="moose-equation-1789fb92-4d83-4032-b6b4-97d63a961d19"><script>var element = document.getElementById("moose-equation-1789fb92-4d83-4032-b6b4-97d63a961d19");katex.render("y", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>; if the latter is used, these are switched. </p></li><li><p>Specify the following three parameters:</p><ul class="browser-default"><li><p><a href="#a8d0df9e-de5f-4e21-b530-5be3ba5e2791" class="moose-modal-link modal-trigger">&quot;rz_coord_blocks&quot;</a>: The list of blocks using an <code>RZ</code> coordinate system (all must be specified). </p></li><li><p><a href="#86458d3e-d266-4a55-ae0e-1e88691e50ec" class="moose-modal-link modal-trigger">&quot;rz_coord_origins&quot;</a>: The list of origin points for the axisymmetric axes corresponding to each block in <a href="#6ab98f7f-e525-45be-af41-8766897dce49" class="moose-modal-link modal-trigger">&quot;rz_coord_blocks&quot;</a>. </p></li><li><p><a href="#3d1fb3f2-7200-469f-8c28-759b3d6cfda2" class="moose-modal-link modal-trigger">&quot;rz_coord_directions&quot;</a>: The list of direction vectors for the axisymmetric axes corresponding to each block in <a href="#3bea5d64-9c10-44ca-a010-0a68f574ec50" class="moose-modal-link modal-trigger">&quot;rz_coord_blocks&quot;</a>. Note that these direction vectors need not be unit vectors, just nonzero vectors.</p></li></ul></li></ul><p>The second option has greater flexibility, as it allows the following, which the first option does not:</p><ul class="browser-default"><li><p>Multiple axisymmetric coordinate systems can be defined. </p></li><li><p>Any point can be used for the origin of the coordinate system, not just <span class="moose-katex-inline-equation" id="moose-equation-dc037efc-ebe1-4e76-bab9-d698c3b51cb2"><script>var element = document.getElementById("moose-equation-dc037efc-ebe1-4e76-bab9-d698c3b51cb2");katex.render("(0,0,0)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>. </p></li><li><p>Any direction can be used for the axisymmetric axis, not just the <span class="moose-katex-inline-equation" id="moose-equation-78b7fdc4-b8ec-4ee2-86b7-4f2178935dbf"><script>var element = document.getElementById("moose-equation-78b7fdc4-b8ec-4ee2-86b7-4f2178935dbf");katex.render("\\hat{x}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> or <span class="moose-katex-inline-equation" id="moose-equation-a43619a8-b86e-4e13-bd7e-34bd62133cc8"><script>var element = document.getElementById("moose-equation-a43619a8-b86e-4e13-bd7e-34bd62133cc8");katex.render("\\hat{y}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> direction.</p></li></ul><p>Note that the <a href="../Transfers/index.html">Transfers</a> ability for the second option is more limited</p></section><section id="a4dc15b4-e5da-4cf1-af11-741f44ebb3af" data-section-level="3" data-section-text="Specifying coordinate systems within code"><h3 id="specifying-coordinate-systems-within-code">Specifying coordinate systems within code</h3><p>To specify coordinate systems within code, <code>MooseMesh::setCoordSystem(blocks, coord_sys)</code> is used, where <code>blocks</code> and <code>coord_sys</code> have the same behavior as the <a href="#b068914d-ea18-4788-950a-6b311aa0724f" class="moose-modal-link modal-trigger">&quot;coord_block&quot;</a> and <a href="#bd70f956-3664-4317-8643-3c2dd766c764" class="moose-modal-link modal-trigger">&quot;coord_type&quot;</a> parameters, respectively.</p><p>If the <code>RZ</code> coordinate system is used, there are two options for how to specify the coordinate axis(es) within the code, just like in the input file:</p><ul class="browser-default"><li><p>Call <code>MooseMesh::setAxisymmetricCoordAxis(rz_coord_axis)</code>, where <code>rz_coord_axis</code> is like <a href="#843a1bec-9f74-4de2-89ff-41fe553c149b" class="moose-modal-link modal-trigger">&quot;rz_coord_axis&quot;</a>. </p></li><li><p>Call <code>MooseMesh::setGeneralAxisymmetricCoordAxes(blocks, axes)</code>, where <code>blocks</code> is similar to <a href="#08190758-d767-42bf-8cf6-f7d2b2266864" class="moose-modal-link modal-trigger">&quot;rz_coord_blocks&quot;</a> and <code>axes</code> pairs up the origins and directions, similar to combining the parameters <a href="#96adef45-c378-4b94-87d7-56ebcb16fbc1" class="moose-modal-link modal-trigger">&quot;rz_coord_origins&quot;</a> and <a href="#99659f73-1cbe-4c2e-a11b-e38a8fca1b6b" class="moose-modal-link modal-trigger">&quot;rz_coord_directions&quot;</a>.</p></li></ul></section></section></section><div class="moose-modal modal" id="3282c5a5-9371-4b01-b835-754c2af0b0ae"><div class="modal-content"><h4>(moose/test/tests/auxkernels/solution_aux/build.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]


[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 2
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 3
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-10
[]

[Outputs]
  exodus = true
  xda = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="94be9c55-c1fc-41e0-9c00-04109f6872ba"><div class="modal-content"><h4>final_generator</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::string</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the mesh generator output to use for the final Mesh</p></div></div><div class="moose-modal modal" id="f237b30a-fc7d-4c89-9ebc-fbaf5701478e"><div class="modal-content"><h4>(moose/test/tests/mesh/named_entities/name_on_the_fly.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  file = three_block.e

  # These names will be applied on the fly to the
  # mesh so that they can be used in the input file
  # In addition they will show up in the output file
  block_id = &#x27;1 2 3&#x27;
  block_name = &#x27;wood steel copper&#x27;

  boundary_id = &#x27;1 2&#x27;
  boundary_name = &#x27;left right&#x27;
[]

[Variables]
  active = &#x27;u&#x27;

  [u]
    order = FIRST
    family = LAGRANGE
  []
[]

[Kernels]
  active = &#x27;diff&#x27;

  [diff]
    type = Diffusion
    variable = u
  []
[]

[BCs]
  active = &#x27;left right&#x27;

  [left]
    type = DirichletBC
    variable = u
    boundary = &#x27;left&#x27;
    value = 0
  []

  [right]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 1
  []
[]

[Materials]
  active = empty

  [empty]
    type = MTMaterial
    block = &#x27;wood steel copper&#x27;
  []
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="3511101d-7728-443d-80ab-923bca386776"><div class="modal-content"><h4>(moose/modules/solid_mechanics/test/tests/truss/truss_2d.i)</h4><pre style="max-height:350px;"><code class="language-moose">#
# Truss in two dimensional space
#
# The truss is made of five equilateral triangles supported at each end.
# The truss starts at (0,0).  At (1,0), there is a point load of 25.
# The reactions are therefore
#  Ryleft  = 2/3 * 25 = 16.7
#  Ryright = 1/3 * 25 = 8.33
# The area of each member is 0.8.
# Statics gives the stress in each member.  For example, for element 6 (from
#   (0,0) to (1/2,sqrt(3)/2)), the force is
#   f = 2/3 * 25 * 2/sqrt(3) = 100/3/sqrt(3) (compressive)
#   and the stress is
#   s = -100/3/sqrt(3)/0.8 = -24.06
#

[Mesh]
  type = FileMesh
  file = truss_2d.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./axial_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_over_l]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./area]
    order = CONSTANT
    family = MONOMIAL
#    initial_condition = 1.0
  [../]
  [./react_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./x2]
    type = PiecewiseLinear
    x = &#x27;0  1 2 3&#x27;
    y = &#x27;0 .5 1 1&#x27;
  [../]
  [./y2]
    type = PiecewiseLinear
    x = &#x27;0 1  2 3&#x27;
    y = &#x27;0 0 .5 1&#x27;
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./fixy4]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0
  [../]
[]

[DiracKernels]
  [./pull]
    type = ConstantPointSource
    value = -25
    point = &#x27;1 0 0&#x27;
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./axial_stress]
    type = MaterialRealAux
    block = 1
    property = axial_stress
    variable = axial_stress
  [../]
  [./e_over_l]
    type = MaterialRealAux
    block = 1
    property = e_over_l
    variable = e_over_l
  [../]
  [./area]
    type = ConstantAux
    block = 1
    variable = area
    value = 0.8
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;jacobi   101&#x27;

  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10

  dt = 1
  num_steps = 1
  end_time = 1
[]

[Kernels]
  [./solid_x]
    type = StressDivergenceTensorsTruss
    block = 1
    displacements = &#x27;disp_x disp_y&#x27;
    component = 0
    variable = disp_x
    area = area
    save_in = react_x
  [../]
  [./solid_y]
    type = StressDivergenceTensorsTruss
    block = 1
    displacements = &#x27;disp_x disp_y&#x27;
    component = 1
    variable = disp_y
    area = area
    save_in = react_y
  [../]
[]

[Materials]
  [./linelast]
    type = LinearElasticTruss
    block = 1
    youngs_modulus = 1e6
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="41c01252-2c51-48d8-a386-9b5df0dcce70"><div class="modal-content"><h4>(moose/test/tests/postprocessors/displaced_mesh/elemental.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  displacements = &#x27;ux uy&#x27;
[]

[AuxVariables]
  [./ux]
    [./InitialCondition]
      type = FunctionIC
      function = x
    [../]
  [../]
  [./uy]
    [./InitialCondition]
      type = FunctionIC
      function = y
    [../]
  [../]
  [./c]
    initial_condition = 1
  [../]
[]

[Variables]
  [./a]
  [../]
[]
[Kernels]
  [./a]
    type = Diffusion
    variable = a
  [../]
[]

[Postprocessors]
  [./without]
    type = ElementIntegralVariablePostprocessor
    variable = c
    execute_on = initial
  [../]
  [./with]
    type = ElementIntegralVariablePostprocessor
    variable = c
    use_displaced_mesh = true
    execute_on = initial
  [../]
[]

[Problem]
  solve = false
[]

[Executioner]
  type = Transient
  num_steps = 0
[]

[Outputs]
  [./out]
    type = Exodus
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="1804adf5-8f21-4d94-adfc-180198231192"><div class="modal-content"><h4>(moose/test/tests/mesh/mixed_dim/1d_3d.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  file = 1d_3d.e
  # 1d_3d.e contains HEX8 and BEAM2 elements - no additional input file
  # changes are necessary to handle mixed-dim meshes.
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 4
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]

  [./bottom]
    type = DirichletBC
    variable = u
    boundary = 100
    value = 0
  [../]

  [./top]
    type = DirichletBC
    variable = u
    boundary = 101
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = 1d_3d_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="6649ba5c-5bc4-45a4-82d9-6aa2fc937d5c"><div class="modal-content"><h4>coord_type</h4><p class="moose-parameter-description-default"><span>Default:</span>XYZ</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>XYZ, RZ, RSPHERICAL</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Type of the coordinate system per block param</p></div></div><div class="moose-modal modal" id="91e1ba18-3eb0-40f0-a634-314298049047"><div class="modal-content"><h4>coord_block</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Block IDs for the coordinate systems. If this parameter is specified, then it must encompass all the subdomains on the mesh.</p></div></div><div class="moose-modal modal" id="121b4e42-693d-4064-92f6-deb495bf2693"><div class="modal-content"><h4>rz_coord_axis</h4><p class="moose-parameter-description-default"><span>Default:</span>Y</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>X, Y</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The rotation axis (X | Y) for axisymmetric coordinates</p></div></div><div class="moose-modal modal" id="a8d0df9e-de5f-4e21-b530-5be3ba5e2791"><div class="modal-content"><h4>rz_coord_blocks</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Blocks using general axisymmetric coordinate systems</p></div></div><div class="moose-modal modal" id="86458d3e-d266-4a55-ae0e-1e88691e50ec"><div class="modal-content"><h4>rz_coord_origins</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;libMesh::Point&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Axis origin points for each block in 'rz_coord_blocks'</p></div></div><div class="moose-modal modal" id="6ab98f7f-e525-45be-af41-8766897dce49"><div class="modal-content"><h4>rz_coord_blocks</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Blocks using general axisymmetric coordinate systems</p></div></div><div class="moose-modal modal" id="3d1fb3f2-7200-469f-8c28-759b3d6cfda2"><div class="modal-content"><h4>rz_coord_directions</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;libMesh::VectorValue&lt;double&gt;&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Axis directions for each block in 'rz_coord_blocks'</p></div></div><div class="moose-modal modal" id="3bea5d64-9c10-44ca-a010-0a68f574ec50"><div class="modal-content"><h4>rz_coord_blocks</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Blocks using general axisymmetric coordinate systems</p></div></div><div class="moose-modal modal" id="b068914d-ea18-4788-950a-6b311aa0724f"><div class="modal-content"><h4>coord_block</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Block IDs for the coordinate systems. If this parameter is specified, then it must encompass all the subdomains on the mesh.</p></div></div><div class="moose-modal modal" id="bd70f956-3664-4317-8643-3c2dd766c764"><div class="modal-content"><h4>coord_type</h4><p class="moose-parameter-description-default"><span>Default:</span>XYZ</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>XYZ, RZ, RSPHERICAL</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Type of the coordinate system per block param</p></div></div><div class="moose-modal modal" id="843a1bec-9f74-4de2-89ff-41fe553c149b"><div class="modal-content"><h4>rz_coord_axis</h4><p class="moose-parameter-description-default"><span>Default:</span>Y</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>X, Y</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The rotation axis (X | Y) for axisymmetric coordinates</p></div></div><div class="moose-modal modal" id="08190758-d767-42bf-8cf6-f7d2b2266864"><div class="modal-content"><h4>rz_coord_blocks</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Blocks using general axisymmetric coordinate systems</p></div></div><div class="moose-modal modal" id="96adef45-c378-4b94-87d7-56ebcb16fbc1"><div class="modal-content"><h4>rz_coord_origins</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;libMesh::Point&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Axis origin points for each block in 'rz_coord_blocks'</p></div></div><div class="moose-modal modal" id="99659f73-1cbe-4c2e-a11b-e38a8fca1b6b"><div class="modal-content"><h4>rz_coord_directions</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;libMesh::VectorValue&lt;double&gt;&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Axis directions for each block in 'rz_coord_blocks'</p></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
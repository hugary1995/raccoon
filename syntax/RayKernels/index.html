<!DOCTYPE html><head><meta charset="UTF-8"><title>RayKernels | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="0e466e26-4a33-49d8-925c-baa5c3a37a60" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f118501c-f30f-4cce-9e01-5f24d5231dd7" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="02f134fd-210f-419f-ad55-b89c35d559ef" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f02c7d98-8b1d-495b-b5a4-49087541beaf" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="fe8ba6cd-35b1-4e16-a9bd-8a6efcd68f9b"><i class="material-icons">menu</i></a><ul class="sidenav" id="fe8ba6cd-35b1-4e16-a9bd-8a6efcd68f9b"><li><a href="#!" class="dropdown-trigger" data-target="baab1b5d-e435-4342-a906-c6b3d78314d6" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9e4a89fe-9a24-4d03-8797-ab2af41ef8f5" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="967cd6d9-2989-4660-a2ce-313d27269688" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="29269c10-b0c3-4b6a-9d23-9b138db21706" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="0e466e26-4a33-49d8-925c-baa5c3a37a60"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="f118501c-f30f-4cce-9e01-5f24d5231dd7"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="02f134fd-210f-419f-ad55-b89c35d559ef"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="f02c7d98-8b1d-495b-b5a4-49087541beaf"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="baab1b5d-e435-4342-a906-c6b3d78314d6"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="9e4a89fe-9a24-4d03-8797-ab2af41ef8f5"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="967cd6d9-2989-4660-a2ce-313d27269688"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="29269c10-b0c3-4b6a-9d23-9b138db21706"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../index.html">Complete syntax</a></li><li><a href="../raccoon.html">RACCOON syntax</a></li><li><a href="../solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../phase_field.html">Phase field syntax</a></li><li><a href="../heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="cea2c046-f7af-42fb-bfc5-35eda0b03c9f" data-section-level="1" data-section-text="RayKernels"><h1 id="raykernels">RayKernels</h1><p>A RayKernel operates on a line segment of a <a href="../../source/raytracing/Ray.html">Ray</a> within the <a href="../../modules/ray_tracing/index.html">Ray Tracing Module</a>, which is defined by the entry and exit point of the <a href="../../source/raytracing/Ray.html">Ray</a> within an element as it is traced through the mesh. The base object is the <code>RayKernelBase</code>.</p><p>Standard MOOSE convention denotes that a &quot;kernel&quot; is an object that contributes to the residual and the Jacobian. To remain consistent with this nomenclature, the <code>RayKernel</code> and <code>ADRayKernel</code> objects contribute to residuals and Jacobians from a <a href="../../source/raytracing/Ray.html">Ray</a>.</p><p>A summary of the objects that should be derived based on desired operation on segments are as follows:</p><ul class="browser-default"><li><p><a href="../../source/raykernels/RayKernel.html">RayKernel</a>: Segments contribute to residuals and Jacobians (example: line sources, see <a href="../../source/raykernels/LineSourceRayKernel.html">LineSourceRayKernel</a>) </p></li><li><p><a href="../../source/raykernels/ADRayKernel.html">ADRayKernel</a>: Segments contribute to residuals and use automatic-differentiation to compute the Jacobian </p></li><li><p><a href="../../source/raykernels/GenericRayKernel.html">GenericRayKernel</a>: Templated object that enables segment contribution to residuals and Jacobians with and without automatic differentiation (serves a similar purpose as <a href="../../source/kernels/GenericKernel.html">GenericKernel</a>) </p></li><li><p><a href="../../source/raykernels/IntegralRayKernel.html">IntegralRayKernel</a>: Performs an integral on each segment and accumulates the integrated result into the <a href="../../source/raytracing/Ray.html">Ray</a> (example: integral of a variable along a line, see <a href="../../source/raykernels/VariableIntegralRayKernel.html">VariableIntegralRayKernel</a>) </p></li><li><p><a href="../../source/raykernels/AuxRayKernel.html">AuxRayKernel</a>: Segments contribute to an AuxVariable in a user-defined manner (example: segment distances are accumulated into an AuxVariable, see <a href="../../source/raykernels/RayDistanceAux.html">RayDistanceAux</a>) </p></li><li><p><a href="../../source/raykernels/GeneralRayKernel.html">GeneralRayKernel</a>: General purpose object that can be adapted to operate on segments in a manner that is not covered by the classes listed above</p></li></ul><p>The remainder of the discussion focuses on the use of the functionality offered within the base object, <a href="../../source/raykernels/RayKernelBase.html">RayKernelBase</a>. Refer to the objects above for a more specific discussion.</p><section id="870ee7d5-4c8a-497e-9995-8e7f6869de36" data-section-level="2" data-section-text="Using a RayKernel"><h2 id="using-a-raykernel">Using a RayKernel</h2><p>The method that is called on each segment of a <a href="../../source/raytracing/Ray.html">Ray</a> in a RayKernel is <code>onSegment()</code>. This method is to be overridden to specialize the on-segment operation. The <code>preTrace()</code> method is also available to be overridden and is called before a trace begins on a processor/thread. After the ray has finished its trace the <code>postTrace()</code> method is called, this method is also available to be overridden.</p><p>The significant information pertaining to the trace that is available within <code>onSegment()</code> is as follows:</p><ul class="browser-default"><li><p><code>currentRay()</code> - The current <a href="../../source/raytracing/Ray.html">Ray</a> that is being traced on the segment. </p></li><li><p><code>_current_elem</code> - The current element that the <a href="../../source/raytracing/Ray.html">Ray</a> is being traced in. </p></li><li><p><code>_current_segment_start</code> - The start point of the current segment being operated on. This is not necessarily on the element periphery (a side of <code>_current_elem</code>) in the case that a <a href="../../source/raytracing/Ray.html">Ray</a> starts within an element. </p></li><li><p><code>_current_segment_end</code> - The end point of the current segment being operated on. This is not necessarily on the element periphery in the case that a <a href="../../source/raytracing/Ray.html">Ray</a> has ended within an element. </p></li><li><p><code>_current_segment_length</code> - The length of the current segment being operated on. </p></li><li><p><code>_current_intersected_side</code> - The side intersected on <code>_current_elem</code> at <code>_current_segment_end</code>, if any. </p></li><li><p><code>_current_incoming_side</code> - The side intersected on <code>_current_elem</code> at <code>_current_segment_end</code>, if any. </p></li><li><p><code>_current_intersected_extrema</code> - The extrema (element vertex or edge, see <a href="../../source/raytracing/ElemExtrema.html">ElemExtrema</a> for more information) intersected on <code>_current_intersected_side</code> at <code>_current_segment_end</code>, if any. </p></li><li><p><code>_current_subdomain_id</code> - The subdomain ID of the <code>_current_elem</code>.</p></li></ul><p>See the <a href="../../source/raytracing/Ray.html">Ray</a> documentation for what members are available for use during tracing.</p><p>Many standard MOOSE interfaces are also available within RayKernels to do things like access coupled variables, access materials, access UserObjects, access Postprocessors, etc.</p></section><section id="c1f4600e-0133-46cf-bcd6-7b4aac4f92f1" data-section-level="2" data-section-text="Ending the Ray"><h2 id="ending-the-ray">Ending the Ray</h2><p><code>Ray::shouldContinue()</code> denotes whether or not a <a href="../../source/raytracing/Ray.html">Ray</a> will continue to be traced after execution of current objects on the <a href="../../source/raytracing/Ray.html">Ray</a>. In the case of a RayKernel, when <code>currentRay()-&gt;shouldContinue() == false</code>, the <a href="../../source/raytracing/Ray.html">Ray</a> will cease tracing after execution of RayKernels. Internally, the following will set the state of the <a href="../../source/raytracing/Ray.html">Ray</a> to not continue before RayKernels are executed but will still allow them to be executed on the segment that contains the final end point:</p><ul class="browser-default"><li><p>If it has reached the user-set end point (when the <a href="../../source/raytracing/Ray.html">Ray</a> trajectory is set via <code>Ray::setStartingEndPoint()</code>). In this specific case, you can tell if the <a href="../../source/raytracing/Ray.html">Ray</a> has hit its end point by <code>currentRay()-&gt;atEnd()</code>. </p></li><li><p>If it has reached the user-set maximum distance for the <a href="../../source/raytracing/Ray.html">Ray</a> (<code>currentRay()-&gt;distance() == currentRay()-&gt;maxDistance()</code>). </p></li><li><p>If it has reached the global maximum distance set by the study parameter <code>ray_distance</code> (<code>currentRay()-&gt;distance() == _study.maxRayDistance()</code>)</p></li></ul><p>To stop a <a href="../../source/raytracing/Ray.html">Ray</a> from being traced, call:</p><pre style="max-height:350px;"><code class="language-text">
currentRay().setShouldContinue(false);
</code></pre><p>After a <a href="../../source/raytracing/Ray.html">Ray</a> has been set to not continue by any RayKernel, it cannot ever be set to continue again for the current trace.</p></section><section id="23f4429d-dab4-4708-b497-06eec254f6b3" data-section-level="2" data-section-text="Changing the Ray Trajectory"><h2 id="changing-the-ray-trajectory">Changing the Ray Trajectory</h2><p>A <a href="../../source/raytracing/Ray.html">Ray</a> that is currently being traced can have its trajectory changed mid-trace by a RayKernel. The following conditions are imposed on such a trajectory change:</p><ul class="browser-default"><li><p>The <a href="../../source/raytracing/Ray.html">Ray</a> must be continuing (<code>currentRay()-&gt;shouldContinue() == true</code>). That is, it cannot have reached its max distance and it cannot have been set to not continue by another RayKernel. See <a href="index.html#ending-the-ray">Ending the Ray</a> for more information. </p></li><li><p>The new start point (if changed) must remain within the element of the object that changed it. </p></li><li><p>The <a href="../../source/raytracing/Ray.html">Ray</a> cannot have had its end point set by <code>Ray::setStartingEndPoint()</code>. That is, if the user set a specific end point for the <a href="../../source/raytracing/Ray.html">Ray</a> (which internally sets its maximum distance to the straight-line distance from the start to the end), its trajectory can never be changed. </p></li><li><p>Only one trajectory change can be called by all RayKernels on each segment. </p></li><li><p>The <a href="../../source/raytracing/Ray.html">Ray</a> must have moved before its trajectory is changed.</p></li></ul><p>To change the trajectory of a <a href="../../source/raytracing/Ray.html">Ray</a> within a RayKernel, the method <code>changeRayStartDirection()</code> is to be called with parameters being the new start point of the <a href="../../source/raytracing/Ray.html">Ray</a> and the new direction of travel. For example:</p><pre style="max-height:350px;"><code class="language-text">
const Point some_point(1, 2, 3); // must be within _current_elem!
const Point some_direction(1, 0, 0);
changeRayStartDirection(some_point, some_direction);
</code></pre><p>If the start point of the <a href="../../source/raytracing/Ray.html">Ray</a> is changed within the element, the <a href="../../source/raytracing/Ray.html">Ray</a> distance will be adjusted accordingly as if the <a href="../../source/raytracing/Ray.html">Ray</a> hit the changed point instead. That is, the original incremented distance will be removed (<code>_current_segment_length</code>) and the new incremented distance for this segment will be the distance between <code>currentRay()-&gt;currentPoint()</code> and <code>_current_segment_start</code>.</p></section><section id="3ba8d2d1-1a96-44ce-bbb3-4c24ff784a55" data-section-level="2" data-section-text="Modifying / Registering Ray Data"><h2 id="modifying-registering-ray-data">Modifying/Registering Ray Data</h2><p>If your RayKernel requires data or auxiliary data on a <a href="../../source/raytracing/Ray.html">Ray</a> that is unique to said object, you can register said requirement in the constructor using <code>_study.registerRayData()</code> and <code>_study.registerAuxData()</code>. For more information on <a href="../../source/raytracing/Ray.html">Ray</a> registration supplied by the <a href="../../source/userobjects/RayTracingStudy.html">RayTracingStudy</a>, see <a href="../../source/userobjects/RayTracingStudy.html#ray-data-registration">Ray Data Registration</a>.</p><p>An example of this exists in <a href="../../source/raykernels/IntegralRayKernel.html">IntegralRayKernel</a>, which accumulates integrals into a data member on the <a href="../../source/raytracing/Ray.html">Ray</a>. Each <a href="../../source/raykernels/IntegralRayKernel.html">IntegralRayKernel</a> requires its own value to accumulate into, therefore the <a href="../../source/raykernels/IntegralRayKernel.html">IntegralRayKernel</a> registers a value for its own use:</p><pre style="max-height:350px;"><code class="language-cpp">IntegralRayKernel::IntegralRayKernel(const InputParameters &amp; params)
  : IntegralRayKernelBase(params),
    _integral_data_index(_study.registerRayData(integralRayDataName())),
    _average(getParam&lt;bool&gt;(&quot;average&quot;))
{
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#2a514c8b-59a5-436a-947a-12d9ae49e7e2">(moose/modules/ray_tracing/src/raykernels/IntegralRayKernel.C)</a><pre style="max-height:350px;"><code class="language-cpp">class IntegralRayKernel : public IntegralRayKernelBase
{
public:
  IntegralRayKernel(const InputParameters &amp; params);

  static InputParameters validParams();

  /**
   * Gets the name of the Ray data associated with the integral accumulated by this RayKernel
   */
  std::string integralRayDataName() const { return _name + &quot;_value&quot;; }

  void onSegment() override final;

protected:
  virtual Real computeQpIntegral() = 0;

  /// The index into the data on the Ray that this integral accumulates into
  const RayDataIndex _integral_data_index;

  /// Whether or not to compute the average (divide by the length)
  const bool _average;
};
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#61ee0a0f-dc90-4d88-aac4-d90ee19a5191">(moose/modules/ray_tracing/include/raykernels/IntegralRayKernel.h)</a><p>By registering the data, the data is guaranteed to be available for all constructed <a href="../../source/raytracing/Ray.html">Rays</a> and can be accessed by <code>currentRay()-&gt;data()</code> and <code>currentRay()-&gt;auxData()</code>.</p><p>In the case of the <a href="../../source/raykernels/IntegralRayKernel.html">IntegralRayKernel</a>, the <a href="../../source/raytracing/Ray.html">Ray</a> data is accessed as such:</p><pre style="max-height:350px;"><code class="language-cpp">void
IntegralRayKernel::onSegment()
{
  // Note that here we do not multiply by _coord[_qp]!
  //
  // The integral done here is the integral of a field variable/material/etc, and not
  // an integration that contributes to the residual/Jacobian. Hence: it is something like
  // a line integral. In RZ and RSPHERICAL, we want line integrals to still be line integrals.
  // Therefore, it does not make sense to multiply by the coordinate transformation.
  Real integral = 0;
  for (_qp = 0; _qp &lt; _q_point.size(); ++_qp)
    integral += _JxW[_qp] * computeQpIntegral();

  // If we&#x27;re computing the average, divide by the length
  if (_average)
    integral /= _current_segment_length;

  // Accumulate the integral into the Ray
  currentRay()-&gt;data(_integral_data_index) += integral;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#c5b746c1-52f9-4efd-8710-57cb7a1fecdf">(moose/modules/ray_tracing/src/raykernels/IntegralRayKernel.C)</a></section><section id="3b25b4af-859e-4ebe-bbc6-1593d9d9bdc1" data-section-level="2" data-section-text="Creating Additional Rays"><h2 id="creating-additional-rays">Creating Additional Rays</h2><p>It is possible to generate another <a href="../../source/raytracing/Ray.html">Ray</a> to be traced from within a RayKernel. This method is thread safe.</p><p>First, acquire a new <a href="../../source/raytracing/Ray.html">Ray</a> using the <code>acquireRay()</code> method (for more information on acquiring <a href="../../source/raytracing/Ray.html">Rays</a>, see <a href="../../source/userobjects/RayTracingStudy.html#ray-pool">Ray Pool</a>), which takes as arguments the starting point and direction of travel for the new <a href="../../source/raytracing/Ray.html">Ray</a>. For example:</p><pre style="max-height:350px;"><code class="language-text">
const Point some_point(1, 2, 3); // must be within _current_elem!
const Point some_direction(1, 0, 0);
std::shared_ptr&lt;Ray&gt; ray = acquireRay(some_point, some_direction);
</code></pre><p>The acquired <a href="../../source/raytracing/Ray.html">Ray</a> will be initialized with the following:</p><ul class="browser-default"><li><p>Zeroed data and aux data, sized as registered by the <code>RayTracingStudy</code>. </p></li><li><p>A starting point as set by the user. </p></li><li><p>A starting element that is <code>_current_elem</code>. </p></li><li><p>A unique ID.</p></li></ul><p>After the <a href="../../source/raytracing/Ray.html">Ray</a> has been acquired, you may modify its data members as desired before setting it to be traced. Once the <a href="../../source/raytracing/Ray.html">Ray</a> is modified as desired, do the following to insert it into the buffer to be traced:</p><pre style="max-height:350px;"><code class="language-text">
moveRayToBuffer(ray);
</code></pre></section></section><div class="moose-modal modal" id="2a514c8b-59a5-436a-947a-12d9ae49e7e2"><div class="modal-content"><h4>(moose/modules/ray_tracing/src/raykernels/IntegralRayKernel.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;IntegralRayKernel.h&quot;

// Local includes
#include &quot;RayTracingStudy.h&quot;

InputParameters
IntegralRayKernel::validParams()
{
  auto params = IntegralRayKernelBase::validParams();
  params.addParam&lt;bool&gt;(
      &quot;average&quot;,
      false,
      &quot;Whether or not to compute the average value (divides by the segment length)&quot;);
  return params;
}

IntegralRayKernel::IntegralRayKernel(const InputParameters &amp; params)
  : IntegralRayKernelBase(params),
    _integral_data_index(_study.registerRayData(integralRayDataName())),
    _average(getParam&lt;bool&gt;(&quot;average&quot;))
{
}

void
IntegralRayKernel::onSegment()
{
  // Note that here we do not multiply by _coord[_qp]!
  //
  // The integral done here is the integral of a field variable/material/etc, and not
  // an integration that contributes to the residual/Jacobian. Hence: it is something like
  // a line integral. In RZ and RSPHERICAL, we want line integrals to still be line integrals.
  // Therefore, it does not make sense to multiply by the coordinate transformation.
  Real integral = 0;
  for (_qp = 0; _qp &lt; _q_point.size(); ++_qp)
    integral += _JxW[_qp] * computeQpIntegral();

  // If we&#x27;re computing the average, divide by the length
  if (_average)
    integral /= _current_segment_length;

  // Accumulate the integral into the Ray
  currentRay()-&gt;data(_integral_data_index) += integral;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="61ee0a0f-dc90-4d88-aac4-d90ee19a5191"><div class="modal-content"><h4>(moose/modules/ray_tracing/include/raykernels/IntegralRayKernel.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;IntegralRayKernelBase.h&quot;

/**
 * Base class for a RayKernel that integrates along a Ray segment and stores the result in a scalar
 * value on the Ray
 */
class IntegralRayKernel : public IntegralRayKernelBase
{
public:
  IntegralRayKernel(const InputParameters &amp; params);

  static InputParameters validParams();

  /**
   * Gets the name of the Ray data associated with the integral accumulated by this RayKernel
   */
  std::string integralRayDataName() const { return _name + &quot;_value&quot;; }

  void onSegment() override final;

protected:
  virtual Real computeQpIntegral() = 0;

  /// The index into the data on the Ray that this integral accumulates into
  const RayDataIndex _integral_data_index;

  /// Whether or not to compute the average (divide by the length)
  const bool _average;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="c5b746c1-52f9-4efd-8710-57cb7a1fecdf"><div class="modal-content"><h4>(moose/modules/ray_tracing/src/raykernels/IntegralRayKernel.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;IntegralRayKernel.h&quot;

// Local includes
#include &quot;RayTracingStudy.h&quot;

InputParameters
IntegralRayKernel::validParams()
{
  auto params = IntegralRayKernelBase::validParams();
  params.addParam&lt;bool&gt;(
      &quot;average&quot;,
      false,
      &quot;Whether or not to compute the average value (divides by the segment length)&quot;);
  return params;
}

IntegralRayKernel::IntegralRayKernel(const InputParameters &amp; params)
  : IntegralRayKernelBase(params),
    _integral_data_index(_study.registerRayData(integralRayDataName())),
    _average(getParam&lt;bool&gt;(&quot;average&quot;))
{
}

void
IntegralRayKernel::onSegment()
{
  // Note that here we do not multiply by _coord[_qp]!
  //
  // The integral done here is the integral of a field variable/material/etc, and not
  // an integration that contributes to the residual/Jacobian. Hence: it is something like
  // a line integral. In RZ and RSPHERICAL, we want line integrals to still be line integrals.
  // Therefore, it does not make sense to multiply by the coordinate transformation.
  Real integral = 0;
  for (_qp = 0; _qp &lt; _q_point.size(); ++_qp)
    integral += _JxW[_qp] * computeQpIntegral();

  // If we&#x27;re computing the average, divide by the length
  if (_average)
    integral /= _current_segment_length;

  // Accumulate the integral into the Ray
  currentRay()-&gt;data(_integral_data_index) += integral;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
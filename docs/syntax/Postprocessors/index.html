<!DOCTYPE html><head><meta charset="UTF-8"><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script><title>Postprocessor System|RACCOON</title></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://hugary1995.github.io/raccoon/index.html" class="left moose-logo hide-on-med-and-down">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../install/index.html">Install</a></li><li class="moose-mega-menu-trigger" data-target="94a0ddc6-0b52-4320-9b11-9dd64971350e"><a>Benchmarks<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../theory/index.html">Theory</a></li><li><a href="../../modules/index.html">Modules</a></li><li><a href="../index.html">Syntax</a></li></ul><a href="#" class="sidenav-trigger" data-target="930f7781-668b-4c4c-b545-7ee87da26854"><i class="material-icons">menu</i></a><ul class="sidenav" id="930f7781-668b-4c4c-b545-7ee87da26854"><li><a href="../../install/index.html">Install</a></li><li><a href="../../benchmarks.menu.html">Benchmarks</a></li><li><a href="../../theory/index.html">Theory</a></li><li><a href="../../modules/index.html">Modules</a></li><li><a href="../index.html">Syntax</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="moose-mega-menu-content" id="94a0ddc6-0b52-4320-9b11-9dd64971350e"><div class="moose-mega-menu-wrapper"><div class="row row"><div class="col s12 m6 l4"><h2 id="mode-i-crack-propagation"><a href="../../benchmarks/mode1.html">Mode I crack propagation <i class="material-icons moose-inline-icon">link</i></a></h2><img src="../../media/mode1.gif" class="materialboxed moose-image" style="width:75%;float:left;padding-top:2.5%;"></img><p></p></div><div class="col s12 m6 l4"><h2 id="mode-ii-crack-propagation"><a href="../../benchmarks/mode2.html">Mode II crack propagation <i class="material-icons moose-inline-icon">link</i></a></h2><img src="../../media/mode2.gif" class="materialboxed moose-image" style="width:75%;float:left;padding-top:2.5%;"></img><p></p></div><div class="col s12 m6 l4"><h2 id="soil-desiccation"><a href="../../benchmarks/mud.html">Soil desiccation <i class="material-icons moose-inline-icon">link</i></a></h2><img src="../../media/soil.gif" class="materialboxed moose-image" style="width:75%;float:left;padding-top:2.5%;"></img><p></p></div></div></div></div><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="https://hugary1995.github.io/raccoon/index.html" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">syntax</a><a href="." class="breadcrumb">Postprocessors</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="370fc7c2-0bc2-468f-bc22-d5ff5fe6ea63" data-section-level="1" data-section-text="Postprocessor System"><h1 id="postprocessor-system">Postprocessor System</h1><p>A PostProcessor object in MOOSE is a C++ object that computes a single scalar (<code>Real</code>) value, typically the value computed is an aggregation of data from a simulation. For example, the maximum value of a variable (see <a href="../../source/postprocessors/ElementExtremeValue.html">ElementExtremeValue</a>). The value compute may be coupled to other systems via the <code>getPostprocessorValue</code> method available in most MOOSE objects.</p><p>MOOSE includes a large number of postprocessors within the framework, the complete list is provided in <a href="#available-objects">Available Objects list</a> section.</p><section class="scrollspy" id="b02eaa7b-52ab-40bd-ae10-6bf337143264" data-section-level="2" data-section-text="Example Input File"><h2 id="example-input-file">Example Input File</h2><p>The following input file snippet demonstrates the use of the <a href="../../source/postprocessors/ElementExtremeValue.html">ElementExtremeValue</a> to compute the minimum and maximum of the solution variable &quot;u&quot;.</p><pre class="moose-pre"><code class="language-text">[Postprocessors]
  [max]
    type = ElementExtremeValue
    variable = u
  []
  [min]
    type = ElementExtremeValue
    variable = u
    value_type = min
  []
[]
</code></pre><a href="#01306b20-c2e4-450d-a6b9-d074320e33d4" class="modal-trigger">(../moose/test/tests/postprocessors/element_extreme_value/element_extreme_value.i)</a><div class="modal moose-modal" id="01306b20-c2e4-450d-a6b9-d074320e33d4"><div class="modal-content"><h4>/home/gary/projects/moose/test/tests/postprocessors/element_extreme_value/element_extreme_value.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = u
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  []
[]

[Postprocessors]
  [max]
    type = ElementExtremeValue
    variable = u
  []
  [min]
    type = ElementExtremeValue
    variable = u
    value_type = min
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>This snippet is a part of a test that may be executed using the MOOSE test application as follows.</p><pre class="moose-pre"><code class="language-bash">
cd ~/projects/moose/test
make -j8
cd tests/postprocessors/element_extreme_value
~/projects/moose/test/moose_test-opt -i element_extreme_value.i
</code></pre><p>The data from this calculation is reported in the terminal output by default and if <a href="../../source/outputs/Exodus.html">Exodus</a> output is enabled the values will automatically be included in the output file. It is also possible to export the data to a comma separated value (csv) file by enabling the <a href="../../source/outputs/CSV.html">CSV</a> object within the <a href="../Outputs/index.html">Outputs</a> block.</p><pre class="moose-pre"><code class="language-bash">
Postprocessor Values:
+----------------+----------------+----------------+
| time           | max            | min            |
+----------------+----------------+----------------+
|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |
|   1.000000e+00 |   9.788675e-01 |   2.113249e-02 |
+----------------+----------------+----------------+
</code></pre></section><section class="scrollspy" id="e06b5b13-766b-4026-a1f2-4f2c47dc3645" data-section-level="2" data-section-text="Coupling Example Code"><h2 id="coupling-example-code">Coupling Example Code</h2><p>The values computed within a Postprocessor object may be used within other objects that inherit from the <a href="../../source/interfaces/PostprocessorInterface.html">PostprocessorInterface</a>, which is nearly every system within MOOSE. For example, the the <a href="../../source/bcs/PostprocessorNeumannBC.html">PostprocessorNeumannBC</a> object allows for a Neumann boundary condition to be set to a value computed from a postprocessor; this object will be used as example to demonstrate how coupling is performed.</p><p>To understand how the coupling is coded it is beneficial to first see how the coupling is defined via the input file. The following input file snippet shows that a <a href="../../source/postprocessors/PointValue.html">PointValue</a> postprocessor is created and named &quot;right_pp&quot; and the <a href="../../source/bcs/PostprocessorNeumannBC.html">PostprocessorNeumannBC</a> uses this value to set the boundary condition.</p><pre class="moose-pre"><code class="language-text">[Postprocessors]
  [right_pp]
    type = PointValue
    point = &#x27;0.5 0.5 0&#x27;
    variable = aux
    execute_on = &#x27;initial&#x27;
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = PostprocessorNeumannBC
    variable = u
    boundary = right
    postprocessor = right_pp
  []
[]
</code></pre><a href="#3e6de37c-8101-4d24-bd0c-fabb1f207b41" class="modal-trigger">(../moose/test/tests/bcs/pp_neumann/pp_neumann.i)</a><div class="modal moose-modal" id="3e6de37c-8101-4d24-bd0c-fabb1f207b41"><div class="modal-content"><h4>/home/gary/projects/moose/test/tests/bcs/pp_neumann/pp_neumann.i</h4><pre class="moose-pre"><code class="language-text"># NOTE: This file is used within the documentation, so please do not change names within the file
# without checking that associated documentation is not affected, see syntax/Postprocessors/index.md.
[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [u]
  []
[]

[AuxVariables]
  [aux]
    initial_condition = 5
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = u
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = PostprocessorNeumannBC
    variable = u
    boundary = right
    postprocessor = right_pp
  []
[]

[Postprocessors]
  [right_pp]
    type = PointValue
    point = &#x27;0.5 0.5 0&#x27;
    variable = aux
    execute_on = &#x27;initial&#x27;
  []
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>This first step of coding this type of coupling begins by adding the necessary input file syntax to the object that requires a postprocessor value, PostprocessorNeumannBC in this example. In all MOOSE objects input file syntax is governed by the validParams function of an object. To add the ability to couple a postprocessor, simply add a new parameter using the <code>PostprocessorName</code> type, as shown below. Notice, that the add parameters call includes a default value that makes the use of the postprocessor optional.</p><pre class="moose-pre"><code class="language-cpp">
#include &quot;PostprocessorNeumannBC.h&quot;

registerMooseObject(&quot;MooseApp&quot;, PostprocessorNeumannBC);

defineLegacyParams(PostprocessorNeumannBC);

InputParameters
</code></pre><a href="#74682329-4e2c-45d0-b1b6-1bc9d4de35ac" class="modal-trigger">(../moose/framework/src/bcs/PostprocessorNeumannBC.C)</a><div class="modal moose-modal" id="74682329-4e2c-45d0-b1b6-1bc9d4de35ac"><div class="modal-content"><h4>/home/gary/projects/moose/framework/src/bcs/PostprocessorNeumannBC.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;PostprocessorNeumannBC.h&quot;

registerMooseObject(&quot;MooseApp&quot;, PostprocessorNeumannBC);

defineLegacyParams(PostprocessorNeumannBC);

InputParameters
PostprocessorNeumannBC::validParams()
{
  InputParameters params = IntegratedBC::validParams();
  params.addParam&lt;PostprocessorName&gt;(
      &quot;postprocessor&quot;, 0.0, &quot;The postprocessor to use for value of the gradient on the boundary.&quot;);
  return params;
}

PostprocessorNeumannBC::PostprocessorNeumannBC(const InputParameters &amp; parameters)
  : IntegratedBC(parameters), _value(getPostprocessorValue(&quot;postprocessor&quot;))
{
}

Real
PostprocessorNeumannBC::computeQpResidual()
{
  return -_test[_i][_qp] * _value;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>The actual postprocessor value must be assigned to a member variable of the class, thus in the header a member variable must be created, which should always be a constant reference to a <code>PostprocessorValue</code> type. Since this is a reference it must be initialized, this occurs in the source file by calling the <code>getPostprocessorValue</code> method and providing the name used in the validParams function. The following snippets show declaration of the reference in the header and the initialization of this reference in the source file.  The <code>_value</code> member variable is then available for use anywhere inside the object, for the case of the boundary condition it is utilized in the computation of the residual.</p><pre class="moose-pre"><code class="language-cpp">  const PostprocessorValue &amp; _value;
</code></pre><a href="#0ff17e01-2eae-4d79-a259-c373e7a936d8" class="modal-trigger">(../moose/framework/include/bcs/PostprocessorNeumannBC.h)</a><div class="modal moose-modal" id="0ff17e01-2eae-4d79-a259-c373e7a936d8"><div class="modal-content"><h4>/home/gary/projects/moose/framework/include/bcs/PostprocessorNeumannBC.h</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;IntegratedBC.h&quot;

class PostprocessorNeumannBC;

template &lt;&gt;
InputParameters validParams&lt;PostprocessorNeumannBC&gt;();

/**
 * Implements a constant Neumann BC where grad(u) is a equal to a postprocessor on the boundary.
 * Uses the term produced from integrating the diffusion operator by parts.
 */
class PostprocessorNeumannBC : public IntegratedBC
{
public:
  /**
   * Factory constructor, takes parameters so that all derived classes can be built using the same
   * constructor.
   */
  static InputParameters validParams();

  PostprocessorNeumannBC(const InputParameters &amp; parameters);

protected:
  virtual Real computeQpResidual() override;

  /// Value of grad(u) on the boundary.
  const PostprocessorValue &amp; _value;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><pre class="moose-pre"><code class="language-cpp">PostprocessorNeumannBC::validParams()
{
  InputParameters params = IntegratedBC::validParams();
  params.addParam&lt;PostprocessorName&gt;(
      &quot;postprocessor&quot;, 0.0, &quot;The postprocessor to use for value of the gradient on the boundary.&quot;);
  return params;
}
</code></pre><a href="#ba8a5c2f-8247-45a8-8826-b65bedd5c315" class="modal-trigger">(../moose/framework/src/bcs/PostprocessorNeumannBC.C)</a><div class="modal moose-modal" id="ba8a5c2f-8247-45a8-8826-b65bedd5c315"><div class="modal-content"><h4>/home/gary/projects/moose/framework/src/bcs/PostprocessorNeumannBC.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;PostprocessorNeumannBC.h&quot;

registerMooseObject(&quot;MooseApp&quot;, PostprocessorNeumannBC);

defineLegacyParams(PostprocessorNeumannBC);

InputParameters
PostprocessorNeumannBC::validParams()
{
  InputParameters params = IntegratedBC::validParams();
  params.addParam&lt;PostprocessorName&gt;(
      &quot;postprocessor&quot;, 0.0, &quot;The postprocessor to use for value of the gradient on the boundary.&quot;);
  return params;
}

PostprocessorNeumannBC::PostprocessorNeumannBC(const InputParameters &amp; parameters)
  : IntegratedBC(parameters), _value(getPostprocessorValue(&quot;postprocessor&quot;))
{
}

Real
PostprocessorNeumannBC::computeQpResidual()
{
  return -_test[_i][_qp] * _value;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><section id="aa4ed90c-9e92-4fcd-aca4-67a95f15e015" data-section-level="3" data-section-text="Coupling to other values"><h3 id="coupling-to-other-values">Coupling to other values</h3><p>Just as Postprocessor values can be used in other objects, Postprocessors themselves can couple to Functions and Scalar Variables. See the following example that couples a scalar variable into a Postprocessor:</p><pre class="moose-pre"><code class="language-text">[Postprocessors]
  [./totalFlux]
    type = ScalarCoupledPostprocessor
    variable = u
    coupled_scalar = scalar_variable
    boundary = left
  [../]
[]
</code></pre><a href="#5097af0c-7524-407a-98e9-92056a8f3273" class="modal-trigger">(../moose/test/tests/postprocessors/scalar_coupled_postprocessor/scalar_coupled_postprocessor_test.i)</a><div class="modal moose-modal" id="5097af0c-7524-407a-98e9-92056a8f3273"><div class="modal-content"><h4>/home/gary/projects/moose/test/tests/postprocessors/scalar_coupled_postprocessor/scalar_coupled_postprocessor_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  ny = 5
  xmax = 1
  ymax = 1
  elem_type = QUAD4
[]

[Variables]
  [./u]
    initial_condition = 1
  [../]
  [./scalar_variable]
    family = SCALAR
    order = FIRST
    initial_condition = 2
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[ScalarKernels]
  [./td1]
    type = ODETimeDerivative
    variable = scalar_variable
  [../]
[]

[BCs]
  [./leftDirichlet]
      type = DirichletBC
      variable = u
      boundary = &#x27;left&#x27;
      value = 1
  [../]
  [./rightDirichlet]
      type = DirichletBC
      variable = u
      boundary = &#x27;right&#x27;
      value = 0
  [../]
[]

[Postprocessors]
  [./totalFlux]
    type = ScalarCoupledPostprocessor
    variable = u
    coupled_scalar = scalar_variable
    boundary = left
  [../]
[]

[Executioner]
  type = Transient
  dt = 1
  num_steps = 1
  solve_type = JFNK
  l_max_its = 30
  l_tol = 1e-6
  nl_max_its = 20
  nl_rel_tol = 1e-5
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section><section class="scrollspy" id="da5712ff-0d5f-45e0-8acf-e0dddf795916" data-section-level="2" data-section-text="Creating a Object Postprocessor"><h2 id="creating-a-object">Creating a <code>Postprocessor</code> Object</h2><p>In general, every Postprocessor object has two methods that must be defined &quot;execute&quot; and &quot;getValue&quot;.</p><p>First, consider the execute method. This method is called by MOOSE at different time depending on the type of postprocessor object. Therefore, when creating a Postprocessor object the new object should inherit from one of the following C++ classes:</p><ul class="browser-default"><li><p><strong>GeneralPostprocessor</strong>: &quot;execute&quot; is called once on each execution flag. </p></li><li><p><strong>NodalPostprocessor</strong>: &quot;execute&quot; is called for each <strong>node</strong> within the mesh on each execution flag. </p></li><li><p><strong>ElementalPostprocessor</strong>: &quot;execute&quot; is called for each <strong>element</strong> within the mesh on each execution  flag. </p></li><li><p><strong>InternalSidePostprocessor</strong>: &quot;execute&quot; is called for each <strong>side</strong>, that is not on a boundary,  within the mesh on each execution flag. </p></li><li><p><strong>SidePostprocessor</strong>: &quot;execute&quot; is called for each <strong>side</strong>, that is on a boundary, within the mesh  on each execution flag.</p></li></ul><p>The use of execution flags is discussed in the <a href="#execute-on">Execute On</a> section.</p><p>The getValue method is responsible for returning the value of the postprocessor object, this value is what is used by all objects that are coupled to the postprocessor. In some cases the necessary communication is performed within this method, but in general this following is preferred.</p><section id="7d31a916-b65a-4973-b7d3-c8af4bdc1726" data-section-level="3" data-section-text="Parallel Considerations"><h3 id="parallel-considerations">Parallel Considerations</h3><p>When creating a postprocessor it is often necessary to perform some parallel communication to ensure that the value being computed is correct across processes and threads. Three additional methods exists for making this process as simple as possible.</p><ul class="browser-default"><li><p><code>initialize</code>: This is called prior to the execution of the postprocessor and should be used  to setup the object to be in a known state. It is important to point out that execution  in this context includes all calls to the execute method. For example, for a <code>NodalPostprocessor</code>  object the initialize method is called and then the execute method is called for all nodes. </p></li><li><p><code>finalize</code>: This is called after the execution of the postprocessor and is intended to perform  communication to prepare the object for the call to the getValue method. </p></li><li><p><code>threadJoin</code>: This is called after the execution of the postprocessor and is intended to perform  aggregation for shared memory parallelism.</p></li></ul><p>To understand the use of these methods the <a href="../../source/postprocessors/AverageNodalVariableValue.html">AverageNodalVariableValue</a> postprocessor shall be used as an example. As the name suggests this postprocessor computes the average of the value of a variable at the nodes. To perform this calculation the variable values from each node are summed as is the number of values within the execute method. Then the getValue method returns the average by returning the sum divided by the count. The following snippet shows the these two methods: the <code>_u[_qp]</code> is the value of the variable at the current node that comes from a shared base class and  <code>_sum</code> and <code>_n</code> are a member variables defined within class for performing the calculation.</p><pre class="moose-pre"><code class="language-cpp">void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue()
{
  return _sum / _n;
}
</code></pre><a href="#4412851b-f30f-4441-a64d-6a634ae29b7f" class="modal-trigger">(../moose/framework/src/postprocessors/AverageNodalVariableValue.C)</a><div class="modal moose-modal" id="4412851b-f30f-4441-a64d-6a634ae29b7f"><div class="modal-content"><h4>/home/gary/projects/moose/framework/src/postprocessors/AverageNodalVariableValue.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AverageNodalVariableValue.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;SubProblem.h&quot;

registerMooseObject(&quot;MooseApp&quot;, AverageNodalVariableValue);

defineLegacyParams(AverageNodalVariableValue);

InputParameters
AverageNodalVariableValue::validParams()
{
  InputParameters params = NodalVariablePostprocessor::validParams();

  params.addClassDescription(&quot;Computes the average value of a field by sampling all nodal &quot;
                             &quot;solutions on the domain or within a subdomain&quot;);
  return params;
}

AverageNodalVariableValue::AverageNodalVariableValue(const InputParameters &amp; parameters)
  : NodalVariablePostprocessor(parameters), _sum(0), _n(0)
{
}

// doco-init-start
void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
// doco-init-end

// doco-execute-get-start
void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue()
{
  return _sum / _n;
}
// doco-execute-get-end

// doco-final-start
void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
// doco-final-end

// doco-thread-start
void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const AverageNodalVariableValue &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
// doco-thread-end
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>In parallel, the calls to the execute method occur on each process or thread on a subset of the domain, in this case nodes. Therefore, the computed values must be combined to get the actual summations required to compute the average value. The first step is to setup the state of this calculation within the initialize method, which in this example sets the <code>_sum</code> and <code>_n</code> member variables to zero.</p><pre class="moose-pre"><code class="language-cpp">void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
</code></pre><a href="#c329b564-4359-4359-beac-b59e4a519cd7" class="modal-trigger">(../moose/framework/src/postprocessors/AverageNodalVariableValue.C)</a><div class="modal moose-modal" id="c329b564-4359-4359-beac-b59e4a519cd7"><div class="modal-content"><h4>/home/gary/projects/moose/framework/src/postprocessors/AverageNodalVariableValue.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AverageNodalVariableValue.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;SubProblem.h&quot;

registerMooseObject(&quot;MooseApp&quot;, AverageNodalVariableValue);

defineLegacyParams(AverageNodalVariableValue);

InputParameters
AverageNodalVariableValue::validParams()
{
  InputParameters params = NodalVariablePostprocessor::validParams();

  params.addClassDescription(&quot;Computes the average value of a field by sampling all nodal &quot;
                             &quot;solutions on the domain or within a subdomain&quot;);
  return params;
}

AverageNodalVariableValue::AverageNodalVariableValue(const InputParameters &amp; parameters)
  : NodalVariablePostprocessor(parameters), _sum(0), _n(0)
{
}

// doco-init-start
void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
// doco-init-end

// doco-execute-get-start
void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue()
{
  return _sum / _n;
}
// doco-execute-get-end

// doco-final-start
void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
// doco-final-end

// doco-thread-start
void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const AverageNodalVariableValue &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
// doco-thread-end
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>After the aforementioned execute method is called for each node the computed values for <code>_sum</code> and <code>_n</code> must be aggregated from across processes to the root processes. For this problem a gather operation is required to collect the values computed on all processes to the root process. This is accomplished via the <code>gatherSum</code> method.</p><pre class="moose-pre"><code class="language-cpp">void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
</code></pre><a href="#0af52d10-e2d2-4672-b278-b44e3de7a1b1" class="modal-trigger">(../moose/framework/src/postprocessors/AverageNodalVariableValue.C)</a><div class="modal moose-modal" id="0af52d10-e2d2-4672-b278-b44e3de7a1b1"><div class="modal-content"><h4>/home/gary/projects/moose/framework/src/postprocessors/AverageNodalVariableValue.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AverageNodalVariableValue.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;SubProblem.h&quot;

registerMooseObject(&quot;MooseApp&quot;, AverageNodalVariableValue);

defineLegacyParams(AverageNodalVariableValue);

InputParameters
AverageNodalVariableValue::validParams()
{
  InputParameters params = NodalVariablePostprocessor::validParams();

  params.addClassDescription(&quot;Computes the average value of a field by sampling all nodal &quot;
                             &quot;solutions on the domain or within a subdomain&quot;);
  return params;
}

AverageNodalVariableValue::AverageNodalVariableValue(const InputParameters &amp; parameters)
  : NodalVariablePostprocessor(parameters), _sum(0), _n(0)
{
}

// doco-init-start
void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
// doco-init-end

// doco-execute-get-start
void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue()
{
  return _sum / _n;
}
// doco-execute-get-end

// doco-final-start
void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
// doco-final-end

// doco-thread-start
void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const AverageNodalVariableValue &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
// doco-thread-end
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>Of course, the type of communication necessary depends on the calculation being performed. The <a href="../../source/userobject/UserObject.html">UserObject</a> base class includes helper methods for common parallel communications functions.</p><p>The initialize and finalize methods are utilized to aggregate for message passing (MPI) based parallelism. For shared memory parallelism the theadJoin method is used. This method is called, like finalize, after execution is complete and includes a single argument. This argument is a reference to a UserObject, which is a base class of Postprocessor objects. The purpose of this method is to enable the aggregation for the Postprocessor objects that were executed on other threads to the object on the root thread. For the AverageNodalVariableValue postprocessor the values for <code>_sum</code> and <code>_n</code> on the root process object are updated to include the these same values from the other threads.</p><pre class="moose-pre"><code class="language-cpp">void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const AverageNodalVariableValue &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
</code></pre><a href="#84e90ca2-cd62-40cd-95f1-fcd37d01ce57" class="modal-trigger">(../moose/framework/src/postprocessors/AverageNodalVariableValue.C)</a><div class="modal moose-modal" id="84e90ca2-cd62-40cd-95f1-fcd37d01ce57"><div class="modal-content"><h4>/home/gary/projects/moose/framework/src/postprocessors/AverageNodalVariableValue.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AverageNodalVariableValue.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;SubProblem.h&quot;

registerMooseObject(&quot;MooseApp&quot;, AverageNodalVariableValue);

defineLegacyParams(AverageNodalVariableValue);

InputParameters
AverageNodalVariableValue::validParams()
{
  InputParameters params = NodalVariablePostprocessor::validParams();

  params.addClassDescription(&quot;Computes the average value of a field by sampling all nodal &quot;
                             &quot;solutions on the domain or within a subdomain&quot;);
  return params;
}

AverageNodalVariableValue::AverageNodalVariableValue(const InputParameters &amp; parameters)
  : NodalVariablePostprocessor(parameters), _sum(0), _n(0)
{
}

// doco-init-start
void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
// doco-init-end

// doco-execute-get-start
void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue()
{
  return _sum / _n;
}
// doco-execute-get-end

// doco-final-start
void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
// doco-final-end

// doco-thread-start
void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const AverageNodalVariableValue &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
// doco-thread-end
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section><section class="scrollspy" id="b0be9a5f-d2ae-4382-8afa-63571fda99c5" data-section-level="2" data-section-text="Execute On ..."><h2 id="execute-on">Execute On...</h2><p>Postprocessor objects inherit from the <a href="../../source/interfaces/SetupInterface.html">SetupInterface (execute_on)</a> that allows the objects to execute and varying and multiple times during a simulation, such as during initialization and at the end of each time step. Refer to the <a href="../../source/interfaces/SetupInterface.html">SetupInterface (execute_on)</a> for additional information.</p></section><section class="scrollspy" id="19d29601-6c0d-41e4-9ab7-302f1d4c534e" data-section-level="2" data-section-text="Using Old and Older values"><h2 id="using-old-and-older-values">Using Old and Older values</h2><p>MOOSE maintains previously computed values in the postprocessor system for using lagged information in a computation. Both the previous time step&#x27;s value and the value computed two steps back may be retrieved. One reason you might use older values is to break cyclic dependencies. MOOSE does not consider a dependence on an old value when considering the order of evaluation among objects with dependencies.</p></section><section class="scrollspy" id="b20b7971-a2e5-4b04-9378-5956accdc7be" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/postprocessors/AreaPostprocessor.html">AreaPostprocessor</a>Computes the &quot;area&quot; or dimension - 1 &quot;volume&quot; of a given boundary or boundaries in your mesh.</li><li class="collection-item"><a href="../../source/postprocessors/AverageElementSize.html">AverageElementSize</a></li><li class="collection-item"><a href="../../source/postprocessors/AverageNodalVariableValue.html">AverageNodalVariableValue</a>Computes the average value of a field by sampling all nodal solutions on the domain or within a subdomain</li><li class="collection-item"><a href="../../source/postprocessors/AxisymmetricCenterlineAverageValue.html">AxisymmetricCenterlineAverageValue</a>Computes the average value of a variable on a sideset located along the centerline of an axisymmetric model.</li><li class="collection-item"><a href="../../source/postprocessors/ChangeOverTimePostprocessor.html">ChangeOverTimePostprocessor</a>Computes the change or relative change in a post-processor value over a timestep or the entire transient</li><li class="collection-item"><a href="../../source/postprocessors/ChangeOverTimestepPostprocessor.html">ChangeOverTimestepPostprocessor</a>Computes the change or relative change in a post-processor value over a timestep or the entire transient</li><li class="collection-item"><a href="../../source/postprocessors/CumulativeValuePostprocessor.html">CumulativeValuePostprocessor</a></li><li class="collection-item"><a href="../../source/postprocessors/DifferencePostprocessor.html">DifferencePostprocessor</a></li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageSecondTimeDerivative.html">ElementAverageSecondTimeDerivative</a>Computes the element averaged second derivative of variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageTimeDerivative.html">ElementAverageTimeDerivative</a>Computes a volume integral of the time derivative of a given variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageValue.html">ElementAverageValue</a></li><li class="collection-item"><a href="../../source/postprocessors/ElementExtremeValue.html">ElementExtremeValue</a>Finds either the min or max elemental value of a a variable over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/ElementH1Error.html">ElementH1Error</a></li><li class="collection-item"><a href="../../source/postprocessors/ElementH1SemiError.html">ElementH1SemiError</a></li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralArrayVariablePostprocessor.html">ElementIntegralArrayVariablePostprocessor</a>Integral of one component of an array variable.</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralMaterialProperty.html">ElementIntegralMaterialProperty</a></li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralVariablePostprocessor.html">ElementIntegralVariablePostprocessor</a></li><li class="collection-item"><a href="../../source/postprocessors/ElementL2Difference.html">ElementL2Difference</a>Computes the element-wise L2 difference between the current variable and a coupled variable.</li><li class="collection-item"><a href="../../source/postprocessors/ElementL2Error.html">ElementL2Error</a></li><li class="collection-item"><a href="../../source/postprocessors/ElementL2Norm.html">ElementL2Norm</a></li><li class="collection-item"><a href="../../source/postprocessors/ElementVectorL2Error.html">ElementVectorL2Error</a>Computes the Vector L2 difference of up to three variables simultaneously (normally x, y, z)</li><li class="collection-item"><a href="../../source/postprocessors/ElementW1pError.html">ElementW1pError</a></li><li class="collection-item"><a href="../../source/postprocessors/ElementalVariableValue.html">ElementalVariableValue</a>Outputs an elemental variable value at a particular location</li><li class="collection-item"><a href="../../source/postprocessors/EmptyPostprocessor.html">EmptyPostprocessor</a></li><li class="collection-item">ExecutionerAttributeReporter</li><li class="collection-item"><a href="../../source/postprocessors/FindValueOnLine.html">FindValueOnLine</a>Find a specific target value along a sampling line. The variable values along the line should change monotonically. The target value is searched using a bisection algorithm.</li><li class="collection-item"><a href="../../source/postprocessors/FunctionElementIntegral.html">FunctionElementIntegral</a>Integrates a function over elements</li><li class="collection-item"><a href="../../source/postprocessors/FunctionSideIntegral.html">FunctionSideIntegral</a></li><li class="collection-item"><a href="../../source/postprocessors/FunctionValuePostprocessor.html">FunctionValuePostprocessor</a>Computes the value of a supplied function at a single point (scalable)</li><li class="collection-item"><a href="../../source/postprocessors/GreaterThanLessThanPostprocessor.html">GreaterThanLessThanPostprocessor</a></li><li class="collection-item"><a href="../../source/postprocessors/InterfaceAverageVariableValuePostprocessor.html">InterfaceAverageVariableValuePostprocessor</a>Computes the average value of a variable on an interface. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceIntegralVariableValuePostprocessor.html">InterfaceIntegralVariableValuePostprocessor</a>Add access to variables and their gradient on an interface.</li><li class="collection-item"><a href="../../source/postprocessors/LinearCombinationPostprocessor.html">LinearCombinationPostprocessor</a></li><li class="collection-item"><a href="../../source/postprocessors/MemoryUsage.html">MemoryUsage</a>Memory usage statistics for the running simulation.</li><li class="collection-item"><a href="../../source/postprocessors/NodalExtremeValue.html">NodalExtremeValue</a></li><li class="collection-item"><a href="../../source/postprocessors/NodalL2Error.html">NodalL2Error</a></li><li class="collection-item"><a href="../../source/postprocessors/NodalL2Norm.html">NodalL2Norm</a></li><li class="collection-item"><a href="../../source/postprocessors/NodalMaxValue.html">NodalMaxValue</a></li><li class="collection-item"><a href="../../source/postprocessors/NodalProxyMaxValue.html">NodalProxyMaxValue</a></li><li class="collection-item"><a href="../../source/postprocessors/NodalSum.html">NodalSum</a>Computes the sum of all of the nodal values of the specified variable. Note: This object sets the default &quot;unique_node_execute&quot; flag to true to avoid double counting nodes between shared blocks.</li><li class="collection-item"><a href="../../source/postprocessors/NodalVariableValue.html">NodalVariableValue</a>Outputs values of a nodal variable at a particular location</li><li class="collection-item"><a href="../../source/postprocessors/NumDOFs.html">NumDOFs</a>Return the number of Degrees of freedom from either the NL, Aux or both systems.</li><li class="collection-item"><a href="../../source/postprocessors/NumElems.html">NumElems</a>Return the number of active or total elements in the simulation.</li><li class="collection-item"><a href="../../source/postprocessors/NumLinearIterations.html">NumLinearIterations</a></li><li class="collection-item"><a href="../../source/postprocessors/NumNodes.html">NumNodes</a>Returns the total number of nodes in a simulation (works with DistributedMesh)</li><li class="collection-item"><a href="../../source/postprocessors/NumNonlinearIterations.html">NumNonlinearIterations</a>Outputs the number of nonlinear iterations</li><li class="collection-item"><a href="../../source/postprocessors/NumPicardIterations.html">NumPicardIterations</a></li><li class="collection-item"><a href="../../source/postprocessors/NumRelationshipManagers.html">NumRelationshipManagers</a>Return the number of relationship managers active.</li><li class="collection-item"><a href="../../source/postprocessors/NumResidualEvaluations.html">NumResidualEvaluations</a></li><li class="collection-item"><a href="../../source/postprocessors/NumVars.html">NumVars</a>Return the number of variables from either the NL, Aux, or both systems.</li><li class="collection-item"><a href="../../source/postprocessors/PercentChangePostprocessor.html">PercentChangePostprocessor</a></li><li class="collection-item"><a href="../../source/postprocessors/PerfGraphData.html">PerfGraphData</a>Retrieves timing information from the PerfGraph.</li><li class="collection-item"><a href="../../source/postprocessors/PerformanceData.html">PerformanceData</a>Provides programmatic access to Performance Log Data</li><li class="collection-item"><a href="../../source/postprocessors/PointValue.html">PointValue</a></li><li class="collection-item"><a href="../../source/postprocessors/PostprocessorComparison.html">PostprocessorComparison</a>Compares two post-processors and produces a boolean value</li><li class="collection-item"><a href="../../source/postprocessors/Receiver.html">Receiver</a>Reports the value stored in this processor, which is usually filled in by another object. The Receiver does not compute its own value.</li><li class="collection-item"><a href="../../source/postprocessors/RelativeDifferencePostprocessor.html">RelativeDifferencePostprocessor</a>Computes the absolute value of the relative difference between 2 post-processor values.</li><li class="collection-item"><a href="../../source/postprocessors/RelativeSolutionDifferenceNorm.html">RelativeSolutionDifferenceNorm</a>Computes the relative norm of the solution difference of two consecutive time steps.</li><li class="collection-item"><a href="../../source/postprocessors/Residual.html">Residual</a></li><li class="collection-item"><a href="../../source/postprocessors/ScalarL2Error.html">ScalarL2Error</a></li><li class="collection-item"><a href="../../source/postprocessors/ScalarVariable.html">ScalarVariable</a></li><li class="collection-item"><a href="../../source/postprocessors/ScalePostprocessor.html">ScalePostprocessor</a>Scales a post-processor by a value</li><li class="collection-item"><a href="../../source/postprocessors/SideAverageValue.html">SideAverageValue</a>Computes the average value of a variable on a sideset. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="../../source/postprocessors/SideFluxAverage.html">SideFluxAverage</a>Computes the integral of the flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideFluxIntegral.html">SideFluxIntegral</a>Computes the integral of the flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideIntegralVariablePostprocessor.html">SideIntegralVariablePostprocessor</a></li><li class="collection-item"><a href="../../source/postprocessors/TimeExtremeValue.html">TimeExtremeValue</a>A postprocessor for reporting the extreme value of another postprocessor over time.</li><li class="collection-item"><a href="../../source/postprocessors/TimestepSize.html">TimestepSize</a>Reports the timestep size</li><li class="collection-item"><a href="../../source/postprocessors/TotalVariableValue.html">TotalVariableValue</a></li><li class="collection-item"><a href="../../source/postprocessors/VariableInnerProduct.html">VariableInnerProduct</a></li><li class="collection-item"><a href="../../source/postprocessors/VariableResidual.html">VariableResidual</a>Computes the Residual of a single variable in the solution vector.</li><li class="collection-item"><a href="../../source/postprocessors/VectorPostprocessorComparison.html">VectorPostprocessorComparison</a>Compares two vector post-processors of equal size and produces a boolean value</li><li class="collection-item"><a href="../../source/postprocessors/VolumePostprocessor.html">VolumePostprocessor</a>Computes the volume of a specified block</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="../../source/postprocessors/AsymptoticExpansionHomogenizationElasticConstants.html">AsymptoticExpansionHomogenizationElasticConstants</a>Postprocessor for asymptotic expansion homogenization for elasticity</li><li class="collection-item"><a href="../../source/postprocessors/CavityPressurePostprocessor.html">CavityPressurePostprocessor</a>Interfaces with the CavityPressureUserObject to store the initial number of moles of a gas contained within an internal volume.</li><li class="collection-item"><a href="../../source/postprocessors/CrackFrontData.html">CrackFrontData</a>Determines which nodes are along the crack front</li><li class="collection-item"><a href="../../source/postprocessors/CriticalTimeStep.html">CriticalTimeStep</a>Computes and reports the critical time step for the explicit solver.</li><li class="collection-item"><a href="../../source/postprocessors/InteractionIntegral.html">InteractionIntegral</a>Computes the interaction integral for fracture</li><li class="collection-item"><a href="../../source/postprocessors/JIntegral.html">JIntegral</a>Calculates the J-integral at a specified point  along the crack front</li><li class="collection-item"><a href="../../source/postprocessors/Mass.html">Mass</a></li><li class="collection-item"><a href="../../source/postprocessors/MaterialTensorIntegral.html">MaterialTensorIntegral</a>This postprocessor computes an element integral of a component of a material tensor as specified by the user-supplied indices</li><li class="collection-item"><a href="../../source/postprocessors/MaterialTimeStepPostprocessor.html">MaterialTimeStepPostprocessor</a>This postprocessor estimates a timestep that reduces the increment change in a material property below a given threshold.</li><li class="collection-item"><a href="../../source/postprocessors/MixedModeEquivalentK.html">MixedModeEquivalentK</a>Computes the mixed-mode stress intensity factor given the <span tex="K_I" bookmark="moose-equation-a2f7509a-ce36-40dd-a8be-49420cdf6976" recursive="True" class="moose-katex-inline-equation" id="moose-equation-a2f7509a-ce36-40dd-a8be-49420cdf6976"><script>var element = document.getElementById("moose-equation-a2f7509a-ce36-40dd-a8be-49420cdf6976");katex.render("K_I", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\dArea":"\\text{ d}A","\\dVolume":"\\text{ d}V","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"\\mathcal{G}_c","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>"}});</script></span>, <span tex="K_{II}" bookmark="moose-equation-bd33c0e3-ff25-45d7-8f06-8ba9b2d19842" recursive="True" class="moose-katex-inline-equation" id="moose-equation-bd33c0e3-ff25-45d7-8f06-8ba9b2d19842"><script>var element = document.getElementById("moose-equation-bd33c0e3-ff25-45d7-8f06-8ba9b2d19842");katex.render("K_{II}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\dArea":"\\text{ d}A","\\dVolume":"\\text{ d}V","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"\\mathcal{G}_c","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>"}});</script></span>, and <span tex="K_{III}" bookmark="moose-equation-2575c0ed-cb16-4885-bdd0-2e936bb63dcf" recursive="True" class="moose-katex-inline-equation" id="moose-equation-2575c0ed-cb16-4885-bdd0-2e936bb63dcf"><script>var element = document.getElementById("moose-equation-2575c0ed-cb16-4885-bdd0-2e936bb63dcf");katex.render("K_{III}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\dArea":"\\text{ d}A","\\dVolume":"\\text{ d}V","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"\\mathcal{G}_c","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>"}});</script></span> stress intensity factors</li><li class="collection-item"><a href="../../source/postprocessors/TorqueReaction.html">TorqueReaction</a>TorqueReaction calculates the torque in 2D and 3Dabout a user-specified axis of rotation centeredat a user-specied origin.</li><li class="collection-header">raccoon App</li><li class="collection-item"><a href="../../source/postprocessors/ExternalEnergy.html">ExternalEnergy</a>Compute the increase in external energy during the current step</li><li class="collection-item"><a href="../../source/postprocessors/FractureEnergy.html">FractureEnergy</a></li><li class="collection-item"><a href="../../source/postprocessors/FractureSurfaceArea.html">FractureSurfaceArea</a></li><li class="collection-item"><a href="../../source/postprocessors/PhaseFieldJIntegral.html">PhaseFieldJIntegral</a>Compute the J integral for a phase-field model of fracture</li><li class="collection-header">Contact App</li><li class="collection-item"><a href="../../source/postprocessors/ContactDOFSetSize.html">ContactDOFSetSize</a>Outputs the number of dofs greater than a tolerance threshold indicating mechanical contact</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="../../source/postprocessors/ConvectiveHeatTransferSideIntegral.html">ConvectiveHeatTransferSideIntegral</a>Computes the total convective heat transfer across a boundary.</li><li class="collection-item"><a href="../../source/postprocessors/GrayLambertSurfaceRadiationPP.html">GrayLambertSurfaceRadiationPP</a>This postprocessor allows to extract radiosity, heat flux density, and temperature from the GrayLambertSurfaceRadiationBase object.</li><li class="collection-item"><a href="../../source/postprocessors/HomogenizedThermalConductivity.html">HomogenizedThermalConductivity</a>Postprocessor for asymptotic expansion homogenization for thermal conductivity</li><li class="collection-item"><a href="../../source/postprocessors/ThermalConductivity.html">ThermalConductivity</a>Computes the average value of a variable on a sideset. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="../../source/postprocessors/ViewFactorPP.html">ViewFactorPP</a>This postprocessor allows to extract view factors from ViewFactor userobjects.</li><li class="collection-header">Phase Field App</li><li class="collection-item"><a href="../../source/postprocessors/AverageGrainVolume.html">AverageGrainVolume</a>Calculate average grain area in a polycrystal</li><li class="collection-item"><a href="../../source/postprocessors/DiscreteNucleationData.html">DiscreteNucleationData</a>Output diagnostic data on a DiscreteNucleationInserter</li><li class="collection-item"><a href="../../source/postprocessors/DiscreteNucleationTimeStep.html">DiscreteNucleationTimeStep</a>Return a time step limit for nucleation event to be used by IterationAdaptiveDT</li><li class="collection-item"><a href="../../source/postprocessors/FauxGrainTracker.html">FauxGrainTracker</a>Fake grain tracker object for cases where the number of grains is equal to the number of order parameters.</li><li class="collection-item"><a href="../../source/postprocessors/FeatureFloodCount.html">FeatureFloodCount</a>The object is able to find and count &quot;connected components&quot; in any solution field or number of solution fields. A primary example would be to count &quot;bubbles&quot;.</li><li class="collection-item"><a href="../../source/postprocessors/FeatureVolumeFraction.html">FeatureVolumeFraction</a></li><li class="collection-item"><a href="../../source/postprocessors/GrainBoundaryArea.html">GrainBoundaryArea</a>Calculate total grain boundary length in 2D and area in 3D</li><li class="collection-item"><a href="../../source/postprocessors/GrainTracker.html">GrainTracker</a>Grain Tracker object for running reduced order parameter simulations without grain coalescence.</li><li class="collection-item"><a href="../../source/postprocessors/GrainTrackerElasticity.html">GrainTrackerElasticity</a>Grain Tracker object for running reduced order parameter simulations without grain coalescence.</li><li class="collection-item"><a href="../../source/postprocessors/PFCElementEnergyIntegral.html">PFCElementEnergyIntegral</a></li><li class="collection-item"><a href="../../source/userobjects/PolycrystalCircles.html">PolycrystalCircles</a>Polycrystal circles generated from a vector input or read from a file</li><li class="collection-item"><a href="../../source/userobjects/PolycrystalEBSD.html">PolycrystalEBSD</a>Object for setting up a polycrystal structure from an EBSD Datafile</li><li class="collection-item"><a href="../../source/userobjects/PolycrystalHex.html">PolycrystalHex</a>Perturbed hexagonal polycrystal</li><li class="collection-item"><a href="../../source/userobjects/PolycrystalVoronoi.html">PolycrystalVoronoi</a>Random Voronoi tessellation polycrystal (used by PolycrystalVoronoiAction)</li></ul></section><section class="scrollspy" id="545890db-de84-4ee8-b49f-98a521f49cdf" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/AddPostprocessorAction.html">AddPostprocessorAction</a></li><li class="collection-item"><a href="../../source/actions/SetupPostprocessorDataAction.html">SetupPostprocessorDataAction</a></li></ul></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#b02eaa7b-52ab-40bd-ae10-6bf337143264" class="tooltipped" data-position="left" data-tooltip="Example Input File">Example Input File</a></li><li><a href="#e06b5b13-766b-4026-a1f2-4f2c47dc3645" class="tooltipped" data-position="left" data-tooltip="Coupling Example Code">Coupling Example Code</a></li><li><a href="#da5712ff-0d5f-45e0-8acf-e0dddf795916" class="tooltipped" data-position="left" data-tooltip="Creating a Object Postprocessor">Creating a Object Postprocessor</a></li><li><a href="#b0be9a5f-d2ae-4382-8afa-63571fda99c5" class="tooltipped" data-position="left" data-tooltip="Execute On ...">Execute On ...</a></li><li><a href="#19d29601-6c0d-41e4-9ab7-302f1d4c534e" class="tooltipped" data-position="left" data-tooltip="Using Old and Older values">Using Old and Older values</a></li><li><a href="#b20b7971-a2e5-4b04-9378-5956accdc7be" class="tooltipped" data-position="left" data-tooltip="Available Objects">Available Objects</a></li><li><a href="#545890db-de84-4ee8-b49f-98a521f49cdf" class="tooltipped" data-position="left" data-tooltip="Available Actions">Available Actions</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script>
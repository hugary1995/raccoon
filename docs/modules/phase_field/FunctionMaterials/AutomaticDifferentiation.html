<!DOCTYPE html><head><meta charset="UTF-8"><link rel="icon" type="image/x-icon" href="../../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../../contrib/plotly/plotly.min.js"></script><title>Automatic Differentiation|RACCOON</title></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://hugary1995.github.io/raccoon/index.html" class="left moose-logo hide-on-med-and-down">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../../media/framework/github-logo.png" class="github-mark"></img><img src="../../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../../install/index.html">Install</a></li><li class="moose-mega-menu-trigger" data-target="151a6032-95df-4ff7-a362-2e9b211fd1cb"><a>Benchmarks<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../../theory/index.html">Theory</a></li><li><a href="../../index.html">Modules</a></li><li><a href="../../../syntax/index.html">Syntax</a></li></ul><a href="#" class="sidenav-trigger" data-target="2ccaf90c-9ff1-4d31-9e42-649d690637e0"><i class="material-icons">menu</i></a><ul class="sidenav" id="2ccaf90c-9ff1-4d31-9e42-649d690637e0"><li><a href="../../../install/index.html">Install</a></li><li><a href="../../../benchmarks.menu.html">Benchmarks</a></li><li><a href="../../../theory/index.html">Theory</a></li><li><a href="../../index.html">Modules</a></li><li><a href="../../../syntax/index.html">Syntax</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="moose-mega-menu-content" id="151a6032-95df-4ff7-a362-2e9b211fd1cb"><div class="moose-mega-menu-wrapper"><div class="row row"><div class="col s12 m6 l4"><h2 id="mode-i-crack-propagation"><a href="../../../benchmarks/mode1.html">Mode I crack propagation <i class="material-icons moose-inline-icon">link</i></a></h2><img src="../../../media/mode1.gif" class="materialboxed moose-image" style="width:75%;float:left;padding-top:2.5%;"></img><p></p></div><div class="col s12 m6 l4"><h2 id="mode-ii-crack-propagation"><a href="../../../benchmarks/mode2.html">Mode II crack propagation <i class="material-icons moose-inline-icon">link</i></a></h2><img src="../../../media/mode2.gif" class="materialboxed moose-image" style="width:75%;float:left;padding-top:2.5%;"></img><p></p></div><div class="col s12 m6 l4"><h2 id="soil-desiccation"><a href="../../../benchmarks/mud.html">Soil desiccation <i class="material-icons moose-inline-icon">link</i></a></h2><img src="../../../media/soil.gif" class="materialboxed moose-image" style="width:75%;float:left;padding-top:2.5%;"></img><p></p></div></div></div></div><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="https://hugary1995.github.io/raccoon/index.html" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href="../.." class="breadcrumb">modules</a><a href=".." class="breadcrumb">phase_field</a><span class="breadcrumb">FunctionMaterials</span><a href="#" class="breadcrumb">AutomaticDifferentiation</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="5d33eedc-2df0-4c8e-9b02-a64145cf9e2e" data-section-level="1" data-section-text="Automatic Differentiation"><h1 id="automatic-differentiation">Automatic Differentiation</h1><p>Automatic differentiation is a means to construct derivatives of a given expression in a symbolic way. Specifically this means _not_ performing finite differencing.  Derivatives show up the phase field evolution equations (commonly derivatives of both the free energy and the mobilities). Automatic differentiation shifts the burden of computing the derivatives of the oftentimes complex known expressions for the free energies from the user to the software.</p><p>The version of the _Function Parser_ library that ships with MOOSE contains an automatic differentiation feature that is not present in the <a href="http://warp.povusers.org/FunctionParser/">upstream version</a>.</p><p>Include the automatic differentiation module (which also adds <a href="JITCompile">just in time compilation</a> with</p><pre class="moose-pre"><code class="language-cpp">
#include &quot;libmesh/fparser_ad.hh&quot;
</code></pre><p>The module provides the class</p><pre class="moose-pre"><code class="language-cpp">
FunctionParserADBase&lt;Real&gt;
</code></pre><p>which derives from</p><pre class="moose-pre"><code class="language-cpp">
FunctionParserBase&lt;Real&gt;
</code></pre><p>and provides the additional method</p><pre class="moose-pre"><code class="language-cpp">
int AutoDiff(const std::string&amp; var);
</code></pre><p>where <code>var</code> is the name of the variable to take the derivative with respect to. The <code>AutoDiff</code> method must be called on an initialized and parsed (but not optimized) Function Parser object.</p><p>The automatic differentiation system transforms the compiled bytecode of the parsed function into the bytecode of the derivative. The <code>AutoDiff</code> method can be called multiple times to generate high order derivatives.</p><p>The helper method</p><pre class="moose-pre"><code class="language-cpp">
bool isZero();
</code></pre><p>can be called after optimizing the Function Parser object to check if the function is a constant zero (i.e. the bytecode consists only of a <code>push 0</code> command).</p><section class="scrollspy" id="997c737a-2051-4e93-a892-e69613acebf9" data-section-level="2" data-section-text="Limitations"><h2 id="limitations">Limitations</h2><p>Almost all FParser opcodes are supported, _except_ <code>PCall</code> and <code>FCall</code>, which are function calls to other FParser objects and calls to custom functions.</p><p>The automatic differentiation will currently complain when taking derivatives of functions that are not differentiable in a countable infinite number of points (such as <code>int()</code>), it will however take derivatives of functions like the absolute value <code>abs()</code> that are not differentiable in only a single point. This limitation is arbitrary and may be changed in future versions.</p><p>The current version of the AD module <em>does</em> support differentiating FParser objects that have been previously optimized.</p></section><section class="scrollspy" id="128da56c-665a-4ead-8c16-70a6a114a8ab" data-section-level="2" data-section-text="Example"><h2 id="example">Example</h2><p>The following code snippet illustrates how to compute and evaluate a derivative:</p><pre class="moose-pre"><code class="language-cpp">
FunctionParserADBase&lt;Real&gt; fparser;
std::string func = &quot;sin(a*x)+x^2*(3+sin(3*x))+a&quot;;

// Parse the input expression into bytecode
fparser.Parse(func, &quot;x,a&quot;);

// transform F -&gt; dF/dx
fparser.AutoDiff(&quot;x&quot;);

// run optimizer to simplify the derivative
fparser.Optimize();

// evaluate the derivative (method from FParserBase&lt;Real&gt;)
Real params[2] = {0.1, 1.7};
std::cout &lt;&lt; fparser.Eval(params) &lt;&lt; std::endl;

// print byte code of the derivative (needs debugging enabled)
fparser.PrintByteCode(std::cout);
</code></pre><p>Not that optimizing the FParser object using <code>.Optimize()</code> after taking the derivative is <em>highly</em> recommended, as the automatic differentiation generates lots of trivial terms. For example the derivative of <code>2*x</code> is <code>0*x+2*1</code>, which will be optimized to <code>2</code>.</p></section><section class="scrollspy" id="b4a280f3-2c21-4743-b461-ba044f0dda0a" data-section-level="2" data-section-text="Performance considerations"><h2 id="performance-considerations">Performance considerations</h2><p>The convenience of parsed and automatically differentiated functions does come with a performance penalty. Despite optimizations the parsed functions are slower than hand coded and compiled functions.</p><p>JIT (Just In Time) compilation is available for parsed functions. The JIT system is utilized by adding the <code>enable_jit = true</code> (default) option in the <a href="../../../source/materials/DerivativeParsedMaterial.html"><code>DerivativeParsedMaterial</code></a> block. MOOSE will then attempt to compile the functions and its derivatives into machine code and use it for the residual and Jacobian calculations. This almost fully recovers the performance of hand coded free energies while retaining the flexibility of automatic differentiation.</p></section><section class="scrollspy" id="58e53bf5-c5fb-4db6-a4be-91587129e210" data-section-level="2" data-section-text="See also"><h2 id="see-also">See also</h2><ul class="browser-default"><li><p><a href="ExpressionBuilder.html">ExpressionBuilder</a> - building FParser expressions at compile time using operator overloading</p></li></ul></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#997c737a-2051-4e93-a892-e69613acebf9" class="tooltipped" data-position="left" data-tooltip="Limitations">Limitations</a></li><li><a href="#128da56c-665a-4ead-8c16-70a6a114a8ab" class="tooltipped" data-position="left" data-tooltip="Example">Example</a></li><li><a href="#b4a280f3-2c21-4743-b461-ba044f0dda0a" class="tooltipped" data-position="left" data-tooltip="Performance considerations">Performance considerations</a></li><li><a href="#58e53bf5-c5fb-4db6-a4be-91587129e210" class="tooltipped" data-position="left" data-tooltip="See also">See also</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../../js/init.js"></script><script type="text/javascript" src="../../../js/navigation.js"></script><script type="text/javascript" src="../../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../../js/search_index.js"></script>
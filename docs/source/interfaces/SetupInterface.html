<!DOCTYPE html><head><meta charset="UTF-8"><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script><title>SetupInterface execute on|RACCOON</title></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://hugary1995.github.io/raccoon" class="left moose-logo hide-on-med-and-down">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../install/index.html">Install</a></li><li><a href="../../examples/index.html">Examples</a></li><li><a href="../../theory/index.html">Theory</a></li><li><a href="../../documentation/index.html">Documentation</a></li></ul><a href="#" class="sidenav-trigger" data-target="035f607e-8a4f-4d86-8e79-62fb83bb54c6"><i class="material-icons">menu</i></a><ul class="sidenav" id="035f607e-8a4f-4d86-8e79-62fb83bb54c6"><li><a href="../../install/index.html">Install</a></li><li><a href="../../examples/index.html">Examples</a></li><li><a href="../../theory/index.html">Theory</a></li><li><a href="../../documentation/index.html">Documentation</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="https://hugary1995.github.io/raccoon" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">interfaces</span><a href="#" class="breadcrumb">SetupInterface</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="b98c35a2-20f7-41f0-be62-24b2ac9fb238" data-section-level="1" data-section-text="SetupInterface ( execute _ on )"><h1 id="setupinterface-execute-on">SetupInterface (execute_on)</h1><p>Most user-facing objects in MOOSE inherit from the SetupInterface class. This class provides two features to objects. Foremost, it provides the the &quot;execute_on&quot; parameter, which, as the name suggests, dictates when the object is to be executed. Secondly, it adds virtual setup methods that allow derived classes to perform setup applications prior to execution.</p><section class="scrollspy" id="2c5d8efa-1095-45c7-babd-d90cc9487f4a" data-section-level="2" data-section-text="Execute On"><h2 id="execute-on">Execute On</h2><p>Any object inheriting from the SetupInterface, that adds the <code>validParams&lt;SetupInterface&gt;</code> within its own parameters, will have an &quot;execute_on&quot; parameter that can be set to various flags, the most common flags are listed below.</p><div form="['left', 'left']" recursive="True" class="moose-table-div"><table><thead><tr><th style=";text-align:left">Execute Flag</th><th style=";text-align:left">Description</th></tr></thead><tbody><tr><td style=";text-align:left">INITIAL</td><td style=";text-align:left">Prior to the first time step.</td></tr></tbody><tbody><tr><td style=";text-align:left">TIMESTEP_BEGIN</td><td style=";text-align:left">Prior to the solve for each time step.</td></tr></tbody><tbody><tr><td style=";text-align:left">NONLINEAR</td><td style=";text-align:left">Prior do each non-linear iteration during the solve.</td></tr></tbody><tbody><tr><td style=";text-align:left">LINEAR</td><td style=";text-align:left">Prior do each linear iteration during the solve.</td></tr></tbody><tbody><tr><td style=";text-align:left">TIMESTEP_END</td><td style=";text-align:left">After the solve for each time step.</td></tr></tbody><tbody><tr><td style=";text-align:left">SUBDOMAIN</td><td style=";text-align:left">Executes when the subdomain (i.e., &quot;blocks&quot;) change during calculations.</td></tr></tbody></table></div><p>The &quot;execute_on&quot; parameter can be set to a single flag or multiple flags. For example, it may be desirable to only execute an object initially because the state of the auxiliary computation does not vary. In the input file snippet below, the <a href="../auxkernels/ElementLengthAux.html">ElementLengthAux</a> computation only needs to be computed initially, thus the &quot;exeucte_on&quot; parameter is set as such.</p><pre class="moose-pre"><code class="language-text">[AuxKernels]
  [./min]
    type = ElementLengthAux
    variable = min
    method = min
    execute_on = initial
  [../]
  [./max]
    type = ElementLengthAux
    variable = max
    method = max
    execute_on = initial
  [../]
[../]
</code></pre><a href="#7b99366d-e3e1-4c27-9adc-2911441bbbbd" class="modal-trigger">(../moose/test/tests/auxkernels/element_length/element_length.i)</a><div class="modal moose-modal" id="7b99366d-e3e1-4c27-9adc-2911441bbbbd"><div class="modal-content"><h4>/home/gary/projects/moose/test/tests/auxkernels/element_length/element_length.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 100
[]

[AuxVariables]
  [./min]
  [../]
  [./max]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./min]
    type = ElementLengthAux
    variable = min
    method = min
    execute_on = initial
  [../]
  [./max]
    type = ElementLengthAux
    variable = max
    method = max
    execute_on = initial
  [../]
[../]

[Problem]
  type = FEProblem
  solve = false
[]

[Executioner]
  type = Steady
[]

[Outputs]
  execute_on = &#x27;TIMESTEP_END&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>Alternatively, it is often desirable to run a computation with multiple execute flags. For example, in the input file snippet below a <a href="../controls/TimePeriod.html">TimePeriod</a> control object that is responsible for enabling in <a href="../../syntax/Dampers/index.html">Damper</a> object needs to be run initially and prior to each timestep to guarantee that the damper is enabled when desired.</p><pre class="moose-pre"><code class="language-text">[Controls]
  [./damping_control]
    type = TimePeriod
    disable_objects = &#x27;*::const_damp&#x27;
    start_time = 0.25
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]
</code></pre><a href="#16f39f22-97bc-479a-9b4b-f1142606ffbb" class="modal-trigger">(../moose/test/tests/controls/time_periods/dampers/control.i)</a><div class="modal moose-modal" id="16f39f22-97bc-479a-9b4b-f1142606ffbb"><div class="modal-content"><h4>/home/gary/projects/moose/test/tests/controls/time_periods/dampers/control.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = CoefDiffusion
    variable = u
    coef = 0.1
  [../]
  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  nl_rel_tol = 0.95e-8
[]

[Postprocessors]
  [./nlin]
    type = NumNonlinearIterations
  [../]
[]

[Dampers]
  [./const_damp]
    type = ConstantDamper
    damping = 0.9
  [../]
[]

[Outputs]
  csv = true
[]

[Controls]
  [./damping_control]
    type = TimePeriod
    disable_objects = &#x27;*::const_damp&#x27;
    start_time = 0.25
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>Depending on the system these options or others will be available, since as discussed in <a href="#creating-custom-execute-flags">Creating Custom Execute Flags</a> custom flags may be added. The complete list of execution flags is provided by MOOSE are listed in the &quot;registerExecFlags&quot; function.</p><pre class="moose-pre"><code class="language-cpp">
#ifdef HAVE_GPERFTOOLS
#include &quot;gperftools/profiler.h&quot;
#endif

// MOOSE includes
#include &quot;MooseRevision.h&quot;
#include &quot;AppFactory.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;NonlinearSystemBase.h&quot;
#include &quot;AuxiliarySystem.h&quot;
#include &quot;MooseSyntax.h&quot;
#include &quot;MooseInit.h&quot;
#include &quot;Executioner.h&quot;
#include &quot;PetscSupport.h&quot;
#include &quot;Conversion.h&quot;
#include &quot;CommandLine.h&quot;
#include &quot;InfixIterator.h&quot;
#include &quot;MultiApp.h&quot;
#include &quot;MeshModifier.h&quot;
#include &quot;MeshGenerator.h&quot;
#include &quot;DependencyResolver.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseObjectAction.h&quot;
#include &quot;InputParameterWarehouse.h&quot;
#include &quot;SystemInfo.h&quot;
#include &quot;RestartableDataIO.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;FileOutput.h&quot;
#include &quot;ConsoleUtils.h&quot;
#include &quot;JsonSyntaxTree.h&quot;
#include &quot;JsonInputFileFormatter.h&quot;
#include &quot;SONDefinitionFormatter.h&quot;
#include &quot;RelationshipManager.h&quot;
#include &quot;Registry.h&quot;
#include &quot;SerializerGuard.h&quot;
#include &quot;PerfGraphInterface.h&quot; // For TIME_SECTIOn
#include &quot;Attributes.h&quot;
#include &quot;MooseApp.h&quot;

// Regular expression includes
#include &quot;pcrecpp.h&quot;

#include &quot;libmesh/exodusII_io.h&quot;
#include &quot;libmesh/mesh_refinement.h&quot;
#include &quot;libmesh/string_to_enum.h&quot;
#include &quot;libmesh/checkpoint_io.h&quot;
#include &quot;libmesh/mesh_base.h&quot;

// System include for dynamic library methods
#include &lt;dlfcn.h&gt;
#include &lt;sys/utsname.h&gt; // utsname

// C++ includes
#include &lt;numeric&gt; // std::accumulate
#include &lt;fstream&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstdlib&gt; // for system()
#include &lt;chrono&gt;
#include &lt;thread&gt;

#define QUOTE(macro) stringifyName(macro)

defineLegacyParams(MooseApp);

InputParameters
MooseApp::validParams()
{
  InputParameters params = emptyInputParameters();

  params.addCommandLineParam&lt;bool&gt;(
      &quot;display_version&quot;, &quot;-v --version&quot;, false, &quot;Print application version&quot;);
  params.addCommandLineParam&lt;std::string&gt;(&quot;input_file&quot;, &quot;-i &lt;input_file&gt;&quot;, &quot;Specify an input file&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;mesh_only&quot;,
      &quot;--mesh-only [mesh_file_name]&quot;,
      &quot;Setup and Output the input mesh only (Default: \&quot;&lt;input_file_name&gt;_in.e\&quot;)&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;show_input&quot;,
                                   &quot;--show-input&quot;,
                                   false,
                                   &quot;Shows the parsed input file before running the simulation.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_outputs&quot;, &quot;--show-outputs&quot;, false, &quot;Shows the output execution time information.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_controls&quot;, &quot;--show-controls&quot;, false, &quot;Shows the Control logic available and executed.&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;no_color&quot;, &quot;--no-color&quot;, false, &quot;Disable coloring of all Console outputs.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(&quot;color&quot;,
                                          &quot;--color [auto,on,off]&quot;,
                                          &quot;default-on&quot;,
                                          &quot;Whether to use color in console output (default &#x27;on&#x27;).&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;help&quot;, &quot;-h --help&quot;, false, &quot;Displays CLI usage statement.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;minimal&quot;,
      &quot;--minimal&quot;,
      false,
      &quot;Ignore input file and build a minimal application with Transient executioner.&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;definition&quot;, &quot;--definition&quot;, &quot;Shows a SON style input definition dump for input validation&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;dump&quot;, &quot;--dump [search_string]&quot;, &quot;Shows a dump of available input file syntax.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;registry&quot;, &quot;--registry&quot;, &quot;Lists all known objects and actions.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;registry_hit&quot;, &quot;--registry-hit&quot;, &quot;Lists all known objects and actions in hit format.&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;apptype&quot;, &quot;--type&quot;, false, &quot;Return the name of the application object.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;yaml&quot;, &quot;--yaml&quot;, &quot;Dumps input file syntax in YAML format.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;json&quot;, &quot;--json&quot;, &quot;Dumps input file syntax in JSON format.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;syntax&quot;, &quot;--syntax&quot;, false, &quot;Dumps the associated Action syntax paths ONLY&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;check_input&quot;,
                                   &quot;--check-input&quot;,
                                   false,
                                   &quot;Check the input file (i.e. requires -i &lt;filename&gt;) and quit.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;list_constructed_objects&quot;,
      &quot;--list-constructed-objects&quot;,
      false,
      &quot;List all moose object type names constructed by the master app factory.&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;n_threads&quot;, &quot;--n-threads=&lt;n&gt;&quot;, 1, &quot;Runs the specified number of threads per process&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;warn_unused&quot;, &quot;-w --warn-unused&quot;, false, &quot;Warn about unused input file options&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;error_unused&quot;,
                                   &quot;-e --error-unused&quot;,
                                   false,
                                   &quot;Error when encountering unused input file options&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_override&quot;,
      &quot;-o --error-override&quot;,
      false,
      &quot;Error when encountering overridden or parameters supplied multiple times&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_deprecated&quot;, &quot;--error-deprecated&quot;, false, &quot;Turn deprecated code messages into Errors&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;distributed_mesh&quot;,
      &quot;--distributed-mesh&quot;,
      false,
      &quot;The libMesh Mesh underlying MooseMesh should always be a DistributedMesh&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;split_mesh&quot;,
      &quot;--split-mesh [splits]&quot;,
      &quot;comma-separated list of numbers of chunks to split the mesh into&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;split_file&quot;,
                                          &quot;--split-file [filename]&quot;,
                                          &quot;&quot;,
                                          &quot;optional name of split mesh file(s) to write/read&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;use_split&quot;, &quot;--use-split&quot;, false, &quot;use split distributed mesh files&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;refinements&quot;,
      &quot;-r &lt;n&gt;&quot;,
      0,
      &quot;Specify additional initial uniform refinements for automatic scaling&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;recover&quot;,
                                          &quot;--recover [file_base]&quot;,
                                          &quot;Continue the calculation.  If file_base is omitted then &quot;
                                          &quot;the most recent recovery file will be utilized&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;recoversuffix&quot;,
                                          &quot;--recoversuffix [suffix]&quot;,
                                          &quot;Use a different file extension, other than cpr, &quot;
                                          &quot;for a recovery file&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;half_transient&quot;,
                                   &quot;--half-transient&quot;,
                                   false,
                                   &quot;When true the simulation will only run half of &quot;
                                   &quot;its specified transient (ie half the &quot;
                                   &quot;timesteps).  This is useful for testing &quot;
                                   &quot;recovery and restart&quot;);

  // No default on these two options, they must not both be valid
  params.addCommandLineParam&lt;bool&gt;(
      &quot;trap_fpe&quot;,
      &quot;--trap-fpe&quot;,
      &quot;Enable Floating Point Exception handling in critical sections of &quot;
      &quot;code.  This is enabled automatically in DEBUG mode&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;no_trap_fpe&quot;,
                                   &quot;--no-trap-fpe&quot;,
                                   &quot;Disable Floating Point Exception handling in critical &quot;
                                   &quot;sections of code when using DEBUG mode.&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;error&quot;, &quot;--error&quot;, false, &quot;Turn all warnings into errors&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;timing&quot;,
      &quot;-t --timing&quot;,
      false,
      &quot;Enable all performance logging for timing purposes. This will disable all &quot;
      &quot;screen output of performance logs for all Console objects.&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;no_timing&quot;,
                                   &quot;--no-timing&quot;,
                                   false,
                                   &quot;Disabled performance logging. Overrides -t or --timing &quot;
                                   &quot;if passed in conjunction with this flag&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;allow_test_objects&quot;, &quot;--allow-test-objects&quot;, false, &quot;Register test objects and syntax.&quot;);

  // Options ignored by MOOSE but picked up by libMesh, these are here so that they are displayed in
  // the application help
  params.addCommandLineParam&lt;bool&gt;(
      &quot;keep_cout&quot;,
      &quot;--keep-cout&quot;,
      false,
      &quot;Keep standard output from all processors when running in parallel&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;redirect_stdout&quot;,
      &quot;--redirect-stdout&quot;,
      false,
      &quot;Keep standard output from all processors when running in parallel&quot;);

  // Options for debugging
  params.addCommandLineParam&lt;std::string&gt;(&quot;start_in_debugger&quot;,
                                          &quot;--start-in-debugger &lt;debugger&gt;&quot;,
                                          &quot;Start the application and attach a debugger.  This will &quot;
                                          &quot;launch xterm windows using the command you specify for &quot;
                                          &quot;&#x27;debugger&#x27;&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;,
                                           &quot;--stop-for-debugger [seconds]&quot;,
                                           30,
                                           &quot;Pauses the application during startup for the &quot;
                                           &quot;specified time to allow for connection of debuggers.&quot;);
  params.addParam&lt;bool&gt;(
      &quot;automatic_automatic_scaling&quot;, false, &quot;Whether to turn on automatic scaling by default.&quot;);

  params.addPrivateParam&lt;std::string&gt;(&quot;_app_name&quot;); // the name passed to AppFactory::create
  params.addPrivateParam&lt;std::string&gt;(&quot;_type&quot;);
  params.addPrivateParam&lt;int&gt;(&quot;_argc&quot;);
  params.addPrivateParam&lt;char **&gt;(&quot;_argv&quot;);
  params.addPrivateParam&lt;std::shared_ptr&lt;CommandLine&gt;&gt;(&quot;_command_line&quot;);
  params.addPrivateParam&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(&quot;_comm&quot;);
  params.addPrivateParam&lt;unsigned int&gt;(&quot;_multiapp_level&quot;);
  params.addPrivateParam&lt;unsigned int&gt;(&quot;_multiapp_number&quot;);
  params.addPrivateParam&lt;const MooseMesh *&gt;(&quot;_master_mesh&quot;);
  params.addPrivateParam&lt;const MooseMesh *&gt;(&quot;_master_displaced_mesh&quot;);

  return params;
}

MooseApp::MooseApp(InputParameters parameters)
  : ConsoleStreamInterface(*this),
    ParallelObject(*parameters.get&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(
        &quot;_comm&quot;)), // Can&#x27;t call getParam() before pars is set
    _name(parameters.get&lt;std::string&gt;(&quot;_app_name&quot;)),
    _pars(parameters),
    _type(getParam&lt;std::string&gt;(&quot;_type&quot;)),
    _comm(getParam&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(&quot;_comm&quot;)),
    _perf_graph(type() + &quot; (&quot; + name() + &#x27;)&#x27;),
    _rank_map(*_comm, _perf_graph),
    _file_base_set_by_user(false),
    _output_position_set(false),
    _start_time_set(false),
    _start_time(0.0),
    _global_time_offset(0.0),
    _output_warehouse(*this),
    _input_parameter_warehouse(new InputParameterWarehouse()),
    _action_factory(*this),
    _action_warehouse(*this, _syntax, _action_factory),
    _parser(*this, _action_warehouse),
    _use_nonlinear(true),
    _use_eigen_value(false),
    _enable_unused_check(WARN_UNUSED),
    _factory(*this),
    _error_overridden(false),
    _ready_to_exit(false),
    _initial_from_file(false),
    _distributed_mesh_on_command_line(false),
    _recover(false),
    _restart(false),
    _split_mesh(false),
    _use_split(parameters.get&lt;bool&gt;(&quot;use_split&quot;)),
#ifdef DEBUG
    _trap_fpe(true),
#else
    _trap_fpe(false),
#endif
    _restart_recover_suffix(&quot;cpr&quot;),
    _half_transient(false),
    _check_input(getParam&lt;bool&gt;(&quot;check_input&quot;)),
    _restartable_data(libMesh::n_threads()),
    _multiapp_level(
        isParamValid(&quot;_multiapp_level&quot;) ? parameters.get&lt;unsigned int&gt;(&quot;_multiapp_level&quot;) : 0),
    _multiapp_number(
        isParamValid(&quot;_multiapp_number&quot;) ? parameters.get&lt;unsigned int&gt;(&quot;_multiapp_number&quot;) : 0),
    _master_mesh(isParamValid(&quot;_master_mesh&quot;) ? parameters.get&lt;const MooseMesh *&gt;(&quot;_master_mesh&quot;)
                                              : nullptr),
    _master_displaced_mesh(isParamValid(&quot;_master_displaced_mesh&quot;)
                               ? parameters.get&lt;const MooseMesh *&gt;(&quot;_master_displaced_mesh&quot;)
                               : nullptr),
    _setup_timer(_perf_graph.registerSection(&quot;MooseApp::setup&quot;, 2)),
    _setup_options_timer(_perf_graph.registerSection(&quot;MooseApp::setupOptions&quot;, 5)),
    _run_input_file_timer(_perf_graph.registerSection(&quot;MooseApp::runInputFile&quot;, 3)),
    _execute_timer(_perf_graph.registerSection(&quot;MooseApp::execute&quot;, 2)),
    _execute_executioner_timer(_perf_graph.registerSection(&quot;MooseApp::executeExecutioner&quot;, 3)),
    _restore_timer(_perf_graph.registerSection(&quot;MooseApp::restore&quot;, 2)),
    _run_timer(_perf_graph.registerSection(&quot;MooseApp::run&quot;, 3)),
    _execute_mesh_modifiers_timer(_perf_graph.registerSection(&quot;MooseApp::executeMeshModifiers&quot;, 1)),
    _execute_mesh_generators_timer(
        _perf_graph.registerSection(&quot;MooseApp::executeMeshGenerators&quot;, 1)),
    _restore_cached_backup_timer(_perf_graph.registerSection(&quot;MooseApp::restoreCachedBackup&quot;, 2)),
    _create_minimal_app_timer(_perf_graph.registerSection(&quot;MooseApp::createMinimalApp&quot;, 3)),
    _automatic_automatic_scaling(getParam&lt;bool&gt;(&quot;automatic_automatic_scaling&quot;)),
    _popped_final_mesh_generator(false)
{
#ifdef HAVE_GPERFTOOLS
  if (std::getenv(&quot;MOOSE_PROFILE_BASE&quot;))
  {
    static std::string profile_file =
        std::getenv(&quot;MOOSE_PROFILE_BASE&quot;) + std::to_string(_comm-&gt;rank()) + &quot;.prof&quot;;
    _profiling = true;
    ProfilerStart(profile_file.c_str());
  }
#endif

  Registry::addKnownLabel(_type);
  Moose::registerAll(_factory, _action_factory, _syntax);

  _the_warehouse = libmesh_make_unique&lt;TheWarehouse&gt;();
  _the_warehouse-&gt;registerAttribute&lt;AttribMatrixTags&gt;(&quot;matrix_tags&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribVectorTags&gt;(&quot;vector_tags&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribExecOns&gt;(&quot;exec_ons&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribSubdomains&gt;(&quot;subdomains&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribBoundaries&gt;(&quot;boundaries&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribThread&gt;(&quot;thread&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribPreIC&gt;(&quot;pre_ic&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribPreAux&gt;(&quot;pre_aux&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribName&gt;(&quot;name&quot;, &quot;dummy&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribSystem&gt;(&quot;system&quot;, &quot;dummy&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribVar&gt;(&quot;variable&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribInterfaces&gt;(&quot;interfaces&quot;, 0);

  if (isParamValid(&quot;_argc&quot;) &amp;&amp; isParamValid(&quot;_argv&quot;))
  {
    int argc = getParam&lt;int&gt;(&quot;_argc&quot;);
    char ** argv = getParam&lt;char **&gt;(&quot;_argv&quot;);

    _sys_info = libmesh_make_unique&lt;SystemInfo&gt;(argc, argv);
  }
  if (isParamValid(&quot;_command_line&quot;))
    _command_line = getParam&lt;std::shared_ptr&lt;CommandLine&gt;&gt;(&quot;_command_line&quot;);
  else
    mooseError(&quot;Valid CommandLine object required&quot;);

  if (_check_input &amp;&amp; isParamValid(&quot;recover&quot;))
    mooseError(&quot;Cannot run --check-input with --recover. Recover files might not exist&quot;);

  if (isParamValid(&quot;start_in_debugger&quot;) &amp;&amp; _multiapp_level == 0)
  {
    auto command = getParam&lt;std::string&gt;(&quot;start_in_debugger&quot;);

    Moose::out &lt;&lt; &quot;Starting in debugger using: &quot; &lt;&lt; command &lt;&lt; std::endl;

    auto hostname = MooseUtils::hostname();

    std::stringstream command_stream;

    // This will start XTerm and print out some info first... then run the debugger
    command_stream &lt;&lt; &quot;xterm -e \&quot;echo &#x27;Rank: &quot; &lt;&lt; processor_id() &lt;&lt; &quot;  Hostname: &quot; &lt;&lt; hostname
                   &lt;&lt; &quot;  PID: &quot; &lt;&lt; getpid() &lt;&lt; &quot;&#x27;; echo &#x27;&#x27;; &quot;;

    // Figure out how to run the debugger
    if (command.find(&quot;lldb&quot;) != std::string::npos || command.find(&quot;gdb&quot;) != std::string::npos)
      command_stream &lt;&lt; command &lt;&lt; &quot; -p &quot; &lt;&lt; getpid();
    else
      mooseError(&quot;Unknown debugger: &quot;,
                 command,
                 &quot;\nIf this is truly what you meant then contact moose-users to have a discussion &quot;
                 &quot;about adding your debugger.&quot;);

    // Finish up the command
    command_stream &lt;&lt; &quot;\&quot;&quot;
                   &lt;&lt; &quot; &amp; &quot;;

    std::string command_string = command_stream.str();
    Moose::out &lt;&lt; &quot;Running: &quot; &lt;&lt; command_string &lt;&lt; std::endl;

    int ret = std::system(command_string.c_str());
    libmesh_ignore(ret);

    // Sleep to allow time for the debugger to attach
    std::this_thread::sleep_for(std::chrono::seconds(10));
  }

  if (!parameters.isParamSetByAddParam(&quot;stop_for_debugger&quot;))
  {
    Moose::out &lt;&lt; &quot;\nStopping for &quot; &lt;&lt; getParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;)
               &lt;&lt; &quot; seconds to allow attachment from a debugger.\n&quot;;

    Moose::out &lt;&lt; &quot;\nAll of the processes you can connect to:\n&quot;;
    Moose::out &lt;&lt; &quot;rank - hostname - pid\n&quot;;

    auto hostname = MooseUtils::hostname();

    {
      // The &#x27;false&#x27; turns off the serialization warning
      SerializerGuard sg(_communicator, false); // Guarantees that the processors print in order
      Moose::err &lt;&lt; processor_id() &lt;&lt; &quot; - &quot; &lt;&lt; hostname &lt;&lt; &quot; - &quot; &lt;&lt; getpid() &lt;&lt; &quot;\n&quot;;
    }

    Moose::out &lt;&lt; &quot;\nWaiting...\n&quot; &lt;&lt; std::endl;

    // Sleep to allow time for the debugger to attach
    std::this_thread::sleep_for(std::chrono::seconds(getParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;)));
  }

  if (_master_mesh &amp;&amp; _multiapp_level == 0)
    mooseError(&quot;Mesh can be passed in only for sub-apps&quot;);

  if (_master_displaced_mesh &amp;&amp; !_master_mesh)
    mooseError(&quot;_master_mesh should have been set when _master_displaced_mesh is set&quot;);
}
</code></pre><a href="#a769577b-a52a-4874-96f2-e8bcfc36943d" class="modal-trigger">(../moose/framework/src/base/MooseApp.C)</a><div class="modal moose-modal" id="a769577b-a52a-4874-96f2-e8bcfc36943d"><div class="modal-content"><h4>/home/gary/projects/moose/framework/src/base/MooseApp.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#ifdef HAVE_GPERFTOOLS
#include &quot;gperftools/profiler.h&quot;
#endif

// MOOSE includes
#include &quot;MooseRevision.h&quot;
#include &quot;AppFactory.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;NonlinearSystemBase.h&quot;
#include &quot;AuxiliarySystem.h&quot;
#include &quot;MooseSyntax.h&quot;
#include &quot;MooseInit.h&quot;
#include &quot;Executioner.h&quot;
#include &quot;PetscSupport.h&quot;
#include &quot;Conversion.h&quot;
#include &quot;CommandLine.h&quot;
#include &quot;InfixIterator.h&quot;
#include &quot;MultiApp.h&quot;
#include &quot;MeshModifier.h&quot;
#include &quot;MeshGenerator.h&quot;
#include &quot;DependencyResolver.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseObjectAction.h&quot;
#include &quot;InputParameterWarehouse.h&quot;
#include &quot;SystemInfo.h&quot;
#include &quot;RestartableDataIO.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;FileOutput.h&quot;
#include &quot;ConsoleUtils.h&quot;
#include &quot;JsonSyntaxTree.h&quot;
#include &quot;JsonInputFileFormatter.h&quot;
#include &quot;SONDefinitionFormatter.h&quot;
#include &quot;RelationshipManager.h&quot;
#include &quot;Registry.h&quot;
#include &quot;SerializerGuard.h&quot;
#include &quot;PerfGraphInterface.h&quot; // For TIME_SECTIOn
#include &quot;Attributes.h&quot;
#include &quot;MooseApp.h&quot;

// Regular expression includes
#include &quot;pcrecpp.h&quot;

#include &quot;libmesh/exodusII_io.h&quot;
#include &quot;libmesh/mesh_refinement.h&quot;
#include &quot;libmesh/string_to_enum.h&quot;
#include &quot;libmesh/checkpoint_io.h&quot;
#include &quot;libmesh/mesh_base.h&quot;

// System include for dynamic library methods
#include &lt;dlfcn.h&gt;
#include &lt;sys/utsname.h&gt; // utsname

// C++ includes
#include &lt;numeric&gt; // std::accumulate
#include &lt;fstream&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstdlib&gt; // for system()
#include &lt;chrono&gt;
#include &lt;thread&gt;

#define QUOTE(macro) stringifyName(macro)

defineLegacyParams(MooseApp);

InputParameters
MooseApp::validParams()
{
  InputParameters params = emptyInputParameters();

  params.addCommandLineParam&lt;bool&gt;(
      &quot;display_version&quot;, &quot;-v --version&quot;, false, &quot;Print application version&quot;);
  params.addCommandLineParam&lt;std::string&gt;(&quot;input_file&quot;, &quot;-i &lt;input_file&gt;&quot;, &quot;Specify an input file&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;mesh_only&quot;,
      &quot;--mesh-only [mesh_file_name]&quot;,
      &quot;Setup and Output the input mesh only (Default: \&quot;&lt;input_file_name&gt;_in.e\&quot;)&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;show_input&quot;,
                                   &quot;--show-input&quot;,
                                   false,
                                   &quot;Shows the parsed input file before running the simulation.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_outputs&quot;, &quot;--show-outputs&quot;, false, &quot;Shows the output execution time information.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_controls&quot;, &quot;--show-controls&quot;, false, &quot;Shows the Control logic available and executed.&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;no_color&quot;, &quot;--no-color&quot;, false, &quot;Disable coloring of all Console outputs.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(&quot;color&quot;,
                                          &quot;--color [auto,on,off]&quot;,
                                          &quot;default-on&quot;,
                                          &quot;Whether to use color in console output (default &#x27;on&#x27;).&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;help&quot;, &quot;-h --help&quot;, false, &quot;Displays CLI usage statement.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;minimal&quot;,
      &quot;--minimal&quot;,
      false,
      &quot;Ignore input file and build a minimal application with Transient executioner.&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;definition&quot;, &quot;--definition&quot;, &quot;Shows a SON style input definition dump for input validation&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;dump&quot;, &quot;--dump [search_string]&quot;, &quot;Shows a dump of available input file syntax.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;registry&quot;, &quot;--registry&quot;, &quot;Lists all known objects and actions.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;registry_hit&quot;, &quot;--registry-hit&quot;, &quot;Lists all known objects and actions in hit format.&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;apptype&quot;, &quot;--type&quot;, false, &quot;Return the name of the application object.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;yaml&quot;, &quot;--yaml&quot;, &quot;Dumps input file syntax in YAML format.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;json&quot;, &quot;--json&quot;, &quot;Dumps input file syntax in JSON format.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;syntax&quot;, &quot;--syntax&quot;, false, &quot;Dumps the associated Action syntax paths ONLY&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;check_input&quot;,
                                   &quot;--check-input&quot;,
                                   false,
                                   &quot;Check the input file (i.e. requires -i &lt;filename&gt;) and quit.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;list_constructed_objects&quot;,
      &quot;--list-constructed-objects&quot;,
      false,
      &quot;List all moose object type names constructed by the master app factory.&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;n_threads&quot;, &quot;--n-threads=&lt;n&gt;&quot;, 1, &quot;Runs the specified number of threads per process&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;warn_unused&quot;, &quot;-w --warn-unused&quot;, false, &quot;Warn about unused input file options&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;error_unused&quot;,
                                   &quot;-e --error-unused&quot;,
                                   false,
                                   &quot;Error when encountering unused input file options&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_override&quot;,
      &quot;-o --error-override&quot;,
      false,
      &quot;Error when encountering overridden or parameters supplied multiple times&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_deprecated&quot;, &quot;--error-deprecated&quot;, false, &quot;Turn deprecated code messages into Errors&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;distributed_mesh&quot;,
      &quot;--distributed-mesh&quot;,
      false,
      &quot;The libMesh Mesh underlying MooseMesh should always be a DistributedMesh&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;split_mesh&quot;,
      &quot;--split-mesh [splits]&quot;,
      &quot;comma-separated list of numbers of chunks to split the mesh into&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;split_file&quot;,
                                          &quot;--split-file [filename]&quot;,
                                          &quot;&quot;,
                                          &quot;optional name of split mesh file(s) to write/read&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;use_split&quot;, &quot;--use-split&quot;, false, &quot;use split distributed mesh files&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;refinements&quot;,
      &quot;-r &lt;n&gt;&quot;,
      0,
      &quot;Specify additional initial uniform refinements for automatic scaling&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;recover&quot;,
                                          &quot;--recover [file_base]&quot;,
                                          &quot;Continue the calculation.  If file_base is omitted then &quot;
                                          &quot;the most recent recovery file will be utilized&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;recoversuffix&quot;,
                                          &quot;--recoversuffix [suffix]&quot;,
                                          &quot;Use a different file extension, other than cpr, &quot;
                                          &quot;for a recovery file&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;half_transient&quot;,
                                   &quot;--half-transient&quot;,
                                   false,
                                   &quot;When true the simulation will only run half of &quot;
                                   &quot;its specified transient (ie half the &quot;
                                   &quot;timesteps).  This is useful for testing &quot;
                                   &quot;recovery and restart&quot;);

  // No default on these two options, they must not both be valid
  params.addCommandLineParam&lt;bool&gt;(
      &quot;trap_fpe&quot;,
      &quot;--trap-fpe&quot;,
      &quot;Enable Floating Point Exception handling in critical sections of &quot;
      &quot;code.  This is enabled automatically in DEBUG mode&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;no_trap_fpe&quot;,
                                   &quot;--no-trap-fpe&quot;,
                                   &quot;Disable Floating Point Exception handling in critical &quot;
                                   &quot;sections of code when using DEBUG mode.&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;error&quot;, &quot;--error&quot;, false, &quot;Turn all warnings into errors&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;timing&quot;,
      &quot;-t --timing&quot;,
      false,
      &quot;Enable all performance logging for timing purposes. This will disable all &quot;
      &quot;screen output of performance logs for all Console objects.&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;no_timing&quot;,
                                   &quot;--no-timing&quot;,
                                   false,
                                   &quot;Disabled performance logging. Overrides -t or --timing &quot;
                                   &quot;if passed in conjunction with this flag&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;allow_test_objects&quot;, &quot;--allow-test-objects&quot;, false, &quot;Register test objects and syntax.&quot;);

  // Options ignored by MOOSE but picked up by libMesh, these are here so that they are displayed in
  // the application help
  params.addCommandLineParam&lt;bool&gt;(
      &quot;keep_cout&quot;,
      &quot;--keep-cout&quot;,
      false,
      &quot;Keep standard output from all processors when running in parallel&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;redirect_stdout&quot;,
      &quot;--redirect-stdout&quot;,
      false,
      &quot;Keep standard output from all processors when running in parallel&quot;);

  // Options for debugging
  params.addCommandLineParam&lt;std::string&gt;(&quot;start_in_debugger&quot;,
                                          &quot;--start-in-debugger &lt;debugger&gt;&quot;,
                                          &quot;Start the application and attach a debugger.  This will &quot;
                                          &quot;launch xterm windows using the command you specify for &quot;
                                          &quot;&#x27;debugger&#x27;&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;,
                                           &quot;--stop-for-debugger [seconds]&quot;,
                                           30,
                                           &quot;Pauses the application during startup for the &quot;
                                           &quot;specified time to allow for connection of debuggers.&quot;);
  params.addParam&lt;bool&gt;(
      &quot;automatic_automatic_scaling&quot;, false, &quot;Whether to turn on automatic scaling by default.&quot;);

  params.addPrivateParam&lt;std::string&gt;(&quot;_app_name&quot;); // the name passed to AppFactory::create
  params.addPrivateParam&lt;std::string&gt;(&quot;_type&quot;);
  params.addPrivateParam&lt;int&gt;(&quot;_argc&quot;);
  params.addPrivateParam&lt;char **&gt;(&quot;_argv&quot;);
  params.addPrivateParam&lt;std::shared_ptr&lt;CommandLine&gt;&gt;(&quot;_command_line&quot;);
  params.addPrivateParam&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(&quot;_comm&quot;);
  params.addPrivateParam&lt;unsigned int&gt;(&quot;_multiapp_level&quot;);
  params.addPrivateParam&lt;unsigned int&gt;(&quot;_multiapp_number&quot;);
  params.addPrivateParam&lt;const MooseMesh *&gt;(&quot;_master_mesh&quot;);
  params.addPrivateParam&lt;const MooseMesh *&gt;(&quot;_master_displaced_mesh&quot;);

  return params;
}

MooseApp::MooseApp(InputParameters parameters)
  : ConsoleStreamInterface(*this),
    ParallelObject(*parameters.get&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(
        &quot;_comm&quot;)), // Can&#x27;t call getParam() before pars is set
    _name(parameters.get&lt;std::string&gt;(&quot;_app_name&quot;)),
    _pars(parameters),
    _type(getParam&lt;std::string&gt;(&quot;_type&quot;)),
    _comm(getParam&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(&quot;_comm&quot;)),
    _perf_graph(type() + &quot; (&quot; + name() + &#x27;)&#x27;),
    _rank_map(*_comm, _perf_graph),
    _file_base_set_by_user(false),
    _output_position_set(false),
    _start_time_set(false),
    _start_time(0.0),
    _global_time_offset(0.0),
    _output_warehouse(*this),
    _input_parameter_warehouse(new InputParameterWarehouse()),
    _action_factory(*this),
    _action_warehouse(*this, _syntax, _action_factory),
    _parser(*this, _action_warehouse),
    _use_nonlinear(true),
    _use_eigen_value(false),
    _enable_unused_check(WARN_UNUSED),
    _factory(*this),
    _error_overridden(false),
    _ready_to_exit(false),
    _initial_from_file(false),
    _distributed_mesh_on_command_line(false),
    _recover(false),
    _restart(false),
    _split_mesh(false),
    _use_split(parameters.get&lt;bool&gt;(&quot;use_split&quot;)),
#ifdef DEBUG
    _trap_fpe(true),
#else
    _trap_fpe(false),
#endif
    _restart_recover_suffix(&quot;cpr&quot;),
    _half_transient(false),
    _check_input(getParam&lt;bool&gt;(&quot;check_input&quot;)),
    _restartable_data(libMesh::n_threads()),
    _multiapp_level(
        isParamValid(&quot;_multiapp_level&quot;) ? parameters.get&lt;unsigned int&gt;(&quot;_multiapp_level&quot;) : 0),
    _multiapp_number(
        isParamValid(&quot;_multiapp_number&quot;) ? parameters.get&lt;unsigned int&gt;(&quot;_multiapp_number&quot;) : 0),
    _master_mesh(isParamValid(&quot;_master_mesh&quot;) ? parameters.get&lt;const MooseMesh *&gt;(&quot;_master_mesh&quot;)
                                              : nullptr),
    _master_displaced_mesh(isParamValid(&quot;_master_displaced_mesh&quot;)
                               ? parameters.get&lt;const MooseMesh *&gt;(&quot;_master_displaced_mesh&quot;)
                               : nullptr),
    _setup_timer(_perf_graph.registerSection(&quot;MooseApp::setup&quot;, 2)),
    _setup_options_timer(_perf_graph.registerSection(&quot;MooseApp::setupOptions&quot;, 5)),
    _run_input_file_timer(_perf_graph.registerSection(&quot;MooseApp::runInputFile&quot;, 3)),
    _execute_timer(_perf_graph.registerSection(&quot;MooseApp::execute&quot;, 2)),
    _execute_executioner_timer(_perf_graph.registerSection(&quot;MooseApp::executeExecutioner&quot;, 3)),
    _restore_timer(_perf_graph.registerSection(&quot;MooseApp::restore&quot;, 2)),
    _run_timer(_perf_graph.registerSection(&quot;MooseApp::run&quot;, 3)),
    _execute_mesh_modifiers_timer(_perf_graph.registerSection(&quot;MooseApp::executeMeshModifiers&quot;, 1)),
    _execute_mesh_generators_timer(
        _perf_graph.registerSection(&quot;MooseApp::executeMeshGenerators&quot;, 1)),
    _restore_cached_backup_timer(_perf_graph.registerSection(&quot;MooseApp::restoreCachedBackup&quot;, 2)),
    _create_minimal_app_timer(_perf_graph.registerSection(&quot;MooseApp::createMinimalApp&quot;, 3)),
    _automatic_automatic_scaling(getParam&lt;bool&gt;(&quot;automatic_automatic_scaling&quot;)),
    _popped_final_mesh_generator(false)
{
#ifdef HAVE_GPERFTOOLS
  if (std::getenv(&quot;MOOSE_PROFILE_BASE&quot;))
  {
    static std::string profile_file =
        std::getenv(&quot;MOOSE_PROFILE_BASE&quot;) + std::to_string(_comm-&gt;rank()) + &quot;.prof&quot;;
    _profiling = true;
    ProfilerStart(profile_file.c_str());
  }
#endif

  Registry::addKnownLabel(_type);
  Moose::registerAll(_factory, _action_factory, _syntax);

  _the_warehouse = libmesh_make_unique&lt;TheWarehouse&gt;();
  _the_warehouse-&gt;registerAttribute&lt;AttribMatrixTags&gt;(&quot;matrix_tags&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribVectorTags&gt;(&quot;vector_tags&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribExecOns&gt;(&quot;exec_ons&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribSubdomains&gt;(&quot;subdomains&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribBoundaries&gt;(&quot;boundaries&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribThread&gt;(&quot;thread&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribPreIC&gt;(&quot;pre_ic&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribPreAux&gt;(&quot;pre_aux&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribName&gt;(&quot;name&quot;, &quot;dummy&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribSystem&gt;(&quot;system&quot;, &quot;dummy&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribVar&gt;(&quot;variable&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribInterfaces&gt;(&quot;interfaces&quot;, 0);

  if (isParamValid(&quot;_argc&quot;) &amp;&amp; isParamValid(&quot;_argv&quot;))
  {
    int argc = getParam&lt;int&gt;(&quot;_argc&quot;);
    char ** argv = getParam&lt;char **&gt;(&quot;_argv&quot;);

    _sys_info = libmesh_make_unique&lt;SystemInfo&gt;(argc, argv);
  }
  if (isParamValid(&quot;_command_line&quot;))
    _command_line = getParam&lt;std::shared_ptr&lt;CommandLine&gt;&gt;(&quot;_command_line&quot;);
  else
    mooseError(&quot;Valid CommandLine object required&quot;);

  if (_check_input &amp;&amp; isParamValid(&quot;recover&quot;))
    mooseError(&quot;Cannot run --check-input with --recover. Recover files might not exist&quot;);

  if (isParamValid(&quot;start_in_debugger&quot;) &amp;&amp; _multiapp_level == 0)
  {
    auto command = getParam&lt;std::string&gt;(&quot;start_in_debugger&quot;);

    Moose::out &lt;&lt; &quot;Starting in debugger using: &quot; &lt;&lt; command &lt;&lt; std::endl;

    auto hostname = MooseUtils::hostname();

    std::stringstream command_stream;

    // This will start XTerm and print out some info first... then run the debugger
    command_stream &lt;&lt; &quot;xterm -e \&quot;echo &#x27;Rank: &quot; &lt;&lt; processor_id() &lt;&lt; &quot;  Hostname: &quot; &lt;&lt; hostname
                   &lt;&lt; &quot;  PID: &quot; &lt;&lt; getpid() &lt;&lt; &quot;&#x27;; echo &#x27;&#x27;; &quot;;

    // Figure out how to run the debugger
    if (command.find(&quot;lldb&quot;) != std::string::npos || command.find(&quot;gdb&quot;) != std::string::npos)
      command_stream &lt;&lt; command &lt;&lt; &quot; -p &quot; &lt;&lt; getpid();
    else
      mooseError(&quot;Unknown debugger: &quot;,
                 command,
                 &quot;\nIf this is truly what you meant then contact moose-users to have a discussion &quot;
                 &quot;about adding your debugger.&quot;);

    // Finish up the command
    command_stream &lt;&lt; &quot;\&quot;&quot;
                   &lt;&lt; &quot; &amp; &quot;;

    std::string command_string = command_stream.str();
    Moose::out &lt;&lt; &quot;Running: &quot; &lt;&lt; command_string &lt;&lt; std::endl;

    int ret = std::system(command_string.c_str());
    libmesh_ignore(ret);

    // Sleep to allow time for the debugger to attach
    std::this_thread::sleep_for(std::chrono::seconds(10));
  }

  if (!parameters.isParamSetByAddParam(&quot;stop_for_debugger&quot;))
  {
    Moose::out &lt;&lt; &quot;\nStopping for &quot; &lt;&lt; getParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;)
               &lt;&lt; &quot; seconds to allow attachment from a debugger.\n&quot;;

    Moose::out &lt;&lt; &quot;\nAll of the processes you can connect to:\n&quot;;
    Moose::out &lt;&lt; &quot;rank - hostname - pid\n&quot;;

    auto hostname = MooseUtils::hostname();

    {
      // The &#x27;false&#x27; turns off the serialization warning
      SerializerGuard sg(_communicator, false); // Guarantees that the processors print in order
      Moose::err &lt;&lt; processor_id() &lt;&lt; &quot; - &quot; &lt;&lt; hostname &lt;&lt; &quot; - &quot; &lt;&lt; getpid() &lt;&lt; &quot;\n&quot;;
    }

    Moose::out &lt;&lt; &quot;\nWaiting...\n&quot; &lt;&lt; std::endl;

    // Sleep to allow time for the debugger to attach
    std::this_thread::sleep_for(std::chrono::seconds(getParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;)));
  }

  if (_master_mesh &amp;&amp; _multiapp_level == 0)
    mooseError(&quot;Mesh can be passed in only for sub-apps&quot;);

  if (_master_displaced_mesh &amp;&amp; !_master_mesh)
    mooseError(&quot;_master_mesh should have been set when _master_displaced_mesh is set&quot;);
}

void
MooseApp::checkRegistryLabels()
{
  Registry::checkLabels();
}

MooseApp::~MooseApp()
{
#ifdef HAVE_GPERFTOOLS
  if (_profiling)
    ProfilerStop();
#endif
  _action_warehouse.clear();
  _executioner.reset();
  _the_warehouse.reset();

  delete _input_parameter_warehouse;

#ifdef LIBMESH_HAVE_DLOPEN
  // Close any open dynamic libraries
  for (const auto &amp; it : _lib_handles)
    dlclose(it.second);
#endif
}

std::string
MooseApp::getFrameworkVersion() const
{
  return MOOSE_VERSION;
}

std::string
MooseApp::getVersion() const
{
  return MOOSE_VERSION;
}

std::string
MooseApp::getPrintableVersion() const
{
  return getPrintableName() + &quot; Version: &quot; + getVersion();
}

void
MooseApp::setupOptions()
{
  TIME_SECTION(_setup_options_timer);

  // MOOSE was updated to have the ability to register execution flags in similar fashion as
  // objects. However, this change requires all *App.C/h files to be updated with the new
  // registerExecFlags method. To avoid breaking all applications the default MOOSE flags
  // are added if nothing has been added to this point. In the future this could go away or
  // perhaps be a warning.
  if (_execute_flags.items().empty())
    Moose::registerExecFlags(_factory);

  // Print the header, this is as early as possible
  std::string hdr(header() + &quot;\n&quot;);
  if (multiAppLevel() &gt; 0)
    MooseUtils::indentMessage(_name, hdr);
  Moose::out &lt;&lt; hdr &lt;&lt; std::flush;

  if (getParam&lt;bool&gt;(&quot;error_unused&quot;))
    setCheckUnusedFlag(true);
  else if (getParam&lt;bool&gt;(&quot;warn_unused&quot;))
    setCheckUnusedFlag(false);

  if (getParam&lt;bool&gt;(&quot;error_override&quot;))
    setErrorOverridden();

  _distributed_mesh_on_command_line = getParam&lt;bool&gt;(&quot;distributed_mesh&quot;);

  _half_transient = getParam&lt;bool&gt;(&quot;half_transient&quot;);

  // The no_timing flag takes precedence over the timing flag.
  if (getParam&lt;bool&gt;(&quot;no_timing&quot;))
  {
    _pars.set&lt;bool&gt;(&quot;timing&quot;) = false;

    _perf_graph.setActive(false);
  }

  if (isParamValid(&quot;trap_fpe&quot;) &amp;&amp; isParamValid(&quot;no_trap_fpe&quot;))
    mooseError(&quot;Cannot use both \&quot;--trap-fpe\&quot; and \&quot;--no-trap-fpe\&quot; flags.&quot;);
  if (isParamValid(&quot;trap_fpe&quot;))
    _trap_fpe = true;
  else if (isParamValid(&quot;no_trap_fpe&quot;))
    _trap_fpe = false;

  // Turn all warnings in MOOSE to errors (almost see next logic block)
  Moose::_warnings_are_errors = getParam&lt;bool&gt;(&quot;error&quot;);

  // Deprecated messages can be toggled to errors independently from everything else.
  Moose::_deprecated_is_error = getParam&lt;bool&gt;(&quot;error_deprecated&quot;);

  if (isUltimateMaster()) // makes sure coloring isn&#x27;t reset incorrectly in multi-app settings
  {
    // Toggle the color console off
    Moose::setColorConsole(true, true); // set default color condition
    if (getParam&lt;bool&gt;(&quot;no_color&quot;))
      Moose::setColorConsole(false);

    char * c_color = std::getenv(&quot;MOOSE_COLOR&quot;);
    std::string color = &quot;on&quot;;
    if (c_color)
      color = c_color;
    if (getParam&lt;std::string&gt;(&quot;color&quot;) != &quot;default-on&quot;)
      color = getParam&lt;std::string&gt;(&quot;color&quot;);

    if (color == &quot;auto&quot;)
      Moose::setColorConsole(true);
    else if (color == &quot;on&quot;)
      Moose::setColorConsole(true, true);
    else if (color == &quot;off&quot;)
      Moose::setColorConsole(false);
    else
      mooseWarning(&quot;ignoring invalid --color arg (want &#x27;auto&#x27;, &#x27;on&#x27;, or &#x27;off&#x27;)&quot;);
  }

  // this warning goes below --color processing to honor that setting for
  // the warning. And below settings for warnings/error setup.
  if (getParam&lt;bool&gt;(&quot;no_color&quot;))
    mooseDeprecated(&quot;The --no-color flag is deprecated. Use &#x27;--color off&#x27; instead.&quot;);

// If there&#x27;s no threading model active, but the user asked for
// --n-threads &gt; 1 on the command line, throw a mooseError.  This is
// intended to prevent situations where the user has potentially
// built MOOSE incorrectly (neither TBB nor pthreads found) and is
// asking for multiple threads, not knowing that there will never be
// any threads launched.
#if !LIBMESH_USING_THREADS
  if (libMesh::command_line_value(&quot;--n-threads&quot;, 1) &gt; 1)
    mooseError(&quot;You specified --n-threads &gt; 1, but there is no threading model active!&quot;);
#endif

  // Build a minimal running application, ignoring the input file.
  if (getParam&lt;bool&gt;(&quot;minimal&quot;))
    createMinimalApp();

  else if (getParam&lt;bool&gt;(&quot;display_version&quot;))
  {
    Moose::perf_log.disable_logging();
    Moose::out &lt;&lt; getPrintableVersion() &lt;&lt; std::endl;
    _ready_to_exit = true;
    return;
  }
  else if (getParam&lt;bool&gt;(&quot;help&quot;))
  {
    Moose::perf_log.disable_logging();

    _command_line-&gt;printUsage();
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;dump&quot;))
  {
    Moose::perf_log.disable_logging();

    // Get command line argument following --dump on command line
    std::string following_arg = getParam&lt;std::string&gt;(&quot;dump&quot;);

    // The argument following --dump is a parameter search string,
    // which can be empty.
    std::string param_search;
    if (!following_arg.empty() &amp;&amp; (following_arg.find(&#x27;-&#x27;) != 0))
      param_search = following_arg;

    JsonSyntaxTree tree(param_search);
    _parser.buildJsonSyntaxTree(tree);
    JsonInputFileFormatter formatter;
    Moose::out &lt;&lt; &quot;### START DUMP DATA ###\n&quot;
               &lt;&lt; formatter.toString(tree.getRoot()) &lt;&lt; &quot;\n### END DUMP DATA ###\n&quot;;
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;registry&quot;))
  {
    Moose::out &lt;&lt; &quot;Label\tType\tName\tClass\tFile\n&quot;;

    auto &amp; objmap = Registry::allObjects();
    for (auto &amp; entry : objmap)
    {
      for (auto &amp; obj : entry.second)
      {
        std::string name = obj._name;
        if (name.empty())
          name = obj._alias;
        if (name.empty())
          name = obj._classname;

        Moose::out &lt;&lt; entry.first &lt;&lt; &quot;\tobject\t&quot; &lt;&lt; name &lt;&lt; &quot;\t&quot; &lt;&lt; obj._classname &lt;&lt; &quot;\t&quot;
                   &lt;&lt; obj._file &lt;&lt; &quot;\n&quot;;
      }
    }

    auto &amp; actmap = Registry::allActions();
    for (auto &amp; entry : actmap)
    {
      for (auto &amp; act : entry.second)
        Moose::out &lt;&lt; entry.first &lt;&lt; &quot;\taction\t&quot; &lt;&lt; act._name &lt;&lt; &quot;\t&quot; &lt;&lt; act._classname &lt;&lt; &quot;\t&quot;
                   &lt;&lt; act._file &lt;&lt; &quot;\n&quot;;
    }

    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;registry_hit&quot;))
  {
    Moose::out &lt;&lt; &quot;### START REGISTRY DATA ###\n&quot;;

    hit::Section root(&quot;&quot;);
    auto sec = new hit::Section(&quot;registry&quot;);
    root.addChild(sec);
    auto objsec = new hit::Section(&quot;objects&quot;);
    sec-&gt;addChild(objsec);

    auto &amp; objmap = Registry::allObjects();
    for (auto &amp; entry : objmap)
    {
      for (auto &amp; obj : entry.second)
      {
        std::string name = obj._name;
        if (name.empty())
          name = obj._alias;
        if (name.empty())
          name = obj._classname;

        auto ent = new hit::Section(&quot;entry&quot;);
        objsec-&gt;addChild(ent);
        ent-&gt;addChild(new hit::Field(&quot;label&quot;, hit::Field::Kind::String, entry.first));
        ent-&gt;addChild(new hit::Field(&quot;type&quot;, hit::Field::Kind::String, &quot;object&quot;));
        ent-&gt;addChild(new hit::Field(&quot;name&quot;, hit::Field::Kind::String, name));
        ent-&gt;addChild(new hit::Field(&quot;class&quot;, hit::Field::Kind::String, obj._classname));
        ent-&gt;addChild(new hit::Field(&quot;file&quot;, hit::Field::Kind::String, obj._file));
      }
    }

    auto actsec = new hit::Section(&quot;actions&quot;);
    sec-&gt;addChild(actsec);
    auto &amp; actmap = Registry::allActions();
    for (auto &amp; entry : actmap)
    {
      for (auto &amp; act : entry.second)
      {
        auto ent = new hit::Section(&quot;entry&quot;);
        actsec-&gt;addChild(ent);
        ent-&gt;addChild(new hit::Field(&quot;label&quot;, hit::Field::Kind::String, entry.first));
        ent-&gt;addChild(new hit::Field(&quot;type&quot;, hit::Field::Kind::String, &quot;action&quot;));
        ent-&gt;addChild(new hit::Field(&quot;task&quot;, hit::Field::Kind::String, act._name));
        ent-&gt;addChild(new hit::Field(&quot;class&quot;, hit::Field::Kind::String, act._classname));
        ent-&gt;addChild(new hit::Field(&quot;file&quot;, hit::Field::Kind::String, act._file));
      }
    }

    Moose::out &lt;&lt; root.render();

    Moose::out &lt;&lt; &quot;\n### END REGISTRY DATA ###\n&quot;;
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;definition&quot;))
  {
    Moose::perf_log.disable_logging();
    JsonSyntaxTree tree(&quot;&quot;);
    _parser.buildJsonSyntaxTree(tree);
    SONDefinitionFormatter formatter;
    Moose::out &lt;&lt; formatter.toString(tree.getRoot()) &lt;&lt; &quot;\n&quot;;
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;yaml&quot;))
  {
    Moose::perf_log.disable_logging();

    _parser.initSyntaxFormatter(Parser::YAML, true);

    // Get command line argument following --yaml on command line
    std::string yaml_following_arg = getParam&lt;std::string&gt;(&quot;yaml&quot;);

    // If the argument following --yaml is non-existent or begins with
    // a dash, call buildFullTree() with an empty string, otherwise
    // pass the argument following --yaml.
    if (yaml_following_arg.empty() || (yaml_following_arg.find(&#x27;-&#x27;) == 0))
      _parser.buildFullTree(&quot;&quot;);
    else
      _parser.buildFullTree(yaml_following_arg);

    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;json&quot;))
  {
    Moose::perf_log.disable_logging();

    // Get command line argument following --json on command line
    std::string json_following_arg = getParam&lt;std::string&gt;(&quot;json&quot;);

    // The argument following --json is a parameter search string,
    // which can be empty.
    std::string search;
    if (!json_following_arg.empty() &amp;&amp; (json_following_arg.find(&#x27;-&#x27;) != 0))
      search = json_following_arg;

    JsonSyntaxTree tree(search);
    _parser.buildJsonSyntaxTree(tree);

    Moose::out &lt;&lt; &quot;**START JSON DATA**\n&quot; &lt;&lt; tree.getRoot() &lt;&lt; &quot;\n**END JSON DATA**\n&quot;;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;syntax&quot;))
  {
    Moose::perf_log.disable_logging();

    std::multimap&lt;std::string, Syntax::ActionInfo&gt; syntax = _syntax.getAssociatedActions();
    Moose::out &lt;&lt; &quot;**START SYNTAX DATA**\n&quot;;
    for (const auto &amp; it : syntax)
      Moose::out &lt;&lt; it.first &lt;&lt; &quot;\n&quot;;
    Moose::out &lt;&lt; &quot;**END SYNTAX DATA**\n&quot; &lt;&lt; std::endl;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;apptype&quot;))
  {
    Moose::perf_log.disable_logging();
    Moose::out &lt;&lt; &quot;MooseApp Type: &quot; &lt;&lt; type() &lt;&lt; std::endl;
    _ready_to_exit = true;
  }
  else if (_input_filename != &quot;&quot; ||
           isParamValid(&quot;input_file&quot;)) // They already specified an input filename
  {
    if (_input_filename == &quot;&quot;)
      _input_filename = getParam&lt;std::string&gt;(&quot;input_file&quot;);

    if (isParamValid(&quot;recover&quot;))
    {
      // We need to set the flag manually here since the recover parameter is a string type (takes
      // an optional filename)
      _recover = true;

      // Get command line argument following --recover on command line
      std::string recover_following_arg = getParam&lt;std::string&gt;(&quot;recover&quot;);

      // If the argument following --recover is non-existent or begins with
      // a dash then we are going to eventually find the newest recovery file to use
      if (!(recover_following_arg.empty() || (recover_following_arg.find(&#x27;-&#x27;) == 0)))
        _restart_recover_base = recover_following_arg;
    }

    // Optionally get command line argument following --recoversuffix
    // on command line.  Currently this argument applies to both
    // recovery and restart files.
    if (isParamValid(&quot;recoversuffix&quot;))
    {
      _restart_recover_suffix = getParam&lt;std::string&gt;(&quot;recoversuffix&quot;);
    }

    _parser.parse(_input_filename);

    if (isParamValid(&quot;mesh_only&quot;))
    {
      _syntax.registerTaskName(&quot;mesh_only&quot;, true);
      _syntax.addDependency(&quot;mesh_only&quot;, &quot;setup_mesh_complete&quot;);
      _action_warehouse.setFinalTask(&quot;mesh_only&quot;);
    }
    else if (isParamValid(&quot;split_mesh&quot;))
    {
      _split_mesh = true;
      _syntax.registerTaskName(&quot;split_mesh&quot;, true);
      _syntax.addDependency(&quot;split_mesh&quot;, &quot;setup_mesh_complete&quot;);
      _action_warehouse.setFinalTask(&quot;split_mesh&quot;);
    }
    _action_warehouse.build();

    // Setup the AppFileBase for use by the Outputs or other systems that need output file info
    {
      // Extract the CommonOutputAction
      const auto &amp; common_actions = _action_warehouse.getActionListByName(&quot;common_output&quot;);
      mooseAssert(common_actions.size() == 1, &quot;Should be only one common_output Action&quot;);

      const Action * common = *common_actions.begin();

      // If file_base is set in CommonOutputAction through parsing input, obtain the file_base
      if (common-&gt;isParamValid(&quot;file_base&quot;))
      {
        _output_file_base = common-&gt;getParamTempl&lt;std::string&gt;(&quot;file_base&quot;);
        _file_base_set_by_user = true;
      }
      else if (isUltimateMaster())
      {
        // if this app is a master, we use the input file name as the default file base
        std::string base = getInputFileName();
        size_t pos = base.find_last_of(&#x27;.&#x27;);
        _output_file_base = base.substr(0, pos);
        // Note: we did not append &quot;_out&quot; in the file base here because we do not want to
        //       have it in betwen the input file name and the object name for Output/*
        //       syntax.
      }
      // default file base for multiapps is set by MultiApp
    }
  }
  else /* The catch-all case for bad options or missing options, etc. */
  {
    Moose::perf_log.disable_logging();

    if (_check_input)
      mooseError(&quot;You specified --check-input, but did not provide an input file. Add -i &quot;
                 &quot;&lt;inputfile&gt; to your command line.&quot;);

    _command_line-&gt;printUsage();
    _ready_to_exit = true;
  }
}

void
MooseApp::setInputFileName(const std::string &amp; input_filename)
{
  _input_filename = input_filename;
}

std::string
MooseApp::getOutputFileBase(bool for_non_moose_build_output) const
{
  if (_file_base_set_by_user || for_non_moose_build_output || _multiapp_level)
    return _output_file_base;
  else
    return _output_file_base + &quot;_out&quot;;
}

void
MooseApp::runInputFile()
{
  TIME_SECTION(_run_input_file_timer);

  // If ready to exit has been set, then just return
  if (_ready_to_exit)
    return;

  _action_warehouse.executeAllActions();

  if (isParamValid(&quot;mesh_only&quot;) || isParamValid(&quot;split_mesh&quot;))
    _ready_to_exit = true;
  else if (getParam&lt;bool&gt;(&quot;list_constructed_objects&quot;))
  {
    // TODO: ask multiapps for their constructed objects
    _ready_to_exit = true;
    std::vector&lt;std::string&gt; obj_list = _factory.getConstructedObjects();
    Moose::out &lt;&lt; &quot;**START OBJECT DATA**\n&quot;;
    for (const auto &amp; name : obj_list)
      Moose::out &lt;&lt; name &lt;&lt; &quot;\n&quot;;
    Moose::out &lt;&lt; &quot;**END OBJECT DATA**\n&quot; &lt;&lt; std::endl;
  }
}

void
MooseApp::errorCheck()
{
  bool warn = _enable_unused_check == WARN_UNUSED;
  bool err = _enable_unused_check == ERROR_UNUSED;

  _parser.errorCheck(*_comm, warn, err);

  auto apps = _executioner-&gt;feProblem().getMultiAppWarehouse().getObjects();
  for (auto app : apps)
    for (unsigned int i = 0; i &lt; app-&gt;numLocalApps(); i++)
      app-&gt;localApp(i)-&gt;errorCheck();
}

void
MooseApp::executeExecutioner()
{
  TIME_SECTION(_execute_executioner_timer);

  // If ready to exit has been set, then just return
  if (_ready_to_exit)
    return;

  // run the simulation
  if (_executioner)
  {
#ifdef LIBMESH_HAVE_PETSC
    Moose::PetscSupport::petscSetupOutput(_command_line.get());
#endif

    _executioner-&gt;init();
    errorCheck();
    _executioner-&gt;execute();
  }
  else
    mooseError(&quot;No executioner was specified (go fix your input file)&quot;);
}

bool
MooseApp::isRecovering() const
{
  return _recover;
}

bool
MooseApp::isRestarting() const
{
  return _restart;
}

bool
MooseApp::isSplitMesh() const
{
  return _split_mesh;
}

bool
MooseApp::isUseSplit() const
{
  return _use_split;
}

bool
MooseApp::hasRestartRecoverFileBase() const
{
  return !_restart_recover_base.empty();
}

bool
MooseApp::hasRecoverFileBase() const
{
  mooseDeprecated(&quot;MooseApp::hasRecoverFileBase is deprecated, use &quot;
                  &quot;MooseApp::hasRestartRecoverFileBase() instead.&quot;);
  return !_restart_recover_base.empty();
}

void
MooseApp::registerRestartableNameWithFilter(const std::string &amp; name,
                                            Moose::RESTARTABLE_FILTER filter)
{
  using Moose::RESTARTABLE_FILTER;
  switch (filter)
  {
    case RESTARTABLE_FILTER::RECOVERABLE:
      _recoverable_data_names.insert(name);
      break;
    default:
      mooseError(&quot;Unknown filter&quot;);
  }
}

std::shared_ptr&lt;Backup&gt;
MooseApp::backup()
{
  mooseAssert(_executioner, &quot;Executioner is nullptr&quot;);
  FEProblemBase &amp; fe_problem = _executioner-&gt;feProblem();

  RestartableDataIO rdio(fe_problem);
  return rdio.createBackup();
}

void
MooseApp::restore(std::shared_ptr&lt;Backup&gt; backup, bool for_restart)
{
  TIME_SECTION(_restore_timer);

  mooseAssert(_executioner, &quot;Executioner is nullptr&quot;);
  FEProblemBase &amp; fe_problem = _executioner-&gt;feProblem();

  RestartableDataIO rdio(fe_problem);
  rdio.restoreBackup(backup, for_restart);
}

void
MooseApp::setCheckUnusedFlag(bool warn_is_error)
{
  /**
   * _enable_unused_check is initialized to WARN_UNUSED. If an application chooses to promote
   * this value to ERROR_UNUSED programmatically prior to running the simulation, we certainly
   * don&#x27;t want to allow it to fall back. Therefore, we won&#x27;t set it if it&#x27;s already at the
   * highest value (i.e. error). If however a developer turns it off, it can still be turned on.
   */
  if (_enable_unused_check != ERROR_UNUSED || warn_is_error)
    _enable_unused_check = warn_is_error ? ERROR_UNUSED : WARN_UNUSED;
  else
    mooseInfo(&quot;Ignoring request to turn off or warn about unused parameters.\n&quot;);
}

void
MooseApp::disableCheckUnusedFlag()
{
  _enable_unused_check = OFF;
}

void
MooseApp::setErrorOverridden()
{
  _error_overridden = true;
}

void
MooseApp::run()
{
  TIME_SECTION(_run_timer);

  try
  {
    TIME_SECTION(_setup_timer);
    setupOptions();
    runInputFile();
  }
  catch (std::exception &amp; err)
  {
    mooseError(err.what());
  }

  if (!_check_input)
  {
    TIME_SECTION(_execute_timer);
    executeExecutioner();
  }
  else
  {
    errorCheck();
    // Output to stderr, so it is easier for peacock to get the result
    Moose::err &lt;&lt; &quot;Syntax OK&quot; &lt;&lt; std::endl;
  }
}

void
MooseApp::setOutputPosition(const Point &amp; p)
{
  _output_position_set = true;
  _output_position = p;
  _output_warehouse.meshChanged();

  if (_executioner.get())
    _executioner-&gt;parentOutputPositionChanged();
}

std::list&lt;std::string&gt;
MooseApp::getCheckpointDirectories() const
{
  // Storage for the directory names
  std::list&lt;std::string&gt; checkpoint_dirs;

  // Add the directories added with Outputs/checkpoint=true input syntax
  checkpoint_dirs.push_back(getOutputFileBase() + &quot;_cp&quot;);

  // Add the directories from any existing checkpoint output objects
  const auto &amp; actions = _action_warehouse.getActionListByName(&quot;add_output&quot;);
  for (const auto &amp; action : actions)
  {
    // Get the parameters from the MooseObjectAction
    MooseObjectAction * moose_object_action = dynamic_cast&lt;MooseObjectAction *&gt;(action);
    if (!moose_object_action)
      continue;

    const InputParameters &amp; params = moose_object_action-&gt;getObjectParams();
    if (moose_object_action-&gt;getParamTempl&lt;std::string&gt;(&quot;type&quot;) == &quot;Checkpoint&quot;)
      checkpoint_dirs.push_back(params.get&lt;std::string&gt;(&quot;file_base&quot;) + &quot;_cp&quot;);
  }

  return checkpoint_dirs;
}

std::list&lt;std::string&gt;
MooseApp::getCheckpointFiles() const
{
  auto checkpoint_dirs = getCheckpointDirectories();
  return MooseUtils::getFilesInDirs(checkpoint_dirs);
}

void
MooseApp::setStartTime(Real time)
{
  _start_time_set = true;
  _start_time = time;
}

std::string
MooseApp::getFileName(bool stripLeadingPath) const
{
  return _parser.getFileName(stripLeadingPath);
}

OutputWarehouse &amp;
MooseApp::getOutputWarehouse()
{
  return _output_warehouse;
}

std::string
MooseApp::appNameToLibName(const std::string &amp; app_name) const
{
  std::string library_name(app_name);

  // Strip off the App part (should always be the last 3 letters of the name)
  size_t pos = library_name.find(&quot;App&quot;);
  if (pos != library_name.length() - 3)
    mooseError(&quot;Invalid application name: &quot;, library_name);
  library_name.erase(pos);

  // Now get rid of the camel case, prepend lib, and append the method and suffix
  return std::string(&quot;lib&quot;) + MooseUtils::camelCaseToUnderscore(library_name) + &#x27;-&#x27; +
         QUOTE(METHOD) + &quot;.la&quot;;
}

std::string
MooseApp::libNameToAppName(const std::string &amp; library_name) const
{
  std::string app_name(library_name);

  // Strip off the leading &quot;lib&quot; and trailing &quot;.la&quot;
  if (pcrecpp::RE(&quot;lib(.+?)(?:-\\w+)?\\.la&quot;).Replace(&quot;\\1&quot;, &amp;app_name) == 0)
    mooseError(&quot;Invalid library name: &quot;, app_name);

  return MooseUtils::underscoreToCamelCase(app_name, true);
}

RestartableDataValue &amp;
MooseApp::registerRestartableData(const std::string &amp; name,
                                  std::unique_ptr&lt;RestartableDataValue&gt; data,
                                  THREAD_ID tid,
                                  bool mesh_meta_data,
                                  bool read_only)
{
  // Select the data store for saving this piece of restartable data (mesh or everything else)
  auto &amp; data_ref = mesh_meta_data ? _mesh_meta_data_map : _restartable_data[tid];

  auto insert_pair = data_ref.emplace(name, RestartableDataValuePair(std::move(data), !read_only));

  // Does the storage for this data already exist?
  if (!insert_pair.second)
  {
    auto &amp; data = insert_pair.first-&gt;second;

    // Are we really declaring or just trying to get a reference to the data?
    if (!read_only)
    {
      if (data.declared)
        mooseError(&quot;Attempted to declare restartable mesh meta data twice with the same name: &quot;,
                   name);
      else
        // The data wasn&#x27;t previously declared, but now it is!
        data.declared = true;
    }
  }

  return *insert_pair.first-&gt;second.value;
}

void
MooseApp::dynamicAppRegistration(const std::string &amp; app_name,
                                 std::string library_path,
                                 const std::string &amp; library_name)
{
#ifdef LIBMESH_HAVE_DLOPEN
  Parameters params;
  params.set&lt;std::string&gt;(&quot;app_name&quot;) = app_name;
  params.set&lt;RegistrationType&gt;(&quot;reg_type&quot;) = APPLICATION;
  params.set&lt;std::string&gt;(&quot;registration_method&quot;) = app_name + &quot;__registerApps&quot;;
  params.set&lt;std::string&gt;(&quot;library_path&quot;) = library_path;
  params.set&lt;std::string&gt;(&quot;library_name&quot;) = library_name;

  dynamicRegistration(params);

  // At this point the application should be registered so check it
  if (!AppFactory::instance().isRegistered(app_name))
  {
    std::ostringstream oss;
    std::set&lt;std::string&gt; paths = getLoadedLibraryPaths();

    oss &lt;&lt; &quot;Unable to locate library for \&quot;&quot; &lt;&lt; app_name
        &lt;&lt; &quot;\&quot;.\nWe attempted to locate the library \&quot;&quot; &lt;&lt; appNameToLibName(app_name)
        &lt;&lt; &quot;\&quot; in the following paths:\n\t&quot;;
    std::copy(paths.begin(), paths.end(), infix_ostream_iterator&lt;std::string&gt;(oss, &quot;\n\t&quot;));
    oss &lt;&lt; &quot;\n\nMake sure you have compiled the library and either set the \&quot;library_path\&quot; &quot;
           &quot;variable &quot;
        &lt;&lt; &quot;in your input file or exported \&quot;MOOSE_LIBRARY_PATH\&quot;.\n&quot;
        &lt;&lt; &quot;Compiled in debug mode to see the list of libraries checked for dynamic loading &quot;
           &quot;methods.&quot;;
    mooseError(oss.str());
  }
#else
  mooseError(&quot;Dynamic Loading is either not supported or was not detected by libMesh configure.&quot;);
#endif
}

void
MooseApp::dynamicAllRegistration(const std::string &amp; app_name,
                                 Factory * factory,
                                 ActionFactory * action_factory,
                                 Syntax * syntax,
                                 std::string library_path,
                                 const std::string &amp; library_name)
{
#ifdef LIBMESH_HAVE_DLOPEN
  Parameters params;
  params.set&lt;std::string&gt;(&quot;app_name&quot;) = app_name;
  params.set&lt;RegistrationType&gt;(&quot;reg_type&quot;) = REGALL;
  params.set&lt;std::string&gt;(&quot;registration_method&quot;) = app_name + &quot;__registerAll&quot;;
  params.set&lt;std::string&gt;(&quot;library_path&quot;) = library_path;
  params.set&lt;std::string&gt;(&quot;library_name&quot;) = library_name;

  params.set&lt;Factory *&gt;(&quot;factory&quot;) = factory;
  params.set&lt;Syntax *&gt;(&quot;syntax&quot;) = syntax;
  params.set&lt;ActionFactory *&gt;(&quot;action_factory&quot;) = action_factory;

  dynamicRegistration(params);
#else
  mooseError(&quot;Dynamic Loading is either not supported or was not detected by libMesh configure.&quot;);
#endif
}

void
MooseApp::dynamicRegistration(const Parameters &amp; params)
{
  std::string library_name;
  // was library name provided by the user?
  if (params.get&lt;std::string&gt;(&quot;library_name&quot;).empty())
    library_name = appNameToLibName(params.get&lt;std::string&gt;(&quot;app_name&quot;));
  else
    library_name = params.get&lt;std::string&gt;(&quot;library_name&quot;);

  // Create a vector of paths that we can search inside for libraries
  std::vector&lt;std::string&gt; paths;

  std::string library_path = params.get&lt;std::string&gt;(&quot;library_path&quot;);

  if (library_path != &quot;&quot;)
    MooseUtils::tokenize(library_path, paths, 1, &quot;:&quot;);

  char * moose_lib_path_env = std::getenv(&quot;MOOSE_LIBRARY_PATH&quot;);
  if (moose_lib_path_env)
  {
    std::string moose_lib_path(moose_lib_path_env);
    std::vector&lt;std::string&gt; tmp_paths;

    MooseUtils::tokenize(moose_lib_path, tmp_paths, 1, &quot;:&quot;);

    // merge the two vectors together (all possible search paths)
    paths.insert(paths.end(), tmp_paths.begin(), tmp_paths.end());
  }

  // Attempt to dynamically load the library
  for (const auto &amp; path : paths)
    if (MooseUtils::checkFileReadable(path + &#x27;/&#x27; + library_name, false, false))
      loadLibraryAndDependencies(path + &#x27;/&#x27; + library_name, params);
    else
      mooseWarning(&quot;Unable to open library file \&quot;&quot;,
                   path + &#x27;/&#x27; + library_name,
                   &quot;\&quot;. Double check for spelling errors.&quot;);
}

void
MooseApp::loadLibraryAndDependencies(const std::string &amp; library_filename,
                                     const Parameters &amp; params)
{
  std::string line;
  std::string dl_lib_filename;

  // This RE looks for absolute path libtool filenames (i.e. begins with a slash and ends with a
  // .la)
  pcrecpp::RE re_deps(&quot;(/\\S*\\.la)&quot;);

  std::ifstream handle(library_filename.c_str());
  if (handle.is_open())
  {
    while (std::getline(handle, line))
    {
      // Look for the system dependent dynamic library filename to open
      if (line.find(&quot;dlname=&quot;) != std::string::npos)
        // Magic numbers are computed from length of this string &quot;dlname=&#x27; and line minus that
        // string plus quotes&quot;
        dl_lib_filename = line.substr(8, line.size() - 9);

      if (line.find(&quot;dependency_libs=&quot;) != std::string::npos)
      {
        pcrecpp::StringPiece input(line);
        pcrecpp::StringPiece depend_library;
        while (re_deps.FindAndConsume(&amp;input, &amp;depend_library))
          // Recurse here to load dependent libraries in depth-first order
          loadLibraryAndDependencies(depend_library.as_string(), params);

        // There&#x27;s only one line in the .la file containing the dependency libs so break after
        // finding it
        break;
      }
    }
    handle.close();
  }

  std::string registration_method_name = params.get&lt;std::string&gt;(&quot;registration_method&quot;);
  // Time to load the library, First see if we&#x27;ve already loaded this particular dynamic library
  if (_lib_handles.find(std::make_pair(library_filename, registration_method_name)) ==
          _lib_handles.end() &amp;&amp; // make sure we haven&#x27;t already loaded this library
      dl_lib_filename != &quot;&quot;) // AND make sure we have a library name (we won&#x27;t for static linkage)
  {
    std::pair&lt;std::string, std::string&gt; lib_name_parts =
        MooseUtils::splitFileName(library_filename);

    // Assemble the actual filename using the base path of the *.la file and the dl_lib_filename
    std::string dl_lib_full_path = lib_name_parts.first + &#x27;/&#x27; + dl_lib_filename;

    MooseUtils::checkFileReadable(dl_lib_full_path, false, /*throw_on_unreadable=*/true);

#ifdef LIBMESH_HAVE_DLOPEN
    void * handle = dlopen(dl_lib_full_path.c_str(), RTLD_LAZY);
#else
    void * handle = nullptr;
#endif

    if (!handle)
      mooseError(&quot;The library file \&quot;&quot;,
                 dl_lib_full_path,
                 &quot;\&quot; exists and has proper permissions, but cannot by dynamically loaded.\nThis &quot;
                 &quot;generally means that the loader was unable to load one or more of the &quot;
                 &quot;dependencies listed in the supplied library (see otool or ldd).\n&quot;);

// get the pointer to the method in the library.  The dlsym()
// function returns a null pointer if the symbol cannot be found,
// we also explicitly set the pointer to NULL if dlsym is not
// available.
#ifdef LIBMESH_HAVE_DLOPEN
    void * registration_method = dlsym(handle, registration_method_name.c_str());
#else
    void * registration_method = nullptr;
#endif

    if (!registration_method)
    {
// We found a dynamic library that doesn&#x27;t have a dynamic
// registration method in it. This shouldn&#x27;t be an error, so
// we&#x27;ll just move on.
#ifdef DEBUG
      mooseWarning(&quot;Unable to find extern \&quot;C\&quot; method \&quot;&quot;,
                   registration_method_name,
                   &quot;\&quot; in library: &quot;,
                   dl_lib_full_path,
                   &quot;.\n&quot;,
                   &quot;This doesn&#x27;t necessarily indicate an error condition unless you believe that &quot;
                   &quot;the method should exist in that library.\n&quot;);
#endif

#ifdef LIBMESH_HAVE_DLOPEN
      dlclose(handle);
#endif
    }
    else // registration_method is valid!
    {
      // TODO: Look into cleaning this up
      switch (params.get&lt;RegistrationType&gt;(&quot;reg_type&quot;))
      {
        case APPLICATION:
        {
          typedef void (*register_app_t)();
          register_app_t * reg_ptr = reinterpret_cast&lt;register_app_t *&gt;(&amp;registration_method);
          (*reg_ptr)();
          break;
        }
        case REGALL:
        {
          typedef void (*register_app_t)(Factory *, ActionFactory *, Syntax *);
          register_app_t * reg_ptr = reinterpret_cast&lt;register_app_t *&gt;(&amp;registration_method);
          (*reg_ptr)(params.get&lt;Factory *&gt;(&quot;factory&quot;),
                     params.get&lt;ActionFactory *&gt;(&quot;action_factory&quot;),
                     params.get&lt;Syntax *&gt;(&quot;syntax&quot;));
          break;
        }
        default:
          mooseError(&quot;Unhandled RegistrationType&quot;);
      }

      // Store the handle so we can close it later
      _lib_handles.insert(
          std::make_pair(std::make_pair(library_filename, registration_method_name), handle));
    }
  }
}

std::set&lt;std::string&gt;
MooseApp::getLoadedLibraryPaths() const
{
  // Return the paths but not the open file handles
  std::set&lt;std::string&gt; paths;
  for (const auto &amp; it : _lib_handles)
    paths.insert(it.first.first);

  return paths;
}

InputParameterWarehouse &amp;
MooseApp::getInputParameterWarehouse()
{
  return *_input_parameter_warehouse;
}

std::string
MooseApp::header() const
{
  return std::string(&quot;&quot;);
}

void
MooseApp::addMeshModifier(const std::string &amp; modifier_name,
                          const std::string &amp; name,
                          InputParameters parameters)
{
  std::shared_ptr&lt;MeshModifier&gt; mesh_modifier =
      _factory.create&lt;MeshModifier&gt;(modifier_name, name, parameters);

  _mesh_modifiers.insert(std::make_pair(MooseUtils::shortName(name), mesh_modifier));
}

const MeshModifier &amp;
MooseApp::getMeshModifier(const std::string &amp; name) const
{
  return *_mesh_modifiers.find(MooseUtils::shortName(name))-&gt;second.get();
}

std::vector&lt;std::string&gt;
MooseApp::getMeshModifierNames() const
{
  std::vector&lt;std::string&gt; names;
  for (auto &amp; pair : _mesh_modifiers)
    names.push_back(pair.first);
  return names;
}

void
MooseApp::executeMeshModifiers()
{
  if (!_mesh_modifiers.empty())
  {
    TIME_SECTION(_execute_mesh_modifiers_timer);

    DependencyResolver&lt;std::shared_ptr&lt;MeshModifier&gt;&gt; resolver;

    // Add all of the dependencies into the resolver and sort them
    for (const auto &amp; it : _mesh_modifiers)
    {
      // Make sure an item with no dependencies comes out too!
      resolver.addItem(it.second);

      std::vector&lt;std::string&gt; &amp; modifiers = it.second-&gt;getDependencies();
      for (const auto &amp; depend_name : modifiers)
      {
        auto depend_it = _mesh_modifiers.find(depend_name);

        if (depend_it == _mesh_modifiers.end())
          mooseError(&quot;The MeshModifier \&quot;&quot;,
                     depend_name,
                     &quot;\&quot; was not created, did you make a &quot;
                     &quot;spelling mistake or forget to include it &quot;
                     &quot;in your input file?&quot;);

        resolver.insertDependency(it.second, depend_it-&gt;second);
      }
    }

    const auto &amp; ordered_modifiers = resolver.getSortedValues();

    if (ordered_modifiers.size())
    {
      MooseMesh * mesh = _action_warehouse.mesh().get();
      MooseMesh * displaced_mesh = _action_warehouse.displacedMesh().get();

      // Run the MeshModifiers in the proper order
      for (const auto &amp; modifier : ordered_modifiers)
        modifier-&gt;modifyMesh(mesh, displaced_mesh);

      /**
       * Set preparation flag after modifiers are run. The final preparation
       * will be handled by the SetupMeshComplete Action.
       */
      mesh-&gt;prepared(false);
      if (displaced_mesh)
        displaced_mesh-&gt;prepared(false);
    }
  }
}

void
MooseApp::clearMeshModifiers()
{
  _mesh_modifiers.clear();
}

void
MooseApp::addMeshGenerator(const std::string &amp; generator_name,
                           const std::string &amp; name,
                           InputParameters parameters)
{
  std::shared_ptr&lt;MeshGenerator&gt; mesh_generator =
      _factory.create&lt;MeshGenerator&gt;(generator_name, name, parameters);

  _mesh_generators.insert(std::make_pair(MooseUtils::shortName(name), mesh_generator));
}

const MeshGenerator &amp;
MooseApp::getMeshGenerator(const std::string &amp; name) const
{
  return *_mesh_generators.find(MooseUtils::shortName(name))-&gt;second.get();
}

std::vector&lt;std::string&gt;
MooseApp::getMeshGeneratorNames() const
{
  std::vector&lt;std::string&gt; names;
  for (auto &amp; pair : _mesh_generators)
    names.push_back(pair.first);
  return names;
}

std::unique_ptr&lt;MeshBase&gt; &amp;
MooseApp::getMeshGeneratorOutput(const std::string &amp; name)
{
  auto &amp; outputs = _mesh_generator_outputs[name];

  outputs.push_back(nullptr);

  return outputs.back();
}

void
MooseApp::executeMeshGenerators()
{
  if (!_mesh_generators.empty())
  {
    TIME_SECTION(_execute_mesh_generators_timer);

    DependencyResolver&lt;std::shared_ptr&lt;MeshGenerator&gt;&gt; resolver;

    // Add all of the dependencies into the resolver and sort them
    for (const auto &amp; it : _mesh_generators)
    {
      // Make sure an item with no dependencies comes out too!
      resolver.addItem(it.second);

      std::vector&lt;std::string&gt; &amp; generators = it.second-&gt;getDependencies();
      for (const auto &amp; depend_name : generators)
      {
        auto depend_it = _mesh_generators.find(depend_name);

        if (depend_it == _mesh_generators.end())
          mooseError(&quot;The MeshGenerator \&quot;&quot;,
                     depend_name,
                     &quot;\&quot; was not created, did you make a &quot;
                     &quot;spelling mistake or forget to include it &quot;
                     &quot;in your input file?&quot;);

        resolver.insertDependency(it.second, depend_it-&gt;second);
      }
    }

    const auto &amp; ordered_generators = resolver.getSortedValuesSets();

    if (ordered_generators.size())
    {
      auto &amp; final_generators = ordered_generators.back();

      if (_final_generator_name.empty())
      {
        // If the _final_generated_mesh wasn&#x27;t set from MeshGeneratorMesh, set it now
        _final_generator_name = final_generators.back()-&gt;name();

        // See if we have multiple independent trees of generators
        const auto ancestor_list = resolver.getAncestors(final_generators.back());
        if (ancestor_list.size() != resolver.size())
        {
          // Need to remove duplicates and possibly perform a difference so we&#x27;ll import out list
          // into a set for these operations.
          std::set&lt;std::shared_ptr&lt;MeshGenerator&gt;&gt; ancestors(ancestor_list.begin(),
                                                             ancestor_list.end());
          // Get all of the items from the resolver so we can compare against the tree from the
          // final generator we just pulled.
          const auto &amp; allValues = resolver.getSortedValues();
          decltype(ancestors) all(allValues.begin(), allValues.end());

          decltype(ancestors) ind_tree;
          std::set_difference(all.begin(),
                              all.end(),
                              ancestors.begin(),
                              ancestors.end(),
                              std::inserter(ind_tree, ind_tree.end()));

          std::ostringstream oss;
          oss &lt;&lt; &quot;Your MeshGenerator tree contains multiple possible generator outputs :\n\&quot;&quot;
              &lt;&lt; _final_generator_name
              &lt;&lt; &quot; and one or more of the following from an independent set: \&quot;&quot;;
          bool first = true;
          for (const auto &amp; gen : ind_tree)
          {
            if (!first)
              oss &lt;&lt; &quot;, &quot;;
            else
              first = false;

            oss &lt;&lt; gen-&gt;name();
          }
          oss &lt;&lt; &quot;\&quot;\n\nThis may be due to a missing dependency or may be intentional. Please &quot;
                 &quot;select the final MeshGenerator in\nthe [Mesh] block with the \&quot;final_generator\&quot; &quot;
                 &quot;parameter or add additional dependencies to remove the ambiguity.&quot;;
          mooseError(oss.str());
        }
      }

      // Grab the outputs from the final generator so MeshGeneratorMesh can pick them up
      _final_generated_meshes.emplace_back(&amp;getMeshGeneratorOutput(_final_generator_name));

      // Need to grab two if we&#x27;re going to be making a displaced mesh
      if (_action_warehouse.displacedMesh())
        _final_generated_meshes.emplace_back(&amp;getMeshGeneratorOutput(_final_generator_name));

      // Run the MeshGenerators in the proper order
      for (const auto &amp; generator_set : ordered_generators)
      {
        for (const auto &amp; generator : generator_set)
        {
          auto name = generator-&gt;name();

          auto current_mesh = generator-&gt;generate();

          // Now we need to possibly give this mesh to downstream generators
          auto &amp; outputs = _mesh_generator_outputs[name];

          if (outputs.size())
          {
            auto &amp; first_output = *outputs.begin();

            first_output = std::move(current_mesh);

            const auto &amp; copy_from = *first_output;

            auto output_it = ++outputs.begin();

            // For all of the rest we need to make a copy
            for (; output_it != outputs.end(); ++output_it)
              (*output_it) = copy_from.clone();
          }

          // Once we hit the generator we want, we&#x27;ll terminate the loops (this might be the last
          // iteration anyway)
          if (_final_generator_name == name)
            return;
        }
      }
    }
  }
}

void
MooseApp::setFinalMeshGeneratorName(const std::string &amp; generator_name)
{
  _final_generator_name = generator_name;
}

void
MooseApp::clearMeshGenerators()
{
  _mesh_generators.clear();
}

std::unique_ptr&lt;MeshBase&gt;
MooseApp::getMeshGeneratorMesh(bool check_unique)
{
  if (_popped_final_mesh_generator == true)
    mooseError(&quot;MooseApp::getMeshGeneratorMesh is being called for a second time. You cannot do &quot;
               &quot;this because the final generated mesh was popped from its storage container the &quot;
               &quot;first time this method was called&quot;);

  if (_final_generated_meshes.empty())
    mooseError(&quot;No generated mesh to retrieve. Your input file should contain either a [Mesh] or &quot;
               &quot;[MeshGenerators] block.&quot;);

  auto mesh_unique_ptr_ptr = _final_generated_meshes.front();
  _final_generated_meshes.pop_front();
  _popped_final_mesh_generator = true;

  if (check_unique &amp;&amp; !_final_generated_meshes.empty())
    mooseError(&quot;Multiple generated meshes exist while retrieving the final Mesh. This means that &quot;
               &quot;the selection of the final mesh is non-deterministic.&quot;);

  return std::move(*mesh_unique_ptr_ptr);
}

void
MooseApp::setRestart(bool value)
{
  _restart = value;

  std::shared_ptr&lt;FEProblemBase&gt; fe_problem = _action_warehouse.problemBase();
}

void
MooseApp::setRecover(bool value)
{
  _recover = value;
}

void
MooseApp::setBackupObject(std::shared_ptr&lt;Backup&gt; backup)
{
  _cached_backup = backup;
}

void
MooseApp::restoreCachedBackup()
{
  if (!_cached_backup.get())
    mooseError(&quot;No cached Backup to restore!&quot;);

  TIME_SECTION(_restore_cached_backup_timer);

  restore(_cached_backup, isRestarting());

  // Release our hold on this Backup
  _cached_backup.reset();
}

void
MooseApp::createMinimalApp()
{
  TIME_SECTION(_create_minimal_app_timer);

  // SetupMeshAction
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;SetupMeshAction&quot;);
    action_params.set&lt;std::string&gt;(&quot;type&quot;) = &quot;GeneratedMesh&quot;;

    // Create The Action
    std::shared_ptr&lt;MooseObjectAction&gt; action = std::static_pointer_cast&lt;MooseObjectAction&gt;(
        _action_factory.create(&quot;SetupMeshAction&quot;, &quot;Mesh&quot;, action_params));

    // Set the object parameters
    InputParameters &amp; params = action-&gt;getObjectParams();
    params.set&lt;MooseEnum&gt;(&quot;dim&quot;) = &quot;1&quot;;
    params.set&lt;unsigned int&gt;(&quot;nx&quot;) = 1;

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  // Executioner
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;CreateExecutionerAction&quot;);
    action_params.set&lt;std::string&gt;(&quot;type&quot;) = &quot;Transient&quot;;

    // Create the action
    std::shared_ptr&lt;MooseObjectAction&gt; action = std::static_pointer_cast&lt;MooseObjectAction&gt;(
        _action_factory.create(&quot;CreateExecutionerAction&quot;, &quot;Executioner&quot;, action_params));

    // Set the object parameters
    InputParameters &amp; params = action-&gt;getObjectParams();
    params.set&lt;unsigned int&gt;(&quot;num_steps&quot;) = 1;
    params.set&lt;Real&gt;(&quot;dt&quot;) = 1;

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  // Problem
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;CreateProblemDefaultAction&quot;);
    action_params.set&lt;bool&gt;(&quot;_solve&quot;) = false;

    // Create the action
    std::shared_ptr&lt;Action&gt; action = std::static_pointer_cast&lt;Action&gt;(
        _action_factory.create(&quot;CreateProblemDefaultAction&quot;, &quot;Problem&quot;, action_params));

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  // Outputs
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;CommonOutputAction&quot;);
    action_params.set&lt;bool&gt;(&quot;console&quot;) = false;

    // Create action
    std::shared_ptr&lt;Action&gt; action =
        _action_factory.create(&quot;CommonOutputAction&quot;, &quot;Outputs&quot;, action_params);

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  _action_warehouse.build();
}

void
MooseApp::addExecFlag(const ExecFlagType &amp; flag)
{
  if (flag.id() == MooseEnumItem::INVALID_ID)
  {
    // It is desired that users when creating ExecFlagTypes should not worry about needing
    // to assign a name and an ID. However, the ExecFlagTypes created by users are global
    // constants and the ID to be assigned can&#x27;t be known at construction time of this global
    // constant, it is only known when it is added to this object (ExecFlagEnum). Therefore,
    // this const cast allows the ID to be set after construction. This was the lesser of two
    // evils: const_cast or friend class with mutable members.
    ExecFlagType &amp; non_const_flag = const_cast&lt;ExecFlagType &amp;&gt;(flag);
    auto it = _execute_flags.find(flag.name());
    if (it != _execute_flags.items().end())
      non_const_flag.setID(it-&gt;id());
    else
      non_const_flag.setID(_execute_flags.getNextValidID());
  }
  _execute_flags.addAvailableFlags(flag);
}

bool
MooseApp::hasRelationshipManager(const std::string &amp; name) const
{
  return std::find_if(_relationship_managers.begin(),
                      _relationship_managers.end(),
                      [&amp;name](const std::shared_ptr&lt;RelationshipManager&gt; &amp; rm) {
                        return rm-&gt;name() == name;
                      }) != _relationship_managers.end();
}

bool
MooseApp::addRelationshipManager(std::shared_ptr&lt;RelationshipManager&gt; relationship_manager)
{
  // We don&#x27;t need Geometric-only RelationshipManagers when we run with
  // ReplicatedMesh unless we are splitting the mesh.
  if (!_action_warehouse.mesh()-&gt;isDistributedMesh() &amp;&amp; !_split_mesh &amp;&amp;
      (relationship_manager-&gt;isType(Moose::RelationshipManagerType::GEOMETRIC) &amp;&amp;
       !(relationship_manager-&gt;isType(Moose::RelationshipManagerType::ALGEBRAIC) ||
         relationship_manager-&gt;isType(Moose::RelationshipManagerType::COUPLING))))
    return false;

  bool add = true;
  for (const auto &amp; rm : _relationship_managers)
  {
    if (*rm == *relationship_manager)
    {
      add = false;

      auto &amp; existing_for_whom = rm-&gt;forWhom();

      // Since the existing object is going to cover this one
      // Pass along who is needing it
      for (auto &amp; fw : relationship_manager-&gt;forWhom())
      {
        if (std::find(existing_for_whom.begin(), existing_for_whom.end(), fw) ==
            existing_for_whom.end())
          rm-&gt;addForWhom(fw);
      }

      break;
    }
  }

  if (add)
    _relationship_managers.emplace_back(relationship_manager);

  // Inform the caller whether the object was added or not
  return add;
}

void
MooseApp::attachRelationshipManagers(Moose::RelationshipManagerType rm_type)
{
  for (auto &amp; rm : _relationship_managers)
  {
    if (rm-&gt;isType(rm_type))
    {
      // Will attach them later (during algebraic)
      if (rm_type == Moose::RelationshipManagerType::GEOMETRIC &amp;&amp; !rm-&gt;attachGeometricEarly())
        continue;

      if (rm_type == Moose::RelationshipManagerType::GEOMETRIC)
      {
        // The problem is not built yet - so the ActionWarehouse currently owns the mesh
        auto &amp; mesh = _action_warehouse.mesh();

        rm-&gt;init();

        if (rm-&gt;useDisplacedMesh() &amp;&amp; _action_warehouse.displacedMesh())
          _action_warehouse.displacedMesh()-&gt;getMesh().add_ghosting_functor(*rm);
        else
          mesh-&gt;getMesh().add_ghosting_functor(*rm);
      }

      if (rm_type != Moose::RelationshipManagerType::GEOMETRIC)
      {
        // Now we&#x27;ve built the problem, so we can use it
        auto &amp; problem = _executioner-&gt;feProblem();

        // Ensure that the relationship manager is initialized
        rm-&gt;init();

        // If it&#x27;s also Geometric but didn&#x27;t get attached early - then let&#x27;s attach it now
        if (rm-&gt;isType(Moose::RelationshipManagerType::GEOMETRIC) &amp;&amp; !rm-&gt;attachGeometricEarly())
        {
          if (rm-&gt;useDisplacedMesh() &amp;&amp; _action_warehouse.displacedMesh())
            _action_warehouse.displacedMesh()-&gt;getMesh().add_ghosting_functor(*rm);
          else
            problem.mesh().getMesh().add_ghosting_functor(*rm);
        }

        if (rm-&gt;useDisplacedMesh() &amp;&amp; problem.getDisplacedProblem())
        {
          if (rm_type == Moose::RelationshipManagerType::COUPLING)
          {
            // We actually need to add this to the FEProblemBase NonlinearSystemBase&#x27;s DofMap
            // because the DisplacedProblem &quot;nonlinear&quot; DisplacedSystem doesn&#x27;t have any matrices
            // for which to do coupling
            auto &amp; dof_map = problem.getNonlinearSystemBase().dofMap();
            dof_map.add_coupling_functor(*rm, /*to_mesh = */ false);
            rm-&gt;setDofMap(dof_map);
          }
          // If this rm is algebraic AND coupling, then in the case of the non-linear system there
          // is no reason to add it to the DofMap twice. In the case of the aux system, it actually
          // would be disastrous to add this rm because it&#x27;s going to set a coupling matrix based on
          // the non-linear system. So we don&#x27;t add this rm to either system here if its also a
          // coupling functor
          else if (rm_type == Moose::RelationshipManagerType::ALGEBRAIC &amp;&amp;
                   !rm-&gt;isType(Moose::RelationshipManagerType::COUPLING))
          {
            problem.getDisplacedProblem()-&gt;nlSys().dofMap().add_algebraic_ghosting_functor(
                *rm, /*to_mesh = */ false);
            problem.getDisplacedProblem()-&gt;auxSys().dofMap().add_algebraic_ghosting_functor(
                *rm, /*to_mesh = */ false);
          }
        }
        else // undisplaced
        {
          if (rm_type == Moose::RelationshipManagerType::COUPLING)
          {
            auto &amp; dof_map = problem.getNonlinearSystemBase().dofMap();
            dof_map.add_coupling_functor(*rm, /*to_mesh = */ false);
            rm-&gt;setDofMap(dof_map);
          }
          // If this rm is algebraic AND coupling, then in the case of the non-linear system there
          // is no reason to add it to the DofMap twice. In the case of the aux system, it actually
          // would be disastrous to add this rm because it&#x27;s going to set a coupling matrix based on
          // the non-linear system. So we don&#x27;t add this rm to either system here if its also a
          // coupling functor
          else if (rm_type == Moose::RelationshipManagerType::ALGEBRAIC &amp;&amp;
                   !rm-&gt;isType(Moose::RelationshipManagerType::COUPLING))
          {
            problem.getNonlinearSystemBase().dofMap().add_algebraic_ghosting_functor(
                *rm, /*to_mesh = */ false);
            problem.getAuxiliarySystem().dofMap().add_algebraic_ghosting_functor(
                *rm, /*to_mesh = */ false);
          }
        }
      }
    }
  }
}

std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt;
MooseApp::getRelationshipManagerInfo() const
{
  std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; info_strings;
  info_strings.reserve(_relationship_managers.size());

  for (const auto &amp; rm : _relationship_managers)
  {
    std::stringstream oss;
    oss &lt;&lt; rm-&gt;getInfo();

    auto &amp; for_whom = rm-&gt;forWhom();

    if (!for_whom.empty())
    {
      oss &lt;&lt; &quot; for &quot;;

      std::copy(for_whom.begin(), for_whom.end(), infix_ostream_iterator&lt;std::string&gt;(oss, &quot;, &quot;));
    }

    info_strings.emplace_back(std::make_pair(Moose::stringify(rm-&gt;getType()), oss.str()));
  }

  // List the libMesh GhostingFunctors - Not that in libMesh all of the algebraic and coupling
  // Ghosting Functors are also attached to the mesh. This should catch them all.
  const auto &amp; mesh = _action_warehouse.getMesh();
  if (mesh)
  {
    std::unordered_map&lt;std::string, unsigned int&gt; counts;

    for (auto &amp; gf : as_range(mesh-&gt;getMesh().ghosting_functors_begin(),
                              mesh-&gt;getMesh().ghosting_functors_end()))
    {
      const auto * gf_ptr = dynamic_cast&lt;const RelationshipManager *&gt;(gf);
      if (!gf_ptr)
        // Count how many occurances of the same Ghosting Functor types we are encountering
        counts[demangle(typeid(*gf).name())]++;
    }

    for (const auto pair : counts)
      info_strings.emplace_back(std::make_pair(
          &quot;Default&quot;, pair.first + (pair.second &gt; 1 ? &quot; x &quot; + std::to_string(pair.second) : &quot;&quot;)));
  }

  return info_strings;
}

void
MooseApp::dofMapReinitForRMs()
{
  for (auto &amp; rm : _relationship_managers)
    rm-&gt;dofmap_reinit();
}

void
MooseApp::meshReinitForRMs()
{
  for (auto &amp; rm : _relationship_managers)
    rm-&gt;mesh_reinit();
}

void
MooseApp::checkMeshMetaDataIntegrity() const
{
  std::vector&lt;std::string&gt; not_declared;

  for (const auto &amp; pair : _mesh_meta_data_map)
    if (!pair.second.declared)
      not_declared.push_back(pair.first);

  if (!not_declared.empty())
  {
    std::ostringstream oss;
    std::copy(
        not_declared.begin(), not_declared.end(), infix_ostream_iterator&lt;std::string&gt;(oss, &quot;, &quot;));

    mooseError(&quot;The following Mesh meta-data properties were retrieved but never declared: &quot;,
               oss.str());
  }
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="84605559-094f-49e3-a523-be7c142698f3" data-section-level="2" data-section-text="Modifying Execute On"><h2 id="modifying-execute-on">Modifying Execute On</h2><p>When creating objects that inherit from SetupInterface it is possible to set, add, or remove available execute flags by retrieving and then modifying the <code>ExecFlagEnum</code> parameter. For example, consider the snippet below (see <a href="#1a4a2a14-1cbc-415a-af5f-c7686805adf1" class="modal-trigger">Output.C</a>).</p><div class="modal moose-modal" id="1a4a2a14-1cbc-415a-af5f-c7686805adf1"><div class="modal-content"><h4>/home/gary/projects/moose/framework/src/outputs/Output.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Standard includes
#include &lt;math.h&gt;

// MOOSE includes
#include &quot;Output.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Postprocessor.h&quot;
#include &quot;Restartable.h&quot;
#include &quot;FileMesh.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Console.h&quot;
#include &quot;TimedPrint.h&quot;

#include &quot;libmesh/equation_systems.h&quot;

defineLegacyParams(Output);

InputParameters
Output::validParams()
{
  // Get the parameters from the parent object
  InputParameters params = MooseObject::validParams();
  params += SetupInterface::validParams();

  // Displaced Mesh options
  params.addParam&lt;bool&gt;(
      &quot;use_displaced&quot;, false, &quot;Enable/disable the use of the displaced mesh for outputting&quot;);

  // Output intervals and timing
  params.addParam&lt;unsigned int&gt;(
      &quot;interval&quot;, 1, &quot;The interval at which time steps are output to the solution file&quot;);
  params.addParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;,
                                     &quot;Times at which the output and solution is forced to occur&quot;);
  params.addParam&lt;bool&gt;(&quot;sync_only&quot;, false, &quot;Only export results at sync times&quot;);
  params.addParam&lt;Real&gt;(&quot;start_time&quot;, &quot;Time at which this output object begins to operate&quot;);
  params.addParam&lt;Real&gt;(&quot;end_time&quot;, &quot;Time at which this output object stop operating&quot;);
  params.addParam&lt;int&gt;(&quot;start_step&quot;, &quot;Time step at which this output object begins to operate&quot;);
  params.addParam&lt;int&gt;(&quot;end_step&quot;, &quot;Time step at which this output object stop operating&quot;);
  params.addParam&lt;Real&gt;(
      &quot;time_tolerance&quot;, 1e-14, &quot;Time tolerance utilized checking start and end times&quot;);

  // Update the &#x27;execute_on&#x27; input parameter for output
  ExecFlagEnum &amp; exec_enum = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true);
  exec_enum = Output::getDefaultExecFlagEnum();
  exec_enum = {EXEC_INITIAL, EXEC_TIMESTEP_END};
  params.setDocString(&quot;execute_on&quot;, exec_enum.getDocString());

  // Add ability to append to the &#x27;execute_on&#x27; list
  params.addParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;, exec_enum, exec_enum.getDocString());
  params.set&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;).clear();

  // &#x27;Timing&#x27; group
  params.addParamNamesToGroup(&quot;time_tolerance interval sync_times sync_only start_time end_time &quot;,
                              &quot;Timing&quot;);

  // Add a private parameter for indicating if it was created with short-cut syntax
  params.addPrivateParam&lt;bool&gt;(&quot;_built_by_moose&quot;, false);

  // Register this class as base class
  params.declareControllable(&quot;enable&quot;);
  params.registerBase(&quot;Output&quot;);

  return params;
}

ExecFlagEnum
Output::getDefaultExecFlagEnum()
{
  ExecFlagEnum exec_enum = MooseUtils::getDefaultExecFlagEnum();
  exec_enum.addAvailableFlags(EXEC_FAILED);
  return exec_enum;
}

Output::Output(const InputParameters &amp; parameters)
  : MooseObject(parameters),
    Restartable(this, &quot;Output&quot;),
    MeshChangedInterface(parameters),
    SetupInterface(this),
    PerfGraphInterface(this),
    _problem_ptr(getParam&lt;FEProblemBase *&gt;(&quot;_fe_problem_base&quot;)),
    _transient(_problem_ptr-&gt;isTransient()),
    _use_displaced(getParam&lt;bool&gt;(&quot;use_displaced&quot;)),
    _es_ptr(nullptr),
    _mesh_ptr(nullptr),
    _execute_on(getParam&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;)),
    _time(_problem_ptr-&gt;time()),
    _time_old(_problem_ptr-&gt;timeOld()),
    _t_step(_problem_ptr-&gt;timeStep()),
    _dt(_problem_ptr-&gt;dt()),
    _dt_old(_problem_ptr-&gt;dtOld()),
    _num(0),
    _interval(getParam&lt;unsigned int&gt;(&quot;interval&quot;)),
    _sync_times(std::set&lt;Real&gt;(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).begin(),
                               getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).end())),
    _start_time(isParamValid(&quot;start_time&quot;) ? getParam&lt;Real&gt;(&quot;start_time&quot;)
                                           : std::numeric_limits&lt;Real&gt;::lowest()),
    _end_time(isParamValid(&quot;end_time&quot;) ? getParam&lt;Real&gt;(&quot;end_time&quot;)
                                       : std::numeric_limits&lt;Real&gt;::max()),
    _start_step(isParamValid(&quot;start_step&quot;) ? getParam&lt;int&gt;(&quot;start_step&quot;)
                                           : std::numeric_limits&lt;int&gt;::lowest()),
    _end_step(isParamValid(&quot;end_step&quot;) ? getParam&lt;int&gt;(&quot;end_step&quot;)
                                       : std::numeric_limits&lt;int&gt;::max()),
    _t_tol(getParam&lt;Real&gt;(&quot;time_tolerance&quot;)),
    _sync_only(getParam&lt;bool&gt;(&quot;sync_only&quot;)),
    _initialized(false),
    _allow_output(true),
    _is_advanced(false),
    _advanced_execute_on(_execute_on, parameters),
    _output_step_timer(registerTimedSection(&quot;outputStep&quot;, 2))
{
  if (_use_displaced)
  {
    std::shared_ptr&lt;DisplacedProblem&gt; dp = _problem_ptr-&gt;getDisplacedProblem();
    if (dp != nullptr)
    {
      _es_ptr = &amp;dp-&gt;es();
      _mesh_ptr = &amp;dp-&gt;mesh();
    }
    else
    {
      mooseWarning(
          name(),
          &quot;: Parameter &#x27;use_displaced&#x27; ignored, there is no displaced problem in your simulation.&quot;);
      _es_ptr = &amp;_problem_ptr-&gt;es();
      _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
    }
  }
  else
  {
    _es_ptr = &amp;_problem_ptr-&gt;es();
    _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
  }

  // Apply the additional output flags
  if (isParamValid(&quot;additional_execute_on&quot;))
  {
    const ExecFlagEnum &amp; add = getParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;);
    for (auto &amp; me : add)
      _execute_on.push_back(me);
  }
}

void
Output::initialSetup()
{
  _initialized = true;
}

void
Output::solveSetup()
{
}

void
Output::outputStep(const ExecFlagType &amp; type)
{
  CONSOLE_TIMED_PRINT(&quot;Outputting &quot;, name());

  // Output is not allowed
  if (!_allow_output &amp;&amp; type != EXEC_FORCED)
    return;

  // If recovering disable output of initial condition, it was already output
  if (type == EXEC_INITIAL &amp;&amp; _app.isRecovering())
    return;

  // Return if the current output is not on the desired interval
  if (type != EXEC_FINAL &amp;&amp; !onInterval())
    return;

  // Call the output method
  if (shouldOutput(type))
  {
    TIME_SECTION(_output_step_timer);
    output(type);
  }
}

bool
Output::shouldOutput(const ExecFlagType &amp; type)
{
  // Note that in older versions of MOOSE, this was overloaded (unintentionally) to always return
  // true for the Console output subclass - basically ignoring execute_on options specified for
  // the console (e.g. via the input file).
  if (_execute_on.contains(type) || type == EXEC_FORCED)
    return true;
  return false;
}

bool
Output::onInterval()
{
  // The output flag to return
  bool output = false;

  // Return true if the current step on the current output interval and within the output time range
  // and within the output step range
  if (_time &gt;= _start_time &amp;&amp; _time &lt;= _end_time &amp;&amp; _t_step &gt;= _start_step &amp;&amp;
      _t_step &lt;= _end_step &amp;&amp; (_t_step % _interval) == 0)
    output = true;

  // Return false if &#x27;sync_only&#x27; is set to true
  if (_sync_only)
    output = false;

  // If sync times are not skipped, return true if the current time is a sync_time
  if (_sync_times.find(_time) != _sync_times.end())
    output = true;

  // Return the output status
  return output;
}

Real
Output::time()
{
  if (_transient)
    return _time;
  else
    return _t_step;
}

Real
Output::timeOld()
{
  if (_transient)
    return _time_old;
  else
    return _t_step - 1;
}

Real
Output::dt()
{
  if (_transient)
    return _dt;
  else
    return 1;
}

Real
Output::dtOld()
{
  if (_transient)
    return _dt_old;
  else
    return 1;
}

int
Output::timeStep()
{
  return _t_step;
}

const MultiMooseEnum &amp;
Output::executeOn() const
{
  return _execute_on;
}

bool
Output::isAdvanced()
{
  return _is_advanced;
}

const OutputOnWarehouse &amp;
Output::advancedExecuteOn() const
{
  mooseError(&quot;The output object &quot;, name(), &quot; is not an AdvancedOutput, use isAdvanced() to check.&quot;);
  return _advanced_execute_on;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><pre class="moose-pre"><code class="language-cpp">  ExecFlagEnum &amp; exec_enum = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true);
  exec_enum = Output::getDefaultExecFlagEnum();
  exec_enum = {EXEC_INITIAL, EXEC_TIMESTEP_END};
  params.setDocString(&quot;execute_on&quot;, exec_enum.getDocString());
</code></pre><a href="#c089d000-7dbb-4bb7-819f-fe610be7ad40" class="modal-trigger">(../moose/framework/src/outputs/Output.C)</a><div class="modal moose-modal" id="c089d000-7dbb-4bb7-819f-fe610be7ad40"><div class="modal-content"><h4>/home/gary/projects/moose/framework/src/outputs/Output.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Standard includes
#include &lt;math.h&gt;

// MOOSE includes
#include &quot;Output.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Postprocessor.h&quot;
#include &quot;Restartable.h&quot;
#include &quot;FileMesh.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Console.h&quot;
#include &quot;TimedPrint.h&quot;

#include &quot;libmesh/equation_systems.h&quot;

defineLegacyParams(Output);

InputParameters
Output::validParams()
{
  // Get the parameters from the parent object
  InputParameters params = MooseObject::validParams();
  params += SetupInterface::validParams();

  // Displaced Mesh options
  params.addParam&lt;bool&gt;(
      &quot;use_displaced&quot;, false, &quot;Enable/disable the use of the displaced mesh for outputting&quot;);

  // Output intervals and timing
  params.addParam&lt;unsigned int&gt;(
      &quot;interval&quot;, 1, &quot;The interval at which time steps are output to the solution file&quot;);
  params.addParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;,
                                     &quot;Times at which the output and solution is forced to occur&quot;);
  params.addParam&lt;bool&gt;(&quot;sync_only&quot;, false, &quot;Only export results at sync times&quot;);
  params.addParam&lt;Real&gt;(&quot;start_time&quot;, &quot;Time at which this output object begins to operate&quot;);
  params.addParam&lt;Real&gt;(&quot;end_time&quot;, &quot;Time at which this output object stop operating&quot;);
  params.addParam&lt;int&gt;(&quot;start_step&quot;, &quot;Time step at which this output object begins to operate&quot;);
  params.addParam&lt;int&gt;(&quot;end_step&quot;, &quot;Time step at which this output object stop operating&quot;);
  params.addParam&lt;Real&gt;(
      &quot;time_tolerance&quot;, 1e-14, &quot;Time tolerance utilized checking start and end times&quot;);

  // Update the &#x27;execute_on&#x27; input parameter for output
  ExecFlagEnum &amp; exec_enum = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true);
  exec_enum = Output::getDefaultExecFlagEnum();
  exec_enum = {EXEC_INITIAL, EXEC_TIMESTEP_END};
  params.setDocString(&quot;execute_on&quot;, exec_enum.getDocString());

  // Add ability to append to the &#x27;execute_on&#x27; list
  params.addParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;, exec_enum, exec_enum.getDocString());
  params.set&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;).clear();

  // &#x27;Timing&#x27; group
  params.addParamNamesToGroup(&quot;time_tolerance interval sync_times sync_only start_time end_time &quot;,
                              &quot;Timing&quot;);

  // Add a private parameter for indicating if it was created with short-cut syntax
  params.addPrivateParam&lt;bool&gt;(&quot;_built_by_moose&quot;, false);

  // Register this class as base class
  params.declareControllable(&quot;enable&quot;);
  params.registerBase(&quot;Output&quot;);

  return params;
}

ExecFlagEnum
Output::getDefaultExecFlagEnum()
{
  ExecFlagEnum exec_enum = MooseUtils::getDefaultExecFlagEnum();
  exec_enum.addAvailableFlags(EXEC_FAILED);
  return exec_enum;
}

Output::Output(const InputParameters &amp; parameters)
  : MooseObject(parameters),
    Restartable(this, &quot;Output&quot;),
    MeshChangedInterface(parameters),
    SetupInterface(this),
    PerfGraphInterface(this),
    _problem_ptr(getParam&lt;FEProblemBase *&gt;(&quot;_fe_problem_base&quot;)),
    _transient(_problem_ptr-&gt;isTransient()),
    _use_displaced(getParam&lt;bool&gt;(&quot;use_displaced&quot;)),
    _es_ptr(nullptr),
    _mesh_ptr(nullptr),
    _execute_on(getParam&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;)),
    _time(_problem_ptr-&gt;time()),
    _time_old(_problem_ptr-&gt;timeOld()),
    _t_step(_problem_ptr-&gt;timeStep()),
    _dt(_problem_ptr-&gt;dt()),
    _dt_old(_problem_ptr-&gt;dtOld()),
    _num(0),
    _interval(getParam&lt;unsigned int&gt;(&quot;interval&quot;)),
    _sync_times(std::set&lt;Real&gt;(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).begin(),
                               getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).end())),
    _start_time(isParamValid(&quot;start_time&quot;) ? getParam&lt;Real&gt;(&quot;start_time&quot;)
                                           : std::numeric_limits&lt;Real&gt;::lowest()),
    _end_time(isParamValid(&quot;end_time&quot;) ? getParam&lt;Real&gt;(&quot;end_time&quot;)
                                       : std::numeric_limits&lt;Real&gt;::max()),
    _start_step(isParamValid(&quot;start_step&quot;) ? getParam&lt;int&gt;(&quot;start_step&quot;)
                                           : std::numeric_limits&lt;int&gt;::lowest()),
    _end_step(isParamValid(&quot;end_step&quot;) ? getParam&lt;int&gt;(&quot;end_step&quot;)
                                       : std::numeric_limits&lt;int&gt;::max()),
    _t_tol(getParam&lt;Real&gt;(&quot;time_tolerance&quot;)),
    _sync_only(getParam&lt;bool&gt;(&quot;sync_only&quot;)),
    _initialized(false),
    _allow_output(true),
    _is_advanced(false),
    _advanced_execute_on(_execute_on, parameters),
    _output_step_timer(registerTimedSection(&quot;outputStep&quot;, 2))
{
  if (_use_displaced)
  {
    std::shared_ptr&lt;DisplacedProblem&gt; dp = _problem_ptr-&gt;getDisplacedProblem();
    if (dp != nullptr)
    {
      _es_ptr = &amp;dp-&gt;es();
      _mesh_ptr = &amp;dp-&gt;mesh();
    }
    else
    {
      mooseWarning(
          name(),
          &quot;: Parameter &#x27;use_displaced&#x27; ignored, there is no displaced problem in your simulation.&quot;);
      _es_ptr = &amp;_problem_ptr-&gt;es();
      _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
    }
  }
  else
  {
    _es_ptr = &amp;_problem_ptr-&gt;es();
    _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
  }

  // Apply the additional output flags
  if (isParamValid(&quot;additional_execute_on&quot;))
  {
    const ExecFlagEnum &amp; add = getParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;);
    for (auto &amp; me : add)
      _execute_on.push_back(me);
  }
}

void
Output::initialSetup()
{
  _initialized = true;
}

void
Output::solveSetup()
{
}

void
Output::outputStep(const ExecFlagType &amp; type)
{
  CONSOLE_TIMED_PRINT(&quot;Outputting &quot;, name());

  // Output is not allowed
  if (!_allow_output &amp;&amp; type != EXEC_FORCED)
    return;

  // If recovering disable output of initial condition, it was already output
  if (type == EXEC_INITIAL &amp;&amp; _app.isRecovering())
    return;

  // Return if the current output is not on the desired interval
  if (type != EXEC_FINAL &amp;&amp; !onInterval())
    return;

  // Call the output method
  if (shouldOutput(type))
  {
    TIME_SECTION(_output_step_timer);
    output(type);
  }
}

bool
Output::shouldOutput(const ExecFlagType &amp; type)
{
  // Note that in older versions of MOOSE, this was overloaded (unintentionally) to always return
  // true for the Console output subclass - basically ignoring execute_on options specified for
  // the console (e.g. via the input file).
  if (_execute_on.contains(type) || type == EXEC_FORCED)
    return true;
  return false;
}

bool
Output::onInterval()
{
  // The output flag to return
  bool output = false;

  // Return true if the current step on the current output interval and within the output time range
  // and within the output step range
  if (_time &gt;= _start_time &amp;&amp; _time &lt;= _end_time &amp;&amp; _t_step &gt;= _start_step &amp;&amp;
      _t_step &lt;= _end_step &amp;&amp; (_t_step % _interval) == 0)
    output = true;

  // Return false if &#x27;sync_only&#x27; is set to true
  if (_sync_only)
    output = false;

  // If sync times are not skipped, return true if the current time is a sync_time
  if (_sync_times.find(_time) != _sync_times.end())
    output = true;

  // Return the output status
  return output;
}

Real
Output::time()
{
  if (_transient)
    return _time;
  else
    return _t_step;
}

Real
Output::timeOld()
{
  if (_transient)
    return _time_old;
  else
    return _t_step - 1;
}

Real
Output::dt()
{
  if (_transient)
    return _dt;
  else
    return 1;
}

Real
Output::dtOld()
{
  if (_transient)
    return _dt_old;
  else
    return 1;
}

int
Output::timeStep()
{
  return _t_step;
}

const MultiMooseEnum &amp;
Output::executeOn() const
{
  return _execute_on;
}

bool
Output::isAdvanced()
{
  return _is_advanced;
}

const OutputOnWarehouse &amp;
Output::advancedExecuteOn() const
{
  mooseError(&quot;The output object &quot;, name(), &quot; is not an AdvancedOutput, use isAdvanced() to check.&quot;);
  return _advanced_execute_on;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>First, the &quot;execute_on&quot; is retrieved for modification by using the &quot;set&quot; method. Notice, that a second boolean argument is passed to &quot;set&quot;, this second flag enables &quot;quite mode&quot;. Quite mode will modify the parameter silently as if the default was the modified parameter. In this case, the parameter will be listed as un-modified by the user. That is, <code>InputParameters::isParamSetByUser</code> returns false, if quite mode is not enabled this method would return true.</p><p>Second, the two new execution flags are added (<code>EXEC_FINAL</code> and <code>EXEC_FAILED</code>), therefore these additional options are available to all classes (all Output objects in this case) that inherit from this object.</p><p>Third, the default active flags are set to <code>EXEC_INITIAL</code> and <code>EXEC_TIMESTEP_END</code>, which are the defaults for all Output objects.</p><p>Finally, the documentation string for the &quot;execute_on&quot; parameter for the Output objects is update to reflect the changes made to the parameter. The <code>ExecFlagEnum</code> has a convenience function that generates a documentation string that includes the available options in the string.</p></section><section class="scrollspy" id="cccd60e7-51ac-4cec-a130-102e57838b22" data-section-level="2" data-section-text="Virtual Setup Methods"><h2 id="virtual-setup-methods">Virtual Setup Methods</h2><p>The SetupInterface includes virtual methods that correspond to the primary execute flags with MOOSE, these methods are listed in the header as shown here.</p><pre class="moose-pre"><code class="language-cpp">static InputParameters validParams();
/**
* Gets called at the beginning of the simulation before this object is asked to do its job
*/
virtual void initialSetup();
/**
* Gets called at the beginning of the timestep before this object is asked to do its job
*/
virtual void timestepSetup();
/**
* Gets called just before the Jacobian is computed and before this object is asked to do its job
*/
virtual void jacobianSetup();
/**
* Gets called just before the residual is computed and before this object is asked to do its job
*/
virtual void residualSetup();
/**
* Gets called when the subdomain changes (i.e. in a Jacobian or residual loop) and before this
* object is asked to do its job
*/
virtual void subdomainSetup();
</code></pre><a href="#bbacf226-8082-486f-91c0-821dc6e79819" class="modal-trigger">(../moose/framework/include/interfaces/SetupInterface.h)</a><div class="modal moose-modal" id="bbacf226-8082-486f-91c0-821dc6e79819"><div class="modal-content"><h4>/home/gary/projects/moose/framework/include/interfaces/SetupInterface.h</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;MooseTypes.h&quot;
#include &quot;ExecFlagEnum.h&quot;
#include &quot;MooseEnum.h&quot;
#include &quot;InputParameters.h&quot;

// Forward declarations
class InputParameters;
class MooseObject;
class SetupInterface;

template &lt;typename T&gt;
InputParameters validParams();

template &lt;&gt;
InputParameters validParams&lt;SetupInterface&gt;();

class SetupInterface
{
public:
  SetupInterface(const MooseObject * moose_object);
  virtual ~SetupInterface();

  static InputParameters validParams();

  /**
   * Gets called at the beginning of the simulation before this object is asked to do its job
   */
  virtual void initialSetup();

  /**
   * Gets called at the beginning of the timestep before this object is asked to do its job
   */
  virtual void timestepSetup();

  /**
   * Gets called just before the Jacobian is computed and before this object is asked to do its job
   */
  virtual void jacobianSetup();

  /**
   * Gets called just before the residual is computed and before this object is asked to do its job
   */
  virtual void residualSetup();

  /**
   * Gets called when the subdomain changes (i.e. in a Jacobian or residual loop) and before this
   * object is asked to do its job
   */
  virtual void subdomainSetup();

  /**
   * Return the execute on MultiMooseEnum for this object.
   */
  const ExecFlagEnum &amp; getExecuteOnEnum() const;

  /**
   * (DEPRECATED) Get the execution flag for the object
   * TODO: ExecFlagType
   */
  virtual const std::vector&lt;ExecFlagType&gt; &amp; execFlags() const;

  /**
   * (DEPRECATED) Build and return the execution flags as a bitfield
   * TODO: ExecFlagType
   */
  ExecFlagType execBitFlags() const;

  /**
   * (DEPRECATED) Returns the available options for the &#x27;execute_on&#x27; input parameters
   * TODO: ExecFlagType
   * @return A MooseEnum with the available &#x27;execute_on&#x27; options, the default is &#x27;residual&#x27;
   */
  static ExecFlagEnum getExecuteOptions();

private:
  /// Empty ExecFlagEnum for the case when the &quot;execute_on&quot; parameter is not included. This
  /// is private because others should not be messing with it.
  ExecFlagEnum _empty_execute_enum;

protected:
  /// Execute settings for this oejct.
  const ExecFlagEnum &amp; _execute_enum;

  /// (DEPRECATED) execution flag (when is the object executed/evaluated) TODO: ExecFlagType
  const std::vector&lt;ExecFlagType&gt; _exec_flags;

  /// Reference to FEProblemBase
  const ExecFlagType &amp; _current_execute_flag;

  // FEProblemBase::addMultiApp needs to reset the execution flags
  friend class FEProblemBase;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>In general, these methods should be utilized to perform &quot;setup&quot; procedures prior to the calls to execute for the corresponding execute flag.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p><p>A few of the methods were created prior to the execute flags, thus the names do not correspond but they remain as is to keep the API consistent: the &quot;jacobianSetup&quot; methods is called prior to the &quot;NONLINEAR&quot; execute flag and the &quot;residualSetup&quot; is called prior to the &quot;LINEAR&quot; execute flag.</p></p></div></div></div></section><section class="scrollspy" id="28f43f09-ad45-4fd6-9f84-77f1484b899e" data-section-level="2" data-section-text="Creating Custom Execute Flags"><h2 id="creating-custom-execute-flags">Creating Custom Execute Flags</h2><p>It is possible to create custom execute flags for an application. To create at utilize a custom execute flag the following steps should be followed.</p><section id="b325e945-8616-4328-b2b1-a99df623b15a" data-section-level="3" data-section-text="1 . Declare and Define an Execute Flag"><h3 id="1-declare-and-define-an-execute-flag">1. Declare and Define an Execute Flag</h3><p>Within your application a new global <code>const</code> should be declared in a header file. For example, within the <code>LevelSetApp</code> within MOOSE modules, there is a header (LevelSetTypes.h) that declares a new flag (<code>EXEC_ADAPT_MESH</code>).</p><pre class="moose-pre"><code class="language-cpp">
#pragma once

#include &quot;Moose.h&quot;

namespace LevelSet
{
extern const ExecFlagType EXEC_ADAPT_MESH;
extern const ExecFlagType EXEC_COMPUTE_MARKERS;
}
</code></pre><a href="#5d687ca3-b054-406c-9251-b6a10d15caa0" class="modal-trigger">(../moose/modules/level_set/include/base/LevelSetTypes.h)</a><div class="modal moose-modal" id="5d687ca3-b054-406c-9251-b6a10d15caa0"><div class="modal-content"><h4>/home/gary/projects/moose/modules/level_set/include/base/LevelSetTypes.h</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Moose.h&quot;

namespace LevelSet
{
extern const ExecFlagType EXEC_ADAPT_MESH;
extern const ExecFlagType EXEC_COMPUTE_MARKERS;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>This new global must be defined, which occurs in the corresponding source file. When defining the new flags with a name and optionally an integer value.</p><pre class="moose-pre"><code class="language-cpp">
// Level set includes
#include &quot;LevelSetTypes.h&quot;

// MOOSE includes
#include &quot;MooseEnumItem.h&quot;

const ExecFlagType LevelSet::EXEC_ADAPT_MESH(&quot;ADAPT_MESH&quot;);
const ExecFlagType LevelSet::EXEC_COMPUTE_MARKERS(&quot;COMPUTE_MARKERS&quot;, 1234);
</code></pre><a href="#848f0103-69a8-4809-a8e5-2ce8f3536a69" class="modal-trigger">(../moose/modules/level_set/src/base/LevelSetTypes.C)</a><div class="modal moose-modal" id="848f0103-69a8-4809-a8e5-2ce8f3536a69"><div class="modal-content"><h4>/home/gary/projects/moose/modules/level_set/src/base/LevelSetTypes.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Level set includes
#include &quot;LevelSetTypes.h&quot;

// MOOSE includes
#include &quot;MooseEnumItem.h&quot;

const ExecFlagType LevelSet::EXEC_ADAPT_MESH(&quot;ADAPT_MESH&quot;);
const ExecFlagType LevelSet::EXEC_COMPUTE_MARKERS(&quot;COMPUTE_MARKERS&quot;, 1234);
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section id="2e407720-2c0a-4c3f-a00c-729166f6b70b" data-section-level="3" data-section-text="2 . Register the Execute Flag"><h3 id="2-register-the-execute-flag">2. Register the Execute Flag</h3><p>After the new flag(s) are declared and defined, it must be registered with MOOSE. This is accomplished in similar fashion as object registration, simply add the newly created flag by calling <code>registerExecFlag</code> with the <code>registerExecFlags</code> function of your application.</p><pre class="moose-pre"><code class="language-cpp">LevelSetApp::registerExecFlags(Factory &amp; factory)
{
  mooseDeprecated(&quot;use registerAll instead of registerExecFlags&quot;);
  registerExecFlagsInner(factory);
}
</code></pre><a href="#4317c09f-d3dc-44d5-a4b4-1c13840dc1b8" class="modal-trigger">(../moose/modules/level_set/src/base/LevelSetApp.C)</a><div class="modal moose-modal" id="4317c09f-d3dc-44d5-a4b4-1c13840dc1b8"><div class="modal-content"><h4>/home/gary/projects/moose/modules/level_set/src/base/LevelSetApp.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;Moose.h&quot;
#include &quot;LevelSetApp.h&quot;
#include &quot;AppFactory.h&quot;
#include &quot;MooseSyntax.h&quot;
#include &quot;LevelSetTypes.h&quot;

template &lt;&gt;
InputParameters
validParams&lt;LevelSetApp&gt;()
{
  InputParameters params = validParams&lt;MooseApp&gt;();
  params.addClassDescription(
      &quot;Application containing object necessary to solve the level set equation.&quot;);
  params.set&lt;bool&gt;(&quot;automatic_automatic_scaling&quot;) = false;
  return params;
}

registerKnownLabel(&quot;LevelSetApp&quot;);

LevelSetApp::LevelSetApp(InputParameters parameters) : MooseApp(parameters)
{
  srand(processor_id());
  LevelSetApp::registerAll(_factory, _action_factory, _syntax);
}

void
LevelSetApp::registerApps()
{
  registerApp(LevelSetApp);
}

static void
registerExecFlagsInner(Factory &amp; factory)
{
  registerExecFlag(LevelSet::EXEC_ADAPT_MESH);
  registerExecFlag(LevelSet::EXEC_COMPUTE_MARKERS);
}

void
LevelSetApp::registerAll(Factory &amp; f, ActionFactory &amp; af, Syntax &amp; /*s*/)
{
  Registry::registerObjectsTo(f, {&quot;LevelSetApp&quot;});
  Registry::registerActionsTo(af, {&quot;LevelSetApp&quot;});
  registerExecFlagsInner(f);
}

void
LevelSetApp::registerObjects(Factory &amp; factory)
{
  mooseDeprecated(&quot;use registerAll instead of registerObjects&quot;);
  Registry::registerObjectsTo(factory, {&quot;LevelSetApp&quot;});
}

void
LevelSetApp::associateSyntax(Syntax &amp; /*syntax*/, ActionFactory &amp; action_factory)
{
  mooseDeprecated(&quot;use registerAll instead of associateSyntax&quot;);
  Registry::registerActionsTo(action_factory, {&quot;LevelSetApp&quot;});
}
void
LevelSetApp::registerExecFlags(Factory &amp; factory)
{
  mooseDeprecated(&quot;use registerAll instead of registerExecFlags&quot;);
  registerExecFlagsInner(factory);
}

// Dynamic Library Entry Points - DO NOT MODIFY
extern &quot;C&quot; void
LevelSetApp__registerAll(Factory &amp; f, ActionFactory &amp; af, Syntax &amp; s)
{
  LevelSetApp::registerAll(f, af, s);
}
extern &quot;C&quot; void
LevelSetApp__registerApps()
{
  LevelSetApp::registerApps();
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p><p>If your application does not have a <code>registerExecFlags</code> function, it must be created. This can be done automatically by running the <code>add_exec_flag_registration.py</code> that is located in the scripts directory within MOOSE.</p></p></div></div></div></section><section id="e8198273-7990-47e8-a962-47152e5871d8" data-section-level="3" data-section-text="3 . Add the Execute Flag to InputParameters"><h3 id="3-add-the-execute-flag-to-inputparameters">3. Add the Execute Flag to InputParameters</h3><p>After a flag is registered, it must be made available to the object(s) in which are desired to be executed with the custom flag. This is done by adding this new flag to an existing objects valid parameters. For example, the following adds the <code>EXEC_ADAPT_MESH</code> flag to a <code>Transfer</code> object.</p><pre class="moose-pre"><code class="language-cpp">ExecFlagEnum &amp; exec = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);
exec.addAvailableFlags(LevelSet::EXEC_ADAPT_MESH, LevelSet::EXEC_COMPUTE_MARKERS);
exec = {LevelSet::EXEC_COMPUTE_MARKERS, LevelSet::EXEC_ADAPT_MESH};
</code></pre><a href="#3253aa5b-b544-4d1d-a94d-49b0d05e76fd" class="modal-trigger">(../moose/modules/level_set/src/transfers/LevelSetMeshRefinementTransfer.C)</a><div class="modal moose-modal" id="3253aa5b-b544-4d1d-a94d-49b0d05e76fd"><div class="modal-content"><h4>/home/gary/projects/moose/modules/level_set/src/transfers/LevelSetMeshRefinementTransfer.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;LevelSetMeshRefinementTransfer.h&quot;

// MOOSE includes
#include &quot;Adaptivity.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;MooseVariable.h&quot;
#include &quot;MultiApp.h&quot;
#include &quot;LevelSetTypes.h&quot;

registerMooseObject(&quot;LevelSetApp&quot;, LevelSetMeshRefinementTransfer);

template &lt;&gt;
InputParameters
validParams&lt;LevelSetMeshRefinementTransfer&gt;()
{
  InputParameters params = validParams&lt;MultiAppCopyTransfer&gt;();
  params.addClassDescription(&quot;Transfers the mesh from the master application to the sub &quot;
                             &quot;application for the purposes of level set reinitialization problems &quot;
                             &quot;with mesh adaptivity.&quot;);
  params.set&lt;MultiMooseEnum&gt;(&quot;direction&quot;) = &quot;TO_MULTIAPP&quot;;
  params.suppressParameter&lt;MultiMooseEnum&gt;(&quot;direction&quot;);

  ExecFlagEnum &amp; exec = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);
  exec.addAvailableFlags(LevelSet::EXEC_ADAPT_MESH, LevelSet::EXEC_COMPUTE_MARKERS);
  exec = {LevelSet::EXEC_COMPUTE_MARKERS, LevelSet::EXEC_ADAPT_MESH};
  params.set&lt;bool&gt;(&quot;check_multiapp_execute_on&quot;) = false;
  params.suppressParameter&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);

  return params;
}

LevelSetMeshRefinementTransfer::LevelSetMeshRefinementTransfer(const InputParameters &amp; parameters)
  : MultiAppCopyTransfer(parameters)
{
}

void
LevelSetMeshRefinementTransfer::initialSetup()
{
  FEProblemBase &amp; from_problem = _multi_app-&gt;problemBase();
  for (unsigned int i = 0; i &lt; _multi_app-&gt;numGlobalApps(); i++)
    if (_multi_app-&gt;hasLocalApp(i))
    {
      FEProblemBase &amp; to_problem = _multi_app-&gt;appProblemBase(i);
      MooseVariable &amp; to_var = to_problem.getStandardVariable(0, _to_var_name);
      Adaptivity &amp; adapt = to_problem.adaptivity();
      adapt.setMarkerVariableName(to_var.name());
      adapt.setCyclesPerStep(from_problem.adaptivity().getCyclesPerStep());
      adapt.init(1, 0);
      adapt.setUseNewSystem();
      adapt.setMaxHLevel(from_problem.adaptivity().getMaxHLevel());
      adapt.setAdaptivityOn(false);
    }
}

void
LevelSetMeshRefinementTransfer::execute()
{
  if (_current_execute_flag == LevelSet::EXEC_COMPUTE_MARKERS)
    MultiAppCopyTransfer::execute();

  else if (_current_execute_flag == LevelSet::EXEC_ADAPT_MESH)
  {
    for (unsigned int i = 0; i &lt; _multi_app-&gt;numGlobalApps(); i++)
      if (_multi_app-&gt;hasLocalApp(i))
      {
        FEProblemBase &amp; to_problem = _multi_app-&gt;appProblemBase(i);
        Adaptivity &amp; adapt = to_problem.adaptivity();
        adapt.setAdaptivityOn(true);
        to_problem.adaptMesh();
        adapt.setAdaptivityOn(false);
      }
  }
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section id="aabbeed3-ba0f-4bd6-9506-c0debe142cc6" data-section-level="3" data-section-text="4 . Use the Execute Flag"><h3 id="4-use-the-execute-flag">4. Use the Execute Flag</h3><p>Depending on what type of custom computation is desired, various MOOSE execution calls accept execution flags, which will spawn calculations. For example, the <code>LevelSetProblem</code> contains a custom method that uses the <code>EXEC_ADAPT_MESH</code> flag to preform an additional <a href="../../syntax/Transfers/index.html"><code>MultiAppTransfer</code></a> execution.</p><pre class="moose-pre"><code class="language-cpp">execMultiAppTransfers(LevelSet::EXEC_ADAPT_MESH, MultiAppTransfer::TO_MULTIAPP);
</code></pre><a href="#15b1b1af-4552-467a-8db6-95e33acd5e8d" class="modal-trigger">(../moose/modules/level_set/src/base/LevelSetProblem.C)</a><div class="modal moose-modal" id="15b1b1af-4552-467a-8db6-95e33acd5e8d"><div class="modal-content"><h4>/home/gary/projects/moose/modules/level_set/src/base/LevelSetProblem.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;LevelSetProblem.h&quot;
#include &quot;LevelSetTypes.h&quot;

#include &quot;MultiAppTransfer.h&quot;

registerMooseObject(&quot;LevelSetApp&quot;, LevelSetProblem);

template &lt;&gt;
InputParameters
validParams&lt;LevelSetProblem&gt;()
{
  InputParameters params = validParams&lt;FEProblem&gt;();
  params.addClassDescription(&quot;A specilized problem class that adds a custom call to &quot;
                             &quot;MultiAppTransfer execution to transfer adaptivity for the level set &quot;
                             &quot;reinitialization.&quot;);
  return params;
}

LevelSetProblem::LevelSetProblem(const InputParameters &amp; parameters) : FEProblem(parameters) {}

void
LevelSetProblem::computeMarkers()
{
  FEProblem::computeMarkers();
  setCurrentExecuteOnFlag(LevelSet::EXEC_COMPUTE_MARKERS);
  execMultiAppTransfers(LevelSet::EXEC_COMPUTE_MARKERS, MultiAppTransfer::TO_MULTIAPP);
  setCurrentExecuteOnFlag(EXEC_NONE);
}

bool
LevelSetProblem::adaptMesh()
{
  bool adapt = FEProblem::adaptMesh();
  setCurrentExecuteOnFlag(LevelSet::EXEC_ADAPT_MESH);
  execMultiAppTransfers(LevelSet::EXEC_ADAPT_MESH, MultiAppTransfer::TO_MULTIAPP);
  setCurrentExecuteOnFlag(EXEC_NONE);
  return adapt;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#2c5d8efa-1095-45c7-babd-d90cc9487f4a" class="tooltipped" data-position="left" data-tooltip="Execute On">Execute On</a></li><li><a href="#84605559-094f-49e3-a523-be7c142698f3" class="tooltipped" data-position="left" data-tooltip="Modifying Execute On">Modifying Execute On</a></li><li><a href="#cccd60e7-51ac-4cec-a130-102e57838b22" class="tooltipped" data-position="left" data-tooltip="Virtual Setup Methods">Virtual Setup Methods</a></li><li><a href="#28f43f09-ad45-4fd6-9f84-77f1484b899e" class="tooltipped" data-position="left" data-tooltip="Creating Custom Execute Flags">Creating Custom Execute Flags</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script>
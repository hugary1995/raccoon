<!DOCTYPE html><head><meta charset="UTF-8"><title>KKSPhaseConcentrationMultiPhaseDerivatives | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="2ee1066d-4cf1-4096-b130-79a2fdf47d90" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="07a102af-3152-4783-9c12-c389b525edda" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="e595ce05-c1e5-49d3-be2d-f40a4a6c56c8" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="c19a7a22-2295-4ef9-803f-87cf56a07364" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="9c0e67eb-882b-487c-9c7a-721ea7861eb8"><i class="material-icons">menu</i></a><ul class="sidenav" id="9c0e67eb-882b-487c-9c7a-721ea7861eb8"><li><a href="#!" class="dropdown-trigger" data-target="326fec8c-9c71-4479-9404-fc097204b963" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="eb5c35d9-3789-4288-880e-20def4f2373b" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="2c31e890-6550-4af8-8125-71964ca10615" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="3656a0b2-4bf2-4c9d-8185-59cc6e5925d3" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="2ee1066d-4cf1-4096-b130-79a2fdf47d90"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="07a102af-3152-4783-9c12-c389b525edda"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="e595ce05-c1e5-49d3-be2d-f40a4a6c56c8"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="c19a7a22-2295-4ef9-803f-87cf56a07364"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="326fec8c-9c71-4479-9404-fc097204b963"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="eb5c35d9-3789-4288-880e-20def4f2373b"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="2c31e890-6550-4af8-8125-71964ca10615"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="3656a0b2-4bf2-4c9d-8185-59cc6e5925d3"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="0ddbf080-b0b0-44f0-a4e8-9e1fff2f0d14" data-section-level="1" data-section-text="KKSPhaseConcentrationMultiPhaseDerivatives"><h1 id="kksphaseconcentrationmultiphasederivatives">KKSPhaseConcentrationMultiPhaseDerivatives</h1><p>Kim-Kim-Suzuki (KKS) nested solve material for multiphase models (part 2 of 2). KKSPhaseConcentrationMultiPhaseDerivatives computes the partial derivatives of phase concentrations w.r.t global concentrations and phase parameters, for example, <span class="moose-katex-inline-equation" id="moose-equation-626bcc48-9a88-444d-bc87-02d7ebdc1882"><script>var element = document.getElementById("moose-equation-626bcc48-9a88-444d-bc87-02d7ebdc1882");katex.render("\\frac{\\partial c_{i,p}}{\\partial c_i}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-f44e8523-3492-4287-8d51-9d6bb6a96a9a"><script>var element = document.getElementById("moose-equation-f44e8523-3492-4287-8d51-9d6bb6a96a9a");katex.render("c_i", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the global concentration and <span class="moose-katex-inline-equation" id="moose-equation-ca194444-1299-4913-a7ff-7782d989de88"><script>var element = document.getElementById("moose-equation-ca194444-1299-4913-a7ff-7782d989de88");katex.render("c_{i,p}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the phase concentration of species <span class="moose-katex-inline-equation" id="moose-equation-8f6e8d14-a9d2-4ca0-8352-eeb984b23d34"><script>var element = document.getElementById("moose-equation-8f6e8d14-a9d2-4ca0-8352-eeb984b23d34");katex.render("i", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> in phase <span class="moose-katex-inline-equation" id="moose-equation-e8e4f3a6-9670-4e41-884a-2c36bc56e632"><script>var element = document.getElementById("moose-equation-e8e4f3a6-9670-4e41-884a-2c36bc56e632");katex.render("p", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>. Another example is <span class="moose-katex-inline-equation" id="moose-equation-9b94beef-79f7-44a4-a6c9-dd1a7a9274a3"><script>var element = document.getElementById("moose-equation-9b94beef-79f7-44a4-a6c9-dd1a7a9274a3");katex.render("\\frac{\\partial c_{i,p}}{\\eta_p}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-13618050-18d3-475b-ba99-614536463bf9"><script>var element = document.getElementById("moose-equation-13618050-18d3-475b-ba99-614536463bf9");katex.render("\\eta_p", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a phase parameter in the model. These partial derivatives are used in KKS kernels as chain rule terms in the residual and Jacobian. The expressions for the derivatives were presented in <a href="#kim_phase-field_1999">Kim et al. (1999)</a>.</p><section id="90b80c03-a2fc-4b55-b3e0-4fb136eab39e" data-section-level="2" data-section-text="Example input :"><h2 id="example-input">Example input:</h2><pre style="max-height:350px;"><code class="language-moose">[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  # simple toy free energies
  [F1]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = F1
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;20*(c1-0.2)^2&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;c1&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;c1&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []
  [F2]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = F2
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;20*(c2-0.5)^2&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;c2&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;c2&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []
  [F3]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = F3
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;20*(c3-0.8)^2&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;c3&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;c3&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []
  [KKSPhaseConcentrationMultiPhaseMaterial]
    type = KKSPhaseConcentrationMultiPhaseMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the KKS phase concentrations by using a nested Newton iteration to solve the equal chemical potential and concentration conservation equations for multiphase systems. This class is intented to be used with KKSPhaseConcentrationMultiPhaseDerivatives.&quot;, &quot;href&quot;: &quot;KKSPhaseConcentrationMultiPhaseMaterial.html&quot;}&gt;&gt;&gt;
    global_cs&lt;&lt;&lt;{&quot;description&quot;: &quot;The interpolated concentrations c, b, etc.&quot;}&gt;&gt;&gt; = &#x27;c&#x27;
    all_etas&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameters.&quot;}&gt;&gt;&gt; = &#x27;eta1 eta2 eta3&#x27;
    hj_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Switching functions in the same order as all_etas.&quot;}&gt;&gt;&gt; = &#x27;h1 h2 h3&#x27;
    ci_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Phase concentrations. They must have the same order as Fj_names and global_cs, for example, c1, c2, b1, b2.&quot;}&gt;&gt;&gt; = &#x27;c1 c2 c3&#x27;
    ci_IC&lt;&lt;&lt;{&quot;description&quot;: &quot;Initial values of ci in the same order of ci_names&quot;}&gt;&gt;&gt; = &#x27;0.2 0.5 0.8&#x27;
    Fj_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Free energy material objects in the same order as all_etas.&quot;}&gt;&gt;&gt; = &#x27;F1 F2 F3&#x27;
    min_iterations&lt;&lt;&lt;{&quot;description&quot;: &quot;Minimum number of nonlinear iterations to execute before accepting convergence&quot;}&gt;&gt;&gt; = 1
    max_iterations&lt;&lt;&lt;{&quot;description&quot;: &quot;Maximum number of nonlinear iterations&quot;}&gt;&gt;&gt; = 1000
    absolute_tolerance&lt;&lt;&lt;{&quot;description&quot;: &quot;Absolute convergence tolerance for Newton iteration&quot;}&gt;&gt;&gt; = 1e-11
    relative_tolerance&lt;&lt;&lt;{&quot;description&quot;: &quot;Relative convergence tolerance for Newton iteration&quot;}&gt;&gt;&gt; = 1e-10
  []
  [KKSPhaseConcentrationMultiPhaseDerivatives]
    type = KKSPhaseConcentrationMultiPhaseDerivatives&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the KKS phase concentration derivatives wrt global concentrations and order parameters, which are used for the chain rule in the KKS kernels. This class is intended to be used with KKSPhaseConcentrationMultiPhaseMaterial.&quot;, &quot;href&quot;: &quot;KKSPhaseConcentrationMultiPhaseDerivatives.html&quot;}&gt;&gt;&gt;
    global_cs&lt;&lt;&lt;{&quot;description&quot;: &quot;The interpolated concentrations c, b, etc&quot;}&gt;&gt;&gt; = &#x27;c&#x27;
    all_etas&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameters.&quot;}&gt;&gt;&gt; = &#x27;eta1 eta2 eta3&#x27;
    Fj_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Free energy material objects in the same order as all_etas.&quot;}&gt;&gt;&gt; = &#x27;F1 F2 F3&#x27;
    hj_names&lt;&lt;&lt;{&quot;description&quot;: &quot;witching functions in the same order as all_etas.&quot;}&gt;&gt;&gt; = &#x27;h1 h2 h3&#x27;
    ci_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Phase concentrations. They must have the same order as Fj_names and global_cs, for example, c1, c2, b1, b2.&quot;}&gt;&gt;&gt; = &#x27;c1 c2 c3&#x27;
  []

  # Switching functions for each phase
  # h1(eta1, eta2, eta3)
  [h1]
    type = SwitchingFunction3PhaseMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Material for switching function that prevents formation of a third phase at a two-phase interface: $h_i = \\eta_i^2/4 [15 (1-\\eta_i) [1 + \\eta_i - (\\eta_k - \\eta_j)^2] + \\eta_i (9\\eta_i^2 - 5)]$&quot;, &quot;href&quot;: &quot;SwitchingFunction3PhaseMaterial.html&quot;}&gt;&gt;&gt;
    eta_i&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter i&quot;}&gt;&gt;&gt; = eta1
    eta_j&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter j&quot;}&gt;&gt;&gt; = eta2
    eta_k&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter k&quot;}&gt;&gt;&gt; = eta3
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = h1
  []
  # h2(eta1, eta2, eta3)
  [h2]
    type = SwitchingFunction3PhaseMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Material for switching function that prevents formation of a third phase at a two-phase interface: $h_i = \\eta_i^2/4 [15 (1-\\eta_i) [1 + \\eta_i - (\\eta_k - \\eta_j)^2] + \\eta_i (9\\eta_i^2 - 5)]$&quot;, &quot;href&quot;: &quot;SwitchingFunction3PhaseMaterial.html&quot;}&gt;&gt;&gt;
    eta_i&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter i&quot;}&gt;&gt;&gt; = eta2
    eta_j&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter j&quot;}&gt;&gt;&gt; = eta3
    eta_k&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter k&quot;}&gt;&gt;&gt; = eta1
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = h2
  []
  # h3(eta1, eta2, eta3)
  [h3]
    type = SwitchingFunction3PhaseMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Material for switching function that prevents formation of a third phase at a two-phase interface: $h_i = \\eta_i^2/4 [15 (1-\\eta_i) [1 + \\eta_i - (\\eta_k - \\eta_j)^2] + \\eta_i (9\\eta_i^2 - 5)]$&quot;, &quot;href&quot;: &quot;SwitchingFunction3PhaseMaterial.html&quot;}&gt;&gt;&gt;
    eta_i&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter i&quot;}&gt;&gt;&gt; = eta3
    eta_j&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter j&quot;}&gt;&gt;&gt; = eta1
    eta_k&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter k&quot;}&gt;&gt;&gt; = eta2
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = h3
  []

  # Barrier functions for each phase
  [g1]
    type = BarrierFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $g(\\eta)$ and its derivative in a polynomial.\nSIMPLE: $\\eta^2(1-\\eta)^2$\nLOW: $\\eta(1-\\eta)$\nHIGH: $\\eta^2(1-\\eta^2)^2$&quot;, &quot;href&quot;: &quot;BarrierFunctionMaterial.html&quot;}&gt;&gt;&gt;
    g_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the barrier function g(eta)&quot;}&gt;&gt;&gt; = SIMPLE
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta1
    function_name&lt;&lt;&lt;{&quot;description&quot;: &quot;actual name for f(eta), i.e. &#x27;h&#x27; or &#x27;g&#x27;&quot;}&gt;&gt;&gt; = g1
  []
  [g2]
    type = BarrierFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $g(\\eta)$ and its derivative in a polynomial.\nSIMPLE: $\\eta^2(1-\\eta)^2$\nLOW: $\\eta(1-\\eta)$\nHIGH: $\\eta^2(1-\\eta^2)^2$&quot;, &quot;href&quot;: &quot;BarrierFunctionMaterial.html&quot;}&gt;&gt;&gt;
    g_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the barrier function g(eta)&quot;}&gt;&gt;&gt; = SIMPLE
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta2
    function_name&lt;&lt;&lt;{&quot;description&quot;: &quot;actual name for f(eta), i.e. &#x27;h&#x27; or &#x27;g&#x27;&quot;}&gt;&gt;&gt; = g2
  []
  [g3]
    type = BarrierFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $g(\\eta)$ and its derivative in a polynomial.\nSIMPLE: $\\eta^2(1-\\eta)^2$\nLOW: $\\eta(1-\\eta)$\nHIGH: $\\eta^2(1-\\eta^2)^2$&quot;, &quot;href&quot;: &quot;BarrierFunctionMaterial.html&quot;}&gt;&gt;&gt;
    g_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the barrier function g(eta)&quot;}&gt;&gt;&gt; = SIMPLE
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta3
    function_name&lt;&lt;&lt;{&quot;description&quot;: &quot;actual name for f(eta), i.e. &#x27;h&#x27; or &#x27;g&#x27;&quot;}&gt;&gt;&gt; = g3
  []

  # constant properties
  [constants]
    type = GenericConstantMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Declares material properties based on names and values prescribed by input parameters.&quot;, &quot;href&quot;: &quot;GenericConstantMaterial.html&quot;}&gt;&gt;&gt;
    prop_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The names of the properties this material will have&quot;}&gt;&gt;&gt; = &#x27;L   kappa  M&#x27;
    prop_values&lt;&lt;&lt;{&quot;description&quot;: &quot;The values associated with the named properties&quot;}&gt;&gt;&gt; = &#x27;0.7 1.0    0.025&#x27;
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#fcf2e9f4-1ab6-424d-b967-f3f8fb76e37f">(moose/modules/phase_field/test/tests/KKS_system/kks_example_multiphase_nested.i)</a></section><section id="9755b710-3e1f-4709-b389-2708a5cdcc4a" data-section-level="2" data-section-text="Class Description"><h2 id="class-description">Class Description</h2><p>Computes the KKS phase concentration derivatives wrt global concentrations and order parameters, which are used for the chain rule in the KKS kernels. This class is intended to be used with KKSPhaseConcentrationMultiPhaseMaterial.</p></section><section id="4c1ab36a-9ff1-4170-b497-90b5b477035d" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="1baabd3e-54c8-4361-893a-078c06453544" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">Fj_names</span><span class="moose-parameter-header-description">Free energy material objects in the same order as all_etas.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;MaterialName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Free energy material objects in the same order as all_etas.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">all_etas</span><span class="moose-parameter-header-description">Order parameters.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Order parameters.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">ci_names</span><span class="moose-parameter-header-description">Phase concentrations. They must have the same order as Fj_names and global_cs, for example, c1, c2, b1, b2.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;MaterialPropertyName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Phase concentrations. They must have the same order as Fj_names and global_cs, for example, c1, c2, b1, b2.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">global_cs</span><span class="moose-parameter-header-description">The interpolated concentrations c, b, etc</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The interpolated concentrations c, b, etc</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">hj_names</span><span class="moose-parameter-header-description">witching functions in the same order as all_etas.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;MaterialPropertyName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>witching functions in the same order as all_etas.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="fa0fed16-160d-43a0-8f69-c3b754028193" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">block</span><span class="moose-parameter-header-description">The list of blocks (ids or names) that this object will be applied</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of blocks (ids or names) that this object will be applied</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">boundary</span><span class="moose-parameter-header-description">The list of boundaries (ids or names) from the mesh where this object applies</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;BoundaryName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of boundaries (ids or names) from the mesh where this object applies</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">compute</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">constant_on</span><span class="moose-parameter-header-default">NONE</span><span class="moose-parameter-header-description">When ELEMENT, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps.When SUBDOMAIN, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps. Evaluations on element qps will be skipped</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>NONE</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>NONE, ELEMENT, SUBDOMAIN</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When ELEMENT, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps.When SUBDOMAIN, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps. Evaluations on element qps will be skipped</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">declare_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any declared properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any declared properties. The suffix will be prepended with a '_' character.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="47bab6cd-fe81-423a-8050-c428db4d76d4" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>Yes</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">implicit</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Determines whether this object is calculated using an implicit or explicit form</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Determines whether this object is calculated using an implicit or explicit form</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">search_method</span><span class="moose-parameter-header-default">nearest_node_connected_sides</span><span class="moose-parameter-header-description">Choice of search algorithm.  All options begin by finding the nearest node in the primary boundary to a query point in the secondary boundary.  In the default nearest_node_connected_sides algorithm, primary boundary elements are searched iff that nearest node is one of their nodes.  This is fast to determine via a pregenerated node-to-elem map and is robust on conforming meshes.  In the optional all_proximate_sides algorithm, primary boundary elements are searched iff they touch that nearest node, even if they are not topologically connected to it.  This is more CPU-intensive but is necessary for robustness on any boundary surfaces which has disconnections (such as Flex IGA meshes) or non-conformity (such as hanging nodes in adaptively h-refined meshes).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nearest_node_connected_sides</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nearest_node_connected_sides, all_proximate_sides</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Choice of search algorithm.  All options begin by finding the nearest node in the primary boundary to a query point in the secondary boundary.  In the default nearest_node_connected_sides algorithm, primary boundary elements are searched iff that nearest node is one of their nodes.  This is fast to determine via a pregenerated node-to-elem map and is robust on conforming meshes.  In the optional all_proximate_sides algorithm, primary boundary elements are searched iff they touch that nearest node, even if they are not topologically connected to it.  This is more CPU-intensive but is necessary for robustness on any boundary surfaces which has disconnections (such as Flex IGA meshes) or non-conformity (such as hanging nodes in adaptively h-refined meshes).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">seed</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The seed for the master random number generator</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The seed for the master random number generator</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="c496fbc2-d35b-4ce3-a2dc-634603b42bc7" data-section-level="3" data-section-text="Outputs Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">output_properties</span><span class="moose-parameter-header-description">List of material properties, from this material, to output (outputs must also be defined to an output type)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>List of material properties, from this material, to output (outputs must also be defined to an output type)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">outputs</span><span class="moose-parameter-header-default">none </span><span class="moose-parameter-header-description">Vector of output names where you would like to restrict the output of variables(s) associated with this object</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>none </p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;OutputName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Vector of output names where you would like to restrict the output of variables(s) associated with this object</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Outputs Parameters</h3></summary></details></section><section id="a7c05a1e-782b-4efc-be0d-165f27455183" data-section-level="3" data-section-text="Material Property Retrieval Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">prop_getter_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_interpolated_state</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">For the old and older state use projected material properties interpolated at the quadrature points. To set up projection use the ProjectedStatefulMaterialStorageAction.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>For the old and older state use projected material properties interpolated at the quadrature points. To set up projection use the ProjectedStatefulMaterialStorageAction.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Material Property Retrieval Parameters</h3></summary></details></section></section><section id="d46f0be4-baa1-4c12-95be-9e24d95b3b6c" data-section-level="2" data-section-text="References"><h2 id="references">References</h2><div class="moose-bibliography"><ol><li id="kim_phase-field_1999">Seong&nbsp;Gyoon Kim, Won&nbsp;Tae Kim, and Toshio Suzuki.
Phase-field model for binary alloys.
<em>Physical Review E</em>, 60(6):7186&ndash;7197, December 1999.
URL: <a href="http://link.aps.org/doi/10.1103/PhysRevE.60.7186">http://link.aps.org/doi/10.1103/PhysRevE.60.7186</a> (visited on 2014-03-31), <a href="https://doi.org/10.1103/PhysRevE.60.7186">doi:10.1103/PhysRevE.60.7186</a>.<a href="#32cf83f8-beb1-4018-829d-550a71ee6bad" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="32cf83f8-beb1-4018-829d-550a71ee6bad"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{kim_phase-field_1999,
    author = "Kim, Seong Gyoon and Kim, Won Tae and Suzuki, Toshio",
    title = "Phase-field model for binary alloys",
    volume = "60",
    url = "http://link.aps.org/doi/10.1103/PhysRevE.60.7186",
    doi = "10.1103/PhysRevE.60.7186",
    number = "6",
    urldate = "2014-03-31",
    journal = "Physical Review E",
    month = "December",
    year = "1999",
    pages = "7186-7197"
}
</code></pre></div></div></li></ol></div></section></section><div class="moose-modal modal" id="fcf2e9f4-1ab6-424d-b967-f3f8fb76e37f"><div class="modal-content"><h4>(moose/modules/phase_field/test/tests/KKS_system/kks_example_multiphase_nested.i)</h4><pre style="max-height:350px;"><code class="language-moose">#
# This test is for the nested solve of 3-phase KKS model
# The split-form of the Cahn-Hilliard equation instead of the Fick&#x27;s diffusion equation is solved

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
  nz = 0
  xmin = 0
  xmax = 40
  ymin = 0
  ymax = 40
  zmin = 0
  zmax = 0
  elem_type = QUAD4
[]

[BCs]
  [Periodic]
    [all]
      auto_direction = &#x27;x y&#x27;
    []
  []
[]

[AuxVariables]
  [Energy]
    order = CONSTANT
    family = MONOMIAL
  []
[]

[Variables]
  # concentration
  [c]
    order = FIRST
    family = LAGRANGE
  []

  # order parameter 1
  [eta1]
    order = FIRST
    family = LAGRANGE
  []

  # order parameter 2
  [eta2]
    order = FIRST
    family = LAGRANGE
  []

  # order parameter 3
  [eta3]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  []

  # chemical potential
  [mu]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  []

  # Lagrange multiplier
  [lambda]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  []
[]

[ICs]
  [eta1]
    variable = eta1
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.9
    outvalue = 0.1
    int_width = 4
  []
  [eta2]
    variable = eta2
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.1
    outvalue = 0.9
    int_width = 4
  []
  [c]
    variable = c
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.2
    outvalue = 0.5
    int_width = 2
  []
[]

[Materials]
  # simple toy free energies
  [F1]
    type = DerivativeParsedMaterial
    property_name = F1
    expression = &#x27;20*(c1-0.2)^2&#x27;
    material_property_names = &#x27;c1&#x27;
    additional_derivative_symbols = &#x27;c1&#x27;
    compute = false
  []
  [F2]
    type = DerivativeParsedMaterial
    property_name = F2
    expression = &#x27;20*(c2-0.5)^2&#x27;
    material_property_names = &#x27;c2&#x27;
    additional_derivative_symbols = &#x27;c2&#x27;
    compute = false
  []
  [F3]
    type = DerivativeParsedMaterial
    property_name = F3
    expression = &#x27;20*(c3-0.8)^2&#x27;
    material_property_names = &#x27;c3&#x27;
    additional_derivative_symbols = &#x27;c3&#x27;
    compute = false
  []
  [KKSPhaseConcentrationMultiPhaseMaterial]
    type = KKSPhaseConcentrationMultiPhaseMaterial
    global_cs = &#x27;c&#x27;
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    ci_IC = &#x27;0.2 0.5 0.8&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    min_iterations = 1
    max_iterations = 1000
    absolute_tolerance = 1e-11
    relative_tolerance = 1e-10
  []
  [KKSPhaseConcentrationMultiPhaseDerivatives]
    type = KKSPhaseConcentrationMultiPhaseDerivatives
    global_cs = &#x27;c&#x27;
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
  []

  # Switching functions for each phase
  # h1(eta1, eta2, eta3)
  [h1]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta1
    eta_j = eta2
    eta_k = eta3
    property_name = h1
  []
  # h2(eta1, eta2, eta3)
  [h2]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta2
    eta_j = eta3
    eta_k = eta1
    property_name = h2
  []
  # h3(eta1, eta2, eta3)
  [h3]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta3
    eta_j = eta1
    eta_k = eta2
    property_name = h3
  []

  # Barrier functions for each phase
  [g1]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta1
    function_name = g1
  []
  [g2]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta2
    function_name = g2
  []
  [g3]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta3
    function_name = g3
  []

  # constant properties
  [constants]
    type = GenericConstantMaterial
    prop_names = &#x27;L   kappa  M&#x27;
    prop_values = &#x27;0.7 1.0    0.025&#x27;
  []
[]

[Kernels]
  [lambda_lagrange]
    type = SwitchingFunctionConstraintLagrange
    variable = lambda
    etas = &#x27;eta1 eta2 eta3&#x27;
    h_names = &#x27;h1   h2   h3&#x27;
    epsilon = 1e-04
  []
  [eta1_lagrange]
    type = SwitchingFunctionConstraintEta
    variable = eta1
    h_name = h1
    lambda = lambda
    coupled_variables = &#x27;eta2 eta3&#x27;
  []
  [eta2_lagrange]
    type = SwitchingFunctionConstraintEta
    variable = eta2
    h_name = h2
    lambda = lambda
    coupled_variables = &#x27;eta1 eta3&#x27;
  []
  [eta3_lagrange]
    type = SwitchingFunctionConstraintEta
    variable = eta3
    h_name = h3
    lambda = lambda
    coupled_variables = &#x27;eta1 eta2&#x27;
  []

  #Kernels for Cahn-Hilliard equation
  [diff_time]
    type = CoupledTimeDerivative
    variable = mu
    v = c
  []
  [CHBulk]
    type = NestedKKSMultiSplitCHCRes
    variable = c
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    global_cs = &#x27;c&#x27;
    w = mu
    c1_names = &#x27;c1&#x27;
    F1_name = F1
    coupled_variables = &#x27;eta1 eta2 eta3 mu&#x27;
  []
  [ckernel]
    type = SplitCHWRes
    variable = mu
    mob_name = M
  []

  # Kernels for Allen-Cahn equation for eta1
  [deta1dt]
    type = TimeDerivative
    variable = eta1
  []
  [ACBulkF1]
    type = NestedKKSMultiACBulkF
    variable = eta1
    global_cs = &#x27;c&#x27;
    eta_i = eta1
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    gi_name = g1
    mob_name = L
    wi = 1.0
    coupled_variables = &#x27;c eta2 eta3&#x27;
  []
  [ACBulkC1]
    type = NestedKKSMultiACBulkC
    variable = eta1
    global_cs = &#x27;c&#x27;
    eta_i = eta1
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    coupled_variables = &#x27;c eta2 eta3&#x27;
  []
  [ACInterface1]
    type = ACInterface
    variable = eta1
    kappa_name = kappa
  []

  # Kernels for Allen-Cahn equation for eta2
  [deta2dt]
    type = TimeDerivative
    variable = eta2
  []
  [ACBulkF2]
    type = NestedKKSMultiACBulkF
    variable = eta2
    global_cs = &#x27;c&#x27;
    eta_i = eta2
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    gi_name = g2
    mob_name = L
    wi = 1.0
    coupled_variables = &#x27;c eta1 eta3&#x27;
  []
  [ACBulkC2]
    type = NestedKKSMultiACBulkC
    variable = eta2
    global_cs = &#x27;c&#x27;
    eta_i = eta2
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    coupled_variables = &#x27;c eta1 eta3&#x27;
  []
  [ACInterface2]
    type = ACInterface
    variable = eta2
    kappa_name = kappa
  []

  # Kernels for Allen-Cahn equation for eta3
  [deta3dt]
    type = TimeDerivative
    variable = eta3
  []
  [ACBulkF3]
    type = NestedKKSMultiACBulkF
    variable = eta3
    global_cs = &#x27;c&#x27;
    eta_i = eta3
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    gi_name = g3
    mob_name = L
    wi = 1.0
    coupled_variables = &#x27;c eta1 eta2&#x27;
  []
  [ACBulkC3]
    type = NestedKKSMultiACBulkC
    variable = eta3
    global_cs = &#x27;c&#x27;
    eta_i = eta3
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    coupled_variables = &#x27;c eta1 eta2&#x27;
  []
  [ACInterface3]
    type = ACInterface
    variable = eta3
    kappa_name = kappa
  []
[]

[AuxKernels]
  [Energy_total]
    type = KKSMultiFreeEnergy
    Fj_names = &#x27;F1 F2 F3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    gj_names = &#x27;g1 g2 g3&#x27;
    variable = Energy
    w = 1
    interfacial_vars = &#x27;eta1  eta2  eta3&#x27;
    kappa_names = &#x27;kappa kappa kappa&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type   -sub_pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;asm       ilu            nonzero&#x27;
  l_max_its = 30
  nl_max_its = 10
  l_tol = 1.0e-4
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-11

  num_steps = 2
  dt = 0.5
[]

[Preconditioning]
  active = &#x27;full&#x27;
  [full]
    type = SMP
    full = true
  []
  [mydebug]
    type = FDP
    full = true
  []
[]

[Outputs]
  file_base = kks_example_multiphase_nested
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
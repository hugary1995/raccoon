<!DOCTYPE html><head><meta charset="UTF-8"><title>KKSPhaseConcentrationMultiPhaseMaterial | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="fa4540cd-2f7e-4449-b1ff-453f12ae704a" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="03d79558-52cb-4b23-90de-b34bf4505729" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d2b76511-c1d9-46ee-a887-05235babc2b7" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="dfd92ce2-639a-4426-af6a-0ad0e0f16172" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="99df8bfd-ed53-4b7f-ae54-ac5a9bc6929e"><i class="material-icons">menu</i></a><ul class="sidenav" id="99df8bfd-ed53-4b7f-ae54-ac5a9bc6929e"><li><a href="#!" class="dropdown-trigger" data-target="0cdce948-c38c-4e4b-85c5-3253a9169b79" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="e09ed062-55ba-4937-ad6f-6ac5a1802769" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="2904a3d4-c117-41ef-9ad3-be219a4d0855" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="94ee5d73-5e81-49bb-ab30-bdc170076c83" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="fa4540cd-2f7e-4449-b1ff-453f12ae704a"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="03d79558-52cb-4b23-90de-b34bf4505729"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="d2b76511-c1d9-46ee-a887-05235babc2b7"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="dfd92ce2-639a-4426-af6a-0ad0e0f16172"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="0cdce948-c38c-4e4b-85c5-3253a9169b79"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="e09ed062-55ba-4937-ad6f-6ac5a1802769"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="2904a3d4-c117-41ef-9ad3-be219a4d0855"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="94ee5d73-5e81-49bb-ab30-bdc170076c83"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="c51c3b93-7acc-4cfe-961d-d8b1fbb3fda4" data-section-level="1" data-section-text="KKSPhaseConcentrationMultiPhaseMaterial"><h1 id="kksphaseconcentrationmultiphasematerial">KKSPhaseConcentrationMultiPhaseMaterial</h1><p>Kim-Kim-Suzuki (KKS) nested solve material for multiphase models (part 1 of 2). KKSPhaseConcentrationMultiPhaseMaterial implements a nested Newton iteration to solve the KKS constraint equations for the phase concentrations <span class="moose-katex-inline-equation" id="moose-equation-8207bef6-2ec5-40e3-833d-555c66c7a33b"><script>var element = document.getElementById("moose-equation-8207bef6-2ec5-40e3-833d-555c66c7a33b");katex.render("c_{i,p}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> as material properties (instead of non-linear variables as in the traditional solve in MOOSE), where <span class="moose-katex-inline-equation" id="moose-equation-395d925c-512f-4d66-b452-6102f98dff00"><script>var element = document.getElementById("moose-equation-395d925c-512f-4d66-b452-6102f98dff00");katex.render("i", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the component species and <span class="moose-katex-inline-equation" id="moose-equation-7a2b4629-79fd-4810-984a-aafc427ccbdb"><script>var element = document.getElementById("moose-equation-7a2b4629-79fd-4810-984a-aafc427ccbdb");katex.render("p", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the phase. For a model with N phases, the constraint equations are the mass conservation equation for each global concentration (<span class="moose-katex-inline-equation" id="moose-equation-2ac2beb7-8bb6-4bc9-946c-30b14de87865"><script>var element = document.getElementById("moose-equation-2ac2beb7-8bb6-4bc9-946c-30b14de87865");katex.render("c_i", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>):</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-989b2af4-1cab-4d18-bcf3-5d32c197b5d0"></span><script>var element = document.getElementById("moose-equation-989b2af4-1cab-4d18-bcf3-5d32c197b5d0");katex.render("c_i=\\sum_{p=1}^N h(\\eta_p)c_{i,p},", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>and the pointwise equality of the phase chemical potentials:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-a6b0a8ec-012c-4316-88e0-d74e11a8425b"></span><script>var element = document.getElementById("moose-equation-a6b0a8ec-012c-4316-88e0-d74e11a8425b");katex.render("\\frac{\\partial f_a}{\\partial c_{i,a}} = \\frac{\\partial f_b}{\\partial c_{i,b}}.", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>The free energies in Fj_materials must have <a href="#84d85cf6-114d-4efb-8a8d-8f62885c56fa" class="moose-modal-link modal-trigger">&quot;compute&quot;</a> set to <code>false</code>. This material also passes the phase free energies and their partial derivatives w.r.t phase concentrations to the KKS kernels (NestKKSMultiACBulkC, NestKKSMultiACBulkF, NestKKSSplitCHCRes).</p><section id="05a63e47-933c-4120-a5c3-855f7cc0864a" data-section-level="2" data-section-text="Example input :"><h2 id="example-input">Example input:</h2><section id="9de88d55-2efb-4300-9e34-378517995069" data-section-level="3" data-section-text="Without damping"><h3 id="without-damping">Without damping</h3><p>Parabolic free energies have valid values for any real number, and therefore don&#x27;t require damping to ensure the solution is inside a trust region.</p><pre style="max-height:350px;"><code class="language-moose">[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  # simple toy free energies
  [F1]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = F1
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;20*(c1-0.2)^2&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;c1&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;c1&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []
  [F2]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = F2
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;20*(c2-0.5)^2&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;c2&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;c2&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []
  [F3]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = F3
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;20*(c3-0.8)^2&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;c3&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;c3&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []
  [KKSPhaseConcentrationMultiPhaseMaterial]
    type = KKSPhaseConcentrationMultiPhaseMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the KKS phase concentrations by using a nested Newton iteration to solve the equal chemical potential and concentration conservation equations for multiphase systems. This class is intented to be used with KKSPhaseConcentrationMultiPhaseDerivatives.&quot;, &quot;href&quot;: &quot;KKSPhaseConcentrationMultiPhaseMaterial.html&quot;}&gt;&gt;&gt;
    global_cs&lt;&lt;&lt;{&quot;description&quot;: &quot;The interpolated concentrations c, b, etc.&quot;}&gt;&gt;&gt; = &#x27;c&#x27;
    all_etas&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameters.&quot;}&gt;&gt;&gt; = &#x27;eta1 eta2 eta3&#x27;
    hj_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Switching functions in the same order as all_etas.&quot;}&gt;&gt;&gt; = &#x27;h1 h2 h3&#x27;
    ci_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Phase concentrations. They must have the same order as Fj_names and global_cs, for example, c1, c2, b1, b2.&quot;}&gt;&gt;&gt; = &#x27;c1 c2 c3&#x27;
    ci_IC&lt;&lt;&lt;{&quot;description&quot;: &quot;Initial values of ci in the same order of ci_names&quot;}&gt;&gt;&gt; = &#x27;0.2 0.5 0.8&#x27;
    Fj_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Free energy material objects in the same order as all_etas.&quot;}&gt;&gt;&gt; = &#x27;F1 F2 F3&#x27;
    min_iterations&lt;&lt;&lt;{&quot;description&quot;: &quot;Minimum number of nonlinear iterations to execute before accepting convergence&quot;}&gt;&gt;&gt; = 1
    max_iterations&lt;&lt;&lt;{&quot;description&quot;: &quot;Maximum number of nonlinear iterations&quot;}&gt;&gt;&gt; = 1000
    absolute_tolerance&lt;&lt;&lt;{&quot;description&quot;: &quot;Absolute convergence tolerance for Newton iteration&quot;}&gt;&gt;&gt; = 1e-11
    relative_tolerance&lt;&lt;&lt;{&quot;description&quot;: &quot;Relative convergence tolerance for Newton iteration&quot;}&gt;&gt;&gt; = 1e-10
  []
  [KKSPhaseConcentrationMultiPhaseDerivatives]
    type = KKSPhaseConcentrationMultiPhaseDerivatives&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the KKS phase concentration derivatives wrt global concentrations and order parameters, which are used for the chain rule in the KKS kernels. This class is intended to be used with KKSPhaseConcentrationMultiPhaseMaterial.&quot;, &quot;href&quot;: &quot;KKSPhaseConcentrationMultiPhaseDerivatives.html&quot;}&gt;&gt;&gt;
    global_cs&lt;&lt;&lt;{&quot;description&quot;: &quot;The interpolated concentrations c, b, etc&quot;}&gt;&gt;&gt; = &#x27;c&#x27;
    all_etas&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameters.&quot;}&gt;&gt;&gt; = &#x27;eta1 eta2 eta3&#x27;
    Fj_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Free energy material objects in the same order as all_etas.&quot;}&gt;&gt;&gt; = &#x27;F1 F2 F3&#x27;
    hj_names&lt;&lt;&lt;{&quot;description&quot;: &quot;witching functions in the same order as all_etas.&quot;}&gt;&gt;&gt; = &#x27;h1 h2 h3&#x27;
    ci_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Phase concentrations. They must have the same order as Fj_names and global_cs, for example, c1, c2, b1, b2.&quot;}&gt;&gt;&gt; = &#x27;c1 c2 c3&#x27;
  []

  # Switching functions for each phase
  # h1(eta1, eta2, eta3)
  [h1]
    type = SwitchingFunction3PhaseMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Material for switching function that prevents formation of a third phase at a two-phase interface: $h_i = \\eta_i^2/4 [15 (1-\\eta_i) [1 + \\eta_i - (\\eta_k - \\eta_j)^2] + \\eta_i (9\\eta_i^2 - 5)]$&quot;, &quot;href&quot;: &quot;SwitchingFunction3PhaseMaterial.html&quot;}&gt;&gt;&gt;
    eta_i&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter i&quot;}&gt;&gt;&gt; = eta1
    eta_j&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter j&quot;}&gt;&gt;&gt; = eta2
    eta_k&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter k&quot;}&gt;&gt;&gt; = eta3
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = h1
  []
  # h2(eta1, eta2, eta3)
  [h2]
    type = SwitchingFunction3PhaseMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Material for switching function that prevents formation of a third phase at a two-phase interface: $h_i = \\eta_i^2/4 [15 (1-\\eta_i) [1 + \\eta_i - (\\eta_k - \\eta_j)^2] + \\eta_i (9\\eta_i^2 - 5)]$&quot;, &quot;href&quot;: &quot;SwitchingFunction3PhaseMaterial.html&quot;}&gt;&gt;&gt;
    eta_i&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter i&quot;}&gt;&gt;&gt; = eta2
    eta_j&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter j&quot;}&gt;&gt;&gt; = eta3
    eta_k&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter k&quot;}&gt;&gt;&gt; = eta1
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = h2
  []
  # h3(eta1, eta2, eta3)
  [h3]
    type = SwitchingFunction3PhaseMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Material for switching function that prevents formation of a third phase at a two-phase interface: $h_i = \\eta_i^2/4 [15 (1-\\eta_i) [1 + \\eta_i - (\\eta_k - \\eta_j)^2] + \\eta_i (9\\eta_i^2 - 5)]$&quot;, &quot;href&quot;: &quot;SwitchingFunction3PhaseMaterial.html&quot;}&gt;&gt;&gt;
    eta_i&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter i&quot;}&gt;&gt;&gt; = eta3
    eta_j&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter j&quot;}&gt;&gt;&gt; = eta1
    eta_k&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter k&quot;}&gt;&gt;&gt; = eta2
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = h3
  []

  # Barrier functions for each phase
  [g1]
    type = BarrierFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $g(\\eta)$ and its derivative in a polynomial.\nSIMPLE: $\\eta^2(1-\\eta)^2$\nLOW: $\\eta(1-\\eta)$\nHIGH: $\\eta^2(1-\\eta^2)^2$&quot;, &quot;href&quot;: &quot;BarrierFunctionMaterial.html&quot;}&gt;&gt;&gt;
    g_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the barrier function g(eta)&quot;}&gt;&gt;&gt; = SIMPLE
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta1
    function_name&lt;&lt;&lt;{&quot;description&quot;: &quot;actual name for f(eta), i.e. &#x27;h&#x27; or &#x27;g&#x27;&quot;}&gt;&gt;&gt; = g1
  []
  [g2]
    type = BarrierFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $g(\\eta)$ and its derivative in a polynomial.\nSIMPLE: $\\eta^2(1-\\eta)^2$\nLOW: $\\eta(1-\\eta)$\nHIGH: $\\eta^2(1-\\eta^2)^2$&quot;, &quot;href&quot;: &quot;BarrierFunctionMaterial.html&quot;}&gt;&gt;&gt;
    g_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the barrier function g(eta)&quot;}&gt;&gt;&gt; = SIMPLE
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta2
    function_name&lt;&lt;&lt;{&quot;description&quot;: &quot;actual name for f(eta), i.e. &#x27;h&#x27; or &#x27;g&#x27;&quot;}&gt;&gt;&gt; = g2
  []
  [g3]
    type = BarrierFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $g(\\eta)$ and its derivative in a polynomial.\nSIMPLE: $\\eta^2(1-\\eta)^2$\nLOW: $\\eta(1-\\eta)$\nHIGH: $\\eta^2(1-\\eta^2)^2$&quot;, &quot;href&quot;: &quot;BarrierFunctionMaterial.html&quot;}&gt;&gt;&gt;
    g_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the barrier function g(eta)&quot;}&gt;&gt;&gt; = SIMPLE
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta3
    function_name&lt;&lt;&lt;{&quot;description&quot;: &quot;actual name for f(eta), i.e. &#x27;h&#x27; or &#x27;g&#x27;&quot;}&gt;&gt;&gt; = g3
  []

  # constant properties
  [constants]
    type = GenericConstantMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Declares material properties based on names and values prescribed by input parameters.&quot;, &quot;href&quot;: &quot;GenericConstantMaterial.html&quot;}&gt;&gt;&gt;
    prop_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The names of the properties this material will have&quot;}&gt;&gt;&gt; = &#x27;L   kappa  M&#x27;
    prop_values&lt;&lt;&lt;{&quot;description&quot;: &quot;The values associated with the named properties&quot;}&gt;&gt;&gt; = &#x27;0.7 1.0    0.025&#x27;
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#2dc3f78b-378c-46fe-941e-727f8a3ca3b3">(moose/modules/phase_field/test/tests/KKS_system/kks_example_multiphase_nested.i)</a></section><section id="f462ad6f-9741-4e01-be71-efc81d14c34e" data-section-level="3" data-section-text="With damping"><h3 id="with-damping">With damping</h3><p>Log free energies are only valid when the component phase mole fractions are within 0 to 1. We add a material <code>C</code> that checks if the nested solve guess is within this trust region. Similar to the free energy, <code>C</code> must have <a href="#300208c9-9f55-4f7d-939d-c6cddff8e6d3" class="moose-modal-link modal-trigger">&quot;compute&quot;</a> set to <code>false</code>. The nested solve then requires damping to ensure the solution is inside the trust region.</p><pre style="max-height:350px;"><code class="language-moose">[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  # simple toy free energies
  [F1]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = F1
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;c1*log(c1/1e-4) + (1-c1)*log((1-c1)/(1-1e-4))&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;c1&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;c1&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []
  [F2]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = F2
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;c2*log(c2/0.5) + (1-c2)*log((1-c2)/(1-0.5))&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;c2&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;c2&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []
  [F3]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = F3
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;c3*log(c3/0.9999) + (1-c3)*log((1-c3)/(1-0.9999))&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;c3&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;c3&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []
  [C]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = &#x27;C&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;c1 c2 c3&#x27;
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;(c1&gt;0)&amp;(c1&lt;1)&amp;(c2&gt;0)&amp;(c2&lt;1)&amp;(c3&gt;0)&amp;(c3&lt;1)&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []
  [KKSPhaseConcentrationMultiPhaseMaterial]
    type = KKSPhaseConcentrationMultiPhaseMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the KKS phase concentrations by using a nested Newton iteration to solve the equal chemical potential and concentration conservation equations for multiphase systems. This class is intented to be used with KKSPhaseConcentrationMultiPhaseDerivatives.&quot;, &quot;href&quot;: &quot;KKSPhaseConcentrationMultiPhaseMaterial.html&quot;}&gt;&gt;&gt;
    global_cs&lt;&lt;&lt;{&quot;description&quot;: &quot;The interpolated concentrations c, b, etc.&quot;}&gt;&gt;&gt; = &#x27;c&#x27;
    all_etas&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameters.&quot;}&gt;&gt;&gt; = &#x27;eta1 eta2 eta3&#x27;
    hj_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Switching functions in the same order as all_etas.&quot;}&gt;&gt;&gt; = &#x27;h1 h2 h3&#x27;
    ci_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Phase concentrations. They must have the same order as Fj_names and global_cs, for example, c1, c2, b1, b2.&quot;}&gt;&gt;&gt; = &#x27;c1 c2 c3&#x27;
    ci_IC&lt;&lt;&lt;{&quot;description&quot;: &quot;Initial values of ci in the same order of ci_names&quot;}&gt;&gt;&gt; = &#x27;0.2 0.5 0.8&#x27;
    Fj_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Free energy material objects in the same order as all_etas.&quot;}&gt;&gt;&gt; = &#x27;F1 F2 F3&#x27;
    min_iterations&lt;&lt;&lt;{&quot;description&quot;: &quot;Minimum number of nonlinear iterations to execute before accepting convergence&quot;}&gt;&gt;&gt; = 1
    max_iterations&lt;&lt;&lt;{&quot;description&quot;: &quot;Maximum number of nonlinear iterations&quot;}&gt;&gt;&gt; = 1000
    absolute_tolerance&lt;&lt;&lt;{&quot;description&quot;: &quot;Absolute convergence tolerance for Newton iteration&quot;}&gt;&gt;&gt; = 1e-15
    relative_tolerance&lt;&lt;&lt;{&quot;description&quot;: &quot;Relative convergence tolerance for Newton iteration&quot;}&gt;&gt;&gt; = 1e-8
    step_size_tolerance&lt;&lt;&lt;{&quot;description&quot;: &quot;Minimum step size of linear iterations relative to value of the solution&quot;}&gt;&gt;&gt; = 1e-05
    damped_Newton&lt;&lt;&lt;{&quot;description&quot;: &quot;Whether or not to use the damped Newton&#x27;s method.&quot;}&gt;&gt;&gt; = true
    conditions&lt;&lt;&lt;{&quot;description&quot;: &quot;Material property that checks bounds and conditions on the material properties being solved for.&quot;}&gt;&gt;&gt; = C
    damping_factor&lt;&lt;&lt;{&quot;description&quot;: &quot;Factor applied to step size if guess does not satisfy damping criteria&quot;}&gt;&gt;&gt; = 0.8
  []
  [KKSPhaseConcentrationMultiPhaseDerivatives]
    type = KKSPhaseConcentrationMultiPhaseDerivatives&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the KKS phase concentration derivatives wrt global concentrations and order parameters, which are used for the chain rule in the KKS kernels. This class is intended to be used with KKSPhaseConcentrationMultiPhaseMaterial.&quot;, &quot;href&quot;: &quot;KKSPhaseConcentrationMultiPhaseDerivatives.html&quot;}&gt;&gt;&gt;
    global_cs&lt;&lt;&lt;{&quot;description&quot;: &quot;The interpolated concentrations c, b, etc&quot;}&gt;&gt;&gt; = &#x27;c&#x27;
    all_etas&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameters.&quot;}&gt;&gt;&gt; = &#x27;eta1 eta2 eta3&#x27;
    Fj_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Free energy material objects in the same order as all_etas.&quot;}&gt;&gt;&gt; = &#x27;F1 F2 F3&#x27;
    hj_names&lt;&lt;&lt;{&quot;description&quot;: &quot;witching functions in the same order as all_etas.&quot;}&gt;&gt;&gt; = &#x27;h1 h2 h3&#x27;
    ci_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Phase concentrations. They must have the same order as Fj_names and global_cs, for example, c1, c2, b1, b2.&quot;}&gt;&gt;&gt; = &#x27;c1 c2 c3&#x27;
  []

  # Switching functions for each phase
  # h1(eta1, eta2, eta3)
  [h1]
    type = SwitchingFunction3PhaseMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Material for switching function that prevents formation of a third phase at a two-phase interface: $h_i = \\eta_i^2/4 [15 (1-\\eta_i) [1 + \\eta_i - (\\eta_k - \\eta_j)^2] + \\eta_i (9\\eta_i^2 - 5)]$&quot;, &quot;href&quot;: &quot;SwitchingFunction3PhaseMaterial.html&quot;}&gt;&gt;&gt;
    eta_i&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter i&quot;}&gt;&gt;&gt; = eta1
    eta_j&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter j&quot;}&gt;&gt;&gt; = eta2
    eta_k&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter k&quot;}&gt;&gt;&gt; = eta3
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = h1
  []
  # h2(eta1, eta2, eta3)
  [h2]
    type = SwitchingFunction3PhaseMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Material for switching function that prevents formation of a third phase at a two-phase interface: $h_i = \\eta_i^2/4 [15 (1-\\eta_i) [1 + \\eta_i - (\\eta_k - \\eta_j)^2] + \\eta_i (9\\eta_i^2 - 5)]$&quot;, &quot;href&quot;: &quot;SwitchingFunction3PhaseMaterial.html&quot;}&gt;&gt;&gt;
    eta_i&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter i&quot;}&gt;&gt;&gt; = eta2
    eta_j&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter j&quot;}&gt;&gt;&gt; = eta3
    eta_k&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter k&quot;}&gt;&gt;&gt; = eta1
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = h2
  []
  # h3(eta1, eta2, eta3)
  [h3]
    type = SwitchingFunction3PhaseMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Material for switching function that prevents formation of a third phase at a two-phase interface: $h_i = \\eta_i^2/4 [15 (1-\\eta_i) [1 + \\eta_i - (\\eta_k - \\eta_j)^2] + \\eta_i (9\\eta_i^2 - 5)]$&quot;, &quot;href&quot;: &quot;SwitchingFunction3PhaseMaterial.html&quot;}&gt;&gt;&gt;
    eta_i&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter i&quot;}&gt;&gt;&gt; = eta3
    eta_j&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter j&quot;}&gt;&gt;&gt; = eta1
    eta_k&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter k&quot;}&gt;&gt;&gt; = eta2
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = h3
  []

  # Barrier functions for each phase
  [g1]
    type = BarrierFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $g(\\eta)$ and its derivative in a polynomial.\nSIMPLE: $\\eta^2(1-\\eta)^2$\nLOW: $\\eta(1-\\eta)$\nHIGH: $\\eta^2(1-\\eta^2)^2$&quot;, &quot;href&quot;: &quot;BarrierFunctionMaterial.html&quot;}&gt;&gt;&gt;
    g_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the barrier function g(eta)&quot;}&gt;&gt;&gt; = SIMPLE
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta1
    function_name&lt;&lt;&lt;{&quot;description&quot;: &quot;actual name for f(eta), i.e. &#x27;h&#x27; or &#x27;g&#x27;&quot;}&gt;&gt;&gt; = g1
  []
  [g2]
    type = BarrierFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $g(\\eta)$ and its derivative in a polynomial.\nSIMPLE: $\\eta^2(1-\\eta)^2$\nLOW: $\\eta(1-\\eta)$\nHIGH: $\\eta^2(1-\\eta^2)^2$&quot;, &quot;href&quot;: &quot;BarrierFunctionMaterial.html&quot;}&gt;&gt;&gt;
    g_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the barrier function g(eta)&quot;}&gt;&gt;&gt; = SIMPLE
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta2
    function_name&lt;&lt;&lt;{&quot;description&quot;: &quot;actual name for f(eta), i.e. &#x27;h&#x27; or &#x27;g&#x27;&quot;}&gt;&gt;&gt; = g2
  []
  [g3]
    type = BarrierFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $g(\\eta)$ and its derivative in a polynomial.\nSIMPLE: $\\eta^2(1-\\eta)^2$\nLOW: $\\eta(1-\\eta)$\nHIGH: $\\eta^2(1-\\eta^2)^2$&quot;, &quot;href&quot;: &quot;BarrierFunctionMaterial.html&quot;}&gt;&gt;&gt;
    g_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the barrier function g(eta)&quot;}&gt;&gt;&gt; = SIMPLE
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta3
    function_name&lt;&lt;&lt;{&quot;description&quot;: &quot;actual name for f(eta), i.e. &#x27;h&#x27; or &#x27;g&#x27;&quot;}&gt;&gt;&gt; = g3
  []

  # constant properties
  [constants]
    type = GenericConstantMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Declares material properties based on names and values prescribed by input parameters.&quot;, &quot;href&quot;: &quot;GenericConstantMaterial.html&quot;}&gt;&gt;&gt;
    prop_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The names of the properties this material will have&quot;}&gt;&gt;&gt; = &#x27;L   kappa  M&#x27;
    prop_values&lt;&lt;&lt;{&quot;description&quot;: &quot;The values associated with the named properties&quot;}&gt;&gt;&gt; = &#x27;0.7 1.0    0.025&#x27;
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#9cc8addc-8047-4c15-b194-f888f6410005">(moose/modules/phase_field/test/tests/KKS_system/kks_example_multiphase_nested_damped.i)</a></section></section><section id="7a146a05-a0f7-4987-81b7-153931cbb2c7" data-section-level="2" data-section-text="Class Description"><h2 id="class-description">Class Description</h2><p>Computes the KKS phase concentrations by using a nested Newton iteration to solve the equal chemical potential and concentration conservation equations for multiphase systems. This class is intented to be used with KKSPhaseConcentrationMultiPhaseDerivatives.</p></section><section id="595920b9-8357-4fe7-9a69-7ebd2c71f453" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="29f7d599-4698-45e3-ba31-f635c735e067" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">Fj_names</span><span class="moose-parameter-header-description">Free energy material objects in the same order as all_etas.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;MaterialName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Free energy material objects in the same order as all_etas.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">all_etas</span><span class="moose-parameter-header-description">Order parameters.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Order parameters.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">ci_IC</span><span class="moose-parameter-header-description">Initial values of ci in the same order of ci_names</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;double&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Initial values of ci in the same order of ci_names</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">ci_names</span><span class="moose-parameter-header-description">Phase concentrations. They must have the same order as Fj_names and global_cs, for example, c1, c2, b1, b2.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;MaterialPropertyName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Phase concentrations. They must have the same order as Fj_names and global_cs, for example, c1, c2, b1, b2.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">global_cs</span><span class="moose-parameter-header-description">The interpolated concentrations c, b, etc.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The interpolated concentrations c, b, etc.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">hj_names</span><span class="moose-parameter-header-description">Switching functions in the same order as all_etas.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;MaterialPropertyName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Switching functions in the same order as all_etas.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="78a43988-de31-4acb-b83b-23356dda9181" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">absolute_tolerance</span><span class="moose-parameter-header-default">1e-13</span><span class="moose-parameter-header-description">Absolute convergence tolerance for Newton iteration</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-13</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Absolute convergence tolerance for Newton iteration</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">acceptable_multiplier</span><span class="moose-parameter-header-default">10</span><span class="moose-parameter-header-description">Factor applied to relative and absolute tolerance for acceptable nonlinear convergence if iterations are no longer making progress</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>10</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Factor applied to relative and absolute tolerance for acceptable nonlinear convergence if iterations are no longer making progress</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">args</span><span class="moose-parameter-header-description">The coupled variables of free energies.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The coupled variables of free energies.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">block</span><span class="moose-parameter-header-description">The list of blocks (ids or names) that this object will be applied</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of blocks (ids or names) that this object will be applied</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">boundary</span><span class="moose-parameter-header-description">The list of boundaries (ids or names) from the mesh where this object applies</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;BoundaryName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of boundaries (ids or names) from the mesh where this object applies</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">compute</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">conditions</span><span class="moose-parameter-header-default">C</span><span class="moose-parameter-header-description">Material property that checks bounds and conditions on the material properties being solved for.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>C</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Material property that checks bounds and conditions on the material properties being solved for.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">constant_on</span><span class="moose-parameter-header-default">NONE</span><span class="moose-parameter-header-description">When ELEMENT, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps.When SUBDOMAIN, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps. Evaluations on element qps will be skipped</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>NONE</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>NONE, ELEMENT, SUBDOMAIN</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When ELEMENT, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps.When SUBDOMAIN, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps. Evaluations on element qps will be skipped</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">damped_Newton</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not to use the damped Newton's method.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not to use the damped Newton's method.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">damping_factor</span><span class="moose-parameter-header-default">0.8</span><span class="moose-parameter-header-description">Factor applied to step size if guess does not satisfy damping criteria</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0.8</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Factor applied to step size if guess does not satisfy damping criteria</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">declare_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any declared properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any declared properties. The suffix will be prepended with a '_' character.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">max_damping_iterations</span><span class="moose-parameter-header-default">100</span><span class="moose-parameter-header-description">Maximum number of damping steps per linear iteration of nested solve</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>100</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Maximum number of damping steps per linear iteration of nested solve</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">max_iterations</span><span class="moose-parameter-header-default">1000</span><span class="moose-parameter-header-description">Maximum number of nonlinear iterations</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1000</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Maximum number of nonlinear iterations</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">min_iterations</span><span class="moose-parameter-header-default">3</span><span class="moose-parameter-header-description">Minimum number of nonlinear iterations to execute before accepting convergence</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>3</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Minimum number of nonlinear iterations to execute before accepting convergence</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">nested_iterations</span><span class="moose-parameter-header-description">The output number of nested Newton iterations at each quadrature point.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The output number of nested Newton iterations at each quadrature point.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">relative_tolerance</span><span class="moose-parameter-header-default">1e-08</span><span class="moose-parameter-header-description">Relative convergence tolerance for Newton iteration</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-08</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Relative convergence tolerance for Newton iteration</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">step_size_tolerance</span><span class="moose-parameter-header-default">1e-15</span><span class="moose-parameter-header-description">Minimum step size of linear iterations relative to value of the solution</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-15</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Minimum step size of linear iterations relative to value of the solution</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="8e266731-ddd9-48b4-8cb0-3cb1bf542c4d" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>Yes</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">implicit</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Determines whether this object is calculated using an implicit or explicit form</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Determines whether this object is calculated using an implicit or explicit form</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">search_method</span><span class="moose-parameter-header-default">nearest_node_connected_sides</span><span class="moose-parameter-header-description">Choice of search algorithm.  All options begin by finding the nearest node in the primary boundary to a query point in the secondary boundary.  In the default nearest_node_connected_sides algorithm, primary boundary elements are searched iff that nearest node is one of their nodes.  This is fast to determine via a pregenerated node-to-elem map and is robust on conforming meshes.  In the optional all_proximate_sides algorithm, primary boundary elements are searched iff they touch that nearest node, even if they are not topologically connected to it.  This is more CPU-intensive but is necessary for robustness on any boundary surfaces which has disconnections (such as Flex IGA meshes) or non-conformity (such as hanging nodes in adaptively h-refined meshes).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nearest_node_connected_sides</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nearest_node_connected_sides, all_proximate_sides</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Choice of search algorithm.  All options begin by finding the nearest node in the primary boundary to a query point in the secondary boundary.  In the default nearest_node_connected_sides algorithm, primary boundary elements are searched iff that nearest node is one of their nodes.  This is fast to determine via a pregenerated node-to-elem map and is robust on conforming meshes.  In the optional all_proximate_sides algorithm, primary boundary elements are searched iff they touch that nearest node, even if they are not topologically connected to it.  This is more CPU-intensive but is necessary for robustness on any boundary surfaces which has disconnections (such as Flex IGA meshes) or non-conformity (such as hanging nodes in adaptively h-refined meshes).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">seed</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The seed for the master random number generator</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The seed for the master random number generator</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="79ab65b3-7744-4a2f-bee9-dc2ee5a18d3a" data-section-level="3" data-section-text="Outputs Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">output_properties</span><span class="moose-parameter-header-description">List of material properties, from this material, to output (outputs must also be defined to an output type)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>List of material properties, from this material, to output (outputs must also be defined to an output type)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">outputs</span><span class="moose-parameter-header-default">none </span><span class="moose-parameter-header-description">Vector of output names where you would like to restrict the output of variables(s) associated with this object</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>none </p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;OutputName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Vector of output names where you would like to restrict the output of variables(s) associated with this object</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Outputs Parameters</h3></summary></details></section><section id="87a4cab4-f328-448a-84e5-be910311d5be" data-section-level="3" data-section-text="Material Property Retrieval Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">prop_getter_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_interpolated_state</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">For the old and older state use projected material properties interpolated at the quadrature points. To set up projection use the ProjectedStatefulMaterialStorageAction.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>For the old and older state use projected material properties interpolated at the quadrature points. To set up projection use the ProjectedStatefulMaterialStorageAction.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Material Property Retrieval Parameters</h3></summary></details></section></section></section><div class="moose-modal modal" id="84d85cf6-114d-4efb-8a8d-8f62885c56fa"><div class="modal-content"><h4>compute</h4><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.</p></div></div><div class="moose-modal modal" id="2dc3f78b-378c-46fe-941e-727f8a3ca3b3"><div class="modal-content"><h4>(moose/modules/phase_field/test/tests/KKS_system/kks_example_multiphase_nested.i)</h4><pre style="max-height:350px;"><code class="language-moose">#
# This test is for the nested solve of 3-phase KKS model
# The split-form of the Cahn-Hilliard equation instead of the Fick&#x27;s diffusion equation is solved

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
  nz = 0
  xmin = 0
  xmax = 40
  ymin = 0
  ymax = 40
  zmin = 0
  zmax = 0
  elem_type = QUAD4
[]

[BCs]
  [Periodic]
    [all]
      auto_direction = &#x27;x y&#x27;
    []
  []
[]

[AuxVariables]
  [Energy]
    order = CONSTANT
    family = MONOMIAL
  []
[]

[Variables]
  # concentration
  [c]
    order = FIRST
    family = LAGRANGE
  []

  # order parameter 1
  [eta1]
    order = FIRST
    family = LAGRANGE
  []

  # order parameter 2
  [eta2]
    order = FIRST
    family = LAGRANGE
  []

  # order parameter 3
  [eta3]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  []

  # chemical potential
  [mu]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  []

  # Lagrange multiplier
  [lambda]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  []
[]

[ICs]
  [eta1]
    variable = eta1
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.9
    outvalue = 0.1
    int_width = 4
  []
  [eta2]
    variable = eta2
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.1
    outvalue = 0.9
    int_width = 4
  []
  [c]
    variable = c
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.2
    outvalue = 0.5
    int_width = 2
  []
[]

[Materials]
  # simple toy free energies
  [F1]
    type = DerivativeParsedMaterial
    property_name = F1
    expression = &#x27;20*(c1-0.2)^2&#x27;
    material_property_names = &#x27;c1&#x27;
    additional_derivative_symbols = &#x27;c1&#x27;
    compute = false
  []
  [F2]
    type = DerivativeParsedMaterial
    property_name = F2
    expression = &#x27;20*(c2-0.5)^2&#x27;
    material_property_names = &#x27;c2&#x27;
    additional_derivative_symbols = &#x27;c2&#x27;
    compute = false
  []
  [F3]
    type = DerivativeParsedMaterial
    property_name = F3
    expression = &#x27;20*(c3-0.8)^2&#x27;
    material_property_names = &#x27;c3&#x27;
    additional_derivative_symbols = &#x27;c3&#x27;
    compute = false
  []
  [KKSPhaseConcentrationMultiPhaseMaterial]
    type = KKSPhaseConcentrationMultiPhaseMaterial
    global_cs = &#x27;c&#x27;
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    ci_IC = &#x27;0.2 0.5 0.8&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    min_iterations = 1
    max_iterations = 1000
    absolute_tolerance = 1e-11
    relative_tolerance = 1e-10
  []
  [KKSPhaseConcentrationMultiPhaseDerivatives]
    type = KKSPhaseConcentrationMultiPhaseDerivatives
    global_cs = &#x27;c&#x27;
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
  []

  # Switching functions for each phase
  # h1(eta1, eta2, eta3)
  [h1]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta1
    eta_j = eta2
    eta_k = eta3
    property_name = h1
  []
  # h2(eta1, eta2, eta3)
  [h2]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta2
    eta_j = eta3
    eta_k = eta1
    property_name = h2
  []
  # h3(eta1, eta2, eta3)
  [h3]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta3
    eta_j = eta1
    eta_k = eta2
    property_name = h3
  []

  # Barrier functions for each phase
  [g1]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta1
    function_name = g1
  []
  [g2]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta2
    function_name = g2
  []
  [g3]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta3
    function_name = g3
  []

  # constant properties
  [constants]
    type = GenericConstantMaterial
    prop_names = &#x27;L   kappa  M&#x27;
    prop_values = &#x27;0.7 1.0    0.025&#x27;
  []
[]

[Kernels]
  [lambda_lagrange]
    type = SwitchingFunctionConstraintLagrange
    variable = lambda
    etas = &#x27;eta1 eta2 eta3&#x27;
    h_names = &#x27;h1   h2   h3&#x27;
    epsilon = 1e-04
  []
  [eta1_lagrange]
    type = SwitchingFunctionConstraintEta
    variable = eta1
    h_name = h1
    lambda = lambda
    coupled_variables = &#x27;eta2 eta3&#x27;
  []
  [eta2_lagrange]
    type = SwitchingFunctionConstraintEta
    variable = eta2
    h_name = h2
    lambda = lambda
    coupled_variables = &#x27;eta1 eta3&#x27;
  []
  [eta3_lagrange]
    type = SwitchingFunctionConstraintEta
    variable = eta3
    h_name = h3
    lambda = lambda
    coupled_variables = &#x27;eta1 eta2&#x27;
  []

  #Kernels for Cahn-Hilliard equation
  [diff_time]
    type = CoupledTimeDerivative
    variable = mu
    v = c
  []
  [CHBulk]
    type = NestedKKSMultiSplitCHCRes
    variable = c
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    global_cs = &#x27;c&#x27;
    w = mu
    c1_names = &#x27;c1&#x27;
    F1_name = F1
    coupled_variables = &#x27;eta1 eta2 eta3 mu&#x27;
  []
  [ckernel]
    type = SplitCHWRes
    variable = mu
    mob_name = M
  []

  # Kernels for Allen-Cahn equation for eta1
  [deta1dt]
    type = TimeDerivative
    variable = eta1
  []
  [ACBulkF1]
    type = NestedKKSMultiACBulkF
    variable = eta1
    global_cs = &#x27;c&#x27;
    eta_i = eta1
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    gi_name = g1
    mob_name = L
    wi = 1.0
    coupled_variables = &#x27;c eta2 eta3&#x27;
  []
  [ACBulkC1]
    type = NestedKKSMultiACBulkC
    variable = eta1
    global_cs = &#x27;c&#x27;
    eta_i = eta1
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    coupled_variables = &#x27;c eta2 eta3&#x27;
  []
  [ACInterface1]
    type = ACInterface
    variable = eta1
    kappa_name = kappa
  []

  # Kernels for Allen-Cahn equation for eta2
  [deta2dt]
    type = TimeDerivative
    variable = eta2
  []
  [ACBulkF2]
    type = NestedKKSMultiACBulkF
    variable = eta2
    global_cs = &#x27;c&#x27;
    eta_i = eta2
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    gi_name = g2
    mob_name = L
    wi = 1.0
    coupled_variables = &#x27;c eta1 eta3&#x27;
  []
  [ACBulkC2]
    type = NestedKKSMultiACBulkC
    variable = eta2
    global_cs = &#x27;c&#x27;
    eta_i = eta2
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    coupled_variables = &#x27;c eta1 eta3&#x27;
  []
  [ACInterface2]
    type = ACInterface
    variable = eta2
    kappa_name = kappa
  []

  # Kernels for Allen-Cahn equation for eta3
  [deta3dt]
    type = TimeDerivative
    variable = eta3
  []
  [ACBulkF3]
    type = NestedKKSMultiACBulkF
    variable = eta3
    global_cs = &#x27;c&#x27;
    eta_i = eta3
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    gi_name = g3
    mob_name = L
    wi = 1.0
    coupled_variables = &#x27;c eta1 eta2&#x27;
  []
  [ACBulkC3]
    type = NestedKKSMultiACBulkC
    variable = eta3
    global_cs = &#x27;c&#x27;
    eta_i = eta3
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    coupled_variables = &#x27;c eta1 eta2&#x27;
  []
  [ACInterface3]
    type = ACInterface
    variable = eta3
    kappa_name = kappa
  []
[]

[AuxKernels]
  [Energy_total]
    type = KKSMultiFreeEnergy
    Fj_names = &#x27;F1 F2 F3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    gj_names = &#x27;g1 g2 g3&#x27;
    variable = Energy
    w = 1
    interfacial_vars = &#x27;eta1  eta2  eta3&#x27;
    kappa_names = &#x27;kappa kappa kappa&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type   -sub_pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;asm       ilu            nonzero&#x27;
  l_max_its = 30
  nl_max_its = 10
  l_tol = 1.0e-4
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-11

  num_steps = 2
  dt = 0.5
[]

[Preconditioning]
  active = &#x27;full&#x27;
  [full]
    type = SMP
    full = true
  []
  [mydebug]
    type = FDP
    full = true
  []
[]

[Outputs]
  file_base = kks_example_multiphase_nested
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="300208c9-9f55-4f7d-939d-c6cddff8e6d3"><div class="modal-content"><h4>compute</h4><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.</p></div></div><div class="moose-modal modal" id="9cc8addc-8047-4c15-b194-f888f6410005"><div class="modal-content"><h4>(moose/modules/phase_field/test/tests/KKS_system/kks_example_multiphase_nested_damped.i)</h4><pre style="max-height:350px;"><code class="language-moose">#
# This test is for the damped nested solve of 3-phase KKS model, and uses log-based free energies.
# The split-form of the Cahn-Hilliard equation instead of the Fick&#x27;s diffusion equation is solved

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
  nz = 0
  xmin = 0
  xmax = 40
  ymin = 0
  ymax = 40
  zmin = 0
  zmax = 0
  elem_type = QUAD4
[]

[BCs]
  [Periodic]
    [all]
      auto_direction = &#x27;x y&#x27;
    []
  []
[]

[AuxVariables]
  [Energy]
    order = CONSTANT
    family = MONOMIAL
  []
[]

[Variables]
  # concentration
  [c]
    order = FIRST
    family = LAGRANGE
  []

  # order parameter 1
  [eta1]
    order = FIRST
    family = LAGRANGE
  []

  # order parameter 2
  [eta2]
    order = FIRST
    family = LAGRANGE
  []

  # order parameter 3
  [eta3]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  []

  # chemical potential
  [mu]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  []

  # Lagrange multiplier
  [lambda]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  []
[]

[ICs]
  [eta1]
    variable = eta1
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.9
    outvalue = 0.1
    int_width = 4
  []
  [eta2]
    variable = eta2
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.1
    outvalue = 0.9
    int_width = 4
  []
  [c]
    variable = c
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.2
    outvalue = 0.5
    int_width = 2
  []
[]

[Materials]
  # simple toy free energies
  [F1]
    type = DerivativeParsedMaterial
    property_name = F1
    expression = &#x27;c1*log(c1/1e-4) + (1-c1)*log((1-c1)/(1-1e-4))&#x27;
    material_property_names = &#x27;c1&#x27;
    additional_derivative_symbols = &#x27;c1&#x27;
    compute = false
  []
  [F2]
    type = DerivativeParsedMaterial
    property_name = F2
    expression = &#x27;c2*log(c2/0.5) + (1-c2)*log((1-c2)/(1-0.5))&#x27;
    material_property_names = &#x27;c2&#x27;
    additional_derivative_symbols = &#x27;c2&#x27;
    compute = false
  []
  [F3]
    type = DerivativeParsedMaterial
    property_name = F3
    expression = &#x27;c3*log(c3/0.9999) + (1-c3)*log((1-c3)/(1-0.9999))&#x27;
    material_property_names = &#x27;c3&#x27;
    additional_derivative_symbols = &#x27;c3&#x27;
    compute = false
  []
  [C]
    type = DerivativeParsedMaterial
    property_name = &#x27;C&#x27;
    material_property_names = &#x27;c1 c2 c3&#x27;
    expression = &#x27;(c1&gt;0)&amp;(c1&lt;1)&amp;(c2&gt;0)&amp;(c2&lt;1)&amp;(c3&gt;0)&amp;(c3&lt;1)&#x27;
    compute = false
  []
  [KKSPhaseConcentrationMultiPhaseMaterial]
    type = KKSPhaseConcentrationMultiPhaseMaterial
    global_cs = &#x27;c&#x27;
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    ci_IC = &#x27;0.2 0.5 0.8&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    min_iterations = 1
    max_iterations = 1000
    absolute_tolerance = 1e-15
    relative_tolerance = 1e-8
    step_size_tolerance = 1e-05
    damped_Newton = true
    conditions = C
    damping_factor = 0.8
  []
  [KKSPhaseConcentrationMultiPhaseDerivatives]
    type = KKSPhaseConcentrationMultiPhaseDerivatives
    global_cs = &#x27;c&#x27;
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
  []

  # Switching functions for each phase
  # h1(eta1, eta2, eta3)
  [h1]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta1
    eta_j = eta2
    eta_k = eta3
    property_name = h1
  []
  # h2(eta1, eta2, eta3)
  [h2]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta2
    eta_j = eta3
    eta_k = eta1
    property_name = h2
  []
  # h3(eta1, eta2, eta3)
  [h3]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta3
    eta_j = eta1
    eta_k = eta2
    property_name = h3
  []

  # Barrier functions for each phase
  [g1]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta1
    function_name = g1
  []
  [g2]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta2
    function_name = g2
  []
  [g3]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta3
    function_name = g3
  []

  # constant properties
  [constants]
    type = GenericConstantMaterial
    prop_names = &#x27;L   kappa  M&#x27;
    prop_values = &#x27;0.7 1.0    0.025&#x27;
  []
[]

[Kernels]
  [lambda_lagrange]
    type = SwitchingFunctionConstraintLagrange
    variable = lambda
    etas = &#x27;eta1 eta2 eta3&#x27;
    h_names = &#x27;h1   h2   h3&#x27;
    epsilon = 1e-04
  []
  [eta1_lagrange]
    type = SwitchingFunctionConstraintEta
    variable = eta1
    h_name = h1
    lambda = lambda
    coupled_variables = &#x27;eta2 eta3&#x27;
  []
  [eta2_lagrange]
    type = SwitchingFunctionConstraintEta
    variable = eta2
    h_name = h2
    lambda = lambda
    coupled_variables = &#x27;eta1 eta3&#x27;
  []
  [eta3_lagrange]
    type = SwitchingFunctionConstraintEta
    variable = eta3
    h_name = h3
    lambda = lambda
    coupled_variables = &#x27;eta1 eta2&#x27;
  []

  #Kernels for Cahn-Hilliard equation
  [diff_time]
    type = CoupledTimeDerivative
    variable = mu
    v = c
  []
  [CHBulk]
    type = NestedKKSMultiSplitCHCRes
    variable = c
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    global_cs = &#x27;c&#x27;
    w = mu
    c1_names = &#x27;c1&#x27;
    F1_name = F1
    coupled_variables = &#x27;eta1 eta2 eta3 mu&#x27;
  []
  [ckernel]
    type = SplitCHWRes
    variable = mu
    mob_name = M
  []

  # Kernels for Allen-Cahn equation for eta1
  [deta1dt]
    type = TimeDerivative
    variable = eta1
  []
  [ACBulkF1]
    type = NestedKKSMultiACBulkF
    variable = eta1
    global_cs = &#x27;c&#x27;
    eta_i = eta1
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    gi_name = g1
    mob_name = L
    wi = 1.0
    coupled_variables = &#x27;c eta2 eta3&#x27;
  []
  [ACBulkC1]
    type = NestedKKSMultiACBulkC
    variable = eta1
    global_cs = &#x27;c&#x27;
    eta_i = eta1
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    coupled_variables = &#x27;c eta2 eta3&#x27;
  []
  [ACInterface1]
    type = ACInterface
    variable = eta1
    kappa_name = kappa
  []

  # Kernels for Allen-Cahn equation for eta2
  [deta2dt]
    type = TimeDerivative
    variable = eta2
  []
  [ACBulkF2]
    type = NestedKKSMultiACBulkF
    variable = eta2
    global_cs = &#x27;c&#x27;
    eta_i = eta2
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    gi_name = g2
    mob_name = L
    wi = 1.0
    coupled_variables = &#x27;c eta1 eta3&#x27;
  []
  [ACBulkC2]
    type = NestedKKSMultiACBulkC
    variable = eta2
    global_cs = &#x27;c&#x27;
    eta_i = eta2
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    coupled_variables = &#x27;c eta1 eta3&#x27;
  []
  [ACInterface2]
    type = ACInterface
    variable = eta2
    kappa_name = kappa
  []

  # Kernels for Allen-Cahn equation for eta3
  [deta3dt]
    type = TimeDerivative
    variable = eta3
  []
  [ACBulkF3]
    type = NestedKKSMultiACBulkF
    variable = eta3
    global_cs = &#x27;c&#x27;
    eta_i = eta3
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    gi_name = g3
    mob_name = L
    wi = 1.0
    coupled_variables = &#x27;c eta1 eta2&#x27;
  []
  [ACBulkC3]
    type = NestedKKSMultiACBulkC
    variable = eta3
    global_cs = &#x27;c&#x27;
    eta_i = eta3
    all_etas = &#x27;eta1 eta2 eta3&#x27;
    ci_names = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    Fj_names = &#x27;F1 F2 F3&#x27;
    coupled_variables = &#x27;c eta1 eta2&#x27;
  []
  [ACInterface3]
    type = ACInterface
    variable = eta3
    kappa_name = kappa
  []
[]

[AuxKernels]
  [Energy_total]
    type = KKSMultiFreeEnergy
    Fj_names = &#x27;F1 F2 F3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    gj_names = &#x27;g1 g2 g3&#x27;
    variable = Energy
    w = 1
    interfacial_vars = &#x27;eta1  eta2  eta3&#x27;
    kappa_names = &#x27;kappa kappa kappa&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type   -sub_pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;asm       ilu            nonzero&#x27;
  l_max_its = 30
  nl_max_its = 10
  l_tol = 1.0e-4
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-11

  num_steps = 2
  dt = 0.01
[]

[Preconditioning]
  active = &#x27;full&#x27;
  [full]
    type = SMP
    full = true
  []
  [mydebug]
    type = FDP
    full = true
  []
[]

[Outputs]
  file_base = kks_example_multiphase_nested_damped
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
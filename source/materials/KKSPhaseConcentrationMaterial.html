<!DOCTYPE html><head><meta charset="UTF-8"><title>KKSPhaseConcentrationMaterial | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="5aca3737-29a4-4503-ba61-688ab33d62e9" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="abff5828-6152-458a-b70a-b4fec1fb22e8" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="878d7c4b-acce-4a30-be91-6776c79a55e6" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1ec29f06-1d6a-46ef-bca8-d05dd6799537" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="2239797e-1931-4fc0-a125-02b97abae662"><i class="material-icons">menu</i></a><ul class="sidenav" id="2239797e-1931-4fc0-a125-02b97abae662"><li><a href="#!" class="dropdown-trigger" data-target="13ab7f5c-2e14-47cf-9b38-46011526cb1e" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8d42acf7-12e3-49de-bc46-15e7808a6176" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ac91c60b-5b3f-4bb3-b79f-3b05510e4dcc" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="20a0bf47-5838-4433-86eb-fcfbb4dc63f4" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="5aca3737-29a4-4503-ba61-688ab33d62e9"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="abff5828-6152-458a-b70a-b4fec1fb22e8"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="878d7c4b-acce-4a30-be91-6776c79a55e6"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="1ec29f06-1d6a-46ef-bca8-d05dd6799537"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="13ab7f5c-2e14-47cf-9b38-46011526cb1e"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="8d42acf7-12e3-49de-bc46-15e7808a6176"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="ac91c60b-5b3f-4bb3-b79f-3b05510e4dcc"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="20a0bf47-5838-4433-86eb-fcfbb4dc63f4"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="e757e82c-ae22-4007-8851-0497bda458fc" data-section-level="1" data-section-text="KKSPhaseConcentrationMaterial"><h1 id="kksphaseconcentrationmaterial">KKSPhaseConcentrationMaterial</h1><p>Kim-Kim-Suzuki (KKS) nested solve material (part 1 of 2). KKSPhaseConcentrationMaterial implements a nested Newton iteration to solve the KKS constraint equations for the phase concentrations <span class="moose-katex-inline-equation" id="moose-equation-c534c309-b06a-419c-8272-0d15724d0e32"><script>var element = document.getElementById("moose-equation-c534c309-b06a-419c-8272-0d15724d0e32");katex.render("c_a", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-6d1e8e0d-1782-4cf8-8d31-9fc85589c3f3"><script>var element = document.getElementById("moose-equation-6d1e8e0d-1782-4cf8-8d31-9fc85589c3f3");katex.render("c_b", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> as material properties (instead of non-linear variables as in the traditional solve in MOOSE). The constraint equations are the mass conservation equation for each global concentration (<span class="moose-katex-inline-equation" id="moose-equation-dbb3680c-5ca8-4ec8-a27e-ba4009abedca"><script>var element = document.getElementById("moose-equation-dbb3680c-5ca8-4ec8-a27e-ba4009abedca");katex.render("c", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>):</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-d1d3a9d0-1d68-4f9c-a14a-dce394345eef"></span><script>var element = document.getElementById("moose-equation-d1d3a9d0-1d68-4f9c-a14a-dce394345eef");katex.render("c=\\left(1-h(\\eta)\\right)c_a + h(\\eta)c_b,", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>and the pointwise equality of the phase chemical potentials:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-9a695f1e-6f78-4fd4-8f28-d7ab03a53e81"></span><script>var element = document.getElementById("moose-equation-9a695f1e-6f78-4fd4-8f28-d7ab03a53e81");katex.render("\\frac{\\partial f_a}{\\partial c_a} = \\frac{\\partial f_b}{\\partial c_b}.", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>The parameters Fa_material and Fb_material must have <a href="#afa12e84-daba-4eae-b8f1-446ca9fe7e45" class="moose-modal-link modal-trigger">&quot;compute&quot;</a> set to <code>false</code>. This material also passes the phase free energies and their partial derivatives w.r.t phase concentrations to the KKS kernels (NestKKSACBulkC, NestKKSACBulkF, NestKKSSplitCHCRes).</p><section id="accc8096-60e4-4f6d-bfce-eb5c54e4db2f" data-section-level="2" data-section-text="Example input :"><h2 id="example-input">Example input:</h2><section id="8260c3a4-d521-4249-a35b-a95fd75bac12" data-section-level="3" data-section-text="Without damping"><h3 id="without-damping">Without damping</h3><p>Parabolic free energies have valid values for any real number, and therefore don&#x27;t require damping to ensure the solution is inside a trust region.</p><pre style="max-height:350px;"><code class="language-moose">[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  # Free energy of the matrix
  [fm]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = fm
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;(0.1-cm)^2&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;cm&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;cm&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []

  # Free energy of the delta phase
  [fd]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = fd
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;(0.9-cd)^2&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;cd&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;cd&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []

  # Compute phase concentrations
  [PhaseConcentrationMaterial]
    type = KKSPhaseConcentrationMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the KKS phase concentrations by using nested Newton iteration to solve the equal chemical potential and concentration conservation equations. This class is intended to be used with KKSPhaseConcentrationDerivatives.&quot;, &quot;href&quot;: &quot;KKSPhaseConcentrationMaterial.html&quot;}&gt;&gt;&gt;
    global_cs&lt;&lt;&lt;{&quot;description&quot;: &quot;The interpolated concentrations c, b, etc.&quot;}&gt;&gt;&gt; = &#x27;c&#x27;
    ci_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Phase concentrations. The order must match Fa, Fb, and global_cs, for example, c1, c2, b1, b2, etc.&quot;}&gt;&gt;&gt; = &#x27;cm cd&#x27;
    ci_IC&lt;&lt;&lt;{&quot;description&quot;: &quot;Initial values of ci in the same order as ci_names.&quot;}&gt;&gt;&gt; = &#x27;0 0&#x27;
    fa_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Fa material object.&quot;}&gt;&gt;&gt; = fm
    fb_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Fb material object.&quot;}&gt;&gt;&gt; = fd
    h_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Switching function h(eta).&quot;}&gt;&gt;&gt; = h
    min_iterations&lt;&lt;&lt;{&quot;description&quot;: &quot;Minimum number of nonlinear iterations to execute before accepting convergence&quot;}&gt;&gt;&gt; = 1
    max_iterations&lt;&lt;&lt;{&quot;description&quot;: &quot;Maximum number of nonlinear iterations&quot;}&gt;&gt;&gt; = 100
    absolute_tolerance&lt;&lt;&lt;{&quot;description&quot;: &quot;Absolute convergence tolerance for Newton iteration&quot;}&gt;&gt;&gt; = 1e-9
    relative_tolerance&lt;&lt;&lt;{&quot;description&quot;: &quot;Relative convergence tolerance for Newton iteration&quot;}&gt;&gt;&gt; = 1e-9
    nested_iterations&lt;&lt;&lt;{&quot;description&quot;: &quot;The output number of nested Newton iterations at each quadrature point.&quot;}&gt;&gt;&gt; = iter
    outputs&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of output names where you would like to restrict the output of variables(s) associated with this object&quot;}&gt;&gt;&gt; = exodus
  []

  # Compute chain rule terms
  [PhaseConcentrationDerivatives]
    type = KKSPhaseConcentrationDerivatives&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the KKS phase concentration derivatives wrt global concentrations and order parameters, which are used in the chain rules in the KKS kernels. This class is intended to be used with KKSPhaseConcentrationMaterial.&quot;, &quot;href&quot;: &quot;KKSPhaseConcentrationDerivatives.html&quot;}&gt;&gt;&gt;
    global_cs&lt;&lt;&lt;{&quot;description&quot;: &quot;The interpolated concentrations c, b, etc&quot;}&gt;&gt;&gt; = &#x27;c&#x27;
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter.&quot;}&gt;&gt;&gt; = eta
    ci_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Phase concentrations. The order must match Fa, Fb, and global_cs, for example, c1, c2, b1, b2, etc&quot;}&gt;&gt;&gt; = &#x27;cm cd&#x27;
    fa_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Fa material object.&quot;}&gt;&gt;&gt; = fm
    fb_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Fb material object.&quot;}&gt;&gt;&gt; = fd
    h_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Switching function h(eta).&quot;}&gt;&gt;&gt; = h
  []

  # h(eta)
  [h_eta]
    type = SwitchingFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $h(\\eta)$ and its derivative in one of two polynomial forms.\nSIMPLE: $3\\eta^2-2\\eta^3$\nHIGH: $\\eta^3(6\\eta^2-15\\eta+10)$&quot;, &quot;href&quot;: &quot;SwitchingFunctionMaterial.html&quot;}&gt;&gt;&gt;
    h_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the switching function h(eta)&quot;}&gt;&gt;&gt; = HIGH
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta
  []

  # g(eta)
  [g_eta]
    type = BarrierFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $g(\\eta)$ and its derivative in a polynomial.\nSIMPLE: $\\eta^2(1-\\eta)^2$\nLOW: $\\eta(1-\\eta)$\nHIGH: $\\eta^2(1-\\eta^2)^2$&quot;, &quot;href&quot;: &quot;BarrierFunctionMaterial.html&quot;}&gt;&gt;&gt;
    g_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the barrier function g(eta)&quot;}&gt;&gt;&gt; = SIMPLE
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta
  []

  # constant properties
  [constants]
    type = GenericConstantMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Declares material properties based on names and values prescribed by input parameters.&quot;, &quot;href&quot;: &quot;GenericConstantMaterial.html&quot;}&gt;&gt;&gt;
    prop_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The names of the properties this material will have&quot;}&gt;&gt;&gt; = &#x27;M   L   kappa&#x27;
    prop_values&lt;&lt;&lt;{&quot;description&quot;: &quot;The values associated with the named properties&quot;}&gt;&gt;&gt; = &#x27;0.7 0.7 0.4  &#x27;
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#dfdcb2ad-26d2-4102-a2b6-567a23b4a028">(moose/modules/phase_field/test/tests/KKS_system/kks_example_nested.i)</a></section><section id="33d8f505-ee21-4532-9df9-c5a35b0cb62a" data-section-level="3" data-section-text="With damping"><h3 id="with-damping">With damping</h3><p>Log free energies are only valid when the component phase mole fractions are within 0 to 1. We add a material <code>C</code> that checks if the nested solve guess is within this trust region. Similar to the free energy, <code>C</code> must have <a href="#57000b4c-23a9-4648-bf58-19cee3a5b0bc" class="moose-modal-link modal-trigger">&quot;compute&quot;</a> set to <code>false</code>. The nested solve then requires damping to ensure the solution is inside the trust region.</p><pre style="max-height:350px;"><code class="language-moose">[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  # Free energy of the matrix
  [fm]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = fm
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;cm*log(cm/1e-4) + (1-cm)*log((1-cm)/(1-1e-4))&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;cm&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;cm&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []

  # Free energy of the delta phase
  [fd]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = fd
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;cd*log(cd/0.9999) + (1-cd)*log((1-cd)/(1-0.9999))&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;cd&#x27;
    additional_derivative_symbols&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of additional (non-variable) symbols (such as material property or postprocessor names) to take derivatives w.r.t.&quot;}&gt;&gt;&gt; = &#x27;cd&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []
  [C]
    type = DerivativeParsedMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed Function Material with automatic derivatives.&quot;, &quot;href&quot;: &quot;DerivativeParsedMaterial.html&quot;}&gt;&gt;&gt;
    property_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the parsed material property&quot;}&gt;&gt;&gt; = &#x27;C&#x27;
    material_property_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of material properties used in the parsed function&quot;}&gt;&gt;&gt; = &#x27;cm cd&#x27;
    expression&lt;&lt;&lt;{&quot;description&quot;: &quot;Parsed function (see FParser) expression for the parsed material&quot;}&gt;&gt;&gt; = &#x27;(cm&gt;0)&amp;(cm&lt;1)&amp;(cd&gt;0)&amp;(cd&lt;1)&#x27;
    compute&lt;&lt;&lt;{&quot;description&quot;: &quot;When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.&quot;}&gt;&gt;&gt; = false
  []
  # Compute phase concentrations
  [PhaseConcentrationMaterial]
    type = KKSPhaseConcentrationMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the KKS phase concentrations by using nested Newton iteration to solve the equal chemical potential and concentration conservation equations. This class is intended to be used with KKSPhaseConcentrationDerivatives.&quot;, &quot;href&quot;: &quot;KKSPhaseConcentrationMaterial.html&quot;}&gt;&gt;&gt;
    global_cs&lt;&lt;&lt;{&quot;description&quot;: &quot;The interpolated concentrations c, b, etc.&quot;}&gt;&gt;&gt; = &#x27;c&#x27;
    ci_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Phase concentrations. The order must match Fa, Fb, and global_cs, for example, c1, c2, b1, b2, etc.&quot;}&gt;&gt;&gt; = &#x27;cm cd&#x27;
    ci_IC&lt;&lt;&lt;{&quot;description&quot;: &quot;Initial values of ci in the same order as ci_names.&quot;}&gt;&gt;&gt; = &#x27;0.1 0.9&#x27;
    fa_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Fa material object.&quot;}&gt;&gt;&gt; = fm
    fb_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Fb material object.&quot;}&gt;&gt;&gt; = fd
    h_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Switching function h(eta).&quot;}&gt;&gt;&gt; = h
    min_iterations&lt;&lt;&lt;{&quot;description&quot;: &quot;Minimum number of nonlinear iterations to execute before accepting convergence&quot;}&gt;&gt;&gt; = 1
    max_iterations&lt;&lt;&lt;{&quot;description&quot;: &quot;Maximum number of nonlinear iterations&quot;}&gt;&gt;&gt; = 100
    absolute_tolerance&lt;&lt;&lt;{&quot;description&quot;: &quot;Absolute convergence tolerance for Newton iteration&quot;}&gt;&gt;&gt; = 1e-15
    relative_tolerance&lt;&lt;&lt;{&quot;description&quot;: &quot;Relative convergence tolerance for Newton iteration&quot;}&gt;&gt;&gt; = 1e-8
    step_size_tolerance&lt;&lt;&lt;{&quot;description&quot;: &quot;Minimum step size of linear iterations relative to value of the solution&quot;}&gt;&gt;&gt; = 1e-05
    nested_iterations&lt;&lt;&lt;{&quot;description&quot;: &quot;The output number of nested Newton iterations at each quadrature point.&quot;}&gt;&gt;&gt; = iter
    outputs&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector of output names where you would like to restrict the output of variables(s) associated with this object&quot;}&gt;&gt;&gt; = exodus
    damped_Newton&lt;&lt;&lt;{&quot;description&quot;: &quot;Whether or not to use the damped Newton&#x27;s method.&quot;}&gt;&gt;&gt; = true
    conditions&lt;&lt;&lt;{&quot;description&quot;: &quot;Material property that checks bounds and conditions on the material properties being solved for.&quot;}&gt;&gt;&gt; = C
    damping_factor&lt;&lt;&lt;{&quot;description&quot;: &quot;Factor applied to step size if guess does not satisfy damping criteria&quot;}&gt;&gt;&gt; = 0.8
  []

  # Compute chain rule terms
  [PhaseConcentrationDerivatives]
    type = KKSPhaseConcentrationDerivatives&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the KKS phase concentration derivatives wrt global concentrations and order parameters, which are used in the chain rules in the KKS kernels. This class is intended to be used with KKSPhaseConcentrationMaterial.&quot;, &quot;href&quot;: &quot;KKSPhaseConcentrationDerivatives.html&quot;}&gt;&gt;&gt;
    global_cs&lt;&lt;&lt;{&quot;description&quot;: &quot;The interpolated concentrations c, b, etc&quot;}&gt;&gt;&gt; = &#x27;c&#x27;
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter.&quot;}&gt;&gt;&gt; = eta
    ci_names&lt;&lt;&lt;{&quot;description&quot;: &quot;Phase concentrations. The order must match Fa, Fb, and global_cs, for example, c1, c2, b1, b2, etc&quot;}&gt;&gt;&gt; = &#x27;cm cd&#x27;
    fa_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Fa material object.&quot;}&gt;&gt;&gt; = fm
    fb_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Fb material object.&quot;}&gt;&gt;&gt; = fd
    h_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Switching function h(eta).&quot;}&gt;&gt;&gt; = h
  []

  # h(eta)
  [h_eta]
    type = SwitchingFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $h(\\eta)$ and its derivative in one of two polynomial forms.\nSIMPLE: $3\\eta^2-2\\eta^3$\nHIGH: $\\eta^3(6\\eta^2-15\\eta+10)$&quot;, &quot;href&quot;: &quot;SwitchingFunctionMaterial.html&quot;}&gt;&gt;&gt;
    h_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the switching function h(eta)&quot;}&gt;&gt;&gt; = HIGH
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta
  []

  # g(eta)
  [g_eta]
    type = BarrierFunctionMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Helper material to provide $g(\\eta)$ and its derivative in a polynomial.\nSIMPLE: $\\eta^2(1-\\eta)^2$\nLOW: $\\eta(1-\\eta)$\nHIGH: $\\eta^2(1-\\eta^2)^2$&quot;, &quot;href&quot;: &quot;BarrierFunctionMaterial.html&quot;}&gt;&gt;&gt;
    g_order&lt;&lt;&lt;{&quot;description&quot;: &quot;Polynomial order of the barrier function g(eta)&quot;}&gt;&gt;&gt; = SIMPLE
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Order parameter variable&quot;}&gt;&gt;&gt; = eta
  []

  # constant properties
  [constants]
    type = GenericConstantMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Declares material properties based on names and values prescribed by input parameters.&quot;, &quot;href&quot;: &quot;GenericConstantMaterial.html&quot;}&gt;&gt;&gt;
    prop_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The names of the properties this material will have&quot;}&gt;&gt;&gt; = &#x27;M   L   kappa&#x27;
    prop_values&lt;&lt;&lt;{&quot;description&quot;: &quot;The values associated with the named properties&quot;}&gt;&gt;&gt; = &#x27;0.7 0.7 0.4  &#x27;
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#5aa78ac9-b8b7-4047-b423-61aeff0eacb6">(moose/modules/phase_field/test/tests/KKS_system/kks_example_nested_damped.i)</a></section></section><section id="58fc155f-d5a7-4200-ae12-f5524b4de73a" data-section-level="2" data-section-text="Class Description"><h2 id="class-description">Class Description</h2><p>Computes the KKS phase concentrations by using nested Newton iteration to solve the equal chemical potential and concentration conservation equations. This class is intended to be used with KKSPhaseConcentrationDerivatives.</p></section><section id="61949aef-cf23-4136-b5e2-1bb25fc0e877" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="00342cb0-12c0-497d-b3e1-b81d7771724b" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">ci_IC</span><span class="moose-parameter-header-description">Initial values of ci in the same order as ci_names.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;double&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Initial values of ci in the same order as ci_names.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">ci_names</span><span class="moose-parameter-header-description">Phase concentrations. The order must match Fa, Fb, and global_cs, for example, c1, c2, b1, b2, etc.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;MaterialPropertyName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Phase concentrations. The order must match Fa, Fb, and global_cs, for example, c1, c2, b1, b2, etc.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">fa_name</span><span class="moose-parameter-header-description">Fa material object.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Fa material object.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">fb_name</span><span class="moose-parameter-header-description">Fb material object.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Fb material object.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">global_cs</span><span class="moose-parameter-header-description">The interpolated concentrations c, b, etc.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The interpolated concentrations c, b, etc.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">h_name</span><span class="moose-parameter-header-description">Switching function h(eta).</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Switching function h(eta).</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="582668dd-89c0-4a8e-a585-9ee39213fbae" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">absolute_tolerance</span><span class="moose-parameter-header-default">1e-13</span><span class="moose-parameter-header-description">Absolute convergence tolerance for Newton iteration</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-13</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Absolute convergence tolerance for Newton iteration</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">acceptable_multiplier</span><span class="moose-parameter-header-default">10</span><span class="moose-parameter-header-description">Factor applied to relative and absolute tolerance for acceptable nonlinear convergence if iterations are no longer making progress</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>10</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Factor applied to relative and absolute tolerance for acceptable nonlinear convergence if iterations are no longer making progress</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">args</span><span class="moose-parameter-header-description">The coupled variables of Fa and Fb.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The coupled variables of Fa and Fb.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">block</span><span class="moose-parameter-header-description">The list of blocks (ids or names) that this object will be applied</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of blocks (ids or names) that this object will be applied</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">boundary</span><span class="moose-parameter-header-description">The list of boundaries (ids or names) from the mesh where this object applies</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;BoundaryName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of boundaries (ids or names) from the mesh where this object applies</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">compute</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">conditions</span><span class="moose-parameter-header-default">C</span><span class="moose-parameter-header-description">Material property that checks bounds and conditions on the material properties being solved for.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>C</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Material property that checks bounds and conditions on the material properties being solved for.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">constant_on</span><span class="moose-parameter-header-default">NONE</span><span class="moose-parameter-header-description">When ELEMENT, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps.When SUBDOMAIN, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps. Evaluations on element qps will be skipped</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>NONE</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>NONE, ELEMENT, SUBDOMAIN</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When ELEMENT, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps.When SUBDOMAIN, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps. Evaluations on element qps will be skipped</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">damped_Newton</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not to use the damped Newton's method.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not to use the damped Newton's method.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">damping_factor</span><span class="moose-parameter-header-default">0.8</span><span class="moose-parameter-header-description">Factor applied to step size if guess does not satisfy damping criteria</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0.8</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Factor applied to step size if guess does not satisfy damping criteria</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">declare_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any declared properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any declared properties. The suffix will be prepended with a '_' character.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">max_damping_iterations</span><span class="moose-parameter-header-default">100</span><span class="moose-parameter-header-description">Maximum number of damping steps per linear iteration of nested solve</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>100</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Maximum number of damping steps per linear iteration of nested solve</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">max_iterations</span><span class="moose-parameter-header-default">1000</span><span class="moose-parameter-header-description">Maximum number of nonlinear iterations</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1000</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Maximum number of nonlinear iterations</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">min_iterations</span><span class="moose-parameter-header-default">3</span><span class="moose-parameter-header-description">Minimum number of nonlinear iterations to execute before accepting convergence</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>3</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Minimum number of nonlinear iterations to execute before accepting convergence</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">nested_iterations</span><span class="moose-parameter-header-description">The output number of nested Newton iterations at each quadrature point.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The output number of nested Newton iterations at each quadrature point.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">relative_tolerance</span><span class="moose-parameter-header-default">1e-08</span><span class="moose-parameter-header-description">Relative convergence tolerance for Newton iteration</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-08</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Relative convergence tolerance for Newton iteration</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">step_size_tolerance</span><span class="moose-parameter-header-default">1e-15</span><span class="moose-parameter-header-description">Minimum step size of linear iterations relative to value of the solution</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-15</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Minimum step size of linear iterations relative to value of the solution</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="b2842a55-287b-4f91-b93f-81fe5b553c0d" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>Yes</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">implicit</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Determines whether this object is calculated using an implicit or explicit form</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Determines whether this object is calculated using an implicit or explicit form</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">search_method</span><span class="moose-parameter-header-default">nearest_node_connected_sides</span><span class="moose-parameter-header-description">Choice of search algorithm.  All options begin by finding the nearest node in the primary boundary to a query point in the secondary boundary.  In the default nearest_node_connected_sides algorithm, primary boundary elements are searched iff that nearest node is one of their nodes.  This is fast to determine via a pregenerated node-to-elem map and is robust on conforming meshes.  In the optional all_proximate_sides algorithm, primary boundary elements are searched iff they touch that nearest node, even if they are not topologically connected to it.  This is more CPU-intensive but is necessary for robustness on any boundary surfaces which has disconnections (such as Flex IGA meshes) or non-conformity (such as hanging nodes in adaptively h-refined meshes).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nearest_node_connected_sides</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nearest_node_connected_sides, all_proximate_sides</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Choice of search algorithm.  All options begin by finding the nearest node in the primary boundary to a query point in the secondary boundary.  In the default nearest_node_connected_sides algorithm, primary boundary elements are searched iff that nearest node is one of their nodes.  This is fast to determine via a pregenerated node-to-elem map and is robust on conforming meshes.  In the optional all_proximate_sides algorithm, primary boundary elements are searched iff they touch that nearest node, even if they are not topologically connected to it.  This is more CPU-intensive but is necessary for robustness on any boundary surfaces which has disconnections (such as Flex IGA meshes) or non-conformity (such as hanging nodes in adaptively h-refined meshes).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">seed</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The seed for the master random number generator</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The seed for the master random number generator</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="fe0050b4-193e-4bad-8aba-25be7c88d6fc" data-section-level="3" data-section-text="Outputs Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">output_properties</span><span class="moose-parameter-header-description">List of material properties, from this material, to output (outputs must also be defined to an output type)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>List of material properties, from this material, to output (outputs must also be defined to an output type)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">outputs</span><span class="moose-parameter-header-default">none </span><span class="moose-parameter-header-description">Vector of output names where you would like to restrict the output of variables(s) associated with this object</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>none </p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;OutputName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Vector of output names where you would like to restrict the output of variables(s) associated with this object</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Outputs Parameters</h3></summary></details></section><section id="1f546a00-e785-4a2f-b29a-f3730d430f01" data-section-level="3" data-section-text="Material Property Retrieval Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">prop_getter_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_interpolated_state</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">For the old and older state use projected material properties interpolated at the quadrature points. To set up projection use the ProjectedStatefulMaterialStorageAction.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>For the old and older state use projected material properties interpolated at the quadrature points. To set up projection use the ProjectedStatefulMaterialStorageAction.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Material Property Retrieval Parameters</h3></summary></details></section></section></section><div class="moose-modal modal" id="afa12e84-daba-4eae-b8f1-446ca9fe7e45"><div class="modal-content"><h4>compute</h4><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.</p></div></div><div class="moose-modal modal" id="dfdcb2ad-26d2-4102-a2b6-567a23b4a028"><div class="modal-content"><h4>(moose/modules/phase_field/test/tests/KKS_system/kks_example_nested.i)</h4><pre style="max-height:350px;"><code class="language-moose">#
# Two-phase nested KKS toy problem
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 15
  ny = 15
  nz = 0
  xmin = -2.5
  xmax = 2.5
  ymin = -2.5
  ymax = 2.5
  zmin = 0
  zmax = 0
  elem_type = QUAD4
[]

[AuxVariables]
  [Fglobal]
    order = CONSTANT
    family = MONOMIAL
  []
[]

[Variables]
  # order parameter
  [eta]
    order = FIRST
    family = LAGRANGE
  []

  # hydrogen concentration
  [c]
    order = FIRST
    family = LAGRANGE
  []

  # chemical potential
  [w]
    order = FIRST
    family = LAGRANGE
  []
[]

[ICs]
  [eta]
    variable = eta
    type = SmoothCircleIC
    x1 = 0.0
    y1 = 0.0
    radius = 1.5
    invalue = 0.2
    outvalue = 0.1
    int_width = 0.75
  []
  [c]
    variable = c
    type = SmoothCircleIC
    x1 = 0.0
    y1 = 0.0
    radius = 1.5
    invalue = 0.6
    outvalue = 0.4
    int_width = 0.75
  []
[]

[BCs]
  [Periodic]
    [all]
      variable = &#x27;eta w c&#x27;
      auto_direction = &#x27;x y&#x27;
    []
  []
[]

[Materials]
  # Free energy of the matrix
  [fm]
    type = DerivativeParsedMaterial
    property_name = fm
    expression = &#x27;(0.1-cm)^2&#x27;
    material_property_names = &#x27;cm&#x27;
    additional_derivative_symbols = &#x27;cm&#x27;
    compute = false
  []

  # Free energy of the delta phase
  [fd]
    type = DerivativeParsedMaterial
    property_name = fd
    expression = &#x27;(0.9-cd)^2&#x27;
    material_property_names = &#x27;cd&#x27;
    additional_derivative_symbols = &#x27;cd&#x27;
    compute = false
  []

  # Compute phase concentrations
  [PhaseConcentrationMaterial]
    type = KKSPhaseConcentrationMaterial
    global_cs = &#x27;c&#x27;
    ci_names = &#x27;cm cd&#x27;
    ci_IC = &#x27;0 0&#x27;
    fa_name = fm
    fb_name = fd
    h_name = h
    min_iterations = 1
    max_iterations = 100
    absolute_tolerance = 1e-9
    relative_tolerance = 1e-9
    nested_iterations = iter
    outputs = exodus
  []

  # Compute chain rule terms
  [PhaseConcentrationDerivatives]
    type = KKSPhaseConcentrationDerivatives
    global_cs = &#x27;c&#x27;
    eta = eta
    ci_names = &#x27;cm cd&#x27;
    fa_name = fm
    fb_name = fd
    h_name = h
  []

  # h(eta)
  [h_eta]
    type = SwitchingFunctionMaterial
    h_order = HIGH
    eta = eta
  []

  # g(eta)
  [g_eta]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta
  []

  # constant properties
  [constants]
    type = GenericConstantMaterial
    prop_names = &#x27;M   L   kappa&#x27;
    prop_values = &#x27;0.7 0.7 0.4  &#x27;
  []
[]

[Kernels]
  # full transient
  active = &#x27;CHBulk ACBulkF ACBulkC ACInterface dcdt detadt ckernel&#x27;

  #
  # Cahn-Hilliard Equation
  #
  [CHBulk]
    type = NestedKKSSplitCHCRes
    variable = c
    global_cs = &#x27;c&#x27;
    w = w
    all_etas = eta
    ca_names = &#x27;cm cd&#x27;
    fa_name = fm
    coupled_variables = &#x27;eta w&#x27;
  []
  [dcdt]
    type = CoupledTimeDerivative
    variable = w
    v = c
  []
  [ckernel]
    type = SplitCHWRes
    mob_name = M
    variable = w
  []

  #
  # Allen-Cahn Equation
  #
  [ACBulkF]
    type = NestedKKSACBulkF
    variable = eta
    global_cs = &#x27;c&#x27;
    ci_names = &#x27;cm cd&#x27;
    fa_name = fm
    fb_name = fd
    g_name = g
    h_name = h
    mob_name = L
    w = 0.4
    coupled_variables = &#x27;c&#x27;
  []
  [ACBulkC]
    type = NestedKKSACBulkC
    variable = eta
    global_cs = &#x27;c&#x27;
    ci_names = &#x27;cm cd&#x27;
    fa_name = fm
    h_name = h
    mob_name = L
    coupled_variables = &#x27;c&#x27;
  []
  [ACInterface]
    type = ACInterface
    variable = eta
    kappa_name = kappa
  []
  [detadt]
    type = TimeDerivative
    variable = eta
  []
[]

[AuxKernels]
  [GlobalFreeEnergy]
    variable = Fglobal
    type = KKSGlobalFreeEnergy
    fa_name = fm
    fb_name = fd
    w = 0.4
  []
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pctype -sub_pc_type -sub_pc_factor_shift_type -pc_factor_shift_type&#x27;
  petsc_options_value = &#x27; asm    lu          nonzero                    nonzero&#x27;

  l_max_its = 100
  nl_max_its = 100
  num_steps = 3

  dt = 0.1
[]

#
# Precondition using handcoded off-diagonal terms
#
[Preconditioning]
  [full]
    type = SMP
    full = true
  []
[]

[Outputs]
  file_base = kks_example_nested
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="57000b4c-23a9-4648-bf58-19cee3a5b0bc"><div class="modal-content"><h4>compute</h4><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.</p></div></div><div class="moose-modal modal" id="5aa78ac9-b8b7-4047-b423-61aeff0eacb6"><div class="modal-content"><h4>(moose/modules/phase_field/test/tests/KKS_system/kks_example_nested_damped.i)</h4><pre style="max-height:350px;"><code class="language-moose">#
# Two-phase damped nested KKS with log-free energies
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 15
  ny = 15
  nz = 0
  xmin = -2.5
  xmax = 2.5
  ymin = -2.5
  ymax = 2.5
  zmin = 0
  zmax = 0
  elem_type = QUAD4
[]

[AuxVariables]
  [Fglobal]
    order = CONSTANT
    family = MONOMIAL
  []
[]

[Variables]
  # order parameter
  [eta]
    order = FIRST
    family = LAGRANGE
  []

  # hydrogen concentration
  [c]
    order = FIRST
    family = LAGRANGE
  []

  # chemical potential
  [w]
    order = FIRST
    family = LAGRANGE
  []
[]

[ICs]
  [eta]
    variable = eta
    type = SmoothCircleIC
    x1 = 0.0
    y1 = 0.0
    radius = 1.5
    invalue = 1
    outvalue = 0.0
    int_width = 0.75
  []
  [c]
    variable = c
    type = SmoothCircleIC
    x1 = 0.0
    y1 = 0.0
    radius = 1.5
    invalue = 0.9
    outvalue = 0.1
    int_width = 0.75
  []
[]

[BCs]
  [Periodic]
    [all]
      variable = &#x27;eta w c&#x27;
      auto_direction = &#x27;x y&#x27;
    []
  []
[]

[Materials]
  # Free energy of the matrix
  [fm]
    type = DerivativeParsedMaterial
    property_name = fm
    expression = &#x27;cm*log(cm/1e-4) + (1-cm)*log((1-cm)/(1-1e-4))&#x27;
    material_property_names = &#x27;cm&#x27;
    additional_derivative_symbols = &#x27;cm&#x27;
    compute = false
  []

  # Free energy of the delta phase
  [fd]
    type = DerivativeParsedMaterial
    property_name = fd
    expression = &#x27;cd*log(cd/0.9999) + (1-cd)*log((1-cd)/(1-0.9999))&#x27;
    material_property_names = &#x27;cd&#x27;
    additional_derivative_symbols = &#x27;cd&#x27;
    compute = false
  []
  [C]
    type = DerivativeParsedMaterial
    property_name = &#x27;C&#x27;
    material_property_names = &#x27;cm cd&#x27;
    expression = &#x27;(cm&gt;0)&amp;(cm&lt;1)&amp;(cd&gt;0)&amp;(cd&lt;1)&#x27;
    compute = false
  []
  # Compute phase concentrations
  [PhaseConcentrationMaterial]
    type = KKSPhaseConcentrationMaterial
    global_cs = &#x27;c&#x27;
    ci_names = &#x27;cm cd&#x27;
    ci_IC = &#x27;0.1 0.9&#x27;
    fa_name = fm
    fb_name = fd
    h_name = h
    min_iterations = 1
    max_iterations = 100
    absolute_tolerance = 1e-15
    relative_tolerance = 1e-8
    step_size_tolerance = 1e-05
    nested_iterations = iter
    outputs = exodus
    damped_Newton = true
    conditions = C
    damping_factor = 0.8
  []

  # Compute chain rule terms
  [PhaseConcentrationDerivatives]
    type = KKSPhaseConcentrationDerivatives
    global_cs = &#x27;c&#x27;
    eta = eta
    ci_names = &#x27;cm cd&#x27;
    fa_name = fm
    fb_name = fd
    h_name = h
  []

  # h(eta)
  [h_eta]
    type = SwitchingFunctionMaterial
    h_order = HIGH
    eta = eta
  []

  # g(eta)
  [g_eta]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta
  []

  # constant properties
  [constants]
    type = GenericConstantMaterial
    prop_names = &#x27;M   L   kappa&#x27;
    prop_values = &#x27;0.7 0.7 0.4  &#x27;
  []
[]

[Kernels]
  # full transient
  active = &#x27;CHBulk ACBulkF ACBulkC ACInterface dcdt detadt ckernel&#x27;

  #
  # Cahn-Hilliard Equation
  #
  [CHBulk]
    type = NestedKKSSplitCHCRes
    variable = c
    global_cs = &#x27;c&#x27;
    w = w
    all_etas = eta
    ca_names = &#x27;cm cd&#x27;
    fa_name = fm
    coupled_variables = &#x27;eta w&#x27;
  []
  [dcdt]
    type = CoupledTimeDerivative
    variable = w
    v = c
  []
  [ckernel]
    type = SplitCHWRes
    mob_name = M
    variable = w
  []

  #
  # Allen-Cahn Equation
  #
  [ACBulkF]
    type = NestedKKSACBulkF
    variable = eta
    global_cs = &#x27;c&#x27;
    ci_names = &#x27;cm cd&#x27;
    fa_name = fm
    fb_name = fd
    g_name = g
    h_name = h
    mob_name = L
    w = 0.4
    coupled_variables = &#x27;c&#x27;
  []
  [ACBulkC]
    type = NestedKKSACBulkC
    variable = eta
    global_cs = &#x27;c&#x27;
    ci_names = &#x27;cm cd&#x27;
    fa_name = fm
    h_name = h
    mob_name = L
    coupled_variables = &#x27;c&#x27;
  []
  [ACInterface]
    type = ACInterface
    variable = eta
    kappa_name = kappa
  []
  [detadt]
    type = TimeDerivative
    variable = eta
  []
[]

[AuxKernels]
  [GlobalFreeEnergy]
    variable = Fglobal
    type = KKSGlobalFreeEnergy
    fa_name = fm
    fb_name = fd
    w = 0.4
  []
[]

[Executioner]
  type = Transient
  scheme = bdf2
    solve_type = &#x27;PJFNK&#x27;

    petsc_options_iname = &#x27;-pctype -sub_pc_type -sub_pc_factor_shift_type -pc_factor_shift_type&#x27;
    petsc_options_value = &#x27; asm    lu          nonzero                    nonzero&#x27;

  l_max_its = 100
  nl_max_its = 100
  num_steps = 3

  dt = 1e-5
[]

#
# Precondition using handcoded off-diagonal terms
#
[Preconditioning]
  [full]
    type = SMP
    full = true
  []
[]

[Outputs]
  file_base = kks_example_nested_damped
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
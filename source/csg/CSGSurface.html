<!DOCTYPE html><head><meta charset="UTF-8"><title>CSGSurface | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="3363558a-90c6-4961-a6fd-a5266e1b6923" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="02bf9583-d53d-4d79-8924-0791b7033914" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="72e13e08-0404-4bed-b05b-2c6381b6fd23" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="3df21d04-658b-45e0-941c-59fe1989eb61" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="d293ca9c-4989-4468-ac4f-c4f82fa50a3f"><i class="material-icons">menu</i></a><ul class="sidenav" id="d293ca9c-4989-4468-ac4f-c4f82fa50a3f"><li><a href="#!" class="dropdown-trigger" data-target="97df1414-9fa0-4da1-a9ef-7af139d926e1" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="c49d8d3e-6f9a-4e4d-bd42-444d9594679c" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="39163db2-faa9-46c5-923a-7ec407f34bbb" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f63e999a-6177-4d12-8b03-01071665a5b6" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="3363558a-90c6-4961-a6fd-a5266e1b6923"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="02bf9583-d53d-4d79-8924-0791b7033914"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="72e13e08-0404-4bed-b05b-2c6381b6fd23"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="3df21d04-658b-45e0-941c-59fe1989eb61"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="97df1414-9fa0-4da1-a9ef-7af139d926e1"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="c49d8d3e-6f9a-4e4d-bd42-444d9594679c"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="39163db2-faa9-46c5-923a-7ec407f34bbb"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="f63e999a-6177-4d12-8b03-01071665a5b6"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="862e793f-e3fa-4dd3-b11a-0a87fed42369" data-section-level="1" data-section-text="CSGSurface"><h1 id="csgsurface">CSGSurface</h1><p>This is an abstract class for any surface definition for <a href="../../syntax/CSG/index.html">constructive solid geometry (CSG)</a> representations. The <a href="CSGBase.html">CSGBase</a> framework already contains definitions for some basic surfaces (planes, spheres, and cylinders), but developers of modules or MOOSE-based application can define additional custom surfaces by deriving from this abstract <code>CSGBase</code> class. General information about implementing <span class="tooltipped" data-tooltip="Constructive Solid Geometry" data-position="top" data-delay="50">CSG</span>-related methods can be found in <a href="CSGBase.html">CSGBase</a>.</p><section id="57117740-079a-4f5e-9f32-df2dcd102497" data-section-level="2" data-section-text="Defining a New Surface Type"><h2 id="defining-a-new-surface-type">Defining a New Surface Type</h2><p>Any arbitrary or custom surface can be defined by inheriting from <code>CSGSurface</code>. At a minimum, the surface name and surface type, must be set, and two virtual methods that need to be defined. Additional information required by the constructor will depend on the specific surface to be defined.</p><section id="69076da7-e0a1-4808-8876-e5b4220e15df" data-section-level="3" data-section-text="Setting Coefficients"><h3 id="setting-coefficients">Setting Coefficients</h3><p>Each surface should be defined by some equation, which therefore requires the definition of coefficients or other parameters. These coefficient values should be set and be returned through the <code>getCoefficients</code> method which will return a map of the coefficient strings to their values. These coefficient values are returned in the <span class="tooltipped" data-tooltip="JavaScript Object Notation" data-position="top" data-delay="50">JSON</span> file that is produced. For example, a plane is defined by the equation <span class="moose-katex-inline-equation" id="moose-equation-65223cef-bc19-4693-8831-4d07d15b52e6"><script>var element = document.getElementById("moose-equation-65223cef-bc19-4693-8831-4d07d15b52e6");katex.render("ax + by + cz = d", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and so this method would return a map of the values for <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>.</p></section><section id="3707f32a-0723-4810-8096-ffdde2ef39d3" data-section-level="3" data-section-text="Half - space Determination"><h3 id="half-space-determination">Half-space Determination</h3><p>In <span class="tooltipped" data-tooltip="Constructive Solid Geometry" data-position="top" data-delay="50">CSG</span> representation, knowing which half-space of the surface is positive or negative is necessary for correct construction of a <a href="CSGBase.html#cells">cell</a> <a href="CSGBase.html#regions">region</a>. To help determine the sign of these half-spaces, each surface type should have a <code>evaluateSurfaceEquationAtPoint</code> method implemented that returns a floating point value, where a positive value indicates that the point lies in the positive half-space, a negative value indicates that the point lies in the negative half-space, and a value of 0 indicates that the point lies on the surface.</p></section><section id="03f7845d-443c-4b62-89e2-b4b9b9347e62" data-section-level="3" data-section-text="Setting the Surface Type"><h3 id="setting-the-surface-type">Setting the Surface Type</h3><p>The type of surface must be set for <code>_surface_type</code> in the surface constructor. It is recommended that this be done based on the class name using <code>MooseUtils::prettyCppType&lt;SurfaceClassName&gt;()</code> so that the surface type automatically matches the class that created it.</p></section><section id="6c48f584-ec0d-4edd-9057-ee0e93d5418e" data-section-level="3" data-section-text="Creating a Surface Clone"><h3 id="creating-a-surface-clone">Creating a Surface Clone</h3><p>In order to make sure that clones of CSGBase objects are created properly, each derived <code>CSGSurface</code> type must implement a <code>clone()</code> method, which returns a <code>std::unique_ptr&lt;CSGSurface&gt;</code> from the given surface instance. This can typically be done by calling <code>std::make_unique</code> on the constructor for the derived surface type.</p></section></section><section id="8c0667db-f79d-43e4-9e4e-1cbf3e1a8d61" data-section-level="2" data-section-text="Example"><h2 id="example">Example</h2><p>Below shows how <code>CSGSphere</code> is implemented as an example.</p><pre style="max-height:350px;"><code class="language-cpp">
#pragma once

#include &quot;CSGSurface.h&quot;

#include &quot;libmesh/point.h&quot;

namespace CSG
{

/**
 * CSGSphere creates an internal representation of a Constructive Solid Geometry (CSG)
 * sphere, represented in the form (x - x0)^2 + (y - y0)^2 + (z - z0)^2 = r^2
 */
class CSGSphere : public CSGSurface
{
public:
  /**
   * @brief Construct a new CSGSphere surface
   *
   * @param name unique name for the sphere surface
   * @param center center point of sphere
   * @param r radius of sphere
   */
  CSGSphere(const std::string &amp; name, const Point &amp; center, const Real r);

  /**
   * @brief Construct a new CSGSphere surface
   *
   * @param name unique name for the sphere surface
   * @param r radius of sphere
   */
  CSGSphere(const std::string &amp; name, const Real r);

  /**
   * Destructor
   */
  virtual ~CSGSphere() = default;

  /**
   * @brief Get the coefficients (x0, y0, z0, r) for the equation of a sphere
   * (x - x0)^2 + (y - y0)^2 + (z - z0)^2 = r^2
   *
   * @return map of coefficients (x0, y0, z0, and r) and their values
   */
  virtual std::unordered_map&lt;std::string, Real&gt; getCoeffs() const override;

  /**
   * @brief given a point, determine its evaluation based on the equation of the sphere
   *
   * @param p point
   * @return evaluation of point based on surface equation
   */
  virtual Real evaluateSurfaceEquationAtPoint(const Point &amp; p) const override;

protected:
  /**
   * @brief create clone of CSGSphere object
   *
   * @return std::unordered_map&lt;CSGSurface&gt; unique_ptr to cloned sphere
   */
  virtual std::unique_ptr&lt;CSGSurface&gt; clone() const override
  {
    return std::make_unique&lt;CSGSphere&gt;(_name, Point(_x0, _y0, _z0), _r);
  }

  // check that radius is positive
  void checkRadius() const;

  /// Value of x0 in equation of sphere
  Real _x0;

  /// Value of y0 in equation of sphere
  Real _y0;

  /// Value of z0 in equation of sphere
  Real _z0;

  /// Value of r in equation of sphere
  Real _r;
};
} // namespace CSG
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#a14d13a2-039d-48d9-9a1f-82f396e7eada">(moose/framework/include/csg/CSGSphere.h)</a><pre style="max-height:350px;"><code class="language-cpp">
#include &quot;CSGSphere.h&quot;

namespace CSG
{

CSGSphere::CSGSphere(const std::string &amp; name, const Point &amp; center, const Real r)
  : CSGSurface(name, MooseUtils::prettyCppType&lt;CSGSphere&gt;()),
    _x0(center(0)),
    _y0(center(1)),
    _z0(center(2)),
    _r(r)
{
  checkRadius();
}

CSGSphere::CSGSphere(const std::string &amp; name, const Real r)
  : CSGSurface(name, MooseUtils::prettyCppType&lt;CSGSphere&gt;()), _x0(0.0), _y0(0.0), _z0(0.0), _r(r)
{
  checkRadius();
}

std::unordered_map&lt;std::string, Real&gt;
CSGSphere::getCoeffs() const
{
  std::unordered_map&lt;std::string, Real&gt; coeffs = {{&quot;x0&quot;, _x0}, {&quot;y0&quot;, _y0}, {&quot;z0&quot;, _z0}, {&quot;r&quot;, _r}};
  return coeffs;
}

Real
CSGSphere::evaluateSurfaceEquationAtPoint(const Point &amp; p) const
{
  // Compute distance from the sphere center to determine if inside (&lt; r^2)
  // or outside (&gt; r^2) the sphere
  const Real dist_sq =
      Utility::pow&lt;2&gt;((p(0) - _x0)) + Utility::pow&lt;2&gt;((p(1) - _y0)) + Utility::pow&lt;2&gt;((p(2) - _z0));

  return dist_sq - Utility::pow&lt;2&gt;(_r);
}

void
CSGSphere::checkRadius() const
{
  if (_r &lt;= 0.0)
    mooseError(&quot;Radius of sphere must be positive.&quot;);
}

} // namespace CSG
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#421f80cb-f3eb-4961-928d-af6ad2108c7d">(moose/framework/src/csg/CSGSphere.C)</a></section></section><div class="moose-modal modal" id="a14d13a2-039d-48d9-9a1f-82f396e7eada"><div class="modal-content"><h4>(moose/framework/include/csg/CSGSphere.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;CSGSurface.h&quot;

#include &quot;libmesh/point.h&quot;

namespace CSG
{

/**
 * CSGSphere creates an internal representation of a Constructive Solid Geometry (CSG)
 * sphere, represented in the form (x - x0)^2 + (y - y0)^2 + (z - z0)^2 = r^2
 */
class CSGSphere : public CSGSurface
{
public:
  /**
   * @brief Construct a new CSGSphere surface
   *
   * @param name unique name for the sphere surface
   * @param center center point of sphere
   * @param r radius of sphere
   */
  CSGSphere(const std::string &amp; name, const Point &amp; center, const Real r);

  /**
   * @brief Construct a new CSGSphere surface
   *
   * @param name unique name for the sphere surface
   * @param r radius of sphere
   */
  CSGSphere(const std::string &amp; name, const Real r);

  /**
   * Destructor
   */
  virtual ~CSGSphere() = default;

  /**
   * @brief Get the coefficients (x0, y0, z0, r) for the equation of a sphere
   * (x - x0)^2 + (y - y0)^2 + (z - z0)^2 = r^2
   *
   * @return map of coefficients (x0, y0, z0, and r) and their values
   */
  virtual std::unordered_map&lt;std::string, Real&gt; getCoeffs() const override;

  /**
   * @brief given a point, determine its evaluation based on the equation of the sphere
   *
   * @param p point
   * @return evaluation of point based on surface equation
   */
  virtual Real evaluateSurfaceEquationAtPoint(const Point &amp; p) const override;

protected:
  /**
   * @brief create clone of CSGSphere object
   *
   * @return std::unordered_map&lt;CSGSurface&gt; unique_ptr to cloned sphere
   */
  virtual std::unique_ptr&lt;CSGSurface&gt; clone() const override
  {
    return std::make_unique&lt;CSGSphere&gt;(_name, Point(_x0, _y0, _z0), _r);
  }

  // check that radius is positive
  void checkRadius() const;

  /// Value of x0 in equation of sphere
  Real _x0;

  /// Value of y0 in equation of sphere
  Real _y0;

  /// Value of z0 in equation of sphere
  Real _z0;

  /// Value of r in equation of sphere
  Real _r;
};
} // namespace CSG
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="421f80cb-f3eb-4961-928d-af6ad2108c7d"><div class="modal-content"><h4>(moose/framework/src/csg/CSGSphere.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;CSGSphere.h&quot;

namespace CSG
{

CSGSphere::CSGSphere(const std::string &amp; name, const Point &amp; center, const Real r)
  : CSGSurface(name, MooseUtils::prettyCppType&lt;CSGSphere&gt;()),
    _x0(center(0)),
    _y0(center(1)),
    _z0(center(2)),
    _r(r)
{
  checkRadius();
}

CSGSphere::CSGSphere(const std::string &amp; name, const Real r)
  : CSGSurface(name, MooseUtils::prettyCppType&lt;CSGSphere&gt;()), _x0(0.0), _y0(0.0), _z0(0.0), _r(r)
{
  checkRadius();
}

std::unordered_map&lt;std::string, Real&gt;
CSGSphere::getCoeffs() const
{
  std::unordered_map&lt;std::string, Real&gt; coeffs = {{&quot;x0&quot;, _x0}, {&quot;y0&quot;, _y0}, {&quot;z0&quot;, _z0}, {&quot;r&quot;, _r}};
  return coeffs;
}

Real
CSGSphere::evaluateSurfaceEquationAtPoint(const Point &amp; p) const
{
  // Compute distance from the sphere center to determine if inside (&lt; r^2)
  // or outside (&gt; r^2) the sphere
  const Real dist_sq =
      Utility::pow&lt;2&gt;((p(0) - _x0)) + Utility::pow&lt;2&gt;((p(1) - _y0)) + Utility::pow&lt;2&gt;((p(2) - _z0));

  return dist_sq - Utility::pow&lt;2&gt;(_r);
}

void
CSGSphere::checkRadius() const
{
  if (_r &lt;= 0.0)
    mooseError(&quot;Radius of sphere must be positive.&quot;);
}

} // namespace CSG
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
<!DOCTYPE html><head><meta charset="UTF-8"><title>CSGBase | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="bb0b5d32-8de1-4772-aa66-64f578344533" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9692a647-7912-46fa-af7e-eb041ff555b7" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ae7c5b4b-30cb-4930-adf1-3d7379cdefe9" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="62fe0bb1-689a-461a-b5ad-724d9d97ecb7" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="e240bc2a-a627-4d45-8b39-04ed818bb151"><i class="material-icons">menu</i></a><ul class="sidenav" id="e240bc2a-a627-4d45-8b39-04ed818bb151"><li><a href="#!" class="dropdown-trigger" data-target="46aee5d1-298f-476d-a8e0-1362fec35630" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="39faf951-69e3-417c-8825-39d15aa248ed" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9335498c-07f7-425d-b536-473666039d41" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="69f2c05f-6514-4af1-b331-32079aff8383" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="bb0b5d32-8de1-4772-aa66-64f578344533"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="9692a647-7912-46fa-af7e-eb041ff555b7"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="ae7c5b4b-30cb-4930-adf1-3d7379cdefe9"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="62fe0bb1-689a-461a-b5ad-724d9d97ecb7"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="46aee5d1-298f-476d-a8e0-1362fec35630"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="39faf951-69e3-417c-8825-39d15aa248ed"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="9335498c-07f7-425d-b536-473666039d41"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="69f2c05f-6514-4af1-b331-32079aff8383"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="a29e2e1c-6c5a-4442-8d5e-8fe9eda7dd50" data-section-level="1" data-section-text="CSGBase"><h1 id="csgbase">CSGBase</h1><p><code>CSGBase</code> is the main class developers should interact with when implementing the <code>generateCSG</code> method for any mesh generator. This framework class acts as a container and driver for all methods necessary for creating a <a href="../../syntax/CSG/index.html">constructive solid geometry (CSG)</a> representation such as generating surfaces, cells, and universes of the mesh generator under consideration.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>Throughout this documentation, <code>csg_obj</code> will be used in example code blocks to refer to a <code>CSGBase</code> instance.</p><p></p></div></div></div><section id="04259be2-6d36-4018-8991-7ad09f62bd83" data-section-level="2" data-section-text="Declaring that a mesh generator supports the generation of CSG"><h2 id="declaring-that-a-mesh-generator-supports-the-generation-of-csg">Declaring that a mesh generator supports the generation of CSG</h2><p>In order to call <code>generateCSG</code>, the <code>setHasGenerateCSG</code> method must be called on the mesh generator to declare that the method has been implemented.</p><pre style="max-height:350px;"><code class="language-cpp">InputParameters
TestCSGAxialSurfaceMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();
  // input parameter that is an existing mesh generator
  params.addRequiredParam&lt;MeshGeneratorName&gt;(&quot;input&quot;, &quot;The input MeshGenerator.&quot;);
  // additional params for this specific mesh generator
  params.addRequiredParam&lt;Real&gt;(&quot;axial_height&quot;, &quot;Axial height of the model.&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#66b21c08-5d78-478e-a180-1c9d384c8923">(moose/test/src/csg/TestCSGAxialSurfaceMeshGenerator.C)</a></section><section id="273ab0ae-2d1a-4c7c-8778-e978cc83f923" data-section-level="2" data-section-text="How to implement the routine generateCSG"><h2 id="how-to-implement-the-routine">How to implement the <code>generateCSG</code> routine</h2><p>This section will describe the various components developers should implement into the <code>generateCSG</code> method for a given <a href="../meshgenerators/MeshGenerator.html">MeshGenerator</a>. This method will return a unique pointer to the <code>CSGBase</code> object that was created or modified by the mesh generator in the <code>generateCSG</code> method.</p><section id="77190b39-2063-4ae2-b72a-7c0484be39eb" data-section-level="3" data-section-text="Initialization"><h3 id="initialization">Initialization</h3><p>A new <code>CSGBase</code> object can be initialized with:</p><pre style="max-height:350px;"><code class="language-cpp">  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#91550554-dd4a-4fbe-8943-69a7156dc773">(moose/test/src/csg/ExampleCSGInfiniteSquareMeshGenerator.C)</a><p>Once initialized, surfaces, cells, and universes can be created and manipulated. The following sections explain in detail how to do this as a part of the <code>generateCSG</code> method.</p></section><section id="cce40f6f-fa7a-4d8b-a52c-c4e905b04c2c" data-section-level="3" data-section-text="Surfaces"><h3 id="surfaces">Surfaces</h3><p>Surfaces are used to define the spatial extent of the region of a <code>CSGCell</code>. To create a <code>CSGSurface</code> object, the surface constructor must be called directly to create a unique pointer. This pointer then has to be passed to the current <code>CSGBase</code> instance with <code>addSurface</code> which will then return a const reference to that generated surface (<code>const &amp; CSGSurface</code>). The syntax to do this is as follows, where <code>SurfaceType</code> should be replaced with the specific type of surface being created (e.g., <code>CSG::CSGPlane</code>):</p><pre style="max-height:350px;"><code class="language-cpp">
// the unique surface pointer is made first, creating the surface object
std::unique_ptr&lt;CSG::CSGSurface&gt; surf_ptr = std::make_unique&lt;SurfaceType&gt;(arguments);
// and then it is explicitly passed to this CSGBase instance, which holds the memory ownership for the object
const auto &amp; surface = csg_obj-&gt;addSurface(std::move(surf_ptr));
</code></pre><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Adding surfaces to the CSGBase instance</div><div class="card-content"><div class="moose-alert-content"><p>Surfaces need to be added to the CSGBase instance with <code>addSurface</code> as described above. If this is not done and these surfaces are referenced in regions used to define cells within the CSGBase instance, an error will occur.</p><p></p></div></div></div><p>The <code>CSG</code> framework in MOOSE provides various classes for creating basic surfaces (see table below). Information about how to define new types of surfaces can be found in <a href="CSGSurface.html">CSGSurface</a>.</p><div recursive form="['center', 'center', 'center']" class="moose-table-div"><table><thead><tr><th style=";text-align:center">Surface Type</th><th style=";text-align:center">Class</th><th style=";text-align:center">Description</th></tr></thead><tbody><tr><td style=";text-align:center">Plane</td><td style=";text-align:center"><code>CSGPlane</code></td><td style=";text-align:center">create a plane defined by 3 points or from coefficients <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> for the equation <code>ax + by + cz = d</code></td></tr></tbody><tbody><tr><td style=";text-align:center">Sphere</td><td style=";text-align:center"><code>CSGSphere</code></td><td style=";text-align:center">creates a sphere of radius <code>r</code> at an optionally specified center point (default is <code>(0, 0, 0)</code>)</td></tr></tbody><tbody><tr><td style=";text-align:center">Cylinder</td><td style=";text-align:center"><code>CSGXCylinder</code></td><td style=";text-align:center">creates a cylinder aligned with the x-axis at the specified center location (<code>y</code>, <code>z</code>)</td></tr></tbody><tbody><tr><td style=";text-align:center">Cylinder</td><td style=";text-align:center"><code>CSGYCylinder</code></td><td style=";text-align:center">creates a cylinder aligned with the y-axis at the specified center location (<code>x</code>, <code>z</code>)</td></tr></tbody><tbody><tr><td style=";text-align:center">Cylinder</td><td style=";text-align:center"><code>CSGZCylinder</code></td><td style=";text-align:center">creates a cylinder aligned with the z-axis at the specified center location (<code>x</code>, <code>y</code>)</td></tr></tbody></table></div><p>Example:</p><pre style="max-height:350px;"><code class="language-cpp">    // create a plane using the coefficients for the equation of a plane
    // z plane equation: 0.0*x + 0.0*y + 1.0*z = (+/-)0.5 * axial_height
    std::unique_ptr&lt;CSG::CSGSurface&gt; surface_ptr =
        std::make_unique&lt;CSG::CSGPlane&gt;(default_surf_name, 0.0, 0.0, 1.0, coeffs[i]);
    auto &amp; csg_plane = csg_obj-&gt;addSurface(std::move(surface_ptr));
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#6ddc28c8-c283-459d-aeca-3ad9694ff911">(moose/test/src/csg/TestCSGAxialSurfaceMeshGenerator.C)</a><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Including Surface Types</div><div class="card-content"><div class="moose-alert-content"><p>In order to define a surface, the header file for that surface type must be included in the <code>MeshGenerator.C</code> file (i.e., <code>#include &quot;CSGPlane.h&quot;</code> to create planes).</p><p></p></div></div></div><p>The <code>CSGSurface</code> objects can then be accessed or updated with the following methods from <code>CSGBase</code>:</p><ul class="browser-default"><li><p><code>addSurface</code>: add a unique pointer to a <code>CSGSurface</code> object to this <code>CSGBase</code> instance </p></li><li><p><code>getAllSurfaces</code>: retrieve a list of const references to each <code>CSGSurface</code> object in the <code>CSGBase</code> instance </p></li><li><p><code>getSurfaceByName</code>: retrieve a const reference to the <code>CSGSurface</code> of the specified name </p></li><li><p><code>renameSurface</code>: change the name of the <code>CSGSurface</code></p></li></ul></section><section id="9dce484a-1755-4427-9c19-670bd7beb7b0" data-section-level="3" data-section-text="Regions"><h3 id="regions">Regions</h3><p>A region is a space defined by boolean operations applied to surfaces and other regions. Half-space regions are defined as the positive and negative space separated by a surface. These regions can be unionized, intersected, or the complement taken to further define more complex regions. Series of operations can be defined using parentheses <code>(</code> <code>)</code> to indicate which operations to perform first. The types of operators available to define a <code>CSGRegion</code> using <code>CSGSurface</code> objects are:</p><div recursive form="['center', 'center', 'center']" class="moose-table-div"><table><thead><tr><th style=";text-align:center">Operator</th><th style=";text-align:center">Description</th><th style=";text-align:center">Example Use</th></tr></thead><tbody><tr><td style=";text-align:center"><code>+</code></td><td style=";text-align:center">positive half-space</td><td style=";text-align:center"><code>+surf</code></td></tr></tbody><tbody><tr><td style=";text-align:center"><code>-</code></td><td style=";text-align:center">negative half-space</td><td style=";text-align:center"><code>-surf</code></td></tr></tbody><tbody><tr><td style=";text-align:center"><code>&amp;</code></td><td style=";text-align:center">intersection</td><td style=";text-align:center"><code>-surfA &amp; +surfB</code></td></tr></tbody><tbody><tr><td style=";text-align:center"><code>|</code></td><td style=";text-align:center">union</td><td style=";text-align:center"><code>-surfA</code> <code>|</code> <code>+surfB</code></td></tr></tbody><tbody><tr><td style=";text-align:center"><code>~</code></td><td style=";text-align:center">complement</td><td style=";text-align:center"><code>~(-surfA &amp; +surfB)</code></td></tr></tbody><tbody><tr><td style=";text-align:center"><code>&amp;=</code></td><td style=";text-align:center">update existing region with an intersection</td><td style=";text-align:center"><code>region1 &amp;= -surfA</code></td></tr></tbody><tbody><tr><td style=";text-align:center"><code>|</code><code>=</code></td><td style=";text-align:center">update existing region with a union</td><td style=";text-align:center"><code>region1</code> <code>|</code><code>= +surfB</code></td></tr></tbody></table></div><p>The following is an example of using a combination of all operators to define the space outside a cylinder of a finite height that is topped with a half-sphere. Each of the half-spaces associated with each surface are shown in <a class="moose-float-reference" href="#fig:region_surfs">Figure 1</a>. The cylinder and planes are then combined via intersection to form the region inside a finite cylinder, and the space above the top plane is intersected with the sphere to define a half sphere (<a class="moose-float-reference" href="#fig:region1">Figure 2</a>). These two regions are unionized as shown in <a class="moose-float-reference" href="#fig:region2">Figure 3</a>. The complement of the previous combination then defines the final region <code>~((-cylinder_surf &amp; -top_plane &amp; +bottom_plane) | (+top_plane &amp; -sphere_surf))</code>, as shown in blue in <a class="moose-float-reference" href="#fig:region3">Figure 4</a>.</p><div class="card moose-float" id="fig:region_surfs"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/csg/region_surfs.png" alt="Four different surfaces: an infinite cylinder (blue), a top plane (orange), a bottom plane (red), and a sphere (green)"></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 1: </span><span class="moose-caption-text" id="fig:region_surfs">Four different surfaces: an infinite cylinder (blue), a top plane (orange), a bottom plane (red), and a sphere (green)</span></p></div></div><div class="card moose-float" id="fig:region1"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/csg/region1.png" alt="Two separate regions both defined as *intersections* of *half-spaces*."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 2: </span><span class="moose-caption-text" id="fig:region1">Two separate regions both defined as <em>intersections</em> of <em>half-spaces</em>.</span></p></div></div><div class="card moose-float" id="fig:region2"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/csg/region2.png" alt="One region defined by the *union* of two other regions."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 3: </span><span class="moose-caption-text" id="fig:region2">One region defined by the <em>union</em> of two other regions.</span></p></div></div><div class="card moose-float" id="fig:region3"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/csg/region3.png" alt="A region defined as the *complement* of an existing region."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 4: </span><span class="moose-caption-text" id="fig:region3">A region defined as the <em>complement</em> of an existing region.</span></p></div></div></section><section id="e4d4eece-786c-4eb9-913a-7f8150a429a9" data-section-level="3" data-section-text="Cells"><h3 id="cells">Cells</h3><p>A cell is an object defined by a region and a fill. To create any <code>CSGCell</code>, use the method <code>createCell</code> from <code>CSGBase</code> which will return a const reference to the <code>CSGCell</code> object that is created (<code>const CSGCell &amp;</code>). At the time of calling <code>createCell</code>, a unique cell name, the cell region (<code>CSGRegion</code>), and an indicator of the fill must be provided. The <code>CSGRegion</code> is defined by boolean combinations of <code>CSGSurfaces</code> as described below. Four types of cell fills are currently supported: void, material, universe, and lattice. If creating a void cell, no fill has to be passed to the creation method. To create a cell with a material fill, simply provide it with a name of a material as a string. For a cell with a <code>CSGUniverse</code> fill, pass it a reference to the <code>CSGUniverse</code>. And for a <code>CSGLattice</code> fill, pass a reference to the <code>CSGLattice</code>. Some examples of creating the different types of cells are shown below:</p><pre style="max-height:350px;"><code class="language-cpp">    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#ea1faabd-e6b1-4ca5-aca8-c07b3161b6dd">(moose/unit/src/CSGBaseTest.C)</a><pre style="max-height:350px;"><code class="language-cpp">    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#134ebf59-8bec-483a-8836-8195b858626a">(moose/unit/src/CSGBaseTest.C)</a><pre style="max-height:350px;"><code class="language-cpp">    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#49b7db63-ea56-4b7f-9dd3-0f5afd34b630">(moose/unit/src/CSGBaseTest.C)</a><pre style="max-height:350px;"><code class="language-cpp">    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#08526248-f24f-4c7a-80da-c643011253c0">(moose/unit/src/CSGBaseTest.C)</a><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Materials as Placeholders</div><div class="card-content"><div class="moose-alert-content"><p>A cell with a material fill is <em>not</em> connected to a MOOSE material definition at this time. The &quot;material&quot; is currently just a string to represent the name of a CSG material or other type of fill that is otherwise undefined.</p><p></p></div></div></div><p>The <code>CSGCell</code> objects can then be accessed or updated with the following methods from <code>CSGBase</code>:</p><ul class="browser-default"><li><p><code>getAllCells</code>: retrieve a list of const references to each <code>CSGCell</code> object in the <code>CSGBase</code> instance </p></li><li><p><code>getCellByName</code>: retrieve a const reference to the <code>CSGCell</code> object of the specified name </p></li><li><p><code>renameCell</code>: change the name of the <code>CSGCell</code> object </p></li><li><p><code>updateCellRegion</code>: change the region of the cell; if used, all <code>CSGSurface</code> objects used to define the new <code>CSGRegion</code> must also be a part of the current <code>CSGBase</code></p></li></ul></section><section id="6acfd4ec-da15-4b9c-984e-77b5e021fcad" data-section-level="3" data-section-text="Universes"><h3 id="universes">Universes</h3><p>A universe is a collection of cells and is created by calling <code>createUniverse</code> from <code>CSGBase</code> which will return a const reference to the <code>CSGUniverse</code> object (<code>const CSGUniverse &amp;</code>). A <code>CSGUniverse</code> can be initialized as an empty universe, or by passing a vector of shared pointers to <code>CSGCell</code> objects. Any <code>CSGUniverse</code> object can be renamed (including the <a href="CSGBase.html#root-universe">root universe</a>) with <code>renameUniverse</code>.</p><p>The <code>CSGUniverse</code> objects can then be accessed or updated with the following methods from <code>CSGBase</code>:</p><ul class="browser-default"><li><p><code>getAllUniverses</code>:  retrieve a list of const references to each <code>CSGUniverse</code> object in the <code>CSGBase</code> instance </p></li><li><p><code>getUniverseByName</code>: retrieve a const reference to the <code>CSGUniverse</code> of the specified name </p></li><li><p><code>renameUniverse</code>: change the name of the <code>CSGUniverse</code></p></li></ul><p>Examples:</p><pre style="max-height:350px;"><code class="language-cpp">    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#84873aec-30b2-4bd7-a73c-a5e646dc7b98">(moose/unit/src/CSGBaseTest.C)</a><pre style="max-height:350px;"><code class="language-cpp">    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#158dfe10-7d5b-4c65-b4b4-06db2267e763">(moose/unit/src/CSGBaseTest.C)</a><section id="5f230af9-04ed-4d5f-b13f-933fee28edf2" data-section-level="4" data-section-text="Root Universe"><h4 id="root-universe">Root Universe</h4><p>All universes in a model should be able to be traced back, through the hierarchical tree of cells and universes, to a singular overarching universe known as the root universe. Because universes are a collection of cells and cells can be filled with universe, a tree of universes can be constructed such that the root universe contains the collection of all cells in the model. When a <code>CSGBase</code> object is first <a href="CSGBase.html#initialization">initialized</a>, a root <code>CSGUniverse</code> called <code>ROOT_UNIVERSE</code> is created by default. Every <code>CSGCell</code> that is created will be added to the root universe unless otherwise specified (as described <a href="CSGBase.html#adding-or-removing-cells">below</a>). The root universe exists by default, and which universe is set as the root cannot be changed, except when joining <code>CSGBase</code> objects, as described <a href="CSGBase.html#updating-existing-csgbase-objects">below</a>. However, the name of the root universe can be updated and cells can be manually added or removed using the same methods described <a href="CSGBase.html#universes">above</a>.</p><p>Methods available for managing the root universe:</p><ul class="browser-default"><li><p><code>getRootUniverse</code>: returns a const reference to the root universe of the <code>CSGBase</code> instance </p></li><li><p><code>renameRootUniverse</code>: change the name of the root universe</p></li></ul></section><section id="1e88bd99-fa70-42af-b3c8-89708236f329" data-section-level="4" data-section-text="Adding or Removing Cells"><h4 id="adding-or-removing-cells">Adding or Removing Cells</h4><p>There are multiple ways in which cells can be added to a universe:</p><ol class="browser-default" start="1"><li><p>At the time of universe creation, a vector of references to <code>CSGCell</code> objects can be passed into <code>createUniverse</code> (as described <a href="CSGBase.html#universes">above</a>). Example:</p></li></ol><pre style="max-height:350px;"><code class="language-cpp">    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#66fd06dd-ead4-44c4-9d5c-c02778fa3325">(moose/unit/src/CSGBaseTest.C)</a><ol class="browser-default" start="2"><li><p>When a <code>CSGCell</code> is created with <code>createCell</code>, a pointer to a <code>CSGUniverse</code> can be passed as the final argument to indicate that the cell will be created and added directly to that specified universe. In this case, the cell will <em>not</em> be added to the root universe. A cell that has a universe fill type cannot be added to the same universe that is being used for the fill. For example, the two snippets below come from the same file where a new universe is initialized and passed by reference to the cell when it is created:</p></li></ol><pre style="max-height:350px;"><code class="language-cpp">  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#8eaa12db-ece9-4d62-a43d-902dca9bd8a7">(moose/unit/src/CSGBaseTest.C)</a><pre style="max-height:350px;"><code class="language-cpp">    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#14d4ab05-d2f8-4a4b-8f79-1d6847f7f21f">(moose/unit/src/CSGBaseTest.C)</a><ol class="browser-default" start="3"><li><p>A cell or list of cells can be added to an existing universe with the <code>addCellToUniverse</code> and <code>addCellsToUniverse</code> methods. In this case, if a <code>CSGCell</code> exists in another <code>CSGUniverse</code> (such as the root universe), it will <em>not</em> be removed when being added to another (i.e. if the same behavior as option 2 above is desired, the cell will have to be manually removed from the root universe, as described below). The following is an example where the list of cells is collected first and then added at one time to the existing universe, but this could also be accomplished by using <code>addCellToUniverse</code> in a for-loop after each cell is initially created.</p></li></ol><pre style="max-height:350px;"><code class="language-cpp">  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#8bb1379b-928a-4a09-9aca-c94b8bdf37c9">(moose/unit/src/CSGBaseTest.C)</a><p>Cells can also be removed from a universe in the same way as method 3 above by using the <code>removeCellFromUniverse</code> and <code>removeCellsFromUniverse</code> methods. An example is shown above where the cells are removed from the root universe after they are added to the new universe. Doing this in multiple steps has the same outcome as that of method 2 for adding cells to a universe at the time of cell creation.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Maintaining Connectivity</div><div class="card-content"><div class="moose-alert-content"><p>When adding and removing cells to/from universes, it is important to maintain the connectivity of all universes meaning all universes should be nested under the root universe at the end of the generation process, in order to have a consistent model.</p><p></p></div></div></div></section></section><section id="718a6194-370b-4423-a1a2-2793ebf9df30" data-section-level="3" data-section-text="Lattices"><h3 id="lattices">Lattices</h3><p>A <code>CSGLattice</code> is defined as a patterned arrangement of <a href="CSGBase.html#universes"><code>CSGUniverse</code></a> objects and an &quot;outer&quot; to fill the space around lattice elements. To create any type of lattice, the lattice constructor must be called directly to create a unique pointer. This pointer then has to be passed to the current <code>CSGBase</code> instance with <code>addLattice</code> (optionally specifying the lattice type) which will then return a const reference to that generated lattice object (<code>const &amp; CSGLattice</code> or <code>const &amp; LatticeType</code>). At the time that <code>addLattice</code> is called to add the lattice to the base instance, any <code>CSGUniverse</code> objects associated with the lattice must also be in the <code>CSGBase</code> instance already. The syntax for creating the pointer and adding it is shown below, where <code>LatticeType</code> should be replaced with the specific type of the lattice (e.g., <code>CSGCartesianLattice</code> or <code>CSGHexagonalLattice</code>).</p><pre style="max-height:350px;"><code class="language-cpp">
// the unique lattice pointer is made first, creating the lattice object of the specified type
std::unique_ptr&lt;LatticeType&gt; lat_ptr = std::make_unique&lt;LatticeType&gt;(arguments);
// and then it is explicitly passed to this CSGBase instance, which will keep the memory ownership for the object
const auto &amp; lattice = csg_obj-&gt;addLattice&lt;LatticeType&gt;(std::move(lat_ptr));
</code></pre><p>An example of creating a Cartesian lattice is shown below:</p><pre style="max-height:350px;"><code class="language-cpp">    std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
        std::make_unique&lt;CSG::CSGCartesianLattice&gt;(lat_name, _pitch, universe_pattern);
    csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#e67718fc-8d3a-4f83-962d-282f96080f9d">(moose/test/src/csg/TestCSGLatticeMeshGenerator.C)</a><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Specifying the LatticeType</div><div class="card-content"><div class="moose-alert-content"><p>It is _highly_ recommended that the specific <code>LatticeType</code> of the lattice object always be specified when calling <code>addLattice</code> or <code>getLatticeByName</code>. If it is not specified, it will default to setting the type as the abstract type <code>CSGLattice</code>. If this is the case, no methods or data that is specific to the actual lattice type will be callable on the lattice object, unless a reference cast is used.</p><p></p></div></div></div><p>The <code>CSGBase</code> class provides support for two types of 2D lattice types (Cartesian and regular hexagonal), but any custom lattice type can also be defined by following the information in <a href="CSGLattice.html">CSGLattice</a>. It is assumed that both the Cartesian and hexagonal lattice types are in the <span class="moose-katex-inline-equation" id="moose-equation-1162258c-e8e0-49ae-96e1-32dbdc350f37"><script>var element = document.getElementById("moose-equation-1162258c-e8e0-49ae-96e1-32dbdc350f37");katex.render("x-y", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> plane (having a <span class="moose-katex-inline-equation" id="moose-equation-9ab08e5b-d610-4312-8b9b-bc597f25c368"><script>var element = document.getElementById("moose-equation-9ab08e5b-d610-4312-8b9b-bc597f25c368");katex.render("+z", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> normal). Three types of outer fill are supported: void (default), material (an <code>std::string</code> name), and <a href="CSGBase.html#universes"><code>CSGUniverse</code></a>. For both lattice types, the lattice can be initialized minimally with a name and pitch (the flat-to-flat size of a lattice element). The pattern of universes can also be set at the time of initialization or updated later using the <code>setLatticeUniverses</code> method. And similarly, the outer fill (either a <code>CSGUniverse</code> object or an <code>std::string</code> representing the name of a material) can be set at the time of initialization or set later with the <code>setLatticeOuter</code> method; if the outer is not set, it is assumed to be <code>VOID</code>. Some examples of initializing a lattice with the various options are shown below.</p><pre style="max-height:350px;"><code class="language-cpp">    // initialize without universe map, outer is void, and pitch=1.0
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#2d72366c-0437-41d1-884b-ad5b815d6bb3">(moose/unit/src/CSGLatticeTest.C)</a><pre style="max-height:350px;"><code class="language-cpp">    // initialize with universe map and set outer fill to be a universe
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map, outer_univ);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#f3d6ad4f-409c-4e8a-be8a-660fb1feb787">(moose/unit/src/CSGLatticeTest.C)</a><pre style="max-height:350px;"><code class="language-cpp">    // initialize without universe map but set outer to a material
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, &quot;outer_mat&quot;);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#afbe356e-2b79-41d8-928f-6cffc657be9a">(moose/unit/src/CSGLatticeTest.C)</a><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>2D vs. 3D Lattices</div><div class="card-content"><div class="moose-alert-content"><p>The <code>CSGBase</code> class supports only the creation of 2D lattices. A &quot;3D&quot; lattice can be created by filling multiple 3D cells with 2D lattices and arranging them in layers to form the desired 3D structure.</p><p></p></div></div></div><p>The <code>CSGLattice</code> objects can be accessed or updated with the following methods from <code>CSGBase</code>:</p><ul class="browser-default"><li><p><code>setLatticeUniverses</code>: sets the vector of vectors of <code>CSGUniverse</code> objects as the lattice layout. </p></li><li><p><code>setUniverseAtLatticeIndex</code>: add a <code>CSGUniverse</code> to the lattice at the specified location index (replaces the existing universe). </p></li><li><p><code>setLatticeOuter</code>: sets the <code>CSGUniverse</code> (for a <code>CSGUniverse</code> outer) or the <code>std::string</code> name (for a material outer) as the outer fill. </p></li><li><p><code>resetLatticeOuter</code>: resets the outer fill to void for the lattice. </p></li><li><p><code>renameLattice</code>: change the name of the <code>CSGLattice</code> object. </p></li><li><p><code>getAllLattices</code>: retrieve a vector of const references to each <code>CSGLattice</code> object in the <code>CSGBase</code> instance. </p></li><li><p><code>getLatticeByName</code>: retrieve a const reference to the lattice object of the specified name.</p></li></ul><section id="36de6dff-f767-4a4c-839d-73e468708745" data-section-level="4" data-section-text="Lattice Indexing"><h4 id="lattice-indexing">Lattice Indexing</h4><p>Both the Cartesian and hexagonal lattice types follow a row-column <span class="moose-katex-inline-equation" id="moose-equation-27534610-45e7-473b-9966-9fc7face18fb"><script>var element = document.getElementById("moose-equation-27534610-45e7-473b-9966-9fc7face18fb");katex.render("(i, j)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> indexing scheme for the location of universes in the lattice.</p><p>For Cartesian lattices, there can be any number of rows and columns, but each row must be the same length. The indexing starts at the top left corner of the lattice with element <span class="moose-katex-inline-equation" id="moose-equation-1f36935f-9a80-4d3b-bc3d-6e50434e186c"><script>var element = document.getElementById("moose-equation-1f36935f-9a80-4d3b-bc3d-6e50434e186c");katex.render("(0, 0)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>. An example of the indices for a <span class="moose-katex-inline-equation" id="moose-equation-100e22bf-6331-48b0-bdfa-579b20ddde93"><script>var element = document.getElementById("moose-equation-100e22bf-6331-48b0-bdfa-579b20ddde93");katex.render("2 \\times 3", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> Cartesian lattice is shown in <a class="moose-float-reference" href="#fig:cart_lat">Figure 5</a>.</p><div class="card moose-float" id="fig:cart_lat"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/csg/cart_lat.png" alt="Example of a $2 \times 3$ Cartesian lattice and the corresponding location indices."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 5: </span><span class="moose-caption-text" id="fig:cart_lat">Example of a <span class="moose-katex-inline-equation" id="moose-equation-e93c4c58-2f41-47db-aa80-e9e7bf3055af"><script>var element = document.getElementById("moose-equation-e93c4c58-2f41-47db-aa80-e9e7bf3055af");katex.render("2 \\times 3", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> Cartesian lattice and the corresponding location indices.</span></p></div></div><p>For hexagonal lattices, the lattice is assumed to be x-oriented and also uses the row-column <span class="moose-katex-inline-equation" id="moose-equation-24cf3218-8165-40fb-8d51-c7b3c302b069"><script>var element = document.getElementById("moose-equation-24cf3218-8165-40fb-8d51-c7b3c302b069");katex.render("(i, j)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> indexing scheme, with element <span class="moose-katex-inline-equation" id="moose-equation-e92e9bcb-281d-4872-a4f3-2631e95b6f64"><script>var element = document.getElementById("moose-equation-e92e9bcb-281d-4872-a4f3-2631e95b6f64");katex.render("(0, 0)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> being the top row, leftmost element. The length of the rows is expected to be consistent with the size of the lattice (i.e., the number of rings), which is verified when the universes are set. An example of the <span class="moose-katex-inline-equation" id="moose-equation-3a9bfa5c-12fc-4dc8-b341-48d246c62582"><script>var element = document.getElementById("moose-equation-3a9bfa5c-12fc-4dc8-b341-48d246c62582");katex.render("(i, j)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> indices for a 3-ring hexagonal lattice is shown in <a class="moose-float-reference" href="#fig:hex_lat_row">Figure 6</a>.</p><div class="card moose-float" id="fig:hex_lat_row"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/csg/hex_lat_row.png" alt="Example of a 3-ring hexagonal lattice that has the location indices labeled in the $(i, j)$ form."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 6: </span><span class="moose-caption-text" id="fig:hex_lat_row">Example of a 3-ring hexagonal lattice that has the location indices labeled in the <span class="moose-katex-inline-equation" id="moose-equation-9b3bad21-e26f-4e13-8676-2be9e4390ca1"><script>var element = document.getElementById("moose-equation-9b3bad21-e26f-4e13-8676-2be9e4390ca1");katex.render("(i, j)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> form.</span></p></div></div><p>Convenience methods are provided for <code>CSGHexagonalLattice</code> objects to convert between the required <span class="moose-katex-inline-equation" id="moose-equation-fbdc47d4-2437-4f6d-ba14-95076c9e6cf5"><script>var element = document.getElementById("moose-equation-fbdc47d4-2437-4f6d-ba14-95076c9e6cf5");katex.render("(i, j)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> indices and a ring-based <span class="moose-katex-inline-equation" id="moose-equation-32495fe7-e878-42e2-bd1c-e9525a6c5619"><script>var element = document.getElementById("moose-equation-32495fe7-e878-42e2-bd1c-e9525a6c5619");katex.render("(r, p)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> indexing scheme. In the ring-based scheme, the outermost ring is the 0th ring, and the right-most element in the ring is the 0th position of the ring with indices increasing counter-clockwise around the ring. For the 3-ring lattice above in <a class="moose-float-reference" href="#fig:hex_lat_row">Figure 6</a>, the corresponding <span class="moose-katex-inline-equation" id="moose-equation-05d2d2ac-c586-4bbb-9818-b60d4787de00"><script>var element = document.getElementById("moose-equation-05d2d2ac-c586-4bbb-9818-b60d4787de00");katex.render("(r, p)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> indices would be as shown in <a class="moose-float-reference" href="#fig:hex_lat_ring">Figure 7</a>.</p><div class="card moose-float" id="fig:hex_lat_ring"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/csg/hex_lat_ring.png" alt="Example of a 3-ring hexagonal lattice that has the location indices labeled in the $(r, p)$ form."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 7: </span><span class="moose-caption-text" id="fig:hex_lat_ring">Example of a 3-ring hexagonal lattice that has the location indices labeled in the <span class="moose-katex-inline-equation" id="moose-equation-ea50cfb2-d7f9-4e26-9e6f-3413ab644b5d"><script>var element = document.getElementById("moose-equation-ea50cfb2-d7f9-4e26-9e6f-3413ab644b5d");katex.render("(r, p)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> form.</span></p></div></div><p>For any lattice, the <span class="moose-katex-inline-equation" id="moose-equation-323905e0-118b-444e-a35e-00c2fbfb35a4"><script>var element = document.getElementById("moose-equation-323905e0-118b-444e-a35e-00c2fbfb35a4");katex.render("(r, p)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> index of a universe in the lattice can be retrieved from the <span class="moose-katex-inline-equation" id="moose-equation-144125c8-db69-4a27-9ca9-1bf639464829"><script>var element = document.getElementById("moose-equation-144125c8-db69-4a27-9ca9-1bf639464829");katex.render("(i, j)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> index by calling the <code>getRingIndexFromRowIndex</code> method. And similarly, if the <span class="moose-katex-inline-equation" id="moose-equation-75d2005e-9181-486b-b695-094d9eeebf9a"><script>var element = document.getElementById("moose-equation-75d2005e-9181-486b-b695-094d9eeebf9a");katex.render("(r, p)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> index form is known, the corresponding <span class="moose-katex-inline-equation" id="moose-equation-5ea21091-b0da-46f5-af9e-c55ac033fc41"><script>var element = document.getElementById("moose-equation-5ea21091-b0da-46f5-af9e-c55ac033fc41");katex.render("(i, j)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> index can be retrieved using the <code>getRowIndexFromRingIndex</code> method. It is important to note that while these convenience methods exist to convert between the two indexing schemes, the <code>CSGUniverse</code> objects in the lattice can only be accessed using the <span class="moose-katex-inline-equation" id="moose-equation-02842fa6-f1ba-413f-9bba-98147f7ec07c"><script>var element = document.getElementById("moose-equation-02842fa6-f1ba-413f-9bba-98147f7ec07c");katex.render("(i, j)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> index.</p></section><section id="8bf48b1a-b243-42eb-9ef5-1d4a9dda44d8" data-section-level="4" data-section-text="Defining the Universe Layout"><h4 id="defining-the-universe-layout">Defining the Universe Layout</h4><p>As mentioned above, the layout of the <code>CSGUniverse</code> objects for the lattice can be set at the time of initialization or set/updated later. At the time that the universes are set, the dimensionality of the lattice is determined (i.e., the number of rows, columns, or rings for the lattice). If the dimensionality should need to be changed, a new complete universe arrangement can be set to overwrite the previous arrangement using <code>setLatticeUniverses</code>. Anytime the universe layout is set or changed, the dimensionality will be validated to ensure it compatible with the lattice type. To replace a single element of the lattice, the <code>setUniverseAtLatticeIndex</code> method can be used by providing the element location in <span class="moose-katex-inline-equation" id="moose-equation-a50e3390-ea48-4450-915b-457d5afdd4bb"><script>var element = document.getElementById("moose-equation-a50e3390-ea48-4450-915b-457d5afdd4bb");katex.render("(i, j)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> form. In order to use this method, the full set of universes must have already been defined, either during the lattice initialization or with <code>setLatticeUniverses</code>.</p><pre style="max-height:350px;"><code class="language-cpp">    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#aec2af91-434d-4a6b-864f-7f84646db5af">(moose/unit/src/CSGBaseTest.C)</a><pre style="max-height:350px;"><code class="language-cpp">    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#e00ee1b4-0ef8-4ed0-bdda-a1dd0fbd496f">(moose/unit/src/CSGBaseTest.C)</a><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Building the Lattice Layout Incrementally</div><div class="card-content"><div class="moose-alert-content"><p>The <code>setUniverseAtLatticeIndex</code> method is not meant to be used to change a lattice&#x27;s dimensions by building the lattice element-by-element because the index supplied would be considered out of range in this context. The dimensionality of the lattice is determined when <code>setLatticeUniverses</code> is called. Therefore, to build a lattice incrementally, the recommendation is to build up a vector of vectors of universes incrementally and then call <code>setLatticeUniverses</code> one time. From there, <code>setUniverseAtLatticeIndex</code> can be called to replace an existing universe in the lattice.</p><p></p></div></div></div></section></section><section id="81a096b3-a78b-4dbc-82b1-c34a18f980b5" data-section-level="2" data-section-text="Updating Existing CSGBase Objects"><h2 id="updating-existing-csgbase-objects">Updating Existing CSGBase Objects</h2><p>An empty <code>CSGBase</code> object can be <a href="CSGBase.html#initialization">initialized</a> on its own in each <code>generateCSG</code> method for each mesh generator. However, in most cases, it is necessary to update an existing <code>CSGBase</code> object from a previous <code>MeshGenerator</code> or join multiple <code>CSGBase</code> together such that only one <code>CSGBase</code> object is ultimately produced at the end of the mesh/CSG generation process. There are two main ways to handle this: passing and joining.</p><section id="49e1646b-a2e1-4967-812b-5be310bd4a49" data-section-level="3" data-section-text="Passing between Mesh Generators"><h3 id="passing-between-mesh-generators">Passing between Mesh Generators</h3><p><code>CSGBase</code> objects from other mesh generators can be accessed through methods that parallel those available for accessing other <a href="../meshgenerators/MeshGenerator.html">MeshGenerator</a> objects. For all methods listed below, a unique pointer to the <code>CSGBase</code> object(s) created by <code>generateCSG</code> for the specified <a href="../meshgenerators/MeshGenerator.html">MeshGenerator</a> names are returned.</p><ul class="browser-default"><li><p><code>getCSGBase</code>: get the <code>CSGBase</code> object given a parameter name represented as a <code>std::string</code> that stores the mesh generator name </p></li><li><p><code>getCSGBases</code>: get the <code>CSGBase</code> objects given a parameter name represented as a <code>std::string</code> that stores a list of mesh generator names </p></li><li><p><code>getCSGBaseByName</code>: get the <code>CSGBase</code> object given a <code>MeshGeneratorName</code> </p></li><li><p><code>getCSGBasesByName</code>: get all <code>CSGBase</code> objects given a list of <code>MeshGeneratorName</code>s</p></li></ul><p>These functions should be called from the constructor of the MeshGenerator, so that the MeshGenerator system can properly define the dependency tree of all mesh generators in the input file. The returned CSGBase pointers can be stored in a member variable and updated in the <code>generateCSG()</code> method in order to make any changes to the CSGBase object.</p><p>For example, the following member variable stores the pointer to the CSGBase object that is generated by an input mesh generator:</p><pre style="max-height:350px;"><code class="language-cpp">  /// Holds the generated CSGBase object
  std::unique_ptr&lt;CSG::CSGBase&gt; * _build_csg;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#bf791b2c-7a2b-45ac-87d0-20d0f0c9559a">(moose/test/include/csg/TestCSGAxialSurfaceMeshGenerator.h)</a><p>This variable is initialized in the constructor as:</p><pre style="max-height:350px;"><code class="language-cpp">  _build_csg = &amp;getCSGBase(&quot;input&quot;);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#9b3143d3-3746-4c01-be5f-f64639d1de85">(moose/test/src/csg/TestCSGAxialSurfaceMeshGenerator.C)</a><p>Finally, in the <code>generateCSG()</code> method, <code>std::move</code> is called on the member variable to transfer ownership to the current mesh generator</p><pre style="max-height:350px;"><code class="language-cpp">  // get the existing CSGBase associated with the input mesh generator
  // this is the CSGBase object that will be updated
  std::unique_ptr&lt;CSG::CSGBase&gt; csg_obj = std::move(*_build_csg);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#5eb0faf5-ac09-43f4-b14d-740deee941fd">(moose/test/src/csg/TestCSGAxialSurfaceMeshGenerator.C)</a><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Accessing other MeshGenerator objects by name</div><div class="card-content"><div class="moose-alert-content"><p>A <a href="../meshgenerators/MeshGenerator.html">MeshGenerator</a> object(s) can be passed to another mesh generator as input by providing <code>InputParameters</code> of type <code>MeshGeneratorName</code>. See the <code>ExampleAxialSurfaceMeshGenerator</code> implementation <a href="CSGBase.html#example-implementation">below</a> for an example of this.</p><p></p></div></div></div></section><section id="2b9e3c47-9f83-404d-9728-c107e18b08a9" data-section-level="3" data-section-text="Joining Bases"><h3 id="joining-bases">Joining Bases</h3><p>When two or more existing <code>CSGBase</code> objects need to be combined to continue to use and update, the <code>joinOtherBase</code> method should be used. This method is called from another <code>CSGBase</code> and at a minimum takes a different existing <code>CSGBase</code> object as input. There are 3 different behaviors for joining bases that are supported depending on the additional arguments that are passed:</p><ol class="browser-default" start="1"><li><p>No additional arguments: All cells that are in the root universe of the incoming <code>CSGBase</code> object will be added to the existing root universe of the current base object, and the root universe from the incoming base will no longer exist.</p></li></ol><pre style="max-height:350px;"><code class="language-cpp">  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#5871a8be-d6a6-4536-be92-0c643ed9287c">(moose/unit/src/CSGBaseTest.C)</a><ol class="browser-default" start="2"><li><p>One new root universe name (<code>new_root_name_join</code>): All cells in the root universe of the incoming base will be used to create a new universe of the name specified by the <code>new_root_name_join</code> parameter. These cells will <em>not</em> be added to the existing root universe, which will remain unchanged. This new universe will be added as a new non-root universe in the existing base object. <em>This newly created universe will not be connected to the root universe of the existing <code>CSGBase</code> object by default.</em></p></li></ol><pre style="max-height:350px;"><code class="language-cpp">  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#89c3eb7e-d140-455a-8e8c-019fe152e294">(moose/unit/src/CSGBaseTest.C)</a><ol class="browser-default" start="3"><li><p>Two new root universe names (<code>new_root_name_base</code> and <code>new_root_name_join</code>): The cells in the root universe of the current <code>CSGBase</code> object will be used to create a new non-root universe of the name specified by the <code>new_root_name_base</code> parameter, and the cells in the root universe of the incoming <code>CSGBase</code> object will be used to create a separate non-root universe of the name specified by the <code>new_root_name_join</code> parameter. <em>At the end of this join method, the root universe of the current base object will be empty and neither of the two new non-root universes will be connected to the root universe by default.</em></p></li></ol><pre style="max-height:350px;"><code class="language-cpp">  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#36a2777f-83c0-4b20-b04a-6a409c593394">(moose/unit/src/CSGBaseTest.C)</a><p>For all of these join methods, any non-root universes will remain unchanged and simply added to the list of universes for the current <code>CSGBase</code> object. Similarly, all incoming cells and surfaces are added alongside existing cells and surfaces.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Object Naming Uniqueness</div><div class="card-content"><div class="moose-alert-content"><p>It is very important when using the <code>joinOtherBase</code> method that all <code>CSGSurfaces</code>, <code>CSGCells</code>, and <code>CSGSurfaces</code> are uniquely named so that errors are not encountered when combining sets of objects. An error will be produced during the join process if an object of the same type and name already exists. See <a href="CSGBase.html#object-naming-recommendations">recommendations for naming</a> below.</p><p></p></div></div></div></section></section><section id="8cab55d0-330e-4426-80a9-5deea27ade71" data-section-level="2" data-section-text="Accessing CSG - related Methods"><h2 id="accessing-csg-related-methods">Accessing CSG-related Methods</h2><p>All <span class="tooltipped" data-tooltip="Constructive Solid Geometry" data-position="top" data-delay="50">CSG</span> methods related to creating or changing a <span class="tooltipped" data-tooltip="Constructive Solid Geometry" data-position="top" data-delay="50">CSG</span> object must be called through <code>CSGBase</code>. Calls that retrieve information only but do not manipulate an object (such as <code>getName</code> methods) can be called on the object directly. For example, if a cell were to be created, the current name and region could be retrieved directly from the <code>CSGCell</code> object, but if the name or region needed to be changed, that would need to be handled through <code>CSGBase</code>.</p><p>This ensures proper accounting of all <span class="tooltipped" data-tooltip="Constructive Solid Geometry" data-position="top" data-delay="50">CSG</span>-related objects in the <code>CSGBase</code> instance. Consult the Doxygen documentation for information on all object-specific methods.</p></section><section id="6fac01bd-1e56-4d27-9451-ea58b3c139f5" data-section-level="2" data-section-text="Object Naming Recommendations"><h2 id="object-naming-recommendations">Object Naming Recommendations</h2><p>For each new <span class="tooltipped" data-tooltip="Constructive Solid Geometry" data-position="top" data-delay="50">CSG</span> element (<code>CSGSurface</code>, <code>CSGCell</code>, <code>CSGUniverse</code>, and <code>CSGLattice</code>) that is created, a unique name identifier (of type <code>std::string</code>) must be provided (<code>name</code> parameter for all creation methods). A recommended best practice is to include the mesh generator name (which can be accessed with <code>this-&gt;getName()</code> in any MeshGenerator class) as a part of that object name. This <code>name</code> is used as the unique identifier within the <code>CSGBase</code> instance. Methods for renaming objects are available as described in the above sections to help prevent issues and errors.</p></section><section id="4acfba66-f7bc-4a0b-bf9b-27b1b97878a7" data-section-level="2" data-section-text="Example Implementations"><h2 id="example-implementations">Example Implementations</h2><p>Provided here are example implementations of the <code>generateCSG</code> method for three simple <a href="../meshgenerators/MeshGenerator.html">MeshGenerator</a> types. The first mesh generator creates an infinite rectangular prism given an input parameter for <code>side_length</code>. The code snippets provided here correspond to the <code>.C</code> file.</p><pre style="max-height:350px;"><code class="language-cpp">InputParameters
ExampleCSGInfiniteSquareMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();

  params.addRequiredParam&lt;Real&gt;(&quot;side_length&quot;, &quot;Side length of infinite square.&quot;);
  params.addParam&lt;MeshGeneratorName&gt;(
      &quot;fill&quot;, &quot;optional input lattice mesh generator to fill generated cell with.&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

ExampleCSGInfiniteSquareMeshGenerator::ExampleCSGInfiniteSquareMeshGenerator(
    const InputParameters &amp; params)
  : MeshGenerator(params),
    _side_length(getParam&lt;Real&gt;(&quot;side_length&quot;)),
    _input_fill_name(isParamValid(&quot;fill&quot;) ? getParam&lt;MeshGeneratorName&gt;(&quot;fill&quot;) : &quot;&quot;),
    _has_fill(isParamValid(&quot;fill&quot;))
{
  if (_has_fill)
  {
    _input_fill_mg_ptr = &amp;getMesh(&quot;fill&quot;);
    _input_fill_csg = &amp;getCSGBase(&quot;fill&quot;);
  }
}

std::unique_ptr&lt;MeshBase&gt;
ExampleCSGInfiniteSquareMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
ExampleCSGInfiniteSquareMeshGenerator::generateCSG()
{
  // name of the current mesh generator to use for naming generated objects
  auto mg_name = this-&gt;name();

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();

  // Add surfaces and halfspaces corresponding to 4 planes of infinite square
  std::vector&lt;std::vector&lt;Point&gt;&gt; points_on_planes{{Point(1. * _side_length / 2., 0., 0.),
                                                    Point(1. * _side_length / 2., 1., 0.),
                                                    Point(1. * _side_length / 2., 0., 1.)},
                                                   {Point(-1. * _side_length / 2., 0., 0.),
                                                    Point(-1. * _side_length / 2., 1., 0.),
                                                    Point(-1. * _side_length / 2., 0., 1.)},
                                                   {Point(0., 1. * _side_length / 2., 0.),
                                                    Point(1., 1. * _side_length / 2., 0.),
                                                    Point(0., 1. * _side_length / 2., 1.)},
                                                   {Point(0., -1. * _side_length / 2., 0.),
                                                    Point(1., -1. * _side_length / 2., 0.),
                                                    Point(0., -1. * _side_length / 2., 1.)}};
  std::vector&lt;std::string&gt; surf_names{&quot;plus_x&quot;, &quot;minus_x&quot;, &quot;plus_y&quot;, &quot;minus_y&quot;};

  // initialize cell region to be updated
  CSG::CSGRegion region;

  // set the center of the prism to be used for determining half-spaces
  const auto centroid = Point(0, 0, 0);

  for (unsigned int i = 0; i &lt; points_on_planes.size(); ++i)
  {
    // object name includes the mesh generator name for uniqueness
    const auto surf_name = mg_name + &quot;_surf_&quot; + surf_names[i];
    // create the plane for one face of the prism
    std::unique_ptr&lt;CSG::CSGSurface&gt; plane_ptr = std::make_unique&lt;CSG::CSGPlane&gt;(
        surf_name, points_on_planes[i][0], points_on_planes[i][1], points_on_planes[i][2]);
    auto &amp; csg_plane = csg_obj-&gt;addSurface(std::move(plane_ptr));
    // determine where the plane is in relation to the centroid to be able to set the half-space
    const auto region_direction = csg_plane.getHalfspaceFromPoint(centroid);
    // half-space is either positive (+plane_ptr) or negative (-plane_ptr)
    // depending on the direction to the centroid
    auto halfspace =
        ((region_direction == CSG::CSGSurface::Halfspace::POSITIVE) ? +csg_plane : -csg_plane);
    // check if this is the first half-space to be added to the region,
    // if not, update the existing region with the intersection of the regions (&amp;=)
    if (region.getRegionType() == CSG::CSGRegion::RegionType::EMPTY)
      region = halfspace;
    else
      region &amp;= halfspace;
  }

  // create the cell defined by the surfaces and region just created
  const auto cell_name = mg_name + &quot;_square_cell&quot;;
  // determine fill: either from input fill mesh generator or default material
  if (_has_fill)
  {
    // join the fill CSGBase into the current CSGBase &amp; use the lattice as the fill
    csg_obj-&gt;joinOtherBase(std::move(*_input_fill_csg));
    // assume input MG is a lattice type for sake of this example/test
    const CSG::CSGLattice &amp; lattice = csg_obj-&gt;getLatticeByName(_input_fill_name + &quot;_lattice&quot;);
    csg_obj-&gt;createCell(cell_name, lattice, region);
  }
  else // default material fill
  {
    const auto material_name = &quot;square_material&quot;;
    csg_obj-&gt;createCell(cell_name, material_name, region);
  }

  return csg_obj;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#a7bdbc28-1625-493d-abcf-82486fe172de">(moose/test/src/csg/ExampleCSGInfiniteSquareMeshGenerator.C)</a><p>The next example mesh generator builds on the infinite prism example above by taking a <code>MeshGeneratorName</code> for an existing <code>ExampleCSGInfiniteSquareMeshGenerator</code> as input and adds planes to create a finite rectangular prism.</p><pre style="max-height:350px;"><code class="language-cpp">InputParameters
TestCSGAxialSurfaceMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();
  // input parameter that is an existing mesh generator
  params.addRequiredParam&lt;MeshGeneratorName&gt;(&quot;input&quot;, &quot;The input MeshGenerator.&quot;);
  // additional params for this specific mesh generator
  params.addRequiredParam&lt;Real&gt;(&quot;axial_height&quot;, &quot;Axial height of the model.&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

TestCSGAxialSurfaceMeshGenerator::TestCSGAxialSurfaceMeshGenerator(const InputParameters &amp; params)
  : MeshGenerator(params),
    _mesh_ptr(getMesh(&quot;input&quot;)),
    _axial_height(getParam&lt;Real&gt;(&quot;axial_height&quot;))
{
  _build_csg = &amp;getCSGBase(&quot;input&quot;);
}

std::unique_ptr&lt;MeshBase&gt;
TestCSGAxialSurfaceMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
TestCSGAxialSurfaceMeshGenerator::generateCSG()
{
  // get the existing CSGBase associated with the input mesh generator
  // this is the CSGBase object that will be updated
  std::unique_ptr&lt;CSG::CSGBase&gt; csg_obj = std::move(*_build_csg);

  // get the names of the current mesh generator and the input mesh generator
  // so that unique object naming can be enforced
  auto mg_name = this-&gt;name();
  auto inp_name = getParam&lt;MeshGeneratorName&gt;(&quot;input&quot;);

  // get the expected existing cell
  const auto cell_name = inp_name + &quot;_square_cell&quot;;
  const auto &amp; csg_cell = csg_obj-&gt;getCellByName(cell_name);

  // get the existing cell region to update
  auto cell_region = csg_cell.getRegion();

  // centroid used to determine direction for half-space
  const auto centroid = Point(0, 0, 0);

  // setting a default surface name purely for testing purposes
  const auto default_surf_name = &quot;default_surf&quot;;

  // Add surfaces and halfspaces corresponding to top and bottom axial planes
  std::vector&lt;std::string&gt; surf_names{&quot;plus_z&quot;, &quot;minus_z&quot;};
  std::vector&lt;Real&gt; coeffs{0.5 * _axial_height, -0.5 * _axial_height};
  for (unsigned int i = 0; i &lt; coeffs.size(); ++i)
  {
    // create a plane using the coefficients for the equation of a plane
    // z plane equation: 0.0*x + 0.0*y + 1.0*z = (+/-)0.5 * axial_height
    std::unique_ptr&lt;CSG::CSGSurface&gt; surface_ptr =
        std::make_unique&lt;CSG::CSGPlane&gt;(default_surf_name, 0.0, 0.0, 1.0, coeffs[i]);
    auto &amp; csg_plane = csg_obj-&gt;addSurface(std::move(surface_ptr));

    // Rename surface so that it has a unique surface name based on the mesh generator
    const auto surf_name = mg_name + &quot;_surf_&quot; + surf_names[i];
    csg_obj-&gt;renameSurface(csg_plane, surf_name);

    // determine the half-space to add as an updated intersection
    const auto region_direction = csg_plane.getHalfspaceFromPoint(centroid);
    auto halfspace =
        ((region_direction == CSG::CSGSurface::Halfspace::POSITIVE) ? +csg_plane : -csg_plane);

    // update the existing region with a half-space
    cell_region &amp;= halfspace;
  }

  // set the new region for the existing cell
  csg_obj-&gt;updateCellRegion(csg_cell, cell_region);

  // Rename cell as it now defines a box region instead of an infinite square region
  csg_obj-&gt;renameCell(csg_cell, mg_name + &quot;_box_cell&quot;);

  return csg_obj;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#2d224f15-6c5f-43ab-b439-6d5e106bf862">(moose/test/src/csg/TestCSGAxialSurfaceMeshGenerator.C)</a><p>If the above methods were to be used, the following input would generate the corresponding <span class="tooltipped" data-tooltip="JavaScript Object Notation" data-position="top" data-delay="50">JSON</span> output below.</p><p>Example Input:</p><pre style="max-height:350px;"><code class="language-moose">[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  [inf_square]
    type = ExampleCSGInfiniteSquareMeshGenerator
    side_length = 4
  []
  [cube]
    type = TestCSGAxialSurfaceMeshGenerator
    input = inf_square
    axial_height = 5
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#55e8dd35-df8b-4b23-9ded-0a87ffcbce6b">(moose/test/tests/csg/csg_only_chained.i)</a><p>Example Output:</p><pre style="max-height:350px;"><code class="language-text">{
  &quot;cells&quot;: {
    &quot;cube_box_cell&quot;: {
      &quot;fill&quot;: &quot;square_material&quot;,
      &quot;filltype&quot;: &quot;CSG_MATERIAL&quot;,
      &quot;region_infix&quot;: [
        &quot;+inf_square_surf_plus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-inf_square_surf_minus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-inf_square_surf_plus_y&quot;,
        &quot;&amp;&quot;,
        &quot;+inf_square_surf_minus_y&quot;,
        &quot;&amp;&quot;,
        &quot;-cube_surf_plus_z&quot;,
        &quot;&amp;&quot;,
        &quot;+cube_surf_minus_z&quot;
      ],
      &quot;region_postfix&quot;: [
        &quot;inf_square_surf_plus_x&quot;,
        &quot;+&quot;,
        &quot;inf_square_surf_minus_x&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;inf_square_surf_plus_y&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;inf_square_surf_minus_y&quot;,
        &quot;+&quot;,
        &quot;&amp;&quot;,
        &quot;cube_surf_plus_z&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;cube_surf_minus_z&quot;,
        &quot;+&quot;,
        &quot;&amp;&quot;
      ]
    }
  },
  &quot;surfaces&quot;: {
    &quot;cube_surf_minus_z&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 1.0,
        &quot;d&quot;: -2.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;cube_surf_plus_z&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 1.0,
        &quot;d&quot;: 2.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;inf_square_surf_minus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;inf_square_surf_minus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;inf_square_surf_plus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;inf_square_surf_plus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    }
  },
  &quot;universes&quot;: {
    &quot;ROOT_UNIVERSE&quot;: {
      &quot;cells&quot;: [
        &quot;cube_box_cell&quot;
      ],
      &quot;root&quot;: true
    }
  }
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#2247476e-b00f-4f1f-85ac-fb03c0ce554f">(moose/test/tests/csg/gold/csg_only_chained_out_csg.json)</a><p>A third example implementation shows the construction of a 2D lattice of universes, using the <code>ExampleCSGInfiniteSquareMeshGenerator</code> as input.</p><pre style="max-height:350px;"><code class="language-cpp">InputParameters
TestCSGLatticeMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();
  // input parameter that is an existing mesh generator
  params.addRequiredParam&lt;std::vector&lt;MeshGeneratorName&gt;&gt;(
      &quot;inputs&quot;,
      &quot;The MeshGenerators that form the components of the lattice. Order of inputs corresponds to &quot;
      &quot;the associated integer ID for the pattern (i.e., 0 for first input, 1 for second input, &quot;
      &quot;etc.)&quot;);
  params.addRequiredParam&lt;std::string&gt;(
      &quot;lattice_type&quot;, &quot;The type of lattice to create. Options are &#x27;cartesian&#x27; and &#x27;hexagonal&#x27;.&quot;);
  params.addRequiredParam&lt;Real&gt;(&quot;pitch&quot;,
                                &quot;The pitch (flat-to-flat distance) of each lattice element.&quot;);
  params.addRequiredParam&lt;std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;(
      &quot;pattern&quot;,
      &quot;A double-indexed array starting with the upper-left corner where the index&quot;
      &quot;represents the index of the mesh/CSG generator in the &#x27;inputs&#x27; vector&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

TestCSGLatticeMeshGenerator::TestCSGLatticeMeshGenerator(const InputParameters &amp; params)
  : MeshGenerator(params),
    _lattice_type(getParam&lt;std::string&gt;(&quot;lattice_type&quot;)),
    _pitch(getParam&lt;Real&gt;(&quot;pitch&quot;)),
    _input_names(getParam&lt;std::vector&lt;MeshGeneratorName&gt;&gt;(&quot;inputs&quot;)),
    _mesh_ptrs(getMeshes(&quot;inputs&quot;)),
    _pattern(getParam&lt;std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;(&quot;pattern&quot;))
{
  for (auto inp : _input_names)
    _input_csgs.push_back(&amp;getCSGBaseByName(inp));
}

std::unique_ptr&lt;MeshBase&gt;
TestCSGLatticeMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
TestCSGLatticeMeshGenerator::generateCSG()
{
  // create a new CSGBase object to build the lattice in
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // get the name of the current mesh generator
  auto mg_name = this-&gt;name();

  // join each input CSGBase into the new CSGBase as a unique universe
  std::unordered_map&lt;unsigned int, std::string&gt; univ_id_names;
  for (const auto i : index_range(_input_names))
  {
    std::string join_name = _input_names[i] + &quot;_univ&quot;;
    csg_obj-&gt;joinOtherBase(std::move(*_input_csgs[i]), join_name);
    univ_id_names[i] = join_name;
  }

  // build the universe pattern for the lattice using the input pattern
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; universe_pattern;
  for (const auto &amp; row : _pattern)
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt; universe_row;
    for (const auto univ_id : row)
    {
      const auto &amp; univ = csg_obj-&gt;getUniverseByName(univ_id_names[univ_id]);
      universe_row.push_back(univ);
    }
    universe_pattern.push_back(universe_row);
  }

  // create the lattice based on the specified type
  std::string lat_name = mg_name + &quot;_lattice&quot;;
  if (_lattice_type == &quot;cartesian&quot;)
  {
    std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
        std::make_unique&lt;CSG::CSGCartesianLattice&gt;(lat_name, _pitch, universe_pattern);
    csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  }
  else if (_lattice_type == &quot;hexagonal&quot;)
  {
    std::unique_ptr&lt;CSG::CSGHexagonalLattice&gt; lat_ptr =
        std::make_unique&lt;CSG::CSGHexagonalLattice&gt;(lat_name, _pitch, universe_pattern);
    csg_obj-&gt;addLattice&lt;CSG::CSGHexagonalLattice&gt;(std::move(lat_ptr));
  }
  return csg_obj;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#086ec885-5a57-405e-bfdc-50618c54a79b">(moose/test/src/csg/TestCSGLatticeMeshGenerator.C)</a><p>For this example, the following input would generate the corresponding <span class="tooltipped" data-tooltip="JavaScript Object Notation" data-position="top" data-delay="50">JSON</span> output below.</p><p>Example Input:</p><pre style="max-height:350px;"><code class="language-moose">[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  [sq1]
    type = ExampleCSGInfiniteSquareMeshGenerator
    side_length = 4
  []
  [sq2]
    type = ExampleCSGInfiniteSquareMeshGenerator
    side_length = 3
  []
  [cart_lat]
    type = TestCSGLatticeMeshGenerator
    lattice_type = &#x27;cartesian&#x27;
    inputs = &#x27;sq1 sq2&#x27;
    pattern = &#x27;0 0;
               0 1&#x27;
    pitch = 5
  []
  [sq3]
      type = ExampleCSGInfiniteSquareMeshGenerator
      side_length = 15
      fill = &#x27;cart_lat&#x27;
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#7eff8be8-2f25-4f60-a75c-d7dc3b8a61bf">(moose/test/tests/csg/csg_lattice_cart.i)</a><p>Example Output:</p><pre style="max-height:350px;"><code class="language-text">{
  &quot;cells&quot;: {
    &quot;sq1_square_cell&quot;: {
      &quot;fill&quot;: &quot;square_material&quot;,
      &quot;filltype&quot;: &quot;CSG_MATERIAL&quot;,
      &quot;region_infix&quot;: [
        &quot;+sq1_surf_plus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-sq1_surf_minus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-sq1_surf_plus_y&quot;,
        &quot;&amp;&quot;,
        &quot;+sq1_surf_minus_y&quot;
      ],
      &quot;region_postfix&quot;: [
        &quot;sq1_surf_plus_x&quot;,
        &quot;+&quot;,
        &quot;sq1_surf_minus_x&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;sq1_surf_plus_y&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;sq1_surf_minus_y&quot;,
        &quot;+&quot;,
        &quot;&amp;&quot;
      ]
    },
    &quot;sq2_square_cell&quot;: {
      &quot;fill&quot;: &quot;square_material&quot;,
      &quot;filltype&quot;: &quot;CSG_MATERIAL&quot;,
      &quot;region_infix&quot;: [
        &quot;+sq2_surf_plus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-sq2_surf_minus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-sq2_surf_plus_y&quot;,
        &quot;&amp;&quot;,
        &quot;+sq2_surf_minus_y&quot;
      ],
      &quot;region_postfix&quot;: [
        &quot;sq2_surf_plus_x&quot;,
        &quot;+&quot;,
        &quot;sq2_surf_minus_x&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;sq2_surf_plus_y&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;sq2_surf_minus_y&quot;,
        &quot;+&quot;,
        &quot;&amp;&quot;
      ]
    },
    &quot;sq3_square_cell&quot;: {
      &quot;fill&quot;: &quot;cart_lat_lattice&quot;,
      &quot;filltype&quot;: &quot;LATTICE&quot;,
      &quot;region_infix&quot;: [
        &quot;+sq3_surf_plus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-sq3_surf_minus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-sq3_surf_plus_y&quot;,
        &quot;&amp;&quot;,
        &quot;+sq3_surf_minus_y&quot;
      ],
      &quot;region_postfix&quot;: [
        &quot;sq3_surf_plus_x&quot;,
        &quot;+&quot;,
        &quot;sq3_surf_minus_x&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;sq3_surf_plus_y&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;sq3_surf_minus_y&quot;,
        &quot;+&quot;,
        &quot;&amp;&quot;
      ]
    }
  },
  &quot;lattices&quot;: {
    &quot;cart_lat_lattice&quot;: {
      &quot;attributes&quot;: {
        &quot;ncol&quot;: 2,
        &quot;nrow&quot;: 2,
        &quot;pitch&quot;: 5.0
      },
      &quot;outertype&quot;: &quot;VOID&quot;,
      &quot;type&quot;: &quot;CSG::CSGCartesianLattice&quot;,
      &quot;universes&quot;: [
        [
          &quot;sq1_univ&quot;,
          &quot;sq1_univ&quot;
        ],
        [
          &quot;sq1_univ&quot;,
          &quot;sq2_univ&quot;
        ]
      ]
    }
  },
  &quot;surfaces&quot;: {
    &quot;sq1_surf_minus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq1_surf_minus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq1_surf_plus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq1_surf_plus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq2_surf_minus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 1.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq2_surf_minus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -1.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq2_surf_plus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -1.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq2_surf_plus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 1.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq3_surf_minus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 7.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq3_surf_minus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -7.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq3_surf_plus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -7.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq3_surf_plus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 7.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    }
  },
  &quot;universes&quot;: {
    &quot;ROOT_UNIVERSE&quot;: {
      &quot;cells&quot;: [
        &quot;sq3_square_cell&quot;
      ],
      &quot;root&quot;: true
    },
    &quot;sq1_univ&quot;: {
      &quot;cells&quot;: [
        &quot;sq1_square_cell&quot;
      ]
    },
    &quot;sq2_univ&quot;: {
      &quot;cells&quot;: [
        &quot;sq2_square_cell&quot;
      ]
    }
  }
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#63ce1e63-f96c-48a6-be96-89cad93db6c5">(moose/test/tests/csg/gold/csg_lattice_cart_out_csg.json)</a><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Running the Examples</div><div class="card-content"><div class="moose-alert-content"><p>To run either of the above examples, use <code>--allow-test-objects</code>:</p><pre style="max-height:350px;"><code class="language-shell">
./moose_test-opt --allow-test-objects --csg-only -i tests/csg/csg_only_chained.i
</code></pre><pre style="max-height:350px;"><code class="language-shell">
./moose_test-opt --allow-test-objects --csg-only -i tests/csg/csg_lattice_cart.i
</code></pre><p></p></div></div></div></section></section></section><div class="moose-modal modal" id="66b21c08-5d78-478e-a180-1c9d384c8923"><div class="modal-content"><h4>(moose/test/src/csg/TestCSGAxialSurfaceMeshGenerator.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;TestCSGAxialSurfaceMeshGenerator.h&quot;
#include &quot;MeshGenerator.h&quot;
#include &quot;CSGPlane.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, TestCSGAxialSurfaceMeshGenerator);

InputParameters
TestCSGAxialSurfaceMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();
  // input parameter that is an existing mesh generator
  params.addRequiredParam&lt;MeshGeneratorName&gt;(&quot;input&quot;, &quot;The input MeshGenerator.&quot;);
  // additional params for this specific mesh generator
  params.addRequiredParam&lt;Real&gt;(&quot;axial_height&quot;, &quot;Axial height of the model.&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

TestCSGAxialSurfaceMeshGenerator::TestCSGAxialSurfaceMeshGenerator(const InputParameters &amp; params)
  : MeshGenerator(params),
    _mesh_ptr(getMesh(&quot;input&quot;)),
    _axial_height(getParam&lt;Real&gt;(&quot;axial_height&quot;))
{
  _build_csg = &amp;getCSGBase(&quot;input&quot;);
}

std::unique_ptr&lt;MeshBase&gt;
TestCSGAxialSurfaceMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
TestCSGAxialSurfaceMeshGenerator::generateCSG()
{
  // get the existing CSGBase associated with the input mesh generator
  // this is the CSGBase object that will be updated
  std::unique_ptr&lt;CSG::CSGBase&gt; csg_obj = std::move(*_build_csg);

  // get the names of the current mesh generator and the input mesh generator
  // so that unique object naming can be enforced
  auto mg_name = this-&gt;name();
  auto inp_name = getParam&lt;MeshGeneratorName&gt;(&quot;input&quot;);

  // get the expected existing cell
  const auto cell_name = inp_name + &quot;_square_cell&quot;;
  const auto &amp; csg_cell = csg_obj-&gt;getCellByName(cell_name);

  // get the existing cell region to update
  auto cell_region = csg_cell.getRegion();

  // centroid used to determine direction for half-space
  const auto centroid = Point(0, 0, 0);

  // setting a default surface name purely for testing purposes
  const auto default_surf_name = &quot;default_surf&quot;;

  // Add surfaces and halfspaces corresponding to top and bottom axial planes
  std::vector&lt;std::string&gt; surf_names{&quot;plus_z&quot;, &quot;minus_z&quot;};
  std::vector&lt;Real&gt; coeffs{0.5 * _axial_height, -0.5 * _axial_height};
  for (unsigned int i = 0; i &lt; coeffs.size(); ++i)
  {
    // create a plane using the coefficients for the equation of a plane
    // z plane equation: 0.0*x + 0.0*y + 1.0*z = (+/-)0.5 * axial_height
    std::unique_ptr&lt;CSG::CSGSurface&gt; surface_ptr =
        std::make_unique&lt;CSG::CSGPlane&gt;(default_surf_name, 0.0, 0.0, 1.0, coeffs[i]);
    auto &amp; csg_plane = csg_obj-&gt;addSurface(std::move(surface_ptr));

    // Rename surface so that it has a unique surface name based on the mesh generator
    const auto surf_name = mg_name + &quot;_surf_&quot; + surf_names[i];
    csg_obj-&gt;renameSurface(csg_plane, surf_name);

    // determine the half-space to add as an updated intersection
    const auto region_direction = csg_plane.getHalfspaceFromPoint(centroid);
    auto halfspace =
        ((region_direction == CSG::CSGSurface::Halfspace::POSITIVE) ? +csg_plane : -csg_plane);

    // update the existing region with a half-space
    cell_region &amp;= halfspace;
  }

  // set the new region for the existing cell
  csg_obj-&gt;updateCellRegion(csg_cell, cell_region);

  // Rename cell as it now defines a box region instead of an infinite square region
  csg_obj-&gt;renameCell(csg_cell, mg_name + &quot;_box_cell&quot;);

  return csg_obj;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="91550554-dd4a-4fbe-8943-69a7156dc773"><div class="modal-content"><h4>(moose/test/src/csg/ExampleCSGInfiniteSquareMeshGenerator.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ExampleCSGInfiniteSquareMeshGenerator.h&quot;
#include &quot;CSGBase.h&quot;
#include &quot;CSGPlane.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ExampleCSGInfiniteSquareMeshGenerator);

InputParameters
ExampleCSGInfiniteSquareMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();

  params.addRequiredParam&lt;Real&gt;(&quot;side_length&quot;, &quot;Side length of infinite square.&quot;);
  params.addParam&lt;MeshGeneratorName&gt;(
      &quot;fill&quot;, &quot;optional input lattice mesh generator to fill generated cell with.&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

ExampleCSGInfiniteSquareMeshGenerator::ExampleCSGInfiniteSquareMeshGenerator(
    const InputParameters &amp; params)
  : MeshGenerator(params),
    _side_length(getParam&lt;Real&gt;(&quot;side_length&quot;)),
    _input_fill_name(isParamValid(&quot;fill&quot;) ? getParam&lt;MeshGeneratorName&gt;(&quot;fill&quot;) : &quot;&quot;),
    _has_fill(isParamValid(&quot;fill&quot;))
{
  if (_has_fill)
  {
    _input_fill_mg_ptr = &amp;getMesh(&quot;fill&quot;);
    _input_fill_csg = &amp;getCSGBase(&quot;fill&quot;);
  }
}

std::unique_ptr&lt;MeshBase&gt;
ExampleCSGInfiniteSquareMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
ExampleCSGInfiniteSquareMeshGenerator::generateCSG()
{
  // name of the current mesh generator to use for naming generated objects
  auto mg_name = this-&gt;name();

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();

  // Add surfaces and halfspaces corresponding to 4 planes of infinite square
  std::vector&lt;std::vector&lt;Point&gt;&gt; points_on_planes{{Point(1. * _side_length / 2., 0., 0.),
                                                    Point(1. * _side_length / 2., 1., 0.),
                                                    Point(1. * _side_length / 2., 0., 1.)},
                                                   {Point(-1. * _side_length / 2., 0., 0.),
                                                    Point(-1. * _side_length / 2., 1., 0.),
                                                    Point(-1. * _side_length / 2., 0., 1.)},
                                                   {Point(0., 1. * _side_length / 2., 0.),
                                                    Point(1., 1. * _side_length / 2., 0.),
                                                    Point(0., 1. * _side_length / 2., 1.)},
                                                   {Point(0., -1. * _side_length / 2., 0.),
                                                    Point(1., -1. * _side_length / 2., 0.),
                                                    Point(0., -1. * _side_length / 2., 1.)}};
  std::vector&lt;std::string&gt; surf_names{&quot;plus_x&quot;, &quot;minus_x&quot;, &quot;plus_y&quot;, &quot;minus_y&quot;};

  // initialize cell region to be updated
  CSG::CSGRegion region;

  // set the center of the prism to be used for determining half-spaces
  const auto centroid = Point(0, 0, 0);

  for (unsigned int i = 0; i &lt; points_on_planes.size(); ++i)
  {
    // object name includes the mesh generator name for uniqueness
    const auto surf_name = mg_name + &quot;_surf_&quot; + surf_names[i];
    // create the plane for one face of the prism
    std::unique_ptr&lt;CSG::CSGSurface&gt; plane_ptr = std::make_unique&lt;CSG::CSGPlane&gt;(
        surf_name, points_on_planes[i][0], points_on_planes[i][1], points_on_planes[i][2]);
    auto &amp; csg_plane = csg_obj-&gt;addSurface(std::move(plane_ptr));
    // determine where the plane is in relation to the centroid to be able to set the half-space
    const auto region_direction = csg_plane.getHalfspaceFromPoint(centroid);
    // half-space is either positive (+plane_ptr) or negative (-plane_ptr)
    // depending on the direction to the centroid
    auto halfspace =
        ((region_direction == CSG::CSGSurface::Halfspace::POSITIVE) ? +csg_plane : -csg_plane);
    // check if this is the first half-space to be added to the region,
    // if not, update the existing region with the intersection of the regions (&amp;=)
    if (region.getRegionType() == CSG::CSGRegion::RegionType::EMPTY)
      region = halfspace;
    else
      region &amp;= halfspace;
  }

  // create the cell defined by the surfaces and region just created
  const auto cell_name = mg_name + &quot;_square_cell&quot;;
  // determine fill: either from input fill mesh generator or default material
  if (_has_fill)
  {
    // join the fill CSGBase into the current CSGBase &amp; use the lattice as the fill
    csg_obj-&gt;joinOtherBase(std::move(*_input_fill_csg));
    // assume input MG is a lattice type for sake of this example/test
    const CSG::CSGLattice &amp; lattice = csg_obj-&gt;getLatticeByName(_input_fill_name + &quot;_lattice&quot;);
    csg_obj-&gt;createCell(cell_name, lattice, region);
  }
  else // default material fill
  {
    const auto material_name = &quot;square_material&quot;;
    csg_obj-&gt;createCell(cell_name, material_name, region);
  }

  return csg_obj;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="6ddc28c8-c283-459d-aeca-3ad9694ff911"><div class="modal-content"><h4>(moose/test/src/csg/TestCSGAxialSurfaceMeshGenerator.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;TestCSGAxialSurfaceMeshGenerator.h&quot;
#include &quot;MeshGenerator.h&quot;
#include &quot;CSGPlane.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, TestCSGAxialSurfaceMeshGenerator);

InputParameters
TestCSGAxialSurfaceMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();
  // input parameter that is an existing mesh generator
  params.addRequiredParam&lt;MeshGeneratorName&gt;(&quot;input&quot;, &quot;The input MeshGenerator.&quot;);
  // additional params for this specific mesh generator
  params.addRequiredParam&lt;Real&gt;(&quot;axial_height&quot;, &quot;Axial height of the model.&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

TestCSGAxialSurfaceMeshGenerator::TestCSGAxialSurfaceMeshGenerator(const InputParameters &amp; params)
  : MeshGenerator(params),
    _mesh_ptr(getMesh(&quot;input&quot;)),
    _axial_height(getParam&lt;Real&gt;(&quot;axial_height&quot;))
{
  _build_csg = &amp;getCSGBase(&quot;input&quot;);
}

std::unique_ptr&lt;MeshBase&gt;
TestCSGAxialSurfaceMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
TestCSGAxialSurfaceMeshGenerator::generateCSG()
{
  // get the existing CSGBase associated with the input mesh generator
  // this is the CSGBase object that will be updated
  std::unique_ptr&lt;CSG::CSGBase&gt; csg_obj = std::move(*_build_csg);

  // get the names of the current mesh generator and the input mesh generator
  // so that unique object naming can be enforced
  auto mg_name = this-&gt;name();
  auto inp_name = getParam&lt;MeshGeneratorName&gt;(&quot;input&quot;);

  // get the expected existing cell
  const auto cell_name = inp_name + &quot;_square_cell&quot;;
  const auto &amp; csg_cell = csg_obj-&gt;getCellByName(cell_name);

  // get the existing cell region to update
  auto cell_region = csg_cell.getRegion();

  // centroid used to determine direction for half-space
  const auto centroid = Point(0, 0, 0);

  // setting a default surface name purely for testing purposes
  const auto default_surf_name = &quot;default_surf&quot;;

  // Add surfaces and halfspaces corresponding to top and bottom axial planes
  std::vector&lt;std::string&gt; surf_names{&quot;plus_z&quot;, &quot;minus_z&quot;};
  std::vector&lt;Real&gt; coeffs{0.5 * _axial_height, -0.5 * _axial_height};
  for (unsigned int i = 0; i &lt; coeffs.size(); ++i)
  {
    // create a plane using the coefficients for the equation of a plane
    // z plane equation: 0.0*x + 0.0*y + 1.0*z = (+/-)0.5 * axial_height
    std::unique_ptr&lt;CSG::CSGSurface&gt; surface_ptr =
        std::make_unique&lt;CSG::CSGPlane&gt;(default_surf_name, 0.0, 0.0, 1.0, coeffs[i]);
    auto &amp; csg_plane = csg_obj-&gt;addSurface(std::move(surface_ptr));

    // Rename surface so that it has a unique surface name based on the mesh generator
    const auto surf_name = mg_name + &quot;_surf_&quot; + surf_names[i];
    csg_obj-&gt;renameSurface(csg_plane, surf_name);

    // determine the half-space to add as an updated intersection
    const auto region_direction = csg_plane.getHalfspaceFromPoint(centroid);
    auto halfspace =
        ((region_direction == CSG::CSGSurface::Halfspace::POSITIVE) ? +csg_plane : -csg_plane);

    // update the existing region with a half-space
    cell_region &amp;= halfspace;
  }

  // set the new region for the existing cell
  csg_obj-&gt;updateCellRegion(csg_cell, cell_region);

  // Rename cell as it now defines a box region instead of an infinite square region
  csg_obj-&gt;renameCell(csg_cell, mg_name + &quot;_box_cell&quot;);

  return csg_obj;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ea1faabd-e6b1-4ca5-aca8-c07b3161b6dd"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="134ebf59-8bec-483a-8836-8195b858626a"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="49b7db63-ea56-4b7f-9dd3-0f5afd34b630"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="08526248-f24f-4c7a-80da-c643011253c0"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="84873aec-30b2-4bd7-a73c-a5e646dc7b98"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="158dfe10-7d5b-4c65-b4b4-06db2267e763"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="66fd06dd-ead4-44c4-9d5c-c02778fa3325"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="8eaa12db-ece9-4d62-a43d-902dca9bd8a7"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="14d4ab05-d2f8-4a4b-8f79-1d6847f7f21f"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="8bb1379b-928a-4a09-9aca-c94b8bdf37c9"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="e67718fc-8d3a-4f83-962d-282f96080f9d"><div class="modal-content"><h4>(moose/test/src/csg/TestCSGLatticeMeshGenerator.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;TestCSGLatticeMeshGenerator.h&quot;
#include &quot;MeshGenerator.h&quot;
#include &quot;CSGPlane.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, TestCSGLatticeMeshGenerator);

InputParameters
TestCSGLatticeMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();
  // input parameter that is an existing mesh generator
  params.addRequiredParam&lt;std::vector&lt;MeshGeneratorName&gt;&gt;(
      &quot;inputs&quot;,
      &quot;The MeshGenerators that form the components of the lattice. Order of inputs corresponds to &quot;
      &quot;the associated integer ID for the pattern (i.e., 0 for first input, 1 for second input, &quot;
      &quot;etc.)&quot;);
  params.addRequiredParam&lt;std::string&gt;(
      &quot;lattice_type&quot;, &quot;The type of lattice to create. Options are &#x27;cartesian&#x27; and &#x27;hexagonal&#x27;.&quot;);
  params.addRequiredParam&lt;Real&gt;(&quot;pitch&quot;,
                                &quot;The pitch (flat-to-flat distance) of each lattice element.&quot;);
  params.addRequiredParam&lt;std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;(
      &quot;pattern&quot;,
      &quot;A double-indexed array starting with the upper-left corner where the index&quot;
      &quot;represents the index of the mesh/CSG generator in the &#x27;inputs&#x27; vector&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

TestCSGLatticeMeshGenerator::TestCSGLatticeMeshGenerator(const InputParameters &amp; params)
  : MeshGenerator(params),
    _lattice_type(getParam&lt;std::string&gt;(&quot;lattice_type&quot;)),
    _pitch(getParam&lt;Real&gt;(&quot;pitch&quot;)),
    _input_names(getParam&lt;std::vector&lt;MeshGeneratorName&gt;&gt;(&quot;inputs&quot;)),
    _mesh_ptrs(getMeshes(&quot;inputs&quot;)),
    _pattern(getParam&lt;std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;(&quot;pattern&quot;))
{
  for (auto inp : _input_names)
    _input_csgs.push_back(&amp;getCSGBaseByName(inp));
}

std::unique_ptr&lt;MeshBase&gt;
TestCSGLatticeMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
TestCSGLatticeMeshGenerator::generateCSG()
{
  // create a new CSGBase object to build the lattice in
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // get the name of the current mesh generator
  auto mg_name = this-&gt;name();

  // join each input CSGBase into the new CSGBase as a unique universe
  std::unordered_map&lt;unsigned int, std::string&gt; univ_id_names;
  for (const auto i : index_range(_input_names))
  {
    std::string join_name = _input_names[i] + &quot;_univ&quot;;
    csg_obj-&gt;joinOtherBase(std::move(*_input_csgs[i]), join_name);
    univ_id_names[i] = join_name;
  }

  // build the universe pattern for the lattice using the input pattern
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; universe_pattern;
  for (const auto &amp; row : _pattern)
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt; universe_row;
    for (const auto univ_id : row)
    {
      const auto &amp; univ = csg_obj-&gt;getUniverseByName(univ_id_names[univ_id]);
      universe_row.push_back(univ);
    }
    universe_pattern.push_back(universe_row);
  }

  // create the lattice based on the specified type
  std::string lat_name = mg_name + &quot;_lattice&quot;;
  if (_lattice_type == &quot;cartesian&quot;)
  {
    std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
        std::make_unique&lt;CSG::CSGCartesianLattice&gt;(lat_name, _pitch, universe_pattern);
    csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  }
  else if (_lattice_type == &quot;hexagonal&quot;)
  {
    std::unique_ptr&lt;CSG::CSGHexagonalLattice&gt; lat_ptr =
        std::make_unique&lt;CSG::CSGHexagonalLattice&gt;(lat_name, _pitch, universe_pattern);
    csg_obj-&gt;addLattice&lt;CSG::CSGHexagonalLattice&gt;(std::move(lat_ptr));
  }
  return csg_obj;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="2d72366c-0437-41d1-884b-ad5b815d6bb3"><div class="modal-content"><h4>(moose/unit/src/CSGLatticeTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;
#include &quot;CSGUniverse.h&quot;
#include &quot;CSGCell.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGLattice class and derived classes
 */

/// tests valid CSGCartesianLattice construction
TEST(CSGLatticeTest, testCreateCartLatticeValid)
{
  // universe map and outer universe to use throughout tests
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1, univ1}, {univ1, univ1, univ1}};
  const auto outer_univ = CSGUniverse(&quot;outer_univ&quot;, false);
  {
    // initialize without universe map, outer is void, and pitch=1.0
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
    // check dimensions/attributes
    ASSERT_EQ(cart_lattice.getNRows(), 0);
    ASSERT_EQ(cart_lattice.getNCols(), 0);
    ASSERT_EQ(cart_lattice.getPitch(), 1.0);
    // expect no universe map to be present yet
    ASSERT_EQ(cart_lattice.getUniverses().size(), 0);
    // check other attributes
    ASSERT_TRUE(cart_lattice.getName() == &quot;cartlat&quot;);
    ASSERT_TRUE(cart_lattice.getType() == &quot;CSG::CSGCartesianLattice&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;VOID&quot;);
  }
  {
    // initialize with an array of universes, pitch=1.0
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
    // check dimensions/attributes
    ASSERT_EQ(cart_lattice.getNRows(), 2);
    ASSERT_EQ(cart_lattice.getNCols(), 3);
    ASSERT_EQ(cart_lattice.getPitch(), 1.0);
    // expect 2x3 array
    ASSERT_EQ(cart_lattice.getUniverses().size(), 2);
    ASSERT_EQ(cart_lattice.getUniverses()[0].size(), 3);
    ASSERT_EQ(cart_lattice.getUniverses()[1].size(), 3);
    // check other attributes
    ASSERT_TRUE(cart_lattice.getName() == &quot;cartlat&quot;);
    ASSERT_TRUE(cart_lattice.getType() == &quot;CSG::CSGCartesianLattice&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;VOID&quot;);
  }
  {
    // initialize without universe map but set outer universe
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, outer_univ);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(cart_lattice.getOuterUniverse(), outer_univ);
  }
  {
    // initialize with universe map and set outer fill to be a universe
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map, outer_univ);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(cart_lattice.getOuterUniverse(), outer_univ);
  }
  {
    // initialize without universe map but set outer to a material
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, &quot;outer_mat&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(cart_lattice.getOuterMaterial(), &quot;outer_mat&quot;);
  }
  {
    // initialize with universe map but set outer material
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map, &quot;outer_mat&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(cart_lattice.getOuterMaterial(), &quot;outer_mat&quot;);
  }
}

/// tests invalid CSGCartesianLattice construction
TEST(CSGLatticeTest, testCreateCartLatticeInvalid)
{
  {
    // try initialize with invalid dimension for pitch
    Moose::UnitUtils::assertThrows(
        []() { CSGCartesianLattice(&quot;cartlat&quot;, -1.0); },
        &quot;Lattice cartlat must have pitch greater than 0.&quot;); // invalid pitch
  }
  {
    // try to initialize with universe array of invalid dimensions (second row is different length)
    const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1}, {univ1, univ1}};
    std::string exp_msg = &quot;Cannot set lattice cartlat with universes. Does not have valid &quot;
                          &quot;dimensions for lattice type CSG::CSGCartesianLattice&quot;;
    Moose::UnitUtils::assertThrows([&amp;univ_map]() { CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map); },
                                   exp_msg);
  }
}

/// tests valid CSGHexagonalLattice construction
TEST(CSGLatticeTest, testCreateHexLatticeValid)
{
  // universe map and outer universe to use throughout tests
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1}};
  const auto outer_univ = CSGUniverse(&quot;outer_univ&quot;, false);
  {
    // initialize without universes: pitch=1.0
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0);
    // check dimensions and properties
    ASSERT_EQ(hex_lat.getNRows(), 0);
    ASSERT_EQ(hex_lat.getNRings(), 0);
    ASSERT_EQ(hex_lat.getPitch(), 1.0);
    ASSERT_EQ(hex_lat.getUniverses().size(), 0); // no universe map yet
    ASSERT_TRUE(hex_lat.getName() == &quot;hexlat&quot;);
    ASSERT_TRUE(hex_lat.getType() == &quot;CSG::CSGHexagonalLattice&quot;);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;VOID&quot;);
  }
  {
    // initialize with universe map, pitch=1.0
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map);
    ASSERT_EQ(hex_lat.getNRings(), 3);
    ASSERT_EQ(hex_lat.getPitch(), 1.0);
    ASSERT_EQ(hex_lat.getNRows(), 5); // should be 2*nring -1 (auto calculated)
    ASSERT_EQ(hex_lat.getUniverses().size(), 5);
    ASSERT_EQ(hex_lat.getUniverses()[0].size(), 3);
    ASSERT_EQ(hex_lat.getUniverses()[1].size(), 4);
    ASSERT_EQ(hex_lat.getUniverses()[2].size(), 5);
    ASSERT_EQ(hex_lat.getUniverses()[3].size(), 4);
    ASSERT_EQ(hex_lat.getUniverses()[4].size(), 3);
    ASSERT_TRUE(hex_lat.getName() == &quot;hexlat&quot;);
    ASSERT_TRUE(hex_lat.getType() == &quot;CSG::CSGHexagonalLattice&quot;);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;VOID&quot;);
  }
  {
    // initialize without universe map but set outer universe
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, outer_univ);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(hex_lat.getOuterUniverse(), outer_univ);
  }
  {
    // initialize with universe map but set outer universe
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map, outer_univ);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(hex_lat.getOuterUniverse(), outer_univ);
  }
  {
    // initialize without universe map but set outer material
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, &quot;outer_mat&quot;);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(hex_lat.getOuterMaterial(), &quot;outer_mat&quot;);
  }
  {
    // initialize with universe map but set outer material
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map, &quot;outer_mat&quot;);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(hex_lat.getOuterMaterial(), &quot;outer_mat&quot;);
  }
}

/// tests invalid CSGHexagonalLattice construction
TEST(CSGLatticeTest, testCreateHexLatticeInvalid)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  {
    // try initialize empty by providing invalid dimensions
    Moose::UnitUtils::assertThrows(
        []() { CSGHexagonalLattice(&quot;hexlat&quot;, -1.0); },
        &quot;Lattice hexlat must have pitch greater than 0.&quot;); // invalid pitch
  }
  {
    // create universe map with invalid dimensions (even number of rows)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1},
        {univ1, univ1, univ1, univ1},
        {univ1, univ1, univ1, univ1},
        {univ1, univ1, univ1}};
    std::string exp_msg = &quot;Cannot set lattice hexlat with universes. Does not have valid &quot;
                          &quot;dimensions for lattice type CSG::CSGHexagonalLattice&quot;;
    Moose::UnitUtils::assertThrows([&amp;univ_map]() { CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map); },
                                   exp_msg);
  }
  {
    // create universe map with invalid dimensions (one row has wrong number of elements)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1},
        {univ1, univ1, univ1, univ1},
        {univ1, univ1, univ1, univ1}, // should have 5 elements
        {univ1, univ1, univ1, univ1},
        {univ1, univ1, univ1}};
    std::string exp_msg = &quot;Cannot set lattice hexlat with universes. Does not have valid &quot;
                          &quot;dimensions for lattice type CSG::CSGHexagonalLattice&quot;;
    Moose::UnitUtils::assertThrows([&amp;univ_map]() { CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map); },
                                   exp_msg);
  }
}

/// tests getAttributes function for both CSGCartesianLattice and CSGHexagonalLattice
TEST(CSGLatticeTest, testGetAttributes)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  {
    // cartesian lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1}, {univ1, univ1, univ1}};
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
    auto dims_map = cart_lattice.getAttributes();
    ASSERT_EQ(std::get&lt;unsigned int&gt;(dims_map[&quot;nrow&quot;]), 2);
    ASSERT_EQ(std::get&lt;unsigned int&gt;(dims_map[&quot;ncol&quot;]), 3);
    ASSERT_EQ(std::get&lt;Real&gt;(dims_map[&quot;pitch&quot;]), 1.0);
  }
  {
    // hexagonal lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1}, {univ1, univ1, univ1}, {univ1, univ1}};
    auto hex_lattice = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map);
    auto dims_map = hex_lattice.getAttributes();
    ASSERT_EQ(std::get&lt;unsigned int&gt;(dims_map[&quot;nrow&quot;]), 3);
    ASSERT_EQ(std::get&lt;unsigned int&gt;(dims_map[&quot;nring&quot;]), 2); // should be (nrow + 1)/2
    ASSERT_EQ(std::get&lt;Real&gt;(dims_map[&quot;pitch&quot;]), 1.0);
  }
}

/// tests CSGCartesianLattice::setUniverses function
TEST(CSGLatticeTest, testCartSetUniverses)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  // create initial lattice without a map
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
  {
    // create universe map and set it on the initialized lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1}, {univ1, univ1, univ1}};
    ASSERT_NO_THROW(cart_lattice.setUniverses(univ_map));
    // should have 1x4 map after being set
    ASSERT_EQ(cart_lattice.getUniverses().size(), 2);
    ASSERT_EQ(cart_lattice.getUniverses()[0].size(), 3);
    ASSERT_EQ(cart_lattice.getUniverses()[1].size(), 3);
    // make sure dimensions were updated
    ASSERT_EQ(cart_lattice.getNRows(), 2);
    ASSERT_EQ(cart_lattice.getNCols(), 3);
  }
  {
    // overwrite w/ new universe map of different dimensions - valid
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univ_map = {
        {univ2, univ2, univ2, univ2}};
    ASSERT_NO_THROW(cart_lattice.setUniverses(new_univ_map));
    // expect map to contain all univ2
    for (auto univ_list : cart_lattice.getUniverses())
    {
      for (const CSGUniverse &amp; univ : univ_list)
        ASSERT_EQ(univ, univ2);
    }
    // should have 1x4 map after being set
    ASSERT_EQ(cart_lattice.getUniverses().size(), 1);
    ASSERT_EQ(cart_lattice.getUniverses()[0].size(), 4);
    // make sure dimensions were updated
    ASSERT_EQ(cart_lattice.getNRows(), 1);
    ASSERT_EQ(cart_lattice.getNCols(), 4);
  }
}

/// tests CSGHexagonalLattice::setUniverses function
TEST(CSGLatticeTest, testHexSetUniverses)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  // initial empty lattice
  auto lat = CSGHexagonalLattice(&quot;lat&quot;, 1.0);
  {
    // create universe map and then set it on the initialized lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1}, {univ1, univ1, univ1}, {univ1, univ1}};
    ASSERT_NO_THROW(lat.setUniverses(univ_map););
    // should have a 2-ring map (3 rows) after being set
    ASSERT_EQ(lat.getUniverses().size(), 3);
    ASSERT_EQ(lat.getUniverses()[0].size(), 2);
    ASSERT_EQ(lat.getUniverses()[1].size(), 3);
    ASSERT_EQ(lat.getUniverses()[2].size(), 2);
    // make sure dimensions were set
    ASSERT_EQ(lat.getNRows(), 3);
  }
  {
    // create new map with new dimensions and update lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univ_map = {
        {univ2, univ2, univ2},
        {univ2, univ2, univ2, univ2},
        {univ2, univ2, univ2, univ2, univ2},
        {univ2, univ2, univ2, univ2},
        {univ2, univ2, univ2}};
    lat.setUniverses(new_univ_map);
    // expect map to contain all univ2
    for (auto univ_list : lat.getUniverses())
    {
      for (const CSGUniverse &amp; univ : univ_list)
        ASSERT_EQ(univ, univ2);
    }
    // should have 3-ring (5 row) map after being set
    ASSERT_EQ(lat.getUniverses().size(), 5);
    ASSERT_EQ(lat.getUniverses()[0].size(), 3);
    ASSERT_EQ(lat.getUniverses()[1].size(), 4);
    ASSERT_EQ(lat.getUniverses()[2].size(), 5);
    ASSERT_EQ(lat.getUniverses()[3].size(), 4);
    ASSERT_EQ(lat.getUniverses()[4].size(), 3);
    // make sure dimensions were updated
    ASSERT_EQ(lat.getNRows(), 5);
  }
}

/// tests CSGLattice::getUniverseNameMap function
TEST(CSGLatticeTest, testGetUniverseNameMap)
{
  std::string name1 = &quot;pinky&quot;;
  std::string name2 = &quot;brain&quot;;
  const auto univ1 = CSGUniverse(name1, false);
  const auto univ2 = CSGUniverse(name2, false);
  // create cartesian lattice with 2x2 universe map
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {{univ1, univ2},
                                                                                  {univ2, univ1}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  auto name_map = cart_lattice.getUniverseNameMap();
  ASSERT_EQ(name_map.size(), 2);
  ASSERT_EQ(name_map[0].size(), 2);
  ASSERT_EQ(name_map[1].size(), 2);
  ASSERT_EQ(name_map[0][0], name1);
  ASSERT_EQ(name_map[0][1], name2);
  ASSERT_EQ(name_map[1][0], name2);
  ASSERT_EQ(name_map[1][1], name1);
}

/// tests CSGLattice::hasUniverse function
TEST(CSGLatticeTest, testHasUniverse)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {{univ1, univ2}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  // check for existing universes
  ASSERT_TRUE(cart_lattice.hasUniverse(&quot;univ1&quot;));
  ASSERT_TRUE(cart_lattice.hasUniverse(&quot;univ2&quot;));
  // check for non-existing universe
  ASSERT_FALSE(cart_lattice.hasUniverse(&quot;univ3&quot;));
}

/// tests CSGCartesianLattice::isValidIndex function
TEST(CSGLatticeTest, testCartIsValidIndex)
{
  // create initial lattice of all univ1 elements
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1, univ1}, {univ1, univ1, univ1}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  {
    // test valid index locations
    ASSERT_TRUE(cart_lattice.isValidIndex(std::make_pair(0, 0)));
    ASSERT_TRUE(cart_lattice.isValidIndex(std::make_pair(1, 2)));
  }
  {
    // test invalid index locations
    ASSERT_FALSE(cart_lattice.isValidIndex(std::make_pair(2, 0)));  // row out of bounds
    ASSERT_FALSE(cart_lattice.isValidIndex(std::make_pair(0, 3)));  // col out of bounds
    ASSERT_FALSE(cart_lattice.isValidIndex(std::make_pair(-1, 0))); // negative row
    ASSERT_FALSE(cart_lattice.isValidIndex(std::make_pair(0, -1))); // negative col
  }
}

/// tests CSGHexagonalLattice::isValidIndex function
TEST(CSGLatticeTest, testHexIsValidIndex)
{
  // create initial lattice of all univ1 elements
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1}, {univ1, univ1, univ1}, {univ1, univ1}};
  auto hex_lattice = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map);
  {
    // valid list of indices for 2-ring hex lattice:
    std::vector&lt;std::pair&lt;int, int&gt;&gt; valid_indices = {std::make_pair(0, 0),
                                                      std::make_pair(0, 1),
                                                      std::make_pair(1, 0),
                                                      std::make_pair(1, 1),
                                                      std::make_pair(1, 2),
                                                      std::make_pair(2, 0),
                                                      std::make_pair(2, 1)};
    // check that all valid indices return true
    for (const auto &amp; index : valid_indices)
      ASSERT_TRUE(hex_lattice.isValidIndex(index));
  }
  {
    // check invalid for each case is caught
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(0, 2)));  // col out of bounds (row 0)
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(1, 3)));  // col out of bounds (row 1)
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(3, 0)));  // row out of bounds
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(-1, 0))); // negative row
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(0, -1))); // negative col
  }
}

/// tests CSGCartesianLattice::setUniverseAtIndex function
TEST(CSGLatticeTest, testCartSetUniverseAtIndex)
{
  // create initial lattice of all univ1 elements
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1, univ1}, {univ1, univ1, univ1}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  // initial map should contain structure matching univ_map (all univ1)
  for (auto univ_list : cart_lattice.getUniverses())
  {
    for (const CSGUniverse &amp; univ : univ_list)
      ASSERT_EQ(univ, univ1);
  }
  {
    // replace element in universe map with another using setUniverseAtIndex (valid index location)
    cart_lattice.setUniverseAtIndex(univ2, std::make_pair(1, 2));
    auto univs = cart_lattice.getUniverses();
    for (auto i : index_range(univs))
    {
      for (auto j : index_range(univs[i]))
      {
        // all universes should be univ1 except (1, 2) location
        const CSGUniverse &amp; univ = univs[i][j];
        if (i == 1 &amp;&amp; j == 2)
          ASSERT_EQ(univ, univ2);
        else
          ASSERT_EQ(univ, univ1);
      }
    }
  }
  {
    // try replacing element at an invalid index - should raise error
    Moose::UnitUtils::assertThrows(
        [&amp;cart_lattice, &amp;univ2]() { cart_lattice.setUniverseAtIndex(univ2, std::make_pair(3, 3)); },
        &quot;Cannot set universe at location (3, 3) for lattice cartlat. Not a valid location.&quot;);
  }
  {
    // create a lattice without any map initialized yet and try setting just one element
    // should raise error about map not being initialized yet
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
    Moose::UnitUtils::assertThrows(
        [&amp;cart_lattice, &amp;univ2]() { cart_lattice.setUniverseAtIndex(univ2, std::make_pair(0, 0)); },
        &quot;Cannot set universe at location (0, 0) for lattice cartlat. &quot;
        &quot;Universe map has not been initialized.&quot;);
  }
}

/// tests CSGCartesianLattice different methods for retrieving universes or locations of universes
TEST(CSGLatticeTest, testGetMethods)
{
  // test get all and get by name (valid and invalid) and get at index (valid and invalid)
  // create initial lattice of all univ1 elements
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ2, univ1}, {univ2, univ1, univ2}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  {
    // get universe indices by name - valid name
    auto loc_list = cart_lattice.getUniverseIndices(&quot;univ1&quot;);
    std::vector&lt;std::pair&lt;unsigned int, unsigned int&gt;&gt; exp_locs = {
        std::make_pair(0, 0), std::make_pair(0, 2), std::make_pair(1, 1)};
    ASSERT_EQ(loc_list, exp_locs);
  }
  {
    // get universe indices by name - invalid name; should raise error
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]()
                                   { cart_lattice.getUniverseIndices(&quot;fake_name&quot;); },
                                   &quot;Universe fake_name does not exist in lattice&quot;);
  }
  {
    // get universe at index - valid index
    const CSGUniverse &amp; retr_univ = cart_lattice.getUniverseAtIndex(std::make_pair(0, 1));
    ASSERT_EQ(retr_univ, univ2);
  }
  {
    // get universe at index - invalid index; should raise error
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]()
                                   { cart_lattice.getUniverseAtIndex(std::make_pair(3, 3)); },
                                   &quot;Index (3, 3) is not a valid index for lattice &quot;);
  }
}

/// test setName functionality
TEST(CSGLatticeTest, testSetName)
{
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
  cart_lattice.setName(&quot;new_name&quot;);
  ASSERT_EQ(cart_lattice.getName(), &quot;new_name&quot;);
}

/// test the == and != overloaded operators for cartesian lattices
TEST(CSGLatticeTest, testCartLatticeEquality)
{
  // universe maps to use for different lattice comparisons
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  const auto out1 = CSGUniverse(&quot;outer1&quot;, false);
  const auto out2 = CSGUniverse(&quot;outer2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map1 = {{univ1, univ1},
                                                                                   {univ1, univ1}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map2 = {{univ2, univ2},
                                                                                   {univ2, univ2}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map3 = {{univ1, univ1}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map4 = {{univ1},
                                                                                   {univ1}};
  // identical lattices
  auto l1 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  auto l2 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  // lattice that differs by name only
  auto l3 = CSGCartesianLattice(&quot;cartlat1&quot;, 1.0, univ_map1);
  // lattice that differs by universe map items
  auto l4 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map2);
  // lattice that differs by pitch
  auto l5 = CSGCartesianLattice(&quot;cartlat&quot;, 2.0, univ_map1);
  // lattice that differs by nrow
  auto l6 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map3);
  // lattice that differs by ncol
  auto l7 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map4);
  // differs by outer type - material outer
  auto l8 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  l8.updateOuter(&quot;outer1&quot;);
  // differs by outer type - universe outer
  auto l9 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  l9.updateOuter(out1);
  // differs by outer object - universe outer
  auto l10 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  l10.updateOuter(out2);
  // differs by outer name - material outer
  auto l11 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  l11.updateOuter(&quot;outer2&quot;);

  // check equality
  {
    ASSERT_TRUE(l1 == l2);
  }
  // check inequality
  {
    // all lattices 2-7 should differ from each other in some way
    std::vector&lt;CSGCartesianLattice&gt; diff_compare = {l2, l3, l4, l5, l6, l7, l8, l9, l10, l11};
    for (std::size_t i = 0; i &lt; diff_compare.size(); i++)
    {
      for (std::size_t j = i + 1; j &lt; diff_compare.size(); ++j)
        ASSERT_TRUE(diff_compare[i] != diff_compare[j]);
    }
  }
}

/// test the == and != overloaded operators for hexagonal lattices
TEST(CSGLatticeTest, testHexLatticeEquality)
{
  // universe maps to use for different lattice comparisons
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map1 = {
      {univ1, univ1}, {univ1, univ1, univ1}, {univ1, univ1}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map2 = {
      {univ2, univ2}, {univ2, univ2, univ2}, {univ2, univ2}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map3 = {
      {univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1}};
  // identical lattices
  auto l1 = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map1);
  auto l2 = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map1);
  // lattice that differs by name only
  auto l3 = CSGHexagonalLattice(&quot;hexlat1&quot;, 1.0, univ_map1);
  // lattice that differs by universe map items
  auto l4 = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map2);
  // lattice that differs by pitch
  auto l5 = CSGHexagonalLattice(&quot;hexlat&quot;, 2.0, univ_map1);
  // lattice that differs by nrow/rings
  auto l6 = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map3);

  // check equality
  {
    ASSERT_TRUE(l1 == l2);
  }
  // check inequality
  {
    // all lattices 2-6 should differ from each other in some way
    std::vector&lt;CSGHexagonalLattice&gt; diff_compare = {l2, l3, l4, l5, l6};
    for (std::size_t i = 0; i &lt; diff_compare.size(); i++)
    {
      for (std::size_t j = i + 1; j &lt; diff_compare.size(); ++j)
        ASSERT_TRUE(diff_compare[i] != diff_compare[j]);
    }
  }
}

/// test CSGLattice::getUniqueUniverses
TEST(CSGLatticeTest, testGetUniqueUniverses)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {{univ1, univ1},
                                                                                  {univ2, univ1}};
  auto lat = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  auto unique = lat.getUniqueUniverses();
  ASSERT_EQ(unique.size(), 2);
  ASSERT_EQ(unique[0].get(), univ1);
  ASSERT_EQ(unique[1].get(), univ2);
}

/// test CSG[Cartesian/Hexagonal]Lattice::setPitch
TEST(CSGLatticeTest, testSetPitch)
{
  {
    // cartesian lattice set pitch
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
    // set valid pitch
    cart_lattice.setPitch(2.5);
    ASSERT_EQ(cart_lattice.getPitch(), 2.5);
    // try to set invalid pitch (raise error)
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.setPitch(-0.5); },
                                   &quot;must have pitch greater than 0.&quot;);
  }
  {
    // hexagonal lattice set pitch
    auto hex_lat = CSGHexagonalLattice(&quot;hex_lat&quot;, 1.0);
    // set valid pitch
    hex_lat.setPitch(2.5);
    ASSERT_EQ(hex_lat.getPitch(), 2.5);
    // try to set invalid pitch (raise error)
    Moose::UnitUtils::assertThrows([&amp;hex_lat]() { hex_lat.setPitch(-0.5); },
                                   &quot;must have pitch greater than 0.&quot;);
  }
}

/// test CSGHexagonalLattice::get[Ring/Row]IndexFrom[Row/Ring]Index
TEST(CSGLatticeTest, testHexConvertRowsRings)
{
  // test that conversion between ring and row form works on 2-, 3-, and 4-ring hex lattices
  const auto u = CSGUniverse(&quot;u&quot;, false);
  {
    // 2-ring lattice case
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; umap = {
        {u, u}, {u, u, u}, {u, u}};
    auto lat = CSGHexagonalLattice(&quot;lat&quot;, 1.0, umap);
    std::map&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt;&gt; exp_row_to_ring = {{{0, 0}, {0, 4}},
                                                                          {{0, 1}, {0, 5}},
                                                                          {{1, 0}, {0, 3}},
                                                                          {{1, 1}, {1, 0}},
                                                                          {{1, 2}, {0, 0}},
                                                                          {{2, 0}, {0, 2}},
                                                                          {{2, 1}, {0, 1}}};
    for (const auto &amp; pair : exp_row_to_ring)
    {
      auto row_pair = lat.getRowIndexFromRingIndex(pair.second);
      ASSERT_EQ(row_pair, pair.first);
      auto ring_pair = lat.getRingIndexFromRowIndex(pair.first);
      ASSERT_EQ(ring_pair, pair.second);
    }
    // check that invalid ring index raises error
    Moose::UnitUtils::assertThrows([&amp;lat]() { lat.getRowIndexFromRingIndex(std::make_pair(2, 0)); },
                                   &quot;Ring 2 is not valid for hexagonal lattice lat&quot;);
    Moose::UnitUtils::assertThrows([&amp;lat]() { lat.getRowIndexFromRingIndex(std::make_pair(1, 7)); },
                                   &quot;Position 7 is not valid for ring 1 in hexagonal lattice lat&quot;);
    // check that invalid row-column index raises error
    Moose::UnitUtils::assertThrows([&amp;lat]() { lat.getRingIndexFromRowIndex(std::make_pair(3, 0)); },
                                   &quot;Index (3, 0) is not a valid index for hexagonal lattice lat&quot;);
  }
  {
    // 3-ring case
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; umap = {
        {u, u, u}, {u, u, u, u}, {u, u, u, u, u}, {u, u, u, u}, {u, u, u}};
    auto lat = CSGHexagonalLattice(&quot;lat&quot;, 1.0, umap);
    std::map&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt;&gt; exp_row_to_ring = {{{0, 0}, {0, 8}},
                                                                          {{0, 1}, {0, 9}},
                                                                          {{0, 2}, {0, 10}},
                                                                          {{1, 0}, {0, 7}},
                                                                          {{1, 1}, {1, 4}},
                                                                          {{1, 2}, {1, 5}},
                                                                          {{1, 3}, {0, 11}},
                                                                          {{2, 0}, {0, 6}},
                                                                          {{2, 1}, {1, 3}},
                                                                          {{2, 2}, {2, 0}},
                                                                          {{2, 3}, {1, 0}},
                                                                          {{2, 4}, {0, 0}},
                                                                          {{3, 0}, {0, 5}},
                                                                          {{3, 1}, {1, 2}},
                                                                          {{3, 2}, {1, 1}},
                                                                          {{3, 3}, {0, 1}},
                                                                          {{4, 0}, {0, 4}},
                                                                          {{4, 1}, {0, 3}},
                                                                          {{4, 2}, {0, 2}}};
    for (const auto &amp; pair : exp_row_to_ring)
    {
      auto row_pair = lat.getRowIndexFromRingIndex(pair.second);
      ASSERT_EQ(row_pair, pair.first);
      auto ring_pair = lat.getRingIndexFromRowIndex(pair.first);
      ASSERT_EQ(ring_pair, pair.second);
    }
  }
  {
    // 4-ring case
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; umap = {
        {u, u, u, u},
        {u, u, u, u, u},
        {u, u, u, u, u, u},
        {u, u, u, u, u, u, u},
        {u, u, u, u, u, u},
        {u, u, u, u, u},
        {u, u, u, u}};
    auto lat = CSGHexagonalLattice(&quot;lat&quot;, 1.0, umap);
    std::map&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt;&gt; exp_row_to_ring = {
        {{0, 0}, {0, 12}}, {{0, 1}, {0, 13}}, {{0, 2}, {0, 14}}, {{0, 3}, {0, 15}},
        {{1, 0}, {0, 11}}, {{1, 1}, {1, 8}},  {{1, 2}, {1, 9}},  {{1, 3}, {1, 10}},
        {{1, 4}, {0, 16}}, {{2, 0}, {0, 10}}, {{2, 1}, {1, 7}},  {{2, 2}, {2, 4}},
        {{2, 3}, {2, 5}},  {{2, 4}, {1, 11}}, {{2, 5}, {0, 17}}, {{3, 0}, {0, 9}},
        {{3, 1}, {1, 6}},  {{3, 2}, {2, 3}},  {{3, 3}, {3, 0}},  {{3, 4}, {2, 0}},
        {{3, 5}, {1, 0}},  {{3, 6}, {0, 0}},  {{4, 0}, {0, 8}},  {{4, 1}, {1, 5}},
        {{4, 2}, {2, 2}},  {{4, 3}, {2, 1}},  {{4, 4}, {1, 1}},  {{4, 5}, {0, 1}},
        {{5, 0}, {0, 7}},  {{5, 1}, {1, 4}},  {{5, 2}, {1, 3}},  {{5, 3}, {1, 2}},
        {{5, 4}, {0, 2}},  {{6, 0}, {0, 6}},  {{6, 1}, {0, 5}},  {{6, 2}, {0, 4}},
        {{6, 3}, {0, 3}}};
    for (const auto &amp; pair : exp_row_to_ring)
    {
      auto row_pair = lat.getRowIndexFromRingIndex(pair.second);
      ASSERT_EQ(row_pair, pair.first);
      auto ring_pair = lat.getRingIndexFromRowIndex(pair.first);
      ASSERT_EQ(ring_pair, pair.second);
    }
  }
}

/// tests that a lattice initialized without a universe map can be filled later even after it is used to fill a cell
TEST(CSGLatticeTest, testEmptyToFilled)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  {
    // create lattice without any universes
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
    // create cell and fill with the empty lattice
    auto cell = CSGCell(&quot;cell1&quot;, &amp;cart_lattice, CSG::CSGRegion());
    // now create universe map and set it on the lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {{univ1, univ1},
                                                                                    {univ1, univ1}};
    ASSERT_NO_THROW(cart_lattice.setUniverses(univ_map));
    // verify that the lattice in the cell has the correct universe map now
    const auto &amp; lat_in_cell = cell.getFillLattice();
    ASSERT_EQ(lat_in_cell.getUniverses().size(), 2);
    ASSERT_EQ(lat_in_cell.getUniverses()[0].size(), 2);
  }
}

TEST(CSGLatticeTest, testUpdateOuter)
{
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
  {
    // check outer universe type is set to VOID by default
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;VOID&quot;);
    // make sure trying to get material or universe outer raises error
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.getOuterMaterial(); },
                                   &quot;Lattice &#x27;cartlat&#x27; has VOID outer, not CSG_MATERIAL.&quot;);
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.getOuterUniverse(); },
                                   &quot;Lattice &#x27;cartlat&#x27; has VOID outer, not UNIVERSE.&quot;);
  }
  {
    // update outer to universe
    const auto univ = CSGUniverse(&quot;univ&quot;, false);
    cart_lattice.updateOuter(univ);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(cart_lattice.getOuterUniverse(), univ);
    // try to get material outer - should raise error because type is UNIVERSE
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.getOuterMaterial(); },
                                   &quot;Lattice &#x27;cartlat&#x27; has UNIVERSE outer, not CSG_MATERIAL.&quot;);
  }
  {
    // change outer type to a material name
    cart_lattice.updateOuter(&quot;material&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(cart_lattice.getOuterMaterial(), &quot;material&quot;);
    // try to get universe outer - should raise error because type is CSG_MATERIAL
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.getOuterUniverse(); },
                                   &quot;Lattice &#x27;cartlat&#x27; has CSG_MATERIAL outer, not UNIVERSE.&quot;);
  }
  {
    // reset outer type - should change it back to VOID
    cart_lattice.resetOuter();
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;VOID&quot;);
  }
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="f3d6ad4f-409c-4e8a-be8a-660fb1feb787"><div class="modal-content"><h4>(moose/unit/src/CSGLatticeTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;
#include &quot;CSGUniverse.h&quot;
#include &quot;CSGCell.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGLattice class and derived classes
 */

/// tests valid CSGCartesianLattice construction
TEST(CSGLatticeTest, testCreateCartLatticeValid)
{
  // universe map and outer universe to use throughout tests
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1, univ1}, {univ1, univ1, univ1}};
  const auto outer_univ = CSGUniverse(&quot;outer_univ&quot;, false);
  {
    // initialize without universe map, outer is void, and pitch=1.0
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
    // check dimensions/attributes
    ASSERT_EQ(cart_lattice.getNRows(), 0);
    ASSERT_EQ(cart_lattice.getNCols(), 0);
    ASSERT_EQ(cart_lattice.getPitch(), 1.0);
    // expect no universe map to be present yet
    ASSERT_EQ(cart_lattice.getUniverses().size(), 0);
    // check other attributes
    ASSERT_TRUE(cart_lattice.getName() == &quot;cartlat&quot;);
    ASSERT_TRUE(cart_lattice.getType() == &quot;CSG::CSGCartesianLattice&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;VOID&quot;);
  }
  {
    // initialize with an array of universes, pitch=1.0
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
    // check dimensions/attributes
    ASSERT_EQ(cart_lattice.getNRows(), 2);
    ASSERT_EQ(cart_lattice.getNCols(), 3);
    ASSERT_EQ(cart_lattice.getPitch(), 1.0);
    // expect 2x3 array
    ASSERT_EQ(cart_lattice.getUniverses().size(), 2);
    ASSERT_EQ(cart_lattice.getUniverses()[0].size(), 3);
    ASSERT_EQ(cart_lattice.getUniverses()[1].size(), 3);
    // check other attributes
    ASSERT_TRUE(cart_lattice.getName() == &quot;cartlat&quot;);
    ASSERT_TRUE(cart_lattice.getType() == &quot;CSG::CSGCartesianLattice&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;VOID&quot;);
  }
  {
    // initialize without universe map but set outer universe
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, outer_univ);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(cart_lattice.getOuterUniverse(), outer_univ);
  }
  {
    // initialize with universe map and set outer fill to be a universe
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map, outer_univ);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(cart_lattice.getOuterUniverse(), outer_univ);
  }
  {
    // initialize without universe map but set outer to a material
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, &quot;outer_mat&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(cart_lattice.getOuterMaterial(), &quot;outer_mat&quot;);
  }
  {
    // initialize with universe map but set outer material
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map, &quot;outer_mat&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(cart_lattice.getOuterMaterial(), &quot;outer_mat&quot;);
  }
}

/// tests invalid CSGCartesianLattice construction
TEST(CSGLatticeTest, testCreateCartLatticeInvalid)
{
  {
    // try initialize with invalid dimension for pitch
    Moose::UnitUtils::assertThrows(
        []() { CSGCartesianLattice(&quot;cartlat&quot;, -1.0); },
        &quot;Lattice cartlat must have pitch greater than 0.&quot;); // invalid pitch
  }
  {
    // try to initialize with universe array of invalid dimensions (second row is different length)
    const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1}, {univ1, univ1}};
    std::string exp_msg = &quot;Cannot set lattice cartlat with universes. Does not have valid &quot;
                          &quot;dimensions for lattice type CSG::CSGCartesianLattice&quot;;
    Moose::UnitUtils::assertThrows([&amp;univ_map]() { CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map); },
                                   exp_msg);
  }
}

/// tests valid CSGHexagonalLattice construction
TEST(CSGLatticeTest, testCreateHexLatticeValid)
{
  // universe map and outer universe to use throughout tests
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1}};
  const auto outer_univ = CSGUniverse(&quot;outer_univ&quot;, false);
  {
    // initialize without universes: pitch=1.0
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0);
    // check dimensions and properties
    ASSERT_EQ(hex_lat.getNRows(), 0);
    ASSERT_EQ(hex_lat.getNRings(), 0);
    ASSERT_EQ(hex_lat.getPitch(), 1.0);
    ASSERT_EQ(hex_lat.getUniverses().size(), 0); // no universe map yet
    ASSERT_TRUE(hex_lat.getName() == &quot;hexlat&quot;);
    ASSERT_TRUE(hex_lat.getType() == &quot;CSG::CSGHexagonalLattice&quot;);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;VOID&quot;);
  }
  {
    // initialize with universe map, pitch=1.0
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map);
    ASSERT_EQ(hex_lat.getNRings(), 3);
    ASSERT_EQ(hex_lat.getPitch(), 1.0);
    ASSERT_EQ(hex_lat.getNRows(), 5); // should be 2*nring -1 (auto calculated)
    ASSERT_EQ(hex_lat.getUniverses().size(), 5);
    ASSERT_EQ(hex_lat.getUniverses()[0].size(), 3);
    ASSERT_EQ(hex_lat.getUniverses()[1].size(), 4);
    ASSERT_EQ(hex_lat.getUniverses()[2].size(), 5);
    ASSERT_EQ(hex_lat.getUniverses()[3].size(), 4);
    ASSERT_EQ(hex_lat.getUniverses()[4].size(), 3);
    ASSERT_TRUE(hex_lat.getName() == &quot;hexlat&quot;);
    ASSERT_TRUE(hex_lat.getType() == &quot;CSG::CSGHexagonalLattice&quot;);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;VOID&quot;);
  }
  {
    // initialize without universe map but set outer universe
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, outer_univ);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(hex_lat.getOuterUniverse(), outer_univ);
  }
  {
    // initialize with universe map but set outer universe
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map, outer_univ);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(hex_lat.getOuterUniverse(), outer_univ);
  }
  {
    // initialize without universe map but set outer material
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, &quot;outer_mat&quot;);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(hex_lat.getOuterMaterial(), &quot;outer_mat&quot;);
  }
  {
    // initialize with universe map but set outer material
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map, &quot;outer_mat&quot;);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(hex_lat.getOuterMaterial(), &quot;outer_mat&quot;);
  }
}

/// tests invalid CSGHexagonalLattice construction
TEST(CSGLatticeTest, testCreateHexLatticeInvalid)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  {
    // try initialize empty by providing invalid dimensions
    Moose::UnitUtils::assertThrows(
        []() { CSGHexagonalLattice(&quot;hexlat&quot;, -1.0); },
        &quot;Lattice hexlat must have pitch greater than 0.&quot;); // invalid pitch
  }
  {
    // create universe map with invalid dimensions (even number of rows)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1},
        {univ1, univ1, univ1, univ1},
        {univ1, univ1, univ1, univ1},
        {univ1, univ1, univ1}};
    std::string exp_msg = &quot;Cannot set lattice hexlat with universes. Does not have valid &quot;
                          &quot;dimensions for lattice type CSG::CSGHexagonalLattice&quot;;
    Moose::UnitUtils::assertThrows([&amp;univ_map]() { CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map); },
                                   exp_msg);
  }
  {
    // create universe map with invalid dimensions (one row has wrong number of elements)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1},
        {univ1, univ1, univ1, univ1},
        {univ1, univ1, univ1, univ1}, // should have 5 elements
        {univ1, univ1, univ1, univ1},
        {univ1, univ1, univ1}};
    std::string exp_msg = &quot;Cannot set lattice hexlat with universes. Does not have valid &quot;
                          &quot;dimensions for lattice type CSG::CSGHexagonalLattice&quot;;
    Moose::UnitUtils::assertThrows([&amp;univ_map]() { CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map); },
                                   exp_msg);
  }
}

/// tests getAttributes function for both CSGCartesianLattice and CSGHexagonalLattice
TEST(CSGLatticeTest, testGetAttributes)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  {
    // cartesian lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1}, {univ1, univ1, univ1}};
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
    auto dims_map = cart_lattice.getAttributes();
    ASSERT_EQ(std::get&lt;unsigned int&gt;(dims_map[&quot;nrow&quot;]), 2);
    ASSERT_EQ(std::get&lt;unsigned int&gt;(dims_map[&quot;ncol&quot;]), 3);
    ASSERT_EQ(std::get&lt;Real&gt;(dims_map[&quot;pitch&quot;]), 1.0);
  }
  {
    // hexagonal lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1}, {univ1, univ1, univ1}, {univ1, univ1}};
    auto hex_lattice = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map);
    auto dims_map = hex_lattice.getAttributes();
    ASSERT_EQ(std::get&lt;unsigned int&gt;(dims_map[&quot;nrow&quot;]), 3);
    ASSERT_EQ(std::get&lt;unsigned int&gt;(dims_map[&quot;nring&quot;]), 2); // should be (nrow + 1)/2
    ASSERT_EQ(std::get&lt;Real&gt;(dims_map[&quot;pitch&quot;]), 1.0);
  }
}

/// tests CSGCartesianLattice::setUniverses function
TEST(CSGLatticeTest, testCartSetUniverses)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  // create initial lattice without a map
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
  {
    // create universe map and set it on the initialized lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1}, {univ1, univ1, univ1}};
    ASSERT_NO_THROW(cart_lattice.setUniverses(univ_map));
    // should have 1x4 map after being set
    ASSERT_EQ(cart_lattice.getUniverses().size(), 2);
    ASSERT_EQ(cart_lattice.getUniverses()[0].size(), 3);
    ASSERT_EQ(cart_lattice.getUniverses()[1].size(), 3);
    // make sure dimensions were updated
    ASSERT_EQ(cart_lattice.getNRows(), 2);
    ASSERT_EQ(cart_lattice.getNCols(), 3);
  }
  {
    // overwrite w/ new universe map of different dimensions - valid
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univ_map = {
        {univ2, univ2, univ2, univ2}};
    ASSERT_NO_THROW(cart_lattice.setUniverses(new_univ_map));
    // expect map to contain all univ2
    for (auto univ_list : cart_lattice.getUniverses())
    {
      for (const CSGUniverse &amp; univ : univ_list)
        ASSERT_EQ(univ, univ2);
    }
    // should have 1x4 map after being set
    ASSERT_EQ(cart_lattice.getUniverses().size(), 1);
    ASSERT_EQ(cart_lattice.getUniverses()[0].size(), 4);
    // make sure dimensions were updated
    ASSERT_EQ(cart_lattice.getNRows(), 1);
    ASSERT_EQ(cart_lattice.getNCols(), 4);
  }
}

/// tests CSGHexagonalLattice::setUniverses function
TEST(CSGLatticeTest, testHexSetUniverses)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  // initial empty lattice
  auto lat = CSGHexagonalLattice(&quot;lat&quot;, 1.0);
  {
    // create universe map and then set it on the initialized lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1}, {univ1, univ1, univ1}, {univ1, univ1}};
    ASSERT_NO_THROW(lat.setUniverses(univ_map););
    // should have a 2-ring map (3 rows) after being set
    ASSERT_EQ(lat.getUniverses().size(), 3);
    ASSERT_EQ(lat.getUniverses()[0].size(), 2);
    ASSERT_EQ(lat.getUniverses()[1].size(), 3);
    ASSERT_EQ(lat.getUniverses()[2].size(), 2);
    // make sure dimensions were set
    ASSERT_EQ(lat.getNRows(), 3);
  }
  {
    // create new map with new dimensions and update lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univ_map = {
        {univ2, univ2, univ2},
        {univ2, univ2, univ2, univ2},
        {univ2, univ2, univ2, univ2, univ2},
        {univ2, univ2, univ2, univ2},
        {univ2, univ2, univ2}};
    lat.setUniverses(new_univ_map);
    // expect map to contain all univ2
    for (auto univ_list : lat.getUniverses())
    {
      for (const CSGUniverse &amp; univ : univ_list)
        ASSERT_EQ(univ, univ2);
    }
    // should have 3-ring (5 row) map after being set
    ASSERT_EQ(lat.getUniverses().size(), 5);
    ASSERT_EQ(lat.getUniverses()[0].size(), 3);
    ASSERT_EQ(lat.getUniverses()[1].size(), 4);
    ASSERT_EQ(lat.getUniverses()[2].size(), 5);
    ASSERT_EQ(lat.getUniverses()[3].size(), 4);
    ASSERT_EQ(lat.getUniverses()[4].size(), 3);
    // make sure dimensions were updated
    ASSERT_EQ(lat.getNRows(), 5);
  }
}

/// tests CSGLattice::getUniverseNameMap function
TEST(CSGLatticeTest, testGetUniverseNameMap)
{
  std::string name1 = &quot;pinky&quot;;
  std::string name2 = &quot;brain&quot;;
  const auto univ1 = CSGUniverse(name1, false);
  const auto univ2 = CSGUniverse(name2, false);
  // create cartesian lattice with 2x2 universe map
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {{univ1, univ2},
                                                                                  {univ2, univ1}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  auto name_map = cart_lattice.getUniverseNameMap();
  ASSERT_EQ(name_map.size(), 2);
  ASSERT_EQ(name_map[0].size(), 2);
  ASSERT_EQ(name_map[1].size(), 2);
  ASSERT_EQ(name_map[0][0], name1);
  ASSERT_EQ(name_map[0][1], name2);
  ASSERT_EQ(name_map[1][0], name2);
  ASSERT_EQ(name_map[1][1], name1);
}

/// tests CSGLattice::hasUniverse function
TEST(CSGLatticeTest, testHasUniverse)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {{univ1, univ2}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  // check for existing universes
  ASSERT_TRUE(cart_lattice.hasUniverse(&quot;univ1&quot;));
  ASSERT_TRUE(cart_lattice.hasUniverse(&quot;univ2&quot;));
  // check for non-existing universe
  ASSERT_FALSE(cart_lattice.hasUniverse(&quot;univ3&quot;));
}

/// tests CSGCartesianLattice::isValidIndex function
TEST(CSGLatticeTest, testCartIsValidIndex)
{
  // create initial lattice of all univ1 elements
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1, univ1}, {univ1, univ1, univ1}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  {
    // test valid index locations
    ASSERT_TRUE(cart_lattice.isValidIndex(std::make_pair(0, 0)));
    ASSERT_TRUE(cart_lattice.isValidIndex(std::make_pair(1, 2)));
  }
  {
    // test invalid index locations
    ASSERT_FALSE(cart_lattice.isValidIndex(std::make_pair(2, 0)));  // row out of bounds
    ASSERT_FALSE(cart_lattice.isValidIndex(std::make_pair(0, 3)));  // col out of bounds
    ASSERT_FALSE(cart_lattice.isValidIndex(std::make_pair(-1, 0))); // negative row
    ASSERT_FALSE(cart_lattice.isValidIndex(std::make_pair(0, -1))); // negative col
  }
}

/// tests CSGHexagonalLattice::isValidIndex function
TEST(CSGLatticeTest, testHexIsValidIndex)
{
  // create initial lattice of all univ1 elements
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1}, {univ1, univ1, univ1}, {univ1, univ1}};
  auto hex_lattice = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map);
  {
    // valid list of indices for 2-ring hex lattice:
    std::vector&lt;std::pair&lt;int, int&gt;&gt; valid_indices = {std::make_pair(0, 0),
                                                      std::make_pair(0, 1),
                                                      std::make_pair(1, 0),
                                                      std::make_pair(1, 1),
                                                      std::make_pair(1, 2),
                                                      std::make_pair(2, 0),
                                                      std::make_pair(2, 1)};
    // check that all valid indices return true
    for (const auto &amp; index : valid_indices)
      ASSERT_TRUE(hex_lattice.isValidIndex(index));
  }
  {
    // check invalid for each case is caught
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(0, 2)));  // col out of bounds (row 0)
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(1, 3)));  // col out of bounds (row 1)
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(3, 0)));  // row out of bounds
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(-1, 0))); // negative row
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(0, -1))); // negative col
  }
}

/// tests CSGCartesianLattice::setUniverseAtIndex function
TEST(CSGLatticeTest, testCartSetUniverseAtIndex)
{
  // create initial lattice of all univ1 elements
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1, univ1}, {univ1, univ1, univ1}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  // initial map should contain structure matching univ_map (all univ1)
  for (auto univ_list : cart_lattice.getUniverses())
  {
    for (const CSGUniverse &amp; univ : univ_list)
      ASSERT_EQ(univ, univ1);
  }
  {
    // replace element in universe map with another using setUniverseAtIndex (valid index location)
    cart_lattice.setUniverseAtIndex(univ2, std::make_pair(1, 2));
    auto univs = cart_lattice.getUniverses();
    for (auto i : index_range(univs))
    {
      for (auto j : index_range(univs[i]))
      {
        // all universes should be univ1 except (1, 2) location
        const CSGUniverse &amp; univ = univs[i][j];
        if (i == 1 &amp;&amp; j == 2)
          ASSERT_EQ(univ, univ2);
        else
          ASSERT_EQ(univ, univ1);
      }
    }
  }
  {
    // try replacing element at an invalid index - should raise error
    Moose::UnitUtils::assertThrows(
        [&amp;cart_lattice, &amp;univ2]() { cart_lattice.setUniverseAtIndex(univ2, std::make_pair(3, 3)); },
        &quot;Cannot set universe at location (3, 3) for lattice cartlat. Not a valid location.&quot;);
  }
  {
    // create a lattice without any map initialized yet and try setting just one element
    // should raise error about map not being initialized yet
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
    Moose::UnitUtils::assertThrows(
        [&amp;cart_lattice, &amp;univ2]() { cart_lattice.setUniverseAtIndex(univ2, std::make_pair(0, 0)); },
        &quot;Cannot set universe at location (0, 0) for lattice cartlat. &quot;
        &quot;Universe map has not been initialized.&quot;);
  }
}

/// tests CSGCartesianLattice different methods for retrieving universes or locations of universes
TEST(CSGLatticeTest, testGetMethods)
{
  // test get all and get by name (valid and invalid) and get at index (valid and invalid)
  // create initial lattice of all univ1 elements
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ2, univ1}, {univ2, univ1, univ2}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  {
    // get universe indices by name - valid name
    auto loc_list = cart_lattice.getUniverseIndices(&quot;univ1&quot;);
    std::vector&lt;std::pair&lt;unsigned int, unsigned int&gt;&gt; exp_locs = {
        std::make_pair(0, 0), std::make_pair(0, 2), std::make_pair(1, 1)};
    ASSERT_EQ(loc_list, exp_locs);
  }
  {
    // get universe indices by name - invalid name; should raise error
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]()
                                   { cart_lattice.getUniverseIndices(&quot;fake_name&quot;); },
                                   &quot;Universe fake_name does not exist in lattice&quot;);
  }
  {
    // get universe at index - valid index
    const CSGUniverse &amp; retr_univ = cart_lattice.getUniverseAtIndex(std::make_pair(0, 1));
    ASSERT_EQ(retr_univ, univ2);
  }
  {
    // get universe at index - invalid index; should raise error
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]()
                                   { cart_lattice.getUniverseAtIndex(std::make_pair(3, 3)); },
                                   &quot;Index (3, 3) is not a valid index for lattice &quot;);
  }
}

/// test setName functionality
TEST(CSGLatticeTest, testSetName)
{
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
  cart_lattice.setName(&quot;new_name&quot;);
  ASSERT_EQ(cart_lattice.getName(), &quot;new_name&quot;);
}

/// test the == and != overloaded operators for cartesian lattices
TEST(CSGLatticeTest, testCartLatticeEquality)
{
  // universe maps to use for different lattice comparisons
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  const auto out1 = CSGUniverse(&quot;outer1&quot;, false);
  const auto out2 = CSGUniverse(&quot;outer2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map1 = {{univ1, univ1},
                                                                                   {univ1, univ1}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map2 = {{univ2, univ2},
                                                                                   {univ2, univ2}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map3 = {{univ1, univ1}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map4 = {{univ1},
                                                                                   {univ1}};
  // identical lattices
  auto l1 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  auto l2 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  // lattice that differs by name only
  auto l3 = CSGCartesianLattice(&quot;cartlat1&quot;, 1.0, univ_map1);
  // lattice that differs by universe map items
  auto l4 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map2);
  // lattice that differs by pitch
  auto l5 = CSGCartesianLattice(&quot;cartlat&quot;, 2.0, univ_map1);
  // lattice that differs by nrow
  auto l6 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map3);
  // lattice that differs by ncol
  auto l7 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map4);
  // differs by outer type - material outer
  auto l8 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  l8.updateOuter(&quot;outer1&quot;);
  // differs by outer type - universe outer
  auto l9 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  l9.updateOuter(out1);
  // differs by outer object - universe outer
  auto l10 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  l10.updateOuter(out2);
  // differs by outer name - material outer
  auto l11 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  l11.updateOuter(&quot;outer2&quot;);

  // check equality
  {
    ASSERT_TRUE(l1 == l2);
  }
  // check inequality
  {
    // all lattices 2-7 should differ from each other in some way
    std::vector&lt;CSGCartesianLattice&gt; diff_compare = {l2, l3, l4, l5, l6, l7, l8, l9, l10, l11};
    for (std::size_t i = 0; i &lt; diff_compare.size(); i++)
    {
      for (std::size_t j = i + 1; j &lt; diff_compare.size(); ++j)
        ASSERT_TRUE(diff_compare[i] != diff_compare[j]);
    }
  }
}

/// test the == and != overloaded operators for hexagonal lattices
TEST(CSGLatticeTest, testHexLatticeEquality)
{
  // universe maps to use for different lattice comparisons
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map1 = {
      {univ1, univ1}, {univ1, univ1, univ1}, {univ1, univ1}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map2 = {
      {univ2, univ2}, {univ2, univ2, univ2}, {univ2, univ2}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map3 = {
      {univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1}};
  // identical lattices
  auto l1 = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map1);
  auto l2 = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map1);
  // lattice that differs by name only
  auto l3 = CSGHexagonalLattice(&quot;hexlat1&quot;, 1.0, univ_map1);
  // lattice that differs by universe map items
  auto l4 = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map2);
  // lattice that differs by pitch
  auto l5 = CSGHexagonalLattice(&quot;hexlat&quot;, 2.0, univ_map1);
  // lattice that differs by nrow/rings
  auto l6 = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map3);

  // check equality
  {
    ASSERT_TRUE(l1 == l2);
  }
  // check inequality
  {
    // all lattices 2-6 should differ from each other in some way
    std::vector&lt;CSGHexagonalLattice&gt; diff_compare = {l2, l3, l4, l5, l6};
    for (std::size_t i = 0; i &lt; diff_compare.size(); i++)
    {
      for (std::size_t j = i + 1; j &lt; diff_compare.size(); ++j)
        ASSERT_TRUE(diff_compare[i] != diff_compare[j]);
    }
  }
}

/// test CSGLattice::getUniqueUniverses
TEST(CSGLatticeTest, testGetUniqueUniverses)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {{univ1, univ1},
                                                                                  {univ2, univ1}};
  auto lat = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  auto unique = lat.getUniqueUniverses();
  ASSERT_EQ(unique.size(), 2);
  ASSERT_EQ(unique[0].get(), univ1);
  ASSERT_EQ(unique[1].get(), univ2);
}

/// test CSG[Cartesian/Hexagonal]Lattice::setPitch
TEST(CSGLatticeTest, testSetPitch)
{
  {
    // cartesian lattice set pitch
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
    // set valid pitch
    cart_lattice.setPitch(2.5);
    ASSERT_EQ(cart_lattice.getPitch(), 2.5);
    // try to set invalid pitch (raise error)
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.setPitch(-0.5); },
                                   &quot;must have pitch greater than 0.&quot;);
  }
  {
    // hexagonal lattice set pitch
    auto hex_lat = CSGHexagonalLattice(&quot;hex_lat&quot;, 1.0);
    // set valid pitch
    hex_lat.setPitch(2.5);
    ASSERT_EQ(hex_lat.getPitch(), 2.5);
    // try to set invalid pitch (raise error)
    Moose::UnitUtils::assertThrows([&amp;hex_lat]() { hex_lat.setPitch(-0.5); },
                                   &quot;must have pitch greater than 0.&quot;);
  }
}

/// test CSGHexagonalLattice::get[Ring/Row]IndexFrom[Row/Ring]Index
TEST(CSGLatticeTest, testHexConvertRowsRings)
{
  // test that conversion between ring and row form works on 2-, 3-, and 4-ring hex lattices
  const auto u = CSGUniverse(&quot;u&quot;, false);
  {
    // 2-ring lattice case
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; umap = {
        {u, u}, {u, u, u}, {u, u}};
    auto lat = CSGHexagonalLattice(&quot;lat&quot;, 1.0, umap);
    std::map&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt;&gt; exp_row_to_ring = {{{0, 0}, {0, 4}},
                                                                          {{0, 1}, {0, 5}},
                                                                          {{1, 0}, {0, 3}},
                                                                          {{1, 1}, {1, 0}},
                                                                          {{1, 2}, {0, 0}},
                                                                          {{2, 0}, {0, 2}},
                                                                          {{2, 1}, {0, 1}}};
    for (const auto &amp; pair : exp_row_to_ring)
    {
      auto row_pair = lat.getRowIndexFromRingIndex(pair.second);
      ASSERT_EQ(row_pair, pair.first);
      auto ring_pair = lat.getRingIndexFromRowIndex(pair.first);
      ASSERT_EQ(ring_pair, pair.second);
    }
    // check that invalid ring index raises error
    Moose::UnitUtils::assertThrows([&amp;lat]() { lat.getRowIndexFromRingIndex(std::make_pair(2, 0)); },
                                   &quot;Ring 2 is not valid for hexagonal lattice lat&quot;);
    Moose::UnitUtils::assertThrows([&amp;lat]() { lat.getRowIndexFromRingIndex(std::make_pair(1, 7)); },
                                   &quot;Position 7 is not valid for ring 1 in hexagonal lattice lat&quot;);
    // check that invalid row-column index raises error
    Moose::UnitUtils::assertThrows([&amp;lat]() { lat.getRingIndexFromRowIndex(std::make_pair(3, 0)); },
                                   &quot;Index (3, 0) is not a valid index for hexagonal lattice lat&quot;);
  }
  {
    // 3-ring case
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; umap = {
        {u, u, u}, {u, u, u, u}, {u, u, u, u, u}, {u, u, u, u}, {u, u, u}};
    auto lat = CSGHexagonalLattice(&quot;lat&quot;, 1.0, umap);
    std::map&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt;&gt; exp_row_to_ring = {{{0, 0}, {0, 8}},
                                                                          {{0, 1}, {0, 9}},
                                                                          {{0, 2}, {0, 10}},
                                                                          {{1, 0}, {0, 7}},
                                                                          {{1, 1}, {1, 4}},
                                                                          {{1, 2}, {1, 5}},
                                                                          {{1, 3}, {0, 11}},
                                                                          {{2, 0}, {0, 6}},
                                                                          {{2, 1}, {1, 3}},
                                                                          {{2, 2}, {2, 0}},
                                                                          {{2, 3}, {1, 0}},
                                                                          {{2, 4}, {0, 0}},
                                                                          {{3, 0}, {0, 5}},
                                                                          {{3, 1}, {1, 2}},
                                                                          {{3, 2}, {1, 1}},
                                                                          {{3, 3}, {0, 1}},
                                                                          {{4, 0}, {0, 4}},
                                                                          {{4, 1}, {0, 3}},
                                                                          {{4, 2}, {0, 2}}};
    for (const auto &amp; pair : exp_row_to_ring)
    {
      auto row_pair = lat.getRowIndexFromRingIndex(pair.second);
      ASSERT_EQ(row_pair, pair.first);
      auto ring_pair = lat.getRingIndexFromRowIndex(pair.first);
      ASSERT_EQ(ring_pair, pair.second);
    }
  }
  {
    // 4-ring case
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; umap = {
        {u, u, u, u},
        {u, u, u, u, u},
        {u, u, u, u, u, u},
        {u, u, u, u, u, u, u},
        {u, u, u, u, u, u},
        {u, u, u, u, u},
        {u, u, u, u}};
    auto lat = CSGHexagonalLattice(&quot;lat&quot;, 1.0, umap);
    std::map&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt;&gt; exp_row_to_ring = {
        {{0, 0}, {0, 12}}, {{0, 1}, {0, 13}}, {{0, 2}, {0, 14}}, {{0, 3}, {0, 15}},
        {{1, 0}, {0, 11}}, {{1, 1}, {1, 8}},  {{1, 2}, {1, 9}},  {{1, 3}, {1, 10}},
        {{1, 4}, {0, 16}}, {{2, 0}, {0, 10}}, {{2, 1}, {1, 7}},  {{2, 2}, {2, 4}},
        {{2, 3}, {2, 5}},  {{2, 4}, {1, 11}}, {{2, 5}, {0, 17}}, {{3, 0}, {0, 9}},
        {{3, 1}, {1, 6}},  {{3, 2}, {2, 3}},  {{3, 3}, {3, 0}},  {{3, 4}, {2, 0}},
        {{3, 5}, {1, 0}},  {{3, 6}, {0, 0}},  {{4, 0}, {0, 8}},  {{4, 1}, {1, 5}},
        {{4, 2}, {2, 2}},  {{4, 3}, {2, 1}},  {{4, 4}, {1, 1}},  {{4, 5}, {0, 1}},
        {{5, 0}, {0, 7}},  {{5, 1}, {1, 4}},  {{5, 2}, {1, 3}},  {{5, 3}, {1, 2}},
        {{5, 4}, {0, 2}},  {{6, 0}, {0, 6}},  {{6, 1}, {0, 5}},  {{6, 2}, {0, 4}},
        {{6, 3}, {0, 3}}};
    for (const auto &amp; pair : exp_row_to_ring)
    {
      auto row_pair = lat.getRowIndexFromRingIndex(pair.second);
      ASSERT_EQ(row_pair, pair.first);
      auto ring_pair = lat.getRingIndexFromRowIndex(pair.first);
      ASSERT_EQ(ring_pair, pair.second);
    }
  }
}

/// tests that a lattice initialized without a universe map can be filled later even after it is used to fill a cell
TEST(CSGLatticeTest, testEmptyToFilled)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  {
    // create lattice without any universes
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
    // create cell and fill with the empty lattice
    auto cell = CSGCell(&quot;cell1&quot;, &amp;cart_lattice, CSG::CSGRegion());
    // now create universe map and set it on the lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {{univ1, univ1},
                                                                                    {univ1, univ1}};
    ASSERT_NO_THROW(cart_lattice.setUniverses(univ_map));
    // verify that the lattice in the cell has the correct universe map now
    const auto &amp; lat_in_cell = cell.getFillLattice();
    ASSERT_EQ(lat_in_cell.getUniverses().size(), 2);
    ASSERT_EQ(lat_in_cell.getUniverses()[0].size(), 2);
  }
}

TEST(CSGLatticeTest, testUpdateOuter)
{
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
  {
    // check outer universe type is set to VOID by default
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;VOID&quot;);
    // make sure trying to get material or universe outer raises error
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.getOuterMaterial(); },
                                   &quot;Lattice &#x27;cartlat&#x27; has VOID outer, not CSG_MATERIAL.&quot;);
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.getOuterUniverse(); },
                                   &quot;Lattice &#x27;cartlat&#x27; has VOID outer, not UNIVERSE.&quot;);
  }
  {
    // update outer to universe
    const auto univ = CSGUniverse(&quot;univ&quot;, false);
    cart_lattice.updateOuter(univ);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(cart_lattice.getOuterUniverse(), univ);
    // try to get material outer - should raise error because type is UNIVERSE
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.getOuterMaterial(); },
                                   &quot;Lattice &#x27;cartlat&#x27; has UNIVERSE outer, not CSG_MATERIAL.&quot;);
  }
  {
    // change outer type to a material name
    cart_lattice.updateOuter(&quot;material&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(cart_lattice.getOuterMaterial(), &quot;material&quot;);
    // try to get universe outer - should raise error because type is CSG_MATERIAL
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.getOuterUniverse(); },
                                   &quot;Lattice &#x27;cartlat&#x27; has CSG_MATERIAL outer, not UNIVERSE.&quot;);
  }
  {
    // reset outer type - should change it back to VOID
    cart_lattice.resetOuter();
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;VOID&quot;);
  }
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="afbe356e-2b79-41d8-928f-6cffc657be9a"><div class="modal-content"><h4>(moose/unit/src/CSGLatticeTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;
#include &quot;CSGUniverse.h&quot;
#include &quot;CSGCell.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGLattice class and derived classes
 */

/// tests valid CSGCartesianLattice construction
TEST(CSGLatticeTest, testCreateCartLatticeValid)
{
  // universe map and outer universe to use throughout tests
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1, univ1}, {univ1, univ1, univ1}};
  const auto outer_univ = CSGUniverse(&quot;outer_univ&quot;, false);
  {
    // initialize without universe map, outer is void, and pitch=1.0
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
    // check dimensions/attributes
    ASSERT_EQ(cart_lattice.getNRows(), 0);
    ASSERT_EQ(cart_lattice.getNCols(), 0);
    ASSERT_EQ(cart_lattice.getPitch(), 1.0);
    // expect no universe map to be present yet
    ASSERT_EQ(cart_lattice.getUniverses().size(), 0);
    // check other attributes
    ASSERT_TRUE(cart_lattice.getName() == &quot;cartlat&quot;);
    ASSERT_TRUE(cart_lattice.getType() == &quot;CSG::CSGCartesianLattice&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;VOID&quot;);
  }
  {
    // initialize with an array of universes, pitch=1.0
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
    // check dimensions/attributes
    ASSERT_EQ(cart_lattice.getNRows(), 2);
    ASSERT_EQ(cart_lattice.getNCols(), 3);
    ASSERT_EQ(cart_lattice.getPitch(), 1.0);
    // expect 2x3 array
    ASSERT_EQ(cart_lattice.getUniverses().size(), 2);
    ASSERT_EQ(cart_lattice.getUniverses()[0].size(), 3);
    ASSERT_EQ(cart_lattice.getUniverses()[1].size(), 3);
    // check other attributes
    ASSERT_TRUE(cart_lattice.getName() == &quot;cartlat&quot;);
    ASSERT_TRUE(cart_lattice.getType() == &quot;CSG::CSGCartesianLattice&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;VOID&quot;);
  }
  {
    // initialize without universe map but set outer universe
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, outer_univ);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(cart_lattice.getOuterUniverse(), outer_univ);
  }
  {
    // initialize with universe map and set outer fill to be a universe
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map, outer_univ);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(cart_lattice.getOuterUniverse(), outer_univ);
  }
  {
    // initialize without universe map but set outer to a material
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, &quot;outer_mat&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(cart_lattice.getOuterMaterial(), &quot;outer_mat&quot;);
  }
  {
    // initialize with universe map but set outer material
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map, &quot;outer_mat&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(cart_lattice.getOuterMaterial(), &quot;outer_mat&quot;);
  }
}

/// tests invalid CSGCartesianLattice construction
TEST(CSGLatticeTest, testCreateCartLatticeInvalid)
{
  {
    // try initialize with invalid dimension for pitch
    Moose::UnitUtils::assertThrows(
        []() { CSGCartesianLattice(&quot;cartlat&quot;, -1.0); },
        &quot;Lattice cartlat must have pitch greater than 0.&quot;); // invalid pitch
  }
  {
    // try to initialize with universe array of invalid dimensions (second row is different length)
    const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1}, {univ1, univ1}};
    std::string exp_msg = &quot;Cannot set lattice cartlat with universes. Does not have valid &quot;
                          &quot;dimensions for lattice type CSG::CSGCartesianLattice&quot;;
    Moose::UnitUtils::assertThrows([&amp;univ_map]() { CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map); },
                                   exp_msg);
  }
}

/// tests valid CSGHexagonalLattice construction
TEST(CSGLatticeTest, testCreateHexLatticeValid)
{
  // universe map and outer universe to use throughout tests
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1}};
  const auto outer_univ = CSGUniverse(&quot;outer_univ&quot;, false);
  {
    // initialize without universes: pitch=1.0
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0);
    // check dimensions and properties
    ASSERT_EQ(hex_lat.getNRows(), 0);
    ASSERT_EQ(hex_lat.getNRings(), 0);
    ASSERT_EQ(hex_lat.getPitch(), 1.0);
    ASSERT_EQ(hex_lat.getUniverses().size(), 0); // no universe map yet
    ASSERT_TRUE(hex_lat.getName() == &quot;hexlat&quot;);
    ASSERT_TRUE(hex_lat.getType() == &quot;CSG::CSGHexagonalLattice&quot;);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;VOID&quot;);
  }
  {
    // initialize with universe map, pitch=1.0
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map);
    ASSERT_EQ(hex_lat.getNRings(), 3);
    ASSERT_EQ(hex_lat.getPitch(), 1.0);
    ASSERT_EQ(hex_lat.getNRows(), 5); // should be 2*nring -1 (auto calculated)
    ASSERT_EQ(hex_lat.getUniverses().size(), 5);
    ASSERT_EQ(hex_lat.getUniverses()[0].size(), 3);
    ASSERT_EQ(hex_lat.getUniverses()[1].size(), 4);
    ASSERT_EQ(hex_lat.getUniverses()[2].size(), 5);
    ASSERT_EQ(hex_lat.getUniverses()[3].size(), 4);
    ASSERT_EQ(hex_lat.getUniverses()[4].size(), 3);
    ASSERT_TRUE(hex_lat.getName() == &quot;hexlat&quot;);
    ASSERT_TRUE(hex_lat.getType() == &quot;CSG::CSGHexagonalLattice&quot;);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;VOID&quot;);
  }
  {
    // initialize without universe map but set outer universe
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, outer_univ);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(hex_lat.getOuterUniverse(), outer_univ);
  }
  {
    // initialize with universe map but set outer universe
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map, outer_univ);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(hex_lat.getOuterUniverse(), outer_univ);
  }
  {
    // initialize without universe map but set outer material
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, &quot;outer_mat&quot;);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(hex_lat.getOuterMaterial(), &quot;outer_mat&quot;);
  }
  {
    // initialize with universe map but set outer material
    auto hex_lat = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map, &quot;outer_mat&quot;);
    ASSERT_EQ(hex_lat.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(hex_lat.getOuterMaterial(), &quot;outer_mat&quot;);
  }
}

/// tests invalid CSGHexagonalLattice construction
TEST(CSGLatticeTest, testCreateHexLatticeInvalid)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  {
    // try initialize empty by providing invalid dimensions
    Moose::UnitUtils::assertThrows(
        []() { CSGHexagonalLattice(&quot;hexlat&quot;, -1.0); },
        &quot;Lattice hexlat must have pitch greater than 0.&quot;); // invalid pitch
  }
  {
    // create universe map with invalid dimensions (even number of rows)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1},
        {univ1, univ1, univ1, univ1},
        {univ1, univ1, univ1, univ1},
        {univ1, univ1, univ1}};
    std::string exp_msg = &quot;Cannot set lattice hexlat with universes. Does not have valid &quot;
                          &quot;dimensions for lattice type CSG::CSGHexagonalLattice&quot;;
    Moose::UnitUtils::assertThrows([&amp;univ_map]() { CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map); },
                                   exp_msg);
  }
  {
    // create universe map with invalid dimensions (one row has wrong number of elements)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1},
        {univ1, univ1, univ1, univ1},
        {univ1, univ1, univ1, univ1}, // should have 5 elements
        {univ1, univ1, univ1, univ1},
        {univ1, univ1, univ1}};
    std::string exp_msg = &quot;Cannot set lattice hexlat with universes. Does not have valid &quot;
                          &quot;dimensions for lattice type CSG::CSGHexagonalLattice&quot;;
    Moose::UnitUtils::assertThrows([&amp;univ_map]() { CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map); },
                                   exp_msg);
  }
}

/// tests getAttributes function for both CSGCartesianLattice and CSGHexagonalLattice
TEST(CSGLatticeTest, testGetAttributes)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  {
    // cartesian lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1}, {univ1, univ1, univ1}};
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
    auto dims_map = cart_lattice.getAttributes();
    ASSERT_EQ(std::get&lt;unsigned int&gt;(dims_map[&quot;nrow&quot;]), 2);
    ASSERT_EQ(std::get&lt;unsigned int&gt;(dims_map[&quot;ncol&quot;]), 3);
    ASSERT_EQ(std::get&lt;Real&gt;(dims_map[&quot;pitch&quot;]), 1.0);
  }
  {
    // hexagonal lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1}, {univ1, univ1, univ1}, {univ1, univ1}};
    auto hex_lattice = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map);
    auto dims_map = hex_lattice.getAttributes();
    ASSERT_EQ(std::get&lt;unsigned int&gt;(dims_map[&quot;nrow&quot;]), 3);
    ASSERT_EQ(std::get&lt;unsigned int&gt;(dims_map[&quot;nring&quot;]), 2); // should be (nrow + 1)/2
    ASSERT_EQ(std::get&lt;Real&gt;(dims_map[&quot;pitch&quot;]), 1.0);
  }
}

/// tests CSGCartesianLattice::setUniverses function
TEST(CSGLatticeTest, testCartSetUniverses)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  // create initial lattice without a map
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
  {
    // create universe map and set it on the initialized lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1, univ1}, {univ1, univ1, univ1}};
    ASSERT_NO_THROW(cart_lattice.setUniverses(univ_map));
    // should have 1x4 map after being set
    ASSERT_EQ(cart_lattice.getUniverses().size(), 2);
    ASSERT_EQ(cart_lattice.getUniverses()[0].size(), 3);
    ASSERT_EQ(cart_lattice.getUniverses()[1].size(), 3);
    // make sure dimensions were updated
    ASSERT_EQ(cart_lattice.getNRows(), 2);
    ASSERT_EQ(cart_lattice.getNCols(), 3);
  }
  {
    // overwrite w/ new universe map of different dimensions - valid
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univ_map = {
        {univ2, univ2, univ2, univ2}};
    ASSERT_NO_THROW(cart_lattice.setUniverses(new_univ_map));
    // expect map to contain all univ2
    for (auto univ_list : cart_lattice.getUniverses())
    {
      for (const CSGUniverse &amp; univ : univ_list)
        ASSERT_EQ(univ, univ2);
    }
    // should have 1x4 map after being set
    ASSERT_EQ(cart_lattice.getUniverses().size(), 1);
    ASSERT_EQ(cart_lattice.getUniverses()[0].size(), 4);
    // make sure dimensions were updated
    ASSERT_EQ(cart_lattice.getNRows(), 1);
    ASSERT_EQ(cart_lattice.getNCols(), 4);
  }
}

/// tests CSGHexagonalLattice::setUniverses function
TEST(CSGLatticeTest, testHexSetUniverses)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  // initial empty lattice
  auto lat = CSGHexagonalLattice(&quot;lat&quot;, 1.0);
  {
    // create universe map and then set it on the initialized lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
        {univ1, univ1}, {univ1, univ1, univ1}, {univ1, univ1}};
    ASSERT_NO_THROW(lat.setUniverses(univ_map););
    // should have a 2-ring map (3 rows) after being set
    ASSERT_EQ(lat.getUniverses().size(), 3);
    ASSERT_EQ(lat.getUniverses()[0].size(), 2);
    ASSERT_EQ(lat.getUniverses()[1].size(), 3);
    ASSERT_EQ(lat.getUniverses()[2].size(), 2);
    // make sure dimensions were set
    ASSERT_EQ(lat.getNRows(), 3);
  }
  {
    // create new map with new dimensions and update lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univ_map = {
        {univ2, univ2, univ2},
        {univ2, univ2, univ2, univ2},
        {univ2, univ2, univ2, univ2, univ2},
        {univ2, univ2, univ2, univ2},
        {univ2, univ2, univ2}};
    lat.setUniverses(new_univ_map);
    // expect map to contain all univ2
    for (auto univ_list : lat.getUniverses())
    {
      for (const CSGUniverse &amp; univ : univ_list)
        ASSERT_EQ(univ, univ2);
    }
    // should have 3-ring (5 row) map after being set
    ASSERT_EQ(lat.getUniverses().size(), 5);
    ASSERT_EQ(lat.getUniverses()[0].size(), 3);
    ASSERT_EQ(lat.getUniverses()[1].size(), 4);
    ASSERT_EQ(lat.getUniverses()[2].size(), 5);
    ASSERT_EQ(lat.getUniverses()[3].size(), 4);
    ASSERT_EQ(lat.getUniverses()[4].size(), 3);
    // make sure dimensions were updated
    ASSERT_EQ(lat.getNRows(), 5);
  }
}

/// tests CSGLattice::getUniverseNameMap function
TEST(CSGLatticeTest, testGetUniverseNameMap)
{
  std::string name1 = &quot;pinky&quot;;
  std::string name2 = &quot;brain&quot;;
  const auto univ1 = CSGUniverse(name1, false);
  const auto univ2 = CSGUniverse(name2, false);
  // create cartesian lattice with 2x2 universe map
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {{univ1, univ2},
                                                                                  {univ2, univ1}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  auto name_map = cart_lattice.getUniverseNameMap();
  ASSERT_EQ(name_map.size(), 2);
  ASSERT_EQ(name_map[0].size(), 2);
  ASSERT_EQ(name_map[1].size(), 2);
  ASSERT_EQ(name_map[0][0], name1);
  ASSERT_EQ(name_map[0][1], name2);
  ASSERT_EQ(name_map[1][0], name2);
  ASSERT_EQ(name_map[1][1], name1);
}

/// tests CSGLattice::hasUniverse function
TEST(CSGLatticeTest, testHasUniverse)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {{univ1, univ2}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  // check for existing universes
  ASSERT_TRUE(cart_lattice.hasUniverse(&quot;univ1&quot;));
  ASSERT_TRUE(cart_lattice.hasUniverse(&quot;univ2&quot;));
  // check for non-existing universe
  ASSERT_FALSE(cart_lattice.hasUniverse(&quot;univ3&quot;));
}

/// tests CSGCartesianLattice::isValidIndex function
TEST(CSGLatticeTest, testCartIsValidIndex)
{
  // create initial lattice of all univ1 elements
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1, univ1}, {univ1, univ1, univ1}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  {
    // test valid index locations
    ASSERT_TRUE(cart_lattice.isValidIndex(std::make_pair(0, 0)));
    ASSERT_TRUE(cart_lattice.isValidIndex(std::make_pair(1, 2)));
  }
  {
    // test invalid index locations
    ASSERT_FALSE(cart_lattice.isValidIndex(std::make_pair(2, 0)));  // row out of bounds
    ASSERT_FALSE(cart_lattice.isValidIndex(std::make_pair(0, 3)));  // col out of bounds
    ASSERT_FALSE(cart_lattice.isValidIndex(std::make_pair(-1, 0))); // negative row
    ASSERT_FALSE(cart_lattice.isValidIndex(std::make_pair(0, -1))); // negative col
  }
}

/// tests CSGHexagonalLattice::isValidIndex function
TEST(CSGLatticeTest, testHexIsValidIndex)
{
  // create initial lattice of all univ1 elements
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1}, {univ1, univ1, univ1}, {univ1, univ1}};
  auto hex_lattice = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map);
  {
    // valid list of indices for 2-ring hex lattice:
    std::vector&lt;std::pair&lt;int, int&gt;&gt; valid_indices = {std::make_pair(0, 0),
                                                      std::make_pair(0, 1),
                                                      std::make_pair(1, 0),
                                                      std::make_pair(1, 1),
                                                      std::make_pair(1, 2),
                                                      std::make_pair(2, 0),
                                                      std::make_pair(2, 1)};
    // check that all valid indices return true
    for (const auto &amp; index : valid_indices)
      ASSERT_TRUE(hex_lattice.isValidIndex(index));
  }
  {
    // check invalid for each case is caught
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(0, 2)));  // col out of bounds (row 0)
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(1, 3)));  // col out of bounds (row 1)
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(3, 0)));  // row out of bounds
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(-1, 0))); // negative row
    ASSERT_FALSE(hex_lattice.isValidIndex(std::make_pair(0, -1))); // negative col
  }
}

/// tests CSGCartesianLattice::setUniverseAtIndex function
TEST(CSGLatticeTest, testCartSetUniverseAtIndex)
{
  // create initial lattice of all univ1 elements
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ1, univ1}, {univ1, univ1, univ1}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  // initial map should contain structure matching univ_map (all univ1)
  for (auto univ_list : cart_lattice.getUniverses())
  {
    for (const CSGUniverse &amp; univ : univ_list)
      ASSERT_EQ(univ, univ1);
  }
  {
    // replace element in universe map with another using setUniverseAtIndex (valid index location)
    cart_lattice.setUniverseAtIndex(univ2, std::make_pair(1, 2));
    auto univs = cart_lattice.getUniverses();
    for (auto i : index_range(univs))
    {
      for (auto j : index_range(univs[i]))
      {
        // all universes should be univ1 except (1, 2) location
        const CSGUniverse &amp; univ = univs[i][j];
        if (i == 1 &amp;&amp; j == 2)
          ASSERT_EQ(univ, univ2);
        else
          ASSERT_EQ(univ, univ1);
      }
    }
  }
  {
    // try replacing element at an invalid index - should raise error
    Moose::UnitUtils::assertThrows(
        [&amp;cart_lattice, &amp;univ2]() { cart_lattice.setUniverseAtIndex(univ2, std::make_pair(3, 3)); },
        &quot;Cannot set universe at location (3, 3) for lattice cartlat. Not a valid location.&quot;);
  }
  {
    // create a lattice without any map initialized yet and try setting just one element
    // should raise error about map not being initialized yet
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
    Moose::UnitUtils::assertThrows(
        [&amp;cart_lattice, &amp;univ2]() { cart_lattice.setUniverseAtIndex(univ2, std::make_pair(0, 0)); },
        &quot;Cannot set universe at location (0, 0) for lattice cartlat. &quot;
        &quot;Universe map has not been initialized.&quot;);
  }
}

/// tests CSGCartesianLattice different methods for retrieving universes or locations of universes
TEST(CSGLatticeTest, testGetMethods)
{
  // test get all and get by name (valid and invalid) and get at index (valid and invalid)
  // create initial lattice of all univ1 elements
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {
      {univ1, univ2, univ1}, {univ2, univ1, univ2}};
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  {
    // get universe indices by name - valid name
    auto loc_list = cart_lattice.getUniverseIndices(&quot;univ1&quot;);
    std::vector&lt;std::pair&lt;unsigned int, unsigned int&gt;&gt; exp_locs = {
        std::make_pair(0, 0), std::make_pair(0, 2), std::make_pair(1, 1)};
    ASSERT_EQ(loc_list, exp_locs);
  }
  {
    // get universe indices by name - invalid name; should raise error
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]()
                                   { cart_lattice.getUniverseIndices(&quot;fake_name&quot;); },
                                   &quot;Universe fake_name does not exist in lattice&quot;);
  }
  {
    // get universe at index - valid index
    const CSGUniverse &amp; retr_univ = cart_lattice.getUniverseAtIndex(std::make_pair(0, 1));
    ASSERT_EQ(retr_univ, univ2);
  }
  {
    // get universe at index - invalid index; should raise error
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]()
                                   { cart_lattice.getUniverseAtIndex(std::make_pair(3, 3)); },
                                   &quot;Index (3, 3) is not a valid index for lattice &quot;);
  }
}

/// test setName functionality
TEST(CSGLatticeTest, testSetName)
{
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
  cart_lattice.setName(&quot;new_name&quot;);
  ASSERT_EQ(cart_lattice.getName(), &quot;new_name&quot;);
}

/// test the == and != overloaded operators for cartesian lattices
TEST(CSGLatticeTest, testCartLatticeEquality)
{
  // universe maps to use for different lattice comparisons
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  const auto out1 = CSGUniverse(&quot;outer1&quot;, false);
  const auto out2 = CSGUniverse(&quot;outer2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map1 = {{univ1, univ1},
                                                                                   {univ1, univ1}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map2 = {{univ2, univ2},
                                                                                   {univ2, univ2}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map3 = {{univ1, univ1}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map4 = {{univ1},
                                                                                   {univ1}};
  // identical lattices
  auto l1 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  auto l2 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  // lattice that differs by name only
  auto l3 = CSGCartesianLattice(&quot;cartlat1&quot;, 1.0, univ_map1);
  // lattice that differs by universe map items
  auto l4 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map2);
  // lattice that differs by pitch
  auto l5 = CSGCartesianLattice(&quot;cartlat&quot;, 2.0, univ_map1);
  // lattice that differs by nrow
  auto l6 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map3);
  // lattice that differs by ncol
  auto l7 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map4);
  // differs by outer type - material outer
  auto l8 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  l8.updateOuter(&quot;outer1&quot;);
  // differs by outer type - universe outer
  auto l9 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  l9.updateOuter(out1);
  // differs by outer object - universe outer
  auto l10 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  l10.updateOuter(out2);
  // differs by outer name - material outer
  auto l11 = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map1);
  l11.updateOuter(&quot;outer2&quot;);

  // check equality
  {
    ASSERT_TRUE(l1 == l2);
  }
  // check inequality
  {
    // all lattices 2-7 should differ from each other in some way
    std::vector&lt;CSGCartesianLattice&gt; diff_compare = {l2, l3, l4, l5, l6, l7, l8, l9, l10, l11};
    for (std::size_t i = 0; i &lt; diff_compare.size(); i++)
    {
      for (std::size_t j = i + 1; j &lt; diff_compare.size(); ++j)
        ASSERT_TRUE(diff_compare[i] != diff_compare[j]);
    }
  }
}

/// test the == and != overloaded operators for hexagonal lattices
TEST(CSGLatticeTest, testHexLatticeEquality)
{
  // universe maps to use for different lattice comparisons
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map1 = {
      {univ1, univ1}, {univ1, univ1, univ1}, {univ1, univ1}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map2 = {
      {univ2, univ2}, {univ2, univ2, univ2}, {univ2, univ2}};
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map3 = {
      {univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1, univ1},
      {univ1, univ1, univ1}};
  // identical lattices
  auto l1 = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map1);
  auto l2 = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map1);
  // lattice that differs by name only
  auto l3 = CSGHexagonalLattice(&quot;hexlat1&quot;, 1.0, univ_map1);
  // lattice that differs by universe map items
  auto l4 = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map2);
  // lattice that differs by pitch
  auto l5 = CSGHexagonalLattice(&quot;hexlat&quot;, 2.0, univ_map1);
  // lattice that differs by nrow/rings
  auto l6 = CSGHexagonalLattice(&quot;hexlat&quot;, 1.0, univ_map3);

  // check equality
  {
    ASSERT_TRUE(l1 == l2);
  }
  // check inequality
  {
    // all lattices 2-6 should differ from each other in some way
    std::vector&lt;CSGHexagonalLattice&gt; diff_compare = {l2, l3, l4, l5, l6};
    for (std::size_t i = 0; i &lt; diff_compare.size(); i++)
    {
      for (std::size_t j = i + 1; j &lt; diff_compare.size(); ++j)
        ASSERT_TRUE(diff_compare[i] != diff_compare[j]);
    }
  }
}

/// test CSGLattice::getUniqueUniverses
TEST(CSGLatticeTest, testGetUniqueUniverses)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  const auto univ2 = CSGUniverse(&quot;univ2&quot;, false);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {{univ1, univ1},
                                                                                  {univ2, univ1}};
  auto lat = CSGCartesianLattice(&quot;cartlat&quot;, 1.0, univ_map);
  auto unique = lat.getUniqueUniverses();
  ASSERT_EQ(unique.size(), 2);
  ASSERT_EQ(unique[0].get(), univ1);
  ASSERT_EQ(unique[1].get(), univ2);
}

/// test CSG[Cartesian/Hexagonal]Lattice::setPitch
TEST(CSGLatticeTest, testSetPitch)
{
  {
    // cartesian lattice set pitch
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
    // set valid pitch
    cart_lattice.setPitch(2.5);
    ASSERT_EQ(cart_lattice.getPitch(), 2.5);
    // try to set invalid pitch (raise error)
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.setPitch(-0.5); },
                                   &quot;must have pitch greater than 0.&quot;);
  }
  {
    // hexagonal lattice set pitch
    auto hex_lat = CSGHexagonalLattice(&quot;hex_lat&quot;, 1.0);
    // set valid pitch
    hex_lat.setPitch(2.5);
    ASSERT_EQ(hex_lat.getPitch(), 2.5);
    // try to set invalid pitch (raise error)
    Moose::UnitUtils::assertThrows([&amp;hex_lat]() { hex_lat.setPitch(-0.5); },
                                   &quot;must have pitch greater than 0.&quot;);
  }
}

/// test CSGHexagonalLattice::get[Ring/Row]IndexFrom[Row/Ring]Index
TEST(CSGLatticeTest, testHexConvertRowsRings)
{
  // test that conversion between ring and row form works on 2-, 3-, and 4-ring hex lattices
  const auto u = CSGUniverse(&quot;u&quot;, false);
  {
    // 2-ring lattice case
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; umap = {
        {u, u}, {u, u, u}, {u, u}};
    auto lat = CSGHexagonalLattice(&quot;lat&quot;, 1.0, umap);
    std::map&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt;&gt; exp_row_to_ring = {{{0, 0}, {0, 4}},
                                                                          {{0, 1}, {0, 5}},
                                                                          {{1, 0}, {0, 3}},
                                                                          {{1, 1}, {1, 0}},
                                                                          {{1, 2}, {0, 0}},
                                                                          {{2, 0}, {0, 2}},
                                                                          {{2, 1}, {0, 1}}};
    for (const auto &amp; pair : exp_row_to_ring)
    {
      auto row_pair = lat.getRowIndexFromRingIndex(pair.second);
      ASSERT_EQ(row_pair, pair.first);
      auto ring_pair = lat.getRingIndexFromRowIndex(pair.first);
      ASSERT_EQ(ring_pair, pair.second);
    }
    // check that invalid ring index raises error
    Moose::UnitUtils::assertThrows([&amp;lat]() { lat.getRowIndexFromRingIndex(std::make_pair(2, 0)); },
                                   &quot;Ring 2 is not valid for hexagonal lattice lat&quot;);
    Moose::UnitUtils::assertThrows([&amp;lat]() { lat.getRowIndexFromRingIndex(std::make_pair(1, 7)); },
                                   &quot;Position 7 is not valid for ring 1 in hexagonal lattice lat&quot;);
    // check that invalid row-column index raises error
    Moose::UnitUtils::assertThrows([&amp;lat]() { lat.getRingIndexFromRowIndex(std::make_pair(3, 0)); },
                                   &quot;Index (3, 0) is not a valid index for hexagonal lattice lat&quot;);
  }
  {
    // 3-ring case
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; umap = {
        {u, u, u}, {u, u, u, u}, {u, u, u, u, u}, {u, u, u, u}, {u, u, u}};
    auto lat = CSGHexagonalLattice(&quot;lat&quot;, 1.0, umap);
    std::map&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt;&gt; exp_row_to_ring = {{{0, 0}, {0, 8}},
                                                                          {{0, 1}, {0, 9}},
                                                                          {{0, 2}, {0, 10}},
                                                                          {{1, 0}, {0, 7}},
                                                                          {{1, 1}, {1, 4}},
                                                                          {{1, 2}, {1, 5}},
                                                                          {{1, 3}, {0, 11}},
                                                                          {{2, 0}, {0, 6}},
                                                                          {{2, 1}, {1, 3}},
                                                                          {{2, 2}, {2, 0}},
                                                                          {{2, 3}, {1, 0}},
                                                                          {{2, 4}, {0, 0}},
                                                                          {{3, 0}, {0, 5}},
                                                                          {{3, 1}, {1, 2}},
                                                                          {{3, 2}, {1, 1}},
                                                                          {{3, 3}, {0, 1}},
                                                                          {{4, 0}, {0, 4}},
                                                                          {{4, 1}, {0, 3}},
                                                                          {{4, 2}, {0, 2}}};
    for (const auto &amp; pair : exp_row_to_ring)
    {
      auto row_pair = lat.getRowIndexFromRingIndex(pair.second);
      ASSERT_EQ(row_pair, pair.first);
      auto ring_pair = lat.getRingIndexFromRowIndex(pair.first);
      ASSERT_EQ(ring_pair, pair.second);
    }
  }
  {
    // 4-ring case
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; umap = {
        {u, u, u, u},
        {u, u, u, u, u},
        {u, u, u, u, u, u},
        {u, u, u, u, u, u, u},
        {u, u, u, u, u, u},
        {u, u, u, u, u},
        {u, u, u, u}};
    auto lat = CSGHexagonalLattice(&quot;lat&quot;, 1.0, umap);
    std::map&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt;&gt; exp_row_to_ring = {
        {{0, 0}, {0, 12}}, {{0, 1}, {0, 13}}, {{0, 2}, {0, 14}}, {{0, 3}, {0, 15}},
        {{1, 0}, {0, 11}}, {{1, 1}, {1, 8}},  {{1, 2}, {1, 9}},  {{1, 3}, {1, 10}},
        {{1, 4}, {0, 16}}, {{2, 0}, {0, 10}}, {{2, 1}, {1, 7}},  {{2, 2}, {2, 4}},
        {{2, 3}, {2, 5}},  {{2, 4}, {1, 11}}, {{2, 5}, {0, 17}}, {{3, 0}, {0, 9}},
        {{3, 1}, {1, 6}},  {{3, 2}, {2, 3}},  {{3, 3}, {3, 0}},  {{3, 4}, {2, 0}},
        {{3, 5}, {1, 0}},  {{3, 6}, {0, 0}},  {{4, 0}, {0, 8}},  {{4, 1}, {1, 5}},
        {{4, 2}, {2, 2}},  {{4, 3}, {2, 1}},  {{4, 4}, {1, 1}},  {{4, 5}, {0, 1}},
        {{5, 0}, {0, 7}},  {{5, 1}, {1, 4}},  {{5, 2}, {1, 3}},  {{5, 3}, {1, 2}},
        {{5, 4}, {0, 2}},  {{6, 0}, {0, 6}},  {{6, 1}, {0, 5}},  {{6, 2}, {0, 4}},
        {{6, 3}, {0, 3}}};
    for (const auto &amp; pair : exp_row_to_ring)
    {
      auto row_pair = lat.getRowIndexFromRingIndex(pair.second);
      ASSERT_EQ(row_pair, pair.first);
      auto ring_pair = lat.getRingIndexFromRowIndex(pair.first);
      ASSERT_EQ(ring_pair, pair.second);
    }
  }
}

/// tests that a lattice initialized without a universe map can be filled later even after it is used to fill a cell
TEST(CSGLatticeTest, testEmptyToFilled)
{
  const auto univ1 = CSGUniverse(&quot;univ1&quot;, false);
  {
    // create lattice without any universes
    auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
    // create cell and fill with the empty lattice
    auto cell = CSGCell(&quot;cell1&quot;, &amp;cart_lattice, CSG::CSGRegion());
    // now create universe map and set it on the lattice
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univ_map = {{univ1, univ1},
                                                                                    {univ1, univ1}};
    ASSERT_NO_THROW(cart_lattice.setUniverses(univ_map));
    // verify that the lattice in the cell has the correct universe map now
    const auto &amp; lat_in_cell = cell.getFillLattice();
    ASSERT_EQ(lat_in_cell.getUniverses().size(), 2);
    ASSERT_EQ(lat_in_cell.getUniverses()[0].size(), 2);
  }
}

TEST(CSGLatticeTest, testUpdateOuter)
{
  auto cart_lattice = CSGCartesianLattice(&quot;cartlat&quot;, 1.0);
  {
    // check outer universe type is set to VOID by default
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;VOID&quot;);
    // make sure trying to get material or universe outer raises error
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.getOuterMaterial(); },
                                   &quot;Lattice &#x27;cartlat&#x27; has VOID outer, not CSG_MATERIAL.&quot;);
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.getOuterUniverse(); },
                                   &quot;Lattice &#x27;cartlat&#x27; has VOID outer, not UNIVERSE.&quot;);
  }
  {
    // update outer to universe
    const auto univ = CSGUniverse(&quot;univ&quot;, false);
    cart_lattice.updateOuter(univ);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;UNIVERSE&quot;);
    ASSERT_EQ(cart_lattice.getOuterUniverse(), univ);
    // try to get material outer - should raise error because type is UNIVERSE
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.getOuterMaterial(); },
                                   &quot;Lattice &#x27;cartlat&#x27; has UNIVERSE outer, not CSG_MATERIAL.&quot;);
  }
  {
    // change outer type to a material name
    cart_lattice.updateOuter(&quot;material&quot;);
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;CSG_MATERIAL&quot;);
    ASSERT_EQ(cart_lattice.getOuterMaterial(), &quot;material&quot;);
    // try to get universe outer - should raise error because type is CSG_MATERIAL
    Moose::UnitUtils::assertThrows([&amp;cart_lattice]() { cart_lattice.getOuterUniverse(); },
                                   &quot;Lattice &#x27;cartlat&#x27; has CSG_MATERIAL outer, not UNIVERSE.&quot;);
  }
  {
    // reset outer type - should change it back to VOID
    cart_lattice.resetOuter();
    ASSERT_EQ(cart_lattice.getOuterType(), &quot;VOID&quot;);
  }
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="aec2af91-434d-4a6b-864f-7f84646db5af"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="e00ee1b4-0ef8-4ed0-bdda-a1dd0fbd496f"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="bf791b2c-7a2b-45ac-87d0-20d0f0c9559a"><div class="modal-content"><h4>(moose/test/include/csg/TestCSGAxialSurfaceMeshGenerator.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;MeshGenerator.h&quot;

class TestCSGAxialSurfaceMeshGenerator : public MeshGenerator
{
public:
  static InputParameters validParams();

  TestCSGAxialSurfaceMeshGenerator(const InputParameters &amp; parameters);

  std::unique_ptr&lt;MeshBase&gt; generate() override;

  void generateData() override {};

  std::unique_ptr&lt;CSG::CSGBase&gt; generateCSG() override;

protected:
  /// Pointer to the input mesh
  std::unique_ptr&lt;MeshBase&gt; &amp; _mesh_ptr;
  /// the axial height to set the input mesh to
  const Real _axial_height;
  /// Holds the generated CSGBase object
  std::unique_ptr&lt;CSG::CSGBase&gt; * _build_csg;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="9b3143d3-3746-4c01-be5f-f64639d1de85"><div class="modal-content"><h4>(moose/test/src/csg/TestCSGAxialSurfaceMeshGenerator.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;TestCSGAxialSurfaceMeshGenerator.h&quot;
#include &quot;MeshGenerator.h&quot;
#include &quot;CSGPlane.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, TestCSGAxialSurfaceMeshGenerator);

InputParameters
TestCSGAxialSurfaceMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();
  // input parameter that is an existing mesh generator
  params.addRequiredParam&lt;MeshGeneratorName&gt;(&quot;input&quot;, &quot;The input MeshGenerator.&quot;);
  // additional params for this specific mesh generator
  params.addRequiredParam&lt;Real&gt;(&quot;axial_height&quot;, &quot;Axial height of the model.&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

TestCSGAxialSurfaceMeshGenerator::TestCSGAxialSurfaceMeshGenerator(const InputParameters &amp; params)
  : MeshGenerator(params),
    _mesh_ptr(getMesh(&quot;input&quot;)),
    _axial_height(getParam&lt;Real&gt;(&quot;axial_height&quot;))
{
  _build_csg = &amp;getCSGBase(&quot;input&quot;);
}

std::unique_ptr&lt;MeshBase&gt;
TestCSGAxialSurfaceMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
TestCSGAxialSurfaceMeshGenerator::generateCSG()
{
  // get the existing CSGBase associated with the input mesh generator
  // this is the CSGBase object that will be updated
  std::unique_ptr&lt;CSG::CSGBase&gt; csg_obj = std::move(*_build_csg);

  // get the names of the current mesh generator and the input mesh generator
  // so that unique object naming can be enforced
  auto mg_name = this-&gt;name();
  auto inp_name = getParam&lt;MeshGeneratorName&gt;(&quot;input&quot;);

  // get the expected existing cell
  const auto cell_name = inp_name + &quot;_square_cell&quot;;
  const auto &amp; csg_cell = csg_obj-&gt;getCellByName(cell_name);

  // get the existing cell region to update
  auto cell_region = csg_cell.getRegion();

  // centroid used to determine direction for half-space
  const auto centroid = Point(0, 0, 0);

  // setting a default surface name purely for testing purposes
  const auto default_surf_name = &quot;default_surf&quot;;

  // Add surfaces and halfspaces corresponding to top and bottom axial planes
  std::vector&lt;std::string&gt; surf_names{&quot;plus_z&quot;, &quot;minus_z&quot;};
  std::vector&lt;Real&gt; coeffs{0.5 * _axial_height, -0.5 * _axial_height};
  for (unsigned int i = 0; i &lt; coeffs.size(); ++i)
  {
    // create a plane using the coefficients for the equation of a plane
    // z plane equation: 0.0*x + 0.0*y + 1.0*z = (+/-)0.5 * axial_height
    std::unique_ptr&lt;CSG::CSGSurface&gt; surface_ptr =
        std::make_unique&lt;CSG::CSGPlane&gt;(default_surf_name, 0.0, 0.0, 1.0, coeffs[i]);
    auto &amp; csg_plane = csg_obj-&gt;addSurface(std::move(surface_ptr));

    // Rename surface so that it has a unique surface name based on the mesh generator
    const auto surf_name = mg_name + &quot;_surf_&quot; + surf_names[i];
    csg_obj-&gt;renameSurface(csg_plane, surf_name);

    // determine the half-space to add as an updated intersection
    const auto region_direction = csg_plane.getHalfspaceFromPoint(centroid);
    auto halfspace =
        ((region_direction == CSG::CSGSurface::Halfspace::POSITIVE) ? +csg_plane : -csg_plane);

    // update the existing region with a half-space
    cell_region &amp;= halfspace;
  }

  // set the new region for the existing cell
  csg_obj-&gt;updateCellRegion(csg_cell, cell_region);

  // Rename cell as it now defines a box region instead of an infinite square region
  csg_obj-&gt;renameCell(csg_cell, mg_name + &quot;_box_cell&quot;);

  return csg_obj;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="5eb0faf5-ac09-43f4-b14d-740deee941fd"><div class="modal-content"><h4>(moose/test/src/csg/TestCSGAxialSurfaceMeshGenerator.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;TestCSGAxialSurfaceMeshGenerator.h&quot;
#include &quot;MeshGenerator.h&quot;
#include &quot;CSGPlane.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, TestCSGAxialSurfaceMeshGenerator);

InputParameters
TestCSGAxialSurfaceMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();
  // input parameter that is an existing mesh generator
  params.addRequiredParam&lt;MeshGeneratorName&gt;(&quot;input&quot;, &quot;The input MeshGenerator.&quot;);
  // additional params for this specific mesh generator
  params.addRequiredParam&lt;Real&gt;(&quot;axial_height&quot;, &quot;Axial height of the model.&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

TestCSGAxialSurfaceMeshGenerator::TestCSGAxialSurfaceMeshGenerator(const InputParameters &amp; params)
  : MeshGenerator(params),
    _mesh_ptr(getMesh(&quot;input&quot;)),
    _axial_height(getParam&lt;Real&gt;(&quot;axial_height&quot;))
{
  _build_csg = &amp;getCSGBase(&quot;input&quot;);
}

std::unique_ptr&lt;MeshBase&gt;
TestCSGAxialSurfaceMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
TestCSGAxialSurfaceMeshGenerator::generateCSG()
{
  // get the existing CSGBase associated with the input mesh generator
  // this is the CSGBase object that will be updated
  std::unique_ptr&lt;CSG::CSGBase&gt; csg_obj = std::move(*_build_csg);

  // get the names of the current mesh generator and the input mesh generator
  // so that unique object naming can be enforced
  auto mg_name = this-&gt;name();
  auto inp_name = getParam&lt;MeshGeneratorName&gt;(&quot;input&quot;);

  // get the expected existing cell
  const auto cell_name = inp_name + &quot;_square_cell&quot;;
  const auto &amp; csg_cell = csg_obj-&gt;getCellByName(cell_name);

  // get the existing cell region to update
  auto cell_region = csg_cell.getRegion();

  // centroid used to determine direction for half-space
  const auto centroid = Point(0, 0, 0);

  // setting a default surface name purely for testing purposes
  const auto default_surf_name = &quot;default_surf&quot;;

  // Add surfaces and halfspaces corresponding to top and bottom axial planes
  std::vector&lt;std::string&gt; surf_names{&quot;plus_z&quot;, &quot;minus_z&quot;};
  std::vector&lt;Real&gt; coeffs{0.5 * _axial_height, -0.5 * _axial_height};
  for (unsigned int i = 0; i &lt; coeffs.size(); ++i)
  {
    // create a plane using the coefficients for the equation of a plane
    // z plane equation: 0.0*x + 0.0*y + 1.0*z = (+/-)0.5 * axial_height
    std::unique_ptr&lt;CSG::CSGSurface&gt; surface_ptr =
        std::make_unique&lt;CSG::CSGPlane&gt;(default_surf_name, 0.0, 0.0, 1.0, coeffs[i]);
    auto &amp; csg_plane = csg_obj-&gt;addSurface(std::move(surface_ptr));

    // Rename surface so that it has a unique surface name based on the mesh generator
    const auto surf_name = mg_name + &quot;_surf_&quot; + surf_names[i];
    csg_obj-&gt;renameSurface(csg_plane, surf_name);

    // determine the half-space to add as an updated intersection
    const auto region_direction = csg_plane.getHalfspaceFromPoint(centroid);
    auto halfspace =
        ((region_direction == CSG::CSGSurface::Halfspace::POSITIVE) ? +csg_plane : -csg_plane);

    // update the existing region with a half-space
    cell_region &amp;= halfspace;
  }

  // set the new region for the existing cell
  csg_obj-&gt;updateCellRegion(csg_cell, cell_region);

  // Rename cell as it now defines a box region instead of an infinite square region
  csg_obj-&gt;renameCell(csg_cell, mg_name + &quot;_box_cell&quot;);

  return csg_obj;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="5871a8be-d6a6-4536-be92-0c643ed9287c"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="89c3eb7e-d140-455a-8e8c-019fe152e294"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="36a2777f-83c0-4b20-b04a-6a409c593394"><div class="modal-content"><h4>(moose/unit/src/CSGBaseTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

#include &quot;CSGBase.h&quot;
#include &quot;CSGSphere.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

#include &quot;MooseUnitUtils.h&quot;

namespace CSG
{

/**
 * Tests associated with CSGSurfaceList functionality as called through CSGBase
 */

/// tests CSG[Base/SurfaceList]::addSurface() and CSG[Base/SurfaceList]::getSurfaceByName()
TEST(CSGBaseTest, testAddGetSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces that have the same name
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 2.0);
  // add one surface to base initially
  const auto &amp; added_surf = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  // assert surface is present after adding by successfully using getSurfaceByName
  {
    // public method, returns const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurfaceByName(&quot;surf&quot;));
    // private method, returns non-const
    ASSERT_TRUE(added_surf == csg_obj-&gt;getSurface(&quot;surf&quot;));
  }
  // try to add surface that already exists of the same name, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;surf_ptr2]()
                                   { csg_obj-&gt;addSurface(std::move(surf_ptr2)); },
                                   &quot;Surface with name surf already exists in geometry.&quot;);
  }
  // try to get surface that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getSurfaceByName(&quot;fake_name&quot;); },
                                   &quot;No surface by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/SurfaceList]::getAllSurfaces
TEST(CSGBaseTest, testGetAllSurfaces)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  csg_obj-&gt;addSurface(std::move(surf_ptr1));
  csg_obj-&gt;addSurface(std::move(surf_ptr2));
  auto all_surfs = csg_obj-&gt;getAllSurfaces();
  ASSERT_EQ(2, all_surfs.size());
}

/// tests CSG[Base/SurfaceList]::renameSurface
TEST(CSGBaseTest, testRenameSurface)
{
  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // make two surfaces to add to base
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf2&quot;, 2.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf_ptr1));
  const auto &amp; s2 = csg_obj-&gt;addSurface(std::move(surf_ptr2));

  // successfully rename surface
  {
    csg_obj-&gt;renameSurface(s1, &quot;george&quot;);
    ASSERT_EQ(&quot;george&quot;, s1.getName());
  }
  // error should be raised if try to rename to a name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s2]() { csg_obj-&gt;renameSurface(s2, &quot;george&quot;); },
                                   &quot;Surface with name george already exists in geometry&quot;);
  }
  // error should be raised if trying to rename a surface that is not a part of this instance
  {
    // initialize a new CSGBase object
    auto csg_obj_new = std::make_unique&lt;CSG::CSGBase&gt;();
    // make new surface to add to new base
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr3 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf3&quot;, 1.0);
    const auto &amp; s3 = csg_obj_new-&gt;addSurface(std::move(surf_ptr3));
    // try to rename s3 via original base where it was not added
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;s3]() { csg_obj-&gt;renameSurface(s3, &quot;ringo&quot;); },
                                   &quot;cannot be renamed to ringo as it does not exist&quot;);
  }
}

/// tests CSGBase::checkRegionSurfaces
TEST(CSGBaseTest, testCheckRegionSurfaces)
{
  // make two sets of surfaces that are identical but different base ownership
  // create a region from surfaces in base 1 and make sure that base 2 recognizes the surfaces as
  // not available in that base even though names exist
  auto csg_obj1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  const auto &amp; s1 = csg_obj1-&gt;addSurface(std::move(surf1));

  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf&quot;, 1.0);
  csg_obj2-&gt;addSurface(std::move(surf2));

  auto reg1 = +s1; // uses surfaces from base 1

  // expect error when surfaces are checked in base2
  Moose::UnitUtils::assertThrows([&amp;csg_obj2, &amp;reg1]() { csg_obj2-&gt;checkRegionSurfaces(reg1); },
                                 &quot;Region is being set with a surface named surf that is different &quot;
                                 &quot;from the surface of the same name in the CSGBase instance.&quot;);
}

/**
 * Tests associated with CSGCellList or CSGCell functionality as called through CSGBase
 */

/// tests CSG[Base/CellList]::createCell
TEST(CSGBaseTest, testCreateCell)
{
  // create each type of cell, each w/ or w/out add_to_univ specified to test universe ownership

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // surfaces for regions for cell
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto reg1 = +s1;

  // make a new universe to which the new cells can be added at time of creation
  auto &amp; add_to_univ = csg_obj-&gt;createUniverse(&quot;add_univ&quot;);

  // root universe to check in tests
  auto &amp; root_univ = csg_obj-&gt;getRootUniverse();

  // create lattice to be used as fill
  auto &amp; lat_univ1 = csg_obj-&gt;createUniverse(&quot;latt_univ1&quot;);
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr = std::make_unique&lt;CSG::CSGCartesianLattice&gt;(
      &quot;lat1&quot;,
      1.0,
      std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt;{
          {std::cref(lat_univ1), std::cref(lat_univ1)}});
  const auto &amp; lattice = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  // make void cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;void_cell1&quot;;
    // create a void cell with name cname1 and defined by region reg1
    csg_obj-&gt;createCell(cname1, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;void_cell2&quot;;
    csg_obj-&gt;createCell(cname2, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make material cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;mat_cell1&quot;;
    // create a material-filled cell with name cname1, a fill with material matname,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, &quot;matname&quot;, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;mat_cell2&quot;;
    csg_obj-&gt;createCell(cname2, &quot;matname&quot;, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // make universe cells and check universe ownership
  {
    auto new_univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);

    // create cell to be auto added to root universe
    std::string cname1 = &quot;univ_cell1&quot;;
    // create a universe-filled cell with name cname1, a fill of universe new_univ,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, new_univ, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;univ_cell2&quot;;
    csg_obj-&gt;createCell(cname2, new_univ, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a universe cell and add it to the same universe
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;add_to_univ, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, add_to_univ, reg1, &amp;add_to_univ); },
        &quot;cannot be filled with the same universe to which it is being added&quot;);
  }
  // make lattice cells and check universe ownership
  {
    // create cell to be auto added to root universe
    std::string cname1 = &quot;latt_cell1&quot;;
    // create a lattice-filled cell with name cname1, a fill of lattice,
    // and defined by region reg1
    csg_obj-&gt;createCell(cname1, lattice, reg1);
    // create a cell and add to different universe, not root
    std::string cname2 = &quot;latt_cell2&quot;;
    csg_obj-&gt;createCell(cname2, lattice, reg1, &amp;add_to_univ);

    // cname1 should exist in root but not the other universe
    ASSERT_TRUE(root_univ.hasCell(cname1));
    ASSERT_FALSE(add_to_univ.hasCell(cname1));

    // cname2 should exist in add_to_univ but not root
    ASSERT_TRUE(add_to_univ.hasCell(cname2));
    ASSERT_FALSE(root_univ.hasCell(cname2));
  }
  // expected error: create a lattice cell and add it to a universe that exists in the lattice
  // itself
  {
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lattice, &amp;lat_univ1, &amp;reg1]()
        { csg_obj-&gt;createCell(&quot;c&quot;, lattice, reg1, &amp;lat_univ1); },
        &quot;cannot be filled with a lattice containing the same universe to which it is being added&quot;);
  }
  // expect error: create a cell with existing name
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;reg1]() { csg_obj-&gt;createCell(&quot;void_cell1&quot;, reg1); },
                                   &quot;Cell with name void_cell1 already exists&quot;);
  }
}

/// tests CSG[Base/CellList]::getAllCells
TEST(CSGBaseTest, testGetAllCells)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  // expect the 2 cells to be present
  auto all_cells = csg_obj-&gt;getAllCells();
  ASSERT_EQ(2, all_cells.size());
}

/// tests CSGBase::getCellByName / CSGCellList::getCell
TEST(CSGBaseTest, testGetCellByName)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // get cell that exists
  {
    auto c1_get = csg_obj-&gt;getCellByName(&quot;c1&quot;);
    ASSERT_EQ(c1, c1_get);
  }
  // try to get cell that doesn&#x27;t exist in base, should raise error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getCellByName(&quot;fake_name&quot;); },
                                   &quot;No cell by name fake_name exists in the geometry.&quot;);
  }
}

/// tests CSG[Base/CellList]::renameCell
TEST(CSGBaseTest, testRenameCell)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // rename success
  {
    csg_obj-&gt;renameCell(c1, &quot;paul&quot;);
    ASSERT_EQ(&quot;paul&quot;, c1.getName());
  }
  // rename cell to existing name
  {
    // make a second cell
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;paul&quot;); },
                                   &quot;Cell with name paul already exists&quot;);
  }
  // rename cell that does not exist in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);

    // try to rename from the first base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2]() { csg_obj-&gt;renameCell(c2, &quot;john&quot;); },
                                   &quot;cannot be renamed to john as it does not exist&quot;);
  }
}

/// tests CSGBase::updateCellRegion
TEST(CSGBaseTest, testUpdateCellRegion)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);

  // successfully update cell region to new region
  {
    csg_obj-&gt;updateCellRegion(c1, -s1);
    ASSERT_EQ(-s1, c1.getRegion());
  }
  // try to update cell not in this base
  {
    // make an identical cell in a different base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c2 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;c2, &amp;s1]() { csg_obj-&gt;updateCellRegion(c2, -s1); },
                                   &quot;is being updated that is different from the cell of the same &quot;
                                   &quot;name in the CSGBase instance.&quot;);
  }
}

/**
 * Tests associated with CSGUniverseList and CSGUniverse functionality as called through CSGBase
 */

/// tests CSGBase::createUniverse
TEST(CSGBaseTest, testCreateUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // create empty universe
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;thelma&quot;);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;thelma&quot;)); // no throw confirms existence
    ASSERT_EQ(0, univ.getAllCells().size());               // confirms empty
  }
  // create universe from cells
  {
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
    auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
    auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
    // create a list of cells to be added to the universe
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;louise&quot;, cells);
    ASSERT_NO_THROW(csg_obj-&gt;getUniverseByName(&quot;louise&quot;)); // no throw confirms existence
    ASSERT_EQ(2, univ.getAllCells().size());               // confirms has cells
  }
  // create universe for name that already exists
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;createUniverse(&quot;louise&quot;); },
                                   &quot;Universe with name louise already exists in geometry.&quot;);
  }
}

/// tests CSG[Base/UniverseList]::renameUniverse and CSGBase::renameRootUniverse
TEST(CSGBaseTest, renameUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; root = csg_obj-&gt;getRootUniverse();
  std::string new_name_1 = &quot;simon&quot;;
  std::string new_name_2 = &quot;alvin&quot;;
  std::string new_name_3 = &quot;theo&quot;;

  // rename root through root-specific function
  {
    csg_obj-&gt;renameRootUniverse(new_name_1);
    ASSERT_EQ(new_name_1, root.getName());
  }
  // rename root by passing to method explicitly
  {
    csg_obj-&gt;renameUniverse(root, new_name_2);
    ASSERT_EQ(new_name_2, root.getName());
  }
  // rename a different universe to name that already exists, should raise error
  {
    auto &amp; univ = csg_obj-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_2]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_2); },
                                   &quot;Universe with name &quot; + new_name_2 + &quot; already exists&quot;);
  }
  // rename a universe that doesn&#x27;t exist in the current base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ = csg_obj2-&gt;createUniverse(&quot;new_univ&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;new_name_3]()
                                   { csg_obj-&gt;renameUniverse(univ, new_name_3); },
                                   &quot;cannot be renamed to &quot; + new_name_3 + &quot; as it does not exist&quot;);
  }
}

/// tests CSGBase::addCell[s]ToUniverse
TEST(CSGBaseTest, testAddCellToUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);

  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;);

  // add a list of cells to an existing universe
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2};
    csg_obj-&gt;addCellsToUniverse(univ, cells);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // add individual cell
  {
    csg_obj-&gt;addCellToUniverse(univ, c3);
    ASSERT_EQ(3, univ.getAllCells().size());
  }
  // add cell that is not in current base but has the same name and attributes, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;addCellToUniverse(univ, c4); },
                                   &quot;is being added to universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // add cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;addCellToUniverse(univ_new, c1); },
        &quot;Cells are being added to a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::removeCell[s]FromUniverse
TEST(CSGBaseTest, testRemoveCellFromUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  auto &amp; c1 = csg_obj-&gt;createCell(&quot;c1&quot;, +s1);
  auto &amp; c2 = csg_obj-&gt;createCell(&quot;c2&quot;, -s1);
  auto &amp; c3 = csg_obj-&gt;createCell(&quot;c3&quot;, -s1 | +s1);
  std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells = {c1, c2, c3};
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;univ&quot;, cells);

  // remove inidividual cell
  {
    csg_obj-&gt;removeCellFromUniverse(univ, c1);
    ASSERT_EQ(2, univ.getAllCells().size());
  }
  // remove list of cells
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGCell&gt;&gt; cells_remove = {c2, c3};
    csg_obj-&gt;removeCellsFromUniverse(univ, cells_remove);
    ASSERT_EQ(0, univ.getAllCells().size());
  }
  // remove cell that is not in current base but has the same name and attributes, should raise
  // error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSG::CSGSphere&gt; surf2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
    const auto &amp; s2 = csg_obj2-&gt;addSurface(std::move(surf2));
    auto &amp; c4 = csg_obj2-&gt;createCell(&quot;c1&quot;, +s2);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;univ, &amp;c4]()
                                   { csg_obj-&gt;removeCellFromUniverse(univ, c4); },
                                   &quot;is being removed from universe univ that is different from the &quot;
                                   &quot;cell of the same name in the CSGBase instance.&quot;);
  }
  // remove cell that is in the base a universe that is not in the base, should raise error
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ_new = csg_obj2-&gt;createUniverse(&quot;univ&quot;);

    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;univ_new, &amp;c1]() { csg_obj-&gt;removeCellFromUniverse(univ_new, c1); },
        &quot;Cells are being removed from a universe named univ that is different &quot;
        &quot;from the universe of the same name in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::get*Universe* methods
TEST(CSGBaseTest, testGetUniverse)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;harry&quot;);

  // get root
  {
    auto &amp; root = csg_obj-&gt;getRootUniverse();
    ASSERT_TRUE(root.isRoot());
  }
  // successful getUniverseByName call
  {
    auto &amp; univ_get = csg_obj-&gt;getUniverseByName(&quot;harry&quot;);
    ASSERT_EQ(univ, univ_get);
  }
  // get universe for name that does not exist, expect error
  {
    Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;getUniverseByName(&quot;potter&quot;); },
                                   &quot;No universe by name potter exists in the geometry.&quot;);
  }
  // getAllUniverses
  {
    // two universes expected: ROOT_UNIVERSE and harry
    auto all_univs = csg_obj-&gt;getAllUniverses();
    ASSERT_EQ(2, all_univs.size());
  }
}

/**
 * Tests associated with CSGLattice or CSGLatticeList functionality through CSGBase
 */

/// tests the [re]setLatticeOuter methods
TEST(CSGBaseTest, testLatticeOuter)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSG::CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));

  // initial outer should be VOID
  {
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // update to CSG_MATERIAL type
  {
    csg_obj-&gt;setLatticeOuter(lat, &quot;mat_outer&quot;);
    ASSERT_TRUE(lat.getOuterType() == &quot;CSG_MATERIAL&quot;);
    ASSERT_TRUE(lat.getOuterMaterial() == &quot;mat_outer&quot;);
  }
  // update to UNIVERSE type
  {
    auto &amp; u_out = csg_obj-&gt;createUniverse(&quot;univ_outer&quot;); // universe for lattice outer
    csg_obj-&gt;setLatticeOuter(lat, u_out);
    ASSERT_TRUE(lat.getOuterType() == &quot;UNIVERSE&quot;);
    ASSERT_TRUE(lat.getOuterUniverse() == u_out);
  }
  // reset back to VOID
  {
    csg_obj-&gt;resetLatticeOuter(lat);
    ASSERT_TRUE(lat.getOuterType() == &quot;VOID&quot;);
  }
  // try to set outer universe that is not in this base
  {
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; u_out2 = csg_obj2-&gt;createUniverse(&quot;univ_outer&quot;);
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat, &amp;u_out2]()
                                   { csg_obj-&gt;setLatticeOuter(lat, u_out2); },
                                   &quot;Cannot set outer universe for lattice lat1. Outer universe &quot;
                                   &quot;univ_outer is not in the CSGBase instance.&quot;);
  }
}

/// tests CSGBase::addLattice
TEST(CSGBaseTest, testAddLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ = csg_obj-&gt;createUniverse(&quot;uni&quot;);
  auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;(); // used for error checking
  auto &amp; univ2 = csg_obj2-&gt;createUniverse(&quot;uni&quot;);   // universe of same name from different base

  {
    // create a lattice as a unique pointer and manually add it to the CSGBase
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat&quot;, 1.0, univs);
    // add to CSGBase
    const auto &amp; lat_ref = csg_obj-&gt;addLattice(std::move(custom_lat));
    // check that it exists in the base now
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(1, all_lats.size());
    ASSERT_EQ(lat_ref, all_lats[0]);
  }
  {
    // create a custom lattice containing a universe that was not in this base (raise error)
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs2 = {{univ2}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat2&quot;, 1.0, univs2);
    // try to add to first CSGBase - raises error because universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat2]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat2)); },
                                   &quot;Cannot add lattice custom_lat2 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Universe uni is not in the CSGBase &quot;
                                   &quot;instance.&quot;);
  }
  {
    // create a custom lattice with a universe outer that is not a part of this base
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ}};
    std::unique_ptr&lt;CSGCartesianLattice&gt; custom_lat3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;custom_lat3&quot;, 1.0, univs);
    // set outer universe to one from different base
    custom_lat3-&gt;updateOuter(univ2);
    // try to add to first CSGBase - raises error because outer universe is not in this base
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;custom_lat3]()
                                   { csg_obj-&gt;addLattice(std::move(custom_lat3)); },
                                   &quot;Cannot add lattice custom_lat3 of type &quot;
                                   &quot;CSG::CSGCartesianLattice. Outer universe uni is not in the &quot;
                                   &quot;CSGBase instance.&quot;);
  }
}

/// tests the CSGBase::setUniverseAtLatticeIndex method
TEST(CSGBaseTest, testSetUniverseAtLatticeIndex)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;spidey&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;spin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;spiderverse&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid add new univ
    csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ2, std::make_pair&lt;int, int&gt;(1, 0));
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to add a universe that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;spidey&quot;);
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;lat, &amp;univ3]()
        { csg_obj-&gt;setUniverseAtLatticeIndex(lat, univ3, std::make_pair&lt;int, int&gt;(1, 0)); },
        &quot;Cannot add universe spidey to lattice spiderverse. Universe is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
}

/// tests the CSGBase::setLatticeUniverses method
TEST(CSGBaseTest, testSetLatticeUniverses)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;batman&quot;);
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;robin&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ1}, {univ1}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;batverse&quot;, 1.0, univs);
  const auto &amp; cartlat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // test valid set universes - overwrite old universes
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ2},
                                                                                     {univ2}};
    csg_obj-&gt;setLatticeUniverses(cartlat, new_univs);
    auto all_univs = cartlat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ2);
    ASSERT_EQ(all_univs[1][0].get(), univ2);
  }
  {
    // try to set universes with one that is not from this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    auto &amp; univ3 = csg_obj2-&gt;createUniverse(&quot;batman&quot;);
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ3},
                                                                                     {univ2}};
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj, &amp;cartlat, &amp;new_univs]() { csg_obj-&gt;setLatticeUniverses(cartlat, new_univs); },
        &quot;Cannot set universes for lattice batverse. Universe batman is not in the CSGBase &quot;
        &quot;instance.&quot;);
  }
  {
    // initialize a lattice without universes and then add universes with setLatticeUniverses
    std::unique_ptr&lt;CSGCartesianLattice&gt; new_lat_ptr =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;new_lattice&quot;, 1.0);
    const auto &amp; lat = csg_obj-&gt;addLattice(std::move(new_lat_ptr));
    std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; new_univs = {{univ1},
                                                                                     {univ1}};
    csg_obj-&gt;setLatticeUniverses(lat, new_univs);
    auto all_univs = lat.getUniverses();
    ASSERT_EQ(all_univs[0][0].get(), univ1);
    ASSERT_EQ(all_univs[1][0].get(), univ1);
  }
}

/// tests CSGBase::renameLattice
TEST(CSGBaseTest, testRenameLattice)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;original_name&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // successful rename
    csg_obj-&gt;renameLattice(lat, &quot;new_name&quot;);
    ASSERT_EQ(&quot;new_name&quot;, lat.getName());
  }
  {
    // try to rename to existing name
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat2]()
                                   { csg_obj-&gt;renameLattice(lat2, &quot;new_name&quot;); },
                                   &quot;Lattice with name new_name already exists in geometry.&quot;);
  }
  {
    // try to rename lattice that does not exist in this base
    auto csg_obj2 = std::make_unique&lt;CSG::CSGBase&gt;();
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr3 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;another_lattice&quot;, 1.0);
    const auto &amp; lat3 = csg_obj2-&gt;addLattice(std::move(lat_ptr3));
    Moose::UnitUtils::assertThrows([&amp;csg_obj, &amp;lat3]()
                                   { csg_obj-&gt;renameLattice(lat3, &quot;some_name&quot;); },
                                   &quot;another_lattice cannot be renamed to some_name as it does not &quot;
                                   &quot;exist in this CSGBase instance.&quot;);
  }
}

/// tests CSGBase::getLatticeByName and CSGBase::getAllLattices
TEST(CSGBaseTest, testGetLatticeMethods)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;, 1.0);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  {
    // get lattice by name successfully
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    ASSERT_EQ(typeid(lat_get), typeid(CSGCartesianLattice));
  }
  {
    // get lattice by name without specifying type, assumes default CSGLattice
    const auto &amp; lat_get = csg_obj-&gt;getLatticeByName(&quot;lattice1&quot;);
    ASSERT_EQ(lat, lat_get);
    static_assert(std::is_same&lt;decltype(lat_get), const CSGLattice &amp;&gt;::value);
  }
  {
    // try to get lattice by name that does not exist
    Moose::UnitUtils::assertThrows([&amp;csg_obj]()
                                   { csg_obj-&gt;getLatticeByName&lt;CSGCartesianLattice&gt;(&quot;fake_name&quot;); },
                                   &quot;No lattice by name fake_name exists in the geometry.&quot;);
  }
  {
    // try to get lattice by name with wrong type
    Moose::UnitUtils::assertThrows(
        [&amp;csg_obj]() { csg_obj-&gt;getLatticeByName&lt;CSGHexagonalLattice&gt;(&quot;lattice1&quot;); },
        &quot;Cannot get lattice lattice1. Lattice is not of specified type CSG::CSGHexagonalLattice&quot;);
  }
  {
    // get all lattices
    std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr2 =
        std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lattice2&quot;, 1.0);
    const auto &amp; lat2 = csg_obj-&gt;addLattice(std::move(lat_ptr2));
    auto all_lats = csg_obj-&gt;getAllLattices();
    ASSERT_EQ(2, all_lats.size());
    ASSERT_TRUE(((all_lats[0].get() == lat) &amp;&amp; (all_lats[1].get() == lat2)) ||
                ((all_lats[0].get() == lat2) &amp;&amp; (all_lats[1].get() == lat)));
  }
}

/**
 * CSGBase::joinOtherBase methods
 */

/// test CSGBase::joinOtherBase no passed name
TEST(CSGBaseTest, joinOtherBaseJoinRoot)
{
  // Case 1: Create two CSGBase objects to join together into a single root
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: two universes will remain
  // base1 ROOT_UNIVERSE will gain all cells from base2 ROOT_UNIVERSE
  // base2 ROOT_UNIVERSE will not exist as a separate universe
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  base1-&gt;joinOtherBase(std::move(base2));

  // expect 3 universes: root, extra, lattice universe
  // 3 cells: 2 owned by root, 1 owned by extra
  ASSERT_EQ(3, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  ASSERT_EQ(2, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  ASSERT_TRUE(root.hasCell(c2.getName()));
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase one passed name
TEST(CSGBaseTest, joinOtherBaseOneNewRoot)
{
  // Case 2: Create two CSGBase objects to join together but keep incoming root separate
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 4 universes will remain
  // base1 ROOT_UNIVERSE and univ_in_lat will remain untouched
  // all cells from ROOT_UNIVERSE in base2 create new universe called &quot;new_univ&quot;
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_root_name = &quot;new_univ&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_root_name);

  // expect 4 universes: root, extra, new, and lat
  // 3 cells: 1 owned by root, 1 owned by new, 1 owned by extra
  ASSERT_EQ(4, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have c1 from original root
  ASSERT_EQ(1, root.getAllCells().size());
  ASSERT_TRUE(root.hasCell(c1.getName()));
  // new_univ should have c2 from root of base 2
  auto new_univ = base1-&gt;getUniverseByName(new_root_name);
  ASSERT_EQ(1, new_univ.getAllCells().size());
  ASSERT_TRUE(new_univ.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_EQ(1, new_extra.getAllCells().size());
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::joinOtherBase two passed names
TEST(CSGBaseTest, joinOtherBaseTwoNewRoot)
{
  // Case 3: Create two CSGBase objects to join together with each root becoming a new universe
  // CSGBase 1: only one cell containing a lattice of one universe, which lives in the ROOT_UNIVERSE
  std::unique_ptr&lt;CSGBase&gt; base1 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s1&quot;, 1.0);
  const auto &amp; surf1 = base1-&gt;addSurface(std::move(surf_ptr1));
  // create a lattice of one universe
  auto &amp; univ_in_lat = base1-&gt;createUniverse(&quot;univ_in_lat&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ_in_lat}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = base1-&gt;addLattice(std::move(lat_ptr));
  // create cell containing lattice
  auto &amp; c1 = base1-&gt;createCell(&quot;c1&quot;, lat, +surf1);
  // CSGBase 2: two total unverses (ROOT_UNIVERSE and extra_univ) with a cell in each
  std::unique_ptr&lt;CSGBase&gt; base2 = std::make_unique&lt;CSG::CSGBase&gt;();
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf_ptr2 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;s2&quot;, 1.0);
  const auto &amp; surf2 = base2-&gt;addSurface(std::move(surf_ptr2));
  auto &amp; c2 = base2-&gt;createCell(&quot;c2&quot;, +surf2);
  auto &amp; extra_univ = base2-&gt;createUniverse(&quot;extra_univ&quot;);
  auto &amp; c3 = base2-&gt;createCell(&quot;c3&quot;, -surf2, &amp;extra_univ);

  // Joining: 5 universes will remain
  // all cells from base1 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ1&quot;
  // all cells from base2 ROOT_UNIVERSE will be moved to a new universe called &quot;new_univ2&quot;
  // base1 ROOT_UNIVERSE will be empty
  // the &quot;extra_univ&quot; from base2 and &quot;univ_in_lat&quot; from base1 will remain separate universes
  std::string new_name1 = &quot;new_univ1&quot;;
  std::string new_name2 = &quot;new_univ2&quot;;
  base1-&gt;joinOtherBase(std::move(base2), new_name1, new_name2);

  // expect 5 universes: root, extra, lat, new1 and new2
  // 3 cells: 0 owned by root, 1 owned by new1, 1 owned by new2, 1 owned by extra
  ASSERT_EQ(5, base1-&gt;getAllUniverses().size());
  auto &amp; root = base1-&gt;getRootUniverse();
  ASSERT_EQ(3, base1-&gt;getAllCells().size());
  // root should have 0 cells since all were moved
  ASSERT_EQ(0, root.getAllCells().size());
  // new_univ1 should have c1 from original root of base 1
  auto new_univ1 = base1-&gt;getUniverseByName(new_name1);
  ASSERT_TRUE(new_univ1.hasCell(c1.getName()));
  // new_univ2 should have c2 from original root of base 2
  auto new_univ2 = base1-&gt;getUniverseByName(new_name2);
  ASSERT_TRUE(new_univ2.hasCell(c2.getName()));
  // original existing extra universe should still only have c3
  auto &amp; new_extra = base1-&gt;getUniverseByName(&quot;extra_univ&quot;);
  ASSERT_TRUE(new_extra.hasCell(c3.getName()));
  ASSERT_EQ(1, new_extra.getAllCells().size());
  // expect 2 surfaces
  ASSERT_EQ(2, base1-&gt;getAllSurfaces().size());
  // expect 1 lattice
  ASSERT_EQ(1, base1-&gt;getAllLattices().size());
}

/// test CSGBase::checkUniverseLinking / getLinkedUniverses
TEST(CSGBaseTest, testUniverseLinking)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; univ1 = csg_obj-&gt;createUniverse(&quot;univ1&quot;);

  // new universe is not inherently linked to ROOT_UNIVERSE, should raise warning when checked
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ1 is not linked to root universe.&quot;);

  // link the universe by adding it to a cell that is created in root
  std::unique_ptr&lt;CSG::CSGSphere&gt; surf1 = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;surf1&quot;, 1.0);
  const auto &amp; s1 = csg_obj-&gt;addSurface(std::move(surf1));
  csg_obj-&gt;createCell(&quot;c1&quot;, univ1, +s1);

  // no warning should be raised because it is a part of c1, which is a part of root
  // linking tree: ROOT_UNIVERSE -&gt; c1 -&gt; univ1
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());

  // create a lattice of universes that is not linked to root, should raise warning when checked
  auto &amp; univ2 = csg_obj-&gt;createUniverse(&quot;univ2&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{univ2}};
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 1.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ2 is not linked to root universe.&quot;);

  // set the outer to a universe, universe should also not be linked
  auto &amp; univ_out = csg_obj-&gt;createUniverse(&quot;univ_out&quot;);
  csg_obj-&gt;setLatticeOuter(lat, univ_out);
  Moose::UnitUtils::assertThrows([&amp;csg_obj]() { csg_obj-&gt;checkUniverseLinking(); },
                                 &quot;Universe with name univ_out is not linked to root universe.&quot;);

  // fill a new cell with the lattice, linking it to root, confirm no warning is raised when checked
  // linking tree: ROOT_UNIVERSE -&gt; c2 -&gt; lat1 -&gt; univ2 + univ_out
  csg_obj-&gt;createCell(&quot;c2&quot;, lat, +s1);
  ASSERT_NO_THROW(csg_obj-&gt;checkUniverseLinking());
}

/**
 * Tests associated with CSGBase::clone
 */
/// test CSGBase::clone and equality operators for CSGBase and CSG[Surface|Cell|Universe|Lattice]List
TEST(CSGBaseTest, testCSGBaseClone)
{
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  auto &amp; inner_univ = csg_obj-&gt;createUniverse(&quot;univ1&quot;);
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_inner =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;inner_surf&quot;, 3.0);
  auto &amp; csg_sphere_inner = csg_obj-&gt;addSurface(std::move(sphere_ptr_inner));
  csg_obj-&gt;createCell(&quot;cell_inner&quot;, &quot;mat1&quot;, -csg_sphere_inner, &amp;inner_univ);

  // create cell with universe fill
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_outer =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;outer_surf&quot;, 5.0);
  auto &amp; csg_sphere_outer = csg_obj-&gt;addSurface(std::move(sphere_ptr_outer));
  csg_obj-&gt;createCell(&quot;cell_univ_fill&quot;, inner_univ, -csg_sphere_outer);
  csg_obj-&gt;createCell(&quot;cell_void&quot;, +csg_sphere_outer);
  // create lattice and cell with lattice fill
  auto &amp; lat_univ = csg_obj-&gt;createUniverse(&quot;lat_univ&quot;);
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSGUniverse&gt;&gt;&gt; univs = {{lat_univ}};
  auto &amp; outer_univ = csg_obj-&gt;createUniverse(&quot;outer_univ&quot;);
  std::unique_ptr&lt;CSGCartesianLattice&gt; lat_ptr =
      std::make_unique&lt;CSGCartesianLattice&gt;(&quot;lat1&quot;, 2.0, univs);
  const auto &amp; lat = csg_obj-&gt;addLattice(std::move(lat_ptr));
  csg_obj-&gt;setLatticeOuter(lat, outer_univ);
  csg_obj-&gt;createCell(&quot;cell_lat_fill&quot;, lat, -csg_sphere_outer);

  auto csg_obj_clone = csg_obj-&gt;clone();
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Add new surface to csg_obj, csg_obj and csg_obj_clone should no longer be equal
  std::unique_ptr&lt;CSG::CSGSurface&gt; sphere_ptr_new =
      std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);

  // Add same surface to cloned csg_obj, so that csg_obj and csg_obj_clone are equal again
  sphere_ptr_new = std::make_unique&lt;CSG::CSGSphere&gt;(&quot;new_surf&quot;, 6.0);
  csg_obj_clone-&gt;addSurface(std::move(sphere_ptr_new));
  ASSERT_TRUE(*csg_obj == *csg_obj_clone);

  // Reset outer universe in csg_obj and test equality of csg_obj and csg_obj_clone
  csg_obj-&gt;resetLatticeOuter(lat);
  ASSERT_TRUE(*csg_obj != *csg_obj_clone);
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="a7bdbc28-1625-493d-abcf-82486fe172de"><div class="modal-content"><h4>(moose/test/src/csg/ExampleCSGInfiniteSquareMeshGenerator.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ExampleCSGInfiniteSquareMeshGenerator.h&quot;
#include &quot;CSGBase.h&quot;
#include &quot;CSGPlane.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ExampleCSGInfiniteSquareMeshGenerator);

InputParameters
ExampleCSGInfiniteSquareMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();

  params.addRequiredParam&lt;Real&gt;(&quot;side_length&quot;, &quot;Side length of infinite square.&quot;);
  params.addParam&lt;MeshGeneratorName&gt;(
      &quot;fill&quot;, &quot;optional input lattice mesh generator to fill generated cell with.&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

ExampleCSGInfiniteSquareMeshGenerator::ExampleCSGInfiniteSquareMeshGenerator(
    const InputParameters &amp; params)
  : MeshGenerator(params),
    _side_length(getParam&lt;Real&gt;(&quot;side_length&quot;)),
    _input_fill_name(isParamValid(&quot;fill&quot;) ? getParam&lt;MeshGeneratorName&gt;(&quot;fill&quot;) : &quot;&quot;),
    _has_fill(isParamValid(&quot;fill&quot;))
{
  if (_has_fill)
  {
    _input_fill_mg_ptr = &amp;getMesh(&quot;fill&quot;);
    _input_fill_csg = &amp;getCSGBase(&quot;fill&quot;);
  }
}

std::unique_ptr&lt;MeshBase&gt;
ExampleCSGInfiniteSquareMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
ExampleCSGInfiniteSquareMeshGenerator::generateCSG()
{
  // name of the current mesh generator to use for naming generated objects
  auto mg_name = this-&gt;name();

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();

  // Add surfaces and halfspaces corresponding to 4 planes of infinite square
  std::vector&lt;std::vector&lt;Point&gt;&gt; points_on_planes{{Point(1. * _side_length / 2., 0., 0.),
                                                    Point(1. * _side_length / 2., 1., 0.),
                                                    Point(1. * _side_length / 2., 0., 1.)},
                                                   {Point(-1. * _side_length / 2., 0., 0.),
                                                    Point(-1. * _side_length / 2., 1., 0.),
                                                    Point(-1. * _side_length / 2., 0., 1.)},
                                                   {Point(0., 1. * _side_length / 2., 0.),
                                                    Point(1., 1. * _side_length / 2., 0.),
                                                    Point(0., 1. * _side_length / 2., 1.)},
                                                   {Point(0., -1. * _side_length / 2., 0.),
                                                    Point(1., -1. * _side_length / 2., 0.),
                                                    Point(0., -1. * _side_length / 2., 1.)}};
  std::vector&lt;std::string&gt; surf_names{&quot;plus_x&quot;, &quot;minus_x&quot;, &quot;plus_y&quot;, &quot;minus_y&quot;};

  // initialize cell region to be updated
  CSG::CSGRegion region;

  // set the center of the prism to be used for determining half-spaces
  const auto centroid = Point(0, 0, 0);

  for (unsigned int i = 0; i &lt; points_on_planes.size(); ++i)
  {
    // object name includes the mesh generator name for uniqueness
    const auto surf_name = mg_name + &quot;_surf_&quot; + surf_names[i];
    // create the plane for one face of the prism
    std::unique_ptr&lt;CSG::CSGSurface&gt; plane_ptr = std::make_unique&lt;CSG::CSGPlane&gt;(
        surf_name, points_on_planes[i][0], points_on_planes[i][1], points_on_planes[i][2]);
    auto &amp; csg_plane = csg_obj-&gt;addSurface(std::move(plane_ptr));
    // determine where the plane is in relation to the centroid to be able to set the half-space
    const auto region_direction = csg_plane.getHalfspaceFromPoint(centroid);
    // half-space is either positive (+plane_ptr) or negative (-plane_ptr)
    // depending on the direction to the centroid
    auto halfspace =
        ((region_direction == CSG::CSGSurface::Halfspace::POSITIVE) ? +csg_plane : -csg_plane);
    // check if this is the first half-space to be added to the region,
    // if not, update the existing region with the intersection of the regions (&amp;=)
    if (region.getRegionType() == CSG::CSGRegion::RegionType::EMPTY)
      region = halfspace;
    else
      region &amp;= halfspace;
  }

  // create the cell defined by the surfaces and region just created
  const auto cell_name = mg_name + &quot;_square_cell&quot;;
  // determine fill: either from input fill mesh generator or default material
  if (_has_fill)
  {
    // join the fill CSGBase into the current CSGBase &amp; use the lattice as the fill
    csg_obj-&gt;joinOtherBase(std::move(*_input_fill_csg));
    // assume input MG is a lattice type for sake of this example/test
    const CSG::CSGLattice &amp; lattice = csg_obj-&gt;getLatticeByName(_input_fill_name + &quot;_lattice&quot;);
    csg_obj-&gt;createCell(cell_name, lattice, region);
  }
  else // default material fill
  {
    const auto material_name = &quot;square_material&quot;;
    csg_obj-&gt;createCell(cell_name, material_name, region);
  }

  return csg_obj;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="2d224f15-6c5f-43ab-b439-6d5e106bf862"><div class="modal-content"><h4>(moose/test/src/csg/TestCSGAxialSurfaceMeshGenerator.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;TestCSGAxialSurfaceMeshGenerator.h&quot;
#include &quot;MeshGenerator.h&quot;
#include &quot;CSGPlane.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, TestCSGAxialSurfaceMeshGenerator);

InputParameters
TestCSGAxialSurfaceMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();
  // input parameter that is an existing mesh generator
  params.addRequiredParam&lt;MeshGeneratorName&gt;(&quot;input&quot;, &quot;The input MeshGenerator.&quot;);
  // additional params for this specific mesh generator
  params.addRequiredParam&lt;Real&gt;(&quot;axial_height&quot;, &quot;Axial height of the model.&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

TestCSGAxialSurfaceMeshGenerator::TestCSGAxialSurfaceMeshGenerator(const InputParameters &amp; params)
  : MeshGenerator(params),
    _mesh_ptr(getMesh(&quot;input&quot;)),
    _axial_height(getParam&lt;Real&gt;(&quot;axial_height&quot;))
{
  _build_csg = &amp;getCSGBase(&quot;input&quot;);
}

std::unique_ptr&lt;MeshBase&gt;
TestCSGAxialSurfaceMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
TestCSGAxialSurfaceMeshGenerator::generateCSG()
{
  // get the existing CSGBase associated with the input mesh generator
  // this is the CSGBase object that will be updated
  std::unique_ptr&lt;CSG::CSGBase&gt; csg_obj = std::move(*_build_csg);

  // get the names of the current mesh generator and the input mesh generator
  // so that unique object naming can be enforced
  auto mg_name = this-&gt;name();
  auto inp_name = getParam&lt;MeshGeneratorName&gt;(&quot;input&quot;);

  // get the expected existing cell
  const auto cell_name = inp_name + &quot;_square_cell&quot;;
  const auto &amp; csg_cell = csg_obj-&gt;getCellByName(cell_name);

  // get the existing cell region to update
  auto cell_region = csg_cell.getRegion();

  // centroid used to determine direction for half-space
  const auto centroid = Point(0, 0, 0);

  // setting a default surface name purely for testing purposes
  const auto default_surf_name = &quot;default_surf&quot;;

  // Add surfaces and halfspaces corresponding to top and bottom axial planes
  std::vector&lt;std::string&gt; surf_names{&quot;plus_z&quot;, &quot;minus_z&quot;};
  std::vector&lt;Real&gt; coeffs{0.5 * _axial_height, -0.5 * _axial_height};
  for (unsigned int i = 0; i &lt; coeffs.size(); ++i)
  {
    // create a plane using the coefficients for the equation of a plane
    // z plane equation: 0.0*x + 0.0*y + 1.0*z = (+/-)0.5 * axial_height
    std::unique_ptr&lt;CSG::CSGSurface&gt; surface_ptr =
        std::make_unique&lt;CSG::CSGPlane&gt;(default_surf_name, 0.0, 0.0, 1.0, coeffs[i]);
    auto &amp; csg_plane = csg_obj-&gt;addSurface(std::move(surface_ptr));

    // Rename surface so that it has a unique surface name based on the mesh generator
    const auto surf_name = mg_name + &quot;_surf_&quot; + surf_names[i];
    csg_obj-&gt;renameSurface(csg_plane, surf_name);

    // determine the half-space to add as an updated intersection
    const auto region_direction = csg_plane.getHalfspaceFromPoint(centroid);
    auto halfspace =
        ((region_direction == CSG::CSGSurface::Halfspace::POSITIVE) ? +csg_plane : -csg_plane);

    // update the existing region with a half-space
    cell_region &amp;= halfspace;
  }

  // set the new region for the existing cell
  csg_obj-&gt;updateCellRegion(csg_cell, cell_region);

  // Rename cell as it now defines a box region instead of an infinite square region
  csg_obj-&gt;renameCell(csg_cell, mg_name + &quot;_box_cell&quot;);

  return csg_obj;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="55e8dd35-df8b-4b23-9ded-0a87ffcbce6b"><div class="modal-content"><h4>(moose/test/tests/csg/csg_only_chained.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  [inf_square]
    type = ExampleCSGInfiniteSquareMeshGenerator
    side_length = 4
  []
  [cube]
    type = TestCSGAxialSurfaceMeshGenerator
    input = inf_square
    axial_height = 5
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="2247476e-b00f-4f1f-85ac-fb03c0ce554f"><div class="modal-content"><h4>(moose/test/tests/csg/gold/csg_only_chained_out_csg.json)</h4><pre style="max-height:350px;"><code class="language-text">{
  &quot;cells&quot;: {
    &quot;cube_box_cell&quot;: {
      &quot;fill&quot;: &quot;square_material&quot;,
      &quot;filltype&quot;: &quot;CSG_MATERIAL&quot;,
      &quot;region_infix&quot;: [
        &quot;+inf_square_surf_plus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-inf_square_surf_minus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-inf_square_surf_plus_y&quot;,
        &quot;&amp;&quot;,
        &quot;+inf_square_surf_minus_y&quot;,
        &quot;&amp;&quot;,
        &quot;-cube_surf_plus_z&quot;,
        &quot;&amp;&quot;,
        &quot;+cube_surf_minus_z&quot;
      ],
      &quot;region_postfix&quot;: [
        &quot;inf_square_surf_plus_x&quot;,
        &quot;+&quot;,
        &quot;inf_square_surf_minus_x&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;inf_square_surf_plus_y&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;inf_square_surf_minus_y&quot;,
        &quot;+&quot;,
        &quot;&amp;&quot;,
        &quot;cube_surf_plus_z&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;cube_surf_minus_z&quot;,
        &quot;+&quot;,
        &quot;&amp;&quot;
      ]
    }
  },
  &quot;surfaces&quot;: {
    &quot;cube_surf_minus_z&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 1.0,
        &quot;d&quot;: -2.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;cube_surf_plus_z&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 1.0,
        &quot;d&quot;: 2.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;inf_square_surf_minus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;inf_square_surf_minus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;inf_square_surf_plus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;inf_square_surf_plus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    }
  },
  &quot;universes&quot;: {
    &quot;ROOT_UNIVERSE&quot;: {
      &quot;cells&quot;: [
        &quot;cube_box_cell&quot;
      ],
      &quot;root&quot;: true
    }
  }
}</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="086ec885-5a57-405e-bfdc-50618c54a79b"><div class="modal-content"><h4>(moose/test/src/csg/TestCSGLatticeMeshGenerator.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;TestCSGLatticeMeshGenerator.h&quot;
#include &quot;MeshGenerator.h&quot;
#include &quot;CSGPlane.h&quot;
#include &quot;CSGCartesianLattice.h&quot;
#include &quot;CSGHexagonalLattice.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, TestCSGLatticeMeshGenerator);

InputParameters
TestCSGLatticeMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();
  // input parameter that is an existing mesh generator
  params.addRequiredParam&lt;std::vector&lt;MeshGeneratorName&gt;&gt;(
      &quot;inputs&quot;,
      &quot;The MeshGenerators that form the components of the lattice. Order of inputs corresponds to &quot;
      &quot;the associated integer ID for the pattern (i.e., 0 for first input, 1 for second input, &quot;
      &quot;etc.)&quot;);
  params.addRequiredParam&lt;std::string&gt;(
      &quot;lattice_type&quot;, &quot;The type of lattice to create. Options are &#x27;cartesian&#x27; and &#x27;hexagonal&#x27;.&quot;);
  params.addRequiredParam&lt;Real&gt;(&quot;pitch&quot;,
                                &quot;The pitch (flat-to-flat distance) of each lattice element.&quot;);
  params.addRequiredParam&lt;std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;(
      &quot;pattern&quot;,
      &quot;A double-indexed array starting with the upper-left corner where the index&quot;
      &quot;represents the index of the mesh/CSG generator in the &#x27;inputs&#x27; vector&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

TestCSGLatticeMeshGenerator::TestCSGLatticeMeshGenerator(const InputParameters &amp; params)
  : MeshGenerator(params),
    _lattice_type(getParam&lt;std::string&gt;(&quot;lattice_type&quot;)),
    _pitch(getParam&lt;Real&gt;(&quot;pitch&quot;)),
    _input_names(getParam&lt;std::vector&lt;MeshGeneratorName&gt;&gt;(&quot;inputs&quot;)),
    _mesh_ptrs(getMeshes(&quot;inputs&quot;)),
    _pattern(getParam&lt;std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;(&quot;pattern&quot;))
{
  for (auto inp : _input_names)
    _input_csgs.push_back(&amp;getCSGBaseByName(inp));
}

std::unique_ptr&lt;MeshBase&gt;
TestCSGLatticeMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
TestCSGLatticeMeshGenerator::generateCSG()
{
  // create a new CSGBase object to build the lattice in
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();
  // get the name of the current mesh generator
  auto mg_name = this-&gt;name();

  // join each input CSGBase into the new CSGBase as a unique universe
  std::unordered_map&lt;unsigned int, std::string&gt; univ_id_names;
  for (const auto i : index_range(_input_names))
  {
    std::string join_name = _input_names[i] + &quot;_univ&quot;;
    csg_obj-&gt;joinOtherBase(std::move(*_input_csgs[i]), join_name);
    univ_id_names[i] = join_name;
  }

  // build the universe pattern for the lattice using the input pattern
  std::vector&lt;std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt;&gt; universe_pattern;
  for (const auto &amp; row : _pattern)
  {
    std::vector&lt;std::reference_wrapper&lt;const CSG::CSGUniverse&gt;&gt; universe_row;
    for (const auto univ_id : row)
    {
      const auto &amp; univ = csg_obj-&gt;getUniverseByName(univ_id_names[univ_id]);
      universe_row.push_back(univ);
    }
    universe_pattern.push_back(universe_row);
  }

  // create the lattice based on the specified type
  std::string lat_name = mg_name + &quot;_lattice&quot;;
  if (_lattice_type == &quot;cartesian&quot;)
  {
    std::unique_ptr&lt;CSG::CSGCartesianLattice&gt; lat_ptr =
        std::make_unique&lt;CSG::CSGCartesianLattice&gt;(lat_name, _pitch, universe_pattern);
    csg_obj-&gt;addLattice&lt;CSG::CSGCartesianLattice&gt;(std::move(lat_ptr));
  }
  else if (_lattice_type == &quot;hexagonal&quot;)
  {
    std::unique_ptr&lt;CSG::CSGHexagonalLattice&gt; lat_ptr =
        std::make_unique&lt;CSG::CSGHexagonalLattice&gt;(lat_name, _pitch, universe_pattern);
    csg_obj-&gt;addLattice&lt;CSG::CSGHexagonalLattice&gt;(std::move(lat_ptr));
  }
  return csg_obj;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="7eff8be8-2f25-4f60-a75c-d7dc3b8a61bf"><div class="modal-content"><h4>(moose/test/tests/csg/csg_lattice_cart.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  [sq1]
    type = ExampleCSGInfiniteSquareMeshGenerator
    side_length = 4
  []
  [sq2]
    type = ExampleCSGInfiniteSquareMeshGenerator
    side_length = 3
  []
  [cart_lat]
    type = TestCSGLatticeMeshGenerator
    lattice_type = &#x27;cartesian&#x27;
    inputs = &#x27;sq1 sq2&#x27;
    pattern = &#x27;0 0;
               0 1&#x27;
    pitch = 5
  []
  [sq3]
      type = ExampleCSGInfiniteSquareMeshGenerator
      side_length = 15
      fill = &#x27;cart_lat&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="63ce1e63-f96c-48a6-be96-89cad93db6c5"><div class="modal-content"><h4>(moose/test/tests/csg/gold/csg_lattice_cart_out_csg.json)</h4><pre style="max-height:350px;"><code class="language-text">{
  &quot;cells&quot;: {
    &quot;sq1_square_cell&quot;: {
      &quot;fill&quot;: &quot;square_material&quot;,
      &quot;filltype&quot;: &quot;CSG_MATERIAL&quot;,
      &quot;region_infix&quot;: [
        &quot;+sq1_surf_plus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-sq1_surf_minus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-sq1_surf_plus_y&quot;,
        &quot;&amp;&quot;,
        &quot;+sq1_surf_minus_y&quot;
      ],
      &quot;region_postfix&quot;: [
        &quot;sq1_surf_plus_x&quot;,
        &quot;+&quot;,
        &quot;sq1_surf_minus_x&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;sq1_surf_plus_y&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;sq1_surf_minus_y&quot;,
        &quot;+&quot;,
        &quot;&amp;&quot;
      ]
    },
    &quot;sq2_square_cell&quot;: {
      &quot;fill&quot;: &quot;square_material&quot;,
      &quot;filltype&quot;: &quot;CSG_MATERIAL&quot;,
      &quot;region_infix&quot;: [
        &quot;+sq2_surf_plus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-sq2_surf_minus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-sq2_surf_plus_y&quot;,
        &quot;&amp;&quot;,
        &quot;+sq2_surf_minus_y&quot;
      ],
      &quot;region_postfix&quot;: [
        &quot;sq2_surf_plus_x&quot;,
        &quot;+&quot;,
        &quot;sq2_surf_minus_x&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;sq2_surf_plus_y&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;sq2_surf_minus_y&quot;,
        &quot;+&quot;,
        &quot;&amp;&quot;
      ]
    },
    &quot;sq3_square_cell&quot;: {
      &quot;fill&quot;: &quot;cart_lat_lattice&quot;,
      &quot;filltype&quot;: &quot;LATTICE&quot;,
      &quot;region_infix&quot;: [
        &quot;+sq3_surf_plus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-sq3_surf_minus_x&quot;,
        &quot;&amp;&quot;,
        &quot;-sq3_surf_plus_y&quot;,
        &quot;&amp;&quot;,
        &quot;+sq3_surf_minus_y&quot;
      ],
      &quot;region_postfix&quot;: [
        &quot;sq3_surf_plus_x&quot;,
        &quot;+&quot;,
        &quot;sq3_surf_minus_x&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;sq3_surf_plus_y&quot;,
        &quot;-&quot;,
        &quot;&amp;&quot;,
        &quot;sq3_surf_minus_y&quot;,
        &quot;+&quot;,
        &quot;&amp;&quot;
      ]
    }
  },
  &quot;lattices&quot;: {
    &quot;cart_lat_lattice&quot;: {
      &quot;attributes&quot;: {
        &quot;ncol&quot;: 2,
        &quot;nrow&quot;: 2,
        &quot;pitch&quot;: 5.0
      },
      &quot;outertype&quot;: &quot;VOID&quot;,
      &quot;type&quot;: &quot;CSG::CSGCartesianLattice&quot;,
      &quot;universes&quot;: [
        [
          &quot;sq1_univ&quot;,
          &quot;sq1_univ&quot;
        ],
        [
          &quot;sq1_univ&quot;,
          &quot;sq2_univ&quot;
        ]
      ]
    }
  },
  &quot;surfaces&quot;: {
    &quot;sq1_surf_minus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq1_surf_minus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq1_surf_plus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq1_surf_plus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 2.0
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq2_surf_minus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 1.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq2_surf_minus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -1.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq2_surf_plus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -1.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq2_surf_plus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 1.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq3_surf_minus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 7.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq3_surf_minus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -7.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq3_surf_plus_x&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: -1.0,
        &quot;b&quot;: 0.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: -7.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    },
    &quot;sq3_surf_plus_y&quot;: {
      &quot;coefficients&quot;: {
        &quot;a&quot;: 0.0,
        &quot;b&quot;: 1.0,
        &quot;c&quot;: 0.0,
        &quot;d&quot;: 7.5
      },
      &quot;type&quot;: &quot;CSG::CSGPlane&quot;
    }
  },
  &quot;universes&quot;: {
    &quot;ROOT_UNIVERSE&quot;: {
      &quot;cells&quot;: [
        &quot;sq3_square_cell&quot;
      ],
      &quot;root&quot;: true
    },
    &quot;sq1_univ&quot;: {
      &quot;cells&quot;: [
        &quot;sq1_square_cell&quot;
      ]
    },
    &quot;sq2_univ&quot;: {
      &quot;cells&quot;: [
        &quot;sq2_square_cell&quot;
      ]
    }
  }
}</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
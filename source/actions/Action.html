<!DOCTYPE html><head><meta charset="UTF-8"><title>MOOSE Action System | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="9a746a45-860f-4f11-8c8e-1dfd2b7cffd0" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="53fa185c-7f58-4f07-9f44-fc25b24c5a4a" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="84ee794e-55d7-4dc6-ae61-a7feff1ba949" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="99986969-e507-4682-a639-80bf1f6bb3d4" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="d0c18569-63f1-4bfc-8c8e-82eae343c42f"><i class="material-icons">menu</i></a><ul class="sidenav" id="d0c18569-63f1-4bfc-8c8e-82eae343c42f"><li><a href="#!" class="dropdown-trigger" data-target="e94fe674-2242-4fef-a48a-d18fc513e1c5" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9ba3afc5-9cff-435b-ba66-0c49df89177e" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="746e0171-ba73-4b00-8772-344f21716d7e" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8e700889-8279-49ca-85ae-f8479d49d706" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="9a746a45-860f-4f11-8c8e-1dfd2b7cffd0"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="53fa185c-7f58-4f07-9f44-fc25b24c5a4a"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="84ee794e-55d7-4dc6-ae61-a7feff1ba949"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="99986969-e507-4682-a639-80bf1f6bb3d4"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="e94fe674-2242-4fef-a48a-d18fc513e1c5"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="9ba3afc5-9cff-435b-ba66-0c49df89177e"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="746e0171-ba73-4b00-8772-344f21716d7e"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="8e700889-8279-49ca-85ae-f8479d49d706"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="951a97da-e55e-4d9a-bf6d-4516681512e0" data-section-level="1" data-section-text="MOOSE Action System"><h1 id="moose-action-system">MOOSE Action System</h1><p>MOOSE <em>Actions</em> are used to execute <em>tasks</em>. Each application registers numerous <em>actions</em>, <em>tasks</em>, and <em>syntax</em>. Each task is associated with one or more actions, and each action may perform one or more tasks. Syntax is used by the input file parser to generate actions.</p><p>Common uses for actions are to perform setup and create MOOSE objects.</p><section id="3e75bf76-3ce7-4eda-bf3d-62813f5aeaf4" data-section-level="2" data-section-text="Creating Actions"><h2 id="creating-actions">Creating Actions</h2><p>To create a new action, first derive from the appropriate base class: if the new action is to correspond to creating MOOSE objects from an input file, then derive from <code>MooseObjectAction</code>; else, derive from <code>Action</code>.</p><p>The <code>act()</code> method must be implemented to perform the associated task(s). If the action will be registered to multiple tasks, then the variable <code>_current_task</code> can be queried to determine the current task, for example,</p><pre style="max-height:350px;"><code class="language-cpp">
void
ExampleAction::act()
{
  if (_current_task == &quot;example_task_a&quot;)
  {
    // &quot;example_task_a&quot; execution
  }
  else if (_current_task == &quot;example_task_b&quot;)
  {
    // &quot;example_task_b&quot; execution
  }
}
</code></pre><p><code>MooseObjectAction</code>s, have the member variables <code>_type</code> and <code>_moose_object_pars</code>, which correspond to the type and <a href="../utils/InputParameters.html">InputParameters</a> of the MOOSE object to be created, respectively. For example, the action to create a BC object has the following <code>act()</code> method:</p><pre style="max-height:350px;"><code class="language-cpp">void
AddBCAction::act()
{
#ifdef MOOSE_KOKKOS_ENABLED
  if (_moose_object_pars.isKokkosObject())
    _problem-&gt;addKokkosBoundaryCondition(_type, _name, _moose_object_pars);
  else
#endif
    _problem-&gt;addBoundaryCondition(_type, _name, _moose_object_pars);
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#953eafc1-c485-4563-8d6b-d70b58b6f736">(moose/framework/src/actions/AddBCAction.C)</a><p>The action should be registered to one or more tasks using the <code>registerMooseAction</code> macro (conventionally in the action source file), for example,</p><pre style="max-height:350px;"><code class="language-cpp">
registerMooseAction(&quot;ExampleApp&quot;, ExampleAction, &quot;example_task_a&quot;);
registerMooseAction(&quot;ExampleApp&quot;, ExampleAction, &quot;example_task_b&quot;);
</code></pre></section><section id="f3335f97-e539-487d-a32c-422820b53ef6" data-section-level="2" data-section-text="Registering Tasks"><h2 id="registering_tasks">Registering Tasks</h2><p>Like MOOSE objects, tasks and syntax are registered in an application&#x27;s constructor, conventionally from a static method called <code>registerAll</code>. MOOSE&#x27;s tasks, actions, and syntax are defined in <a class="moose-source-filename tooltipped modal-trigger" href="#285a95a4-fd06-4171-a706-c5338634c5f2">Moose.C</a>, for example.</p><p>Several macros are relevant for registration of tasks and syntax.</p><p>Tasks must be registered using the <code>registerTask</code> macro:</p><pre style="max-height:350px;"><code class="language-cpp">
registerTask(&quot;task_name&quot;, is_required)
</code></pre><p>where <code>task_name</code> is the name of the new task, and <code>is_required</code> should be set to <code>true</code> if the task is required by the application. A required task always has all of its associated actions executed, even if no syntax triggers it.</p><p>Tasks may have dependencies between them. The macro <code>addTaskDependency</code> is used to declare that a task depends on another, for example,</p><pre style="max-height:350px;"><code class="language-cpp">
addTaskDependency(&quot;secondary_task&quot;, &quot;primary_task&quot;)
</code></pre><p>Here a task called &quot;secondary_task&quot; will be executed sometime after the task called &quot;primary_task&quot;.</p></section><section id="38f1bea0-1010-4dad-a64a-d714e09da4ec" data-section-level="2" data-section-text="Registering Syntax"><h2 id="registering_syntax">Registering Syntax</h2><p>There are two macros associated with registering syntax to an action/task: <code>registerSyntax</code> and <code>registerSyntaxTask</code>:</p><pre style="max-height:350px;"><code class="language-cpp">
registerSyntax(action, syntax);
registerSyntaxTask(action, syntax, task);
</code></pre><p>The difference between these is only apparent when the action has more than one task registered to it; in this case, the additional argument in <code>registerSyntaxTask</code> specifies which task of the specified action to execute.</p><p>For example, the <a href="AddKernelAction.html">AddKernelAction</a> is registered to tasks for adding kernels and aux kernels:</p><pre style="max-height:350px;"><code class="language-cpp">
registerSyntaxTask(&quot;AddKernelAction&quot;, &quot;Kernels/*&quot;, &quot;add_kernel&quot;);
registerSyntaxTask(&quot;AddKernelAction&quot;, &quot;AuxKernels/*&quot;, &quot;add_aux_kernel&quot;);
</code></pre><p>The syntax need not be associated only to sub-blocks in the input file. For example, the existence of a <code>Mesh</code> block triggers <a href="SetupMeshCompleteAction.html">SetupMeshCompleteAction</a>:</p><pre style="max-height:350px;"><code class="language-cpp">
registerSyntax(&quot;SetupMeshCompleteAction&quot;, &quot;Mesh&quot;);
</code></pre><p>Also, note that actions do not necessarily require registration of any associated syntax to execute a task: if that task is registered as required, then the action always will be built:</p><pre style="max-height:350px;"><code class="language-cpp">
registerTask(&quot;task_name&quot;, true);
</code></pre></section><section id="1186316d-502a-4ad2-87e7-fa25ec6e7230" data-section-level="2" data-section-text="How Actions Are Built"><h2 id="how-actions-are-built">How Actions Are Built</h2><p>The input file parser creates actions by finding actions/tasks that are associated to a given syntax via the syntax registration calls (see <a href="Action.html#registering_syntax">Registering Syntax</a>). After these actions are created, other actions may be &quot;auto-built&quot; to satisfy unsatisfied <em>required</em> (see <a href="Action.html#registering_tasks">Registering Tasks</a>) tasks: the tasks are sorted via the dependency resolver, using the registered dependencies between them, and then for each unsatisfied, required task, a loop over all of the actions registered to that task is performed:</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-text">Auto-build algorithm</span></p><div class="moose-algorithm"><div class="moose-algorithm-line"><span><span style="font-size:80%">1: </span>&nbsp;<strong>for</strong> each unsatisfied, required task <span class="moose-katex-inline-equation" id="moose-equation-7e03af78-2ba2-401b-81c1-4fa352bfc498"><script>var element = document.getElementById("moose-equation-7e03af78-2ba2-401b-81c1-4fa352bfc498");katex.render("T", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> <strong>do</strong></span><span></span></div> <div class="moose-algorithm-line"><span><span style="font-size:80%">2: </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>for</strong> each action <span class="moose-katex-inline-equation" id="moose-equation-94f276a7-1515-477f-97ab-5e9b130370e8"><script>var element = document.getElementById("moose-equation-94f276a7-1515-477f-97ab-5e9b130370e8");katex.render("A", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> registered to <span class="moose-katex-inline-equation" id="moose-equation-a81a763e-ef7b-4117-8806-a53075a81611"><script>var element = document.getElementById("moose-equation-a81a763e-ef7b-4117-8806-a53075a81611");katex.render("T", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> <strong>do</strong></span><span></span></div> <div class="moose-algorithm-line"><span><span style="font-size:80%">3: </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>if</strong> all required parameters of <span class="moose-katex-inline-equation" id="moose-equation-bfc03e4d-c715-4386-9a7f-704ab16e12fc"><script>var element = document.getElementById("moose-equation-bfc03e4d-c715-4386-9a7f-704ab16e12fc");katex.render("A", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> are valid <strong>then</strong></span><span></span></div> <div class="moose-algorithm-line"><span><span style="font-size:80%">4: </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;build <span class="moose-katex-inline-equation" id="moose-equation-3d8e4fa4-ff68-4cfc-bef5-1e27731396dd"><script>var element = document.getElementById("moose-equation-3d8e4fa4-ff68-4cfc-bef5-1e27731396dd");katex.render("A", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></span><span></span></div> <div class="moose-algorithm-line"><span><span style="font-size:80%">5: </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>end if</strong></span><span></span></div> <div class="moose-algorithm-line"><span><span style="font-size:80%">6: </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>end for</strong></span><span></span></div> <div class="moose-algorithm-line"><span><span style="font-size:80%">7: </span>&nbsp;<strong>end for</strong></span><span></span></div></div></div></div><p>Note that there is no &quot;break&quot; statement after &quot;build <span class="moose-katex-inline-equation" id="moose-equation-aa2c3563-3a4f-4f17-998f-3b1885d52c42"><script>var element = document.getElementById("moose-equation-aa2c3563-3a4f-4f17-998f-3b1885d52c42");katex.render("A", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>&quot;; that is, the auto-building of actions does not stop after the first action has been built.</p></section><section id="da805407-b56b-490d-829c-f0d553db472d" data-section-level="2" data-section-text="Relationship Managers and Actions"><h2 id="relationship-managers-and-actions">Relationship Managers and Actions</h2><p>If adding any <code>MooseObjects</code> in a custom action and those objects have associated relationship managers, then the <code>addRelationshipManagers(Moose::RelationshipManagerType input_rm_type)</code> must be overridden. Both the <code>ContactAction</code> in the contact module, and <code>PorousFlowActionBase</code> in the porous flow module provide examples of overriding this method. For the reasons behind why this must be done in the action system, please see <a href="../relationshipmanagers/RelationshipManager.html#rm_action">Relationship Managers and Actions</a>.</p></section><section id="3a3a0f81-016c-464e-8400-21bc62a1e88c" data-section-level="2" data-section-text="Controlling Action Parameters"><h2 id="controlling-action-parameters">Controlling Action Parameters</h2><p>Action parameters can be controlled like other MOOSE object parameters. See <a href="../../syntax/Controls/index.html#controllable_params_added_by_actions">Controllable Parameters Added by Actions</a> for more information.</p></section><section id="419433e1-2c11-454c-9d4b-cbbc19bc1fab" data-section-level="2" data-section-text="Troubleshooting Actions"><h2 id="troubleshooting-actions">Troubleshooting Actions</h2><p>There are two debugging flags that are particularly useful for troubleshooting actions/tasks:</p><ul class="browser-default"><li><p><code>show_actions</code>: show the list of actions as they execute (in order). </p></li><li><p><code>show_action_dependencies</code>: show the action dependency sets generated by the task dependency resolution, with the groups ordered by execution.</p></li></ul><p>These flags are used in a <code>Debug</code> block:</p><pre style="max-height:350px;"><code class="language-text">
[Debug]
  show_actions = true
  show_action_dependencies = true
[]
</code></pre></section><section id="bd9eb7fd-2a8d-4088-8ae7-0b22a7bc94ba" data-section-level="2" data-section-text="Additional Notes"><h2 id="additional-notes">Additional Notes</h2><p>The following is a list of miscellaneous notes that may be useful to advanced developers:</p><ul class="browser-default"><li><p>The lifetime of actions is the entire simulation. </p></li><li><p>Actions can be obtained via the <code>ActionWarehouse</code> with methods such as <code>getAction</code>, <code>getActions</code>, etc. </p></li><li><p>Actions may be added by other actions, but the added action will only execute for tasks occurring after the task in which the action is added.</p></li></ul></section></section><div class="moose-modal modal" id="953eafc1-c485-4563-8d6b-d70b58b6f736"><div class="modal-content"><h4>(moose/framework/src/actions/AddBCAction.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AddBCAction.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;BoundaryCondition.h&quot;

registerMooseAction(&quot;MooseApp&quot;, AddBCAction, &quot;add_bc&quot;);

InputParameters
AddBCAction::validParams()
{
  InputParameters params = MooseObjectAction::validParams();
  params.addClassDescription(&quot;Add a BoundaryCondition object to the simulation.&quot;);
  return params;
}

AddBCAction::AddBCAction(const InputParameters &amp; params) : MooseObjectAction(params) {}

void
AddBCAction::act()
{
#ifdef MOOSE_KOKKOS_ENABLED
  if (_moose_object_pars.isKokkosObject())
    _problem-&gt;addKokkosBoundaryCondition(_type, _name, _moose_object_pars);
  else
#endif
    _problem-&gt;addBoundaryCondition(_type, _name, _moose_object_pars);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="285a95a4-fd06-4171-a706-c5338634c5f2"><div class="modal-content"><h4>(moose/framework/src/base/Moose.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;libmesh/petsc_macro.h&quot;
#include &quot;libmesh/libmesh_config.h&quot;

#include &quot;Moose.h&quot;
#include &quot;MooseApp.h&quot;

#include &quot;ActionWarehouse.h&quot;
#include &quot;ActionFactory.h&quot;
#include &quot;AuxiliarySystem.h&quot;
#include &quot;Factory.h&quot;
#include &quot;PetscSupport.h&quot;
#include &quot;Syntax.h&quot;
#include &quot;MooseSyntax.h&quot;
#include &quot;ExecFlagRegistry.h&quot;

#include &quot;hit/parse.h&quot;

#include &lt;unistd.h&gt;

const ExecFlagType EXEC_NONE = registerDefaultExecFlag(&quot;NONE&quot;);
const ExecFlagType EXEC_INITIAL = registerDefaultExecFlag(&quot;INITIAL&quot;);
const ExecFlagType EXEC_LINEAR = registerDefaultExecFlag(&quot;LINEAR&quot;);
const ExecFlagType EXEC_LINEAR_CONVERGENCE = registerDefaultExecFlag(&quot;LINEAR_CONVERGENCE&quot;);
const ExecFlagType EXEC_NONLINEAR = registerDefaultExecFlag(&quot;NONLINEAR&quot;);
const ExecFlagType EXEC_NONLINEAR_CONVERGENCE = registerDefaultExecFlag(&quot;NONLINEAR_CONVERGENCE&quot;);
const ExecFlagType EXEC_POSTCHECK = registerDefaultExecFlag(&quot;POSTCHECK&quot;);
const ExecFlagType EXEC_TIMESTEP_END = registerDefaultExecFlag(&quot;TIMESTEP_END&quot;);
const ExecFlagType EXEC_TIMESTEP_BEGIN = registerDefaultExecFlag(&quot;TIMESTEP_BEGIN&quot;);
const ExecFlagType EXEC_MULTIAPP_FIXED_POINT_ITERATION_END =
    registerExecFlag(&quot;MULTIAPP_FIXED_POINT_ITERATION_END&quot;);
const ExecFlagType EXEC_MULTIAPP_FIXED_POINT_END =
    registerDefaultExecFlag(&quot;MULTIAPP_FIXED_POINT_END&quot;);
const ExecFlagType EXEC_MULTIAPP_FIXED_POINT_BEGIN =
    registerDefaultExecFlag(&quot;MULTIAPP_FIXED_POINT_BEGIN&quot;);
const ExecFlagType EXEC_MULTIAPP_FIXED_POINT_CONVERGENCE =
    registerDefaultExecFlag(&quot;MULTIAPP_FIXED_POINT_CONVERGENCE&quot;);
const ExecFlagType EXEC_FINAL = registerDefaultExecFlag(&quot;FINAL&quot;);
const ExecFlagType EXEC_FORCED = registerExecFlag(&quot;FORCED&quot;);
const ExecFlagType EXEC_FAILED = registerExecFlag(&quot;FAILED&quot;);
const ExecFlagType EXEC_CUSTOM = registerDefaultExecFlag(&quot;CUSTOM&quot;);
const ExecFlagType EXEC_SUBDOMAIN = registerExecFlag(&quot;SUBDOMAIN&quot;);
const ExecFlagType EXEC_ALWAYS = registerExecFlag(&quot;ALWAYS&quot;);
const ExecFlagType EXEC_PRE_DISPLACE = registerExecFlag(&quot;PRE_DISPLACE&quot;);
const ExecFlagType EXEC_SAME_AS_MULTIAPP = registerExecFlag(&quot;SAME_AS_MULTIAPP&quot;);
const ExecFlagType EXEC_PRE_MULTIAPP_SETUP = registerExecFlag(&quot;PRE_MULTIAPP_SETUP&quot;);
const ExecFlagType EXEC_TRANSFER = registerExecFlag(&quot;TRANSFER&quot;);
const ExecFlagType EXEC_PRE_KERNELS = registerExecFlag(&quot;PRE_KERNELS&quot;);
#ifdef LIBMESH_ENABLE_AMR
const ExecFlagType EXEC_POST_ADAPTIVITY = registerExecFlag(&quot;POST_ADAPTIVITY&quot;);
#endif

namespace Moose
{

void associateSyntaxInner(Syntax &amp; syntax, ActionFactory &amp; action_factory);

void
registerAll(Factory &amp; f, ActionFactory &amp; af, Syntax &amp; s)
{
  registerObjects(f, {&quot;MooseApp&quot;});
  associateSyntaxInner(s, af);
  registerActions(s, af, {&quot;MooseApp&quot;});
  registerAppDataFilePath(&quot;moose&quot;);
  registerRepository(&quot;moose&quot;, &quot;github.com/idaholab/moose&quot;);
}

void
registerObjects(Factory &amp; factory, const std::set&lt;std::string&gt; &amp; obj_labels)
{
  Registry::registerObjectsTo(factory, obj_labels);
}

void
addActionTypes(Syntax &amp; syntax)
{
  /**
   * The (optional) last param here indicates whether the task should trigger an Action auto-build.
   * If a task is marked as &quot;true&quot;. Then MOOSE will attempt to build the associated Action if one is
   * not supplied by some other means (usually through the input file or custom Action). Only
   * Actions that do not have required parameters and have defaults for all optional parameters can
   * be built automatically (See ActionWarehouse.C).
   *
   * Note: Many of the actions in the &quot;Minimal Problem&quot; section are marked as false.  However, we
   * can generally force creation of these &quot;Action&quot;s as needed by registering them to syntax that we
   * expect to see even if those &quot;Action&quot;s  don&#x27;t normally pick up parameters from the input file.
   */

  // clang-format off
  /**************************/
  /**** Register Actions ****/
  /**************************/
  registerMooseObjectTask(&quot;create_problem&quot;,               Problem,                   false);
  registerMooseObjectTask(&quot;setup_executioner&quot;,            Executioner,               false);
  registerMooseObjectTask(&quot;read_executor&quot;,                Executor,                  false);
  registerTask(&quot;add_executor&quot;, true);

  // TODO Organize these somewhere
  registerTask(&quot;init_physics&quot;, false);
  registerTask(&quot;init_component_physics&quot;, false);
  registerTask(&quot;meta_action_component&quot;, false);
  registerTask(&quot;setup_component&quot;, false);
  // &#x27;list_component&#x27; is used to retrieve ActionComponents for the syntax JSON
  registerTask(&quot;list_component&quot;, false);

  // This task does not construct an object, but it needs all of the parameters that
  // would normally be used to construct an object.
  registerMooseObjectTask(&quot;determine_system_type&quot;,        Executioner,               true);

  registerMooseObjectTask(&quot;setup_mesh&quot;,                   MooseMesh,                 false);
  registerMooseObjectTask(&quot;set_mesh_base&quot;,                MooseMesh,                 false);
  registerMooseObjectTask(&quot;init_mesh&quot;,                    MooseMesh,                 false);
  registerMooseObjectTask(&quot;add_mesh_generator&quot;,           MeshGenerator,             false);
  registerTask(&quot;create_added_mesh_generators&quot;, true);
  registerMooseObjectTask(&quot;append_mesh_generator&quot;,        MeshGenerator,             false);

  registerMooseObjectTask(&quot;add_kernel&quot;,                   Kernel,                    false);
  appendMooseObjectTask  (&quot;add_kernel&quot;,                   EigenKernel);
  appendMooseObjectTask  (&quot;add_kernel&quot;,                   VectorKernel);
  appendMooseObjectTask  (&quot;add_kernel&quot;,                   ArrayKernel);
  appendMooseObjectTask  (&quot;add_kernel&quot;,                   ADArrayKernel);

  registerMooseObjectTask(&quot;add_variable&quot;,                 MooseVariableBase,         false);
  registerMooseObjectTask(&quot;add_aux_variable&quot;,             MooseVariableBase,         false);
  registerMooseObjectTask(&quot;add_elemental_field_variable&quot;, MooseVariableBase,         false);
  registerMooseObjectTask(&quot;add_variables_physics&quot;,        MooseVariableBase,         false);

  registerMooseObjectTask(&quot;add_nodal_kernel&quot;,             NodalKernel,               false);

  registerMooseObjectTask(&quot;add_functor_material&quot;,         FunctorMaterial,           false);
  registerMooseObjectTask(&quot;add_material&quot;,                 MaterialBase,              false);
  appendDeprecatedMooseObjectTask(&quot;add_material&quot;,         FunctorMaterial);
  registerMooseObjectTask(&quot;add_materials_physics&quot;,        FunctorMaterial,           false);
  appendMooseObjectTask  (&quot;add_materials_physics&quot;,        MaterialBase);

  registerMooseObjectTask(&quot;add_bc&quot;,                       BoundaryCondition,         false);

  registerMooseObjectTask(&quot;add_function&quot;,                 Function,                  false);

  registerMooseObjectTask(&quot;add_distribution&quot;,             Distribution,              false);
  registerMooseObjectTask(&quot;add_sampler&quot;,                  Sampler,                   false);

  registerMooseObjectTask(&quot;add_aux_kernel&quot;,               AuxKernel,                 false);
  appendMooseObjectTask  (&quot;add_aux_kernel&quot;,               VectorAuxKernel);
  appendMooseObjectTask  (&quot;add_aux_kernel&quot;,               ArrayAuxKernel);

  registerMooseObjectTask(&quot;add_bound&quot;,                    Bounds,                    false);

  registerMooseObjectTask(&quot;add_scalar_kernel&quot;,            ScalarKernel,              false);
  registerMooseObjectTask(&quot;add_aux_scalar_kernel&quot;,        AuxScalarKernel,           false);
  registerMooseObjectTask(&quot;add_dirac_kernel&quot;,             DiracKernel,               false);
  appendMooseObjectTask  (&quot;add_dirac_kernel&quot;,             VectorDiracKernel);
  registerMooseObjectTask(&quot;add_dg_kernel&quot;,                DGKernel,                  false);
  registerMooseObjectTask(&quot;add_fv_kernel&quot;,                FVKernel,                  false);
  registerMooseObjectTask(&quot;add_linear_fv_kernel&quot;,         LinearFVKernel,            false);
  registerMooseObjectTask(&quot;add_fv_bc&quot;,                    FVBoundaryCondition,       false);
  registerMooseObjectTask(&quot;add_linear_fv_bc&quot;,             LinearFVBoundaryCondition, false);
  registerMooseObjectTask(&quot;add_fv_ik&quot;,                    FVInterfaceKernel,         false);
  registerMooseObjectTask(&quot;add_interface_kernel&quot;,         InterfaceKernel,           false);
  appendMooseObjectTask  (&quot;add_interface_kernel&quot;,         VectorInterfaceKernel);
  registerMooseObjectTask(&quot;add_constraint&quot;,               Constraint,                false);
  registerMooseObjectTask(&quot;add_hybridized_kernel&quot;,        HDGKernel,                 false);
  registerMooseObjectTask(&quot;add_hybridized_integrated_bc&quot;, HDGIntegratedBC,           false);

  registerMooseObjectTask(&quot;add_ic&quot;,                       InitialCondition,          false);
  appendMooseObjectTask  (&quot;add_ic&quot;,                       ScalarInitialCondition);
  registerMooseObjectTask(&quot;add_fv_ic&quot;,                    FVInitialCondition,        false);
  registerMooseObjectTask(&quot;add_ics_physics&quot;,              InitialCondition,          false);
  appendMooseObjectTask  (&quot;add_ics_physics&quot;,              FVInitialCondition);
  appendMooseObjectTask  (&quot;add_ics_physics&quot;,              ScalarInitialCondition);

  registerMooseObjectTask(&quot;add_damper&quot;,                   Damper,                    false);
  registerMooseObjectTask(&quot;setup_predictor&quot;,              Predictor,                 false);
  registerMooseObjectTask(&quot;add_time_steppers&quot;,            TimeStepper,               false);
  registerMooseObjectTask(&quot;add_time_stepper&quot;,             TimeStepper,               false);
  registerTask           (&quot;compose_time_stepper&quot;,                                    true);
  registerMooseObjectTask(&quot;setup_time_integrators&quot;,       TimeIntegrator,            false);
  registerMooseObjectTask(&quot;setup_time_integrator&quot;,        TimeIntegrator,            false);
  registerMooseObjectTask(&quot;add_convergence&quot;,              Convergence,            false);

  registerMooseObjectTask(&quot;add_preconditioning&quot;,          MoosePreconditioner,       false);
  registerMooseObjectTask(&quot;add_field_split&quot;,              Split,                     false);

  registerMooseObjectTask(&quot;add_mesh_division&quot;,            MeshDivision,              false);
  registerMooseObjectTask(&quot;add_user_object&quot;,              UserObject,                false);
  appendMooseObjectTask  (&quot;add_user_object&quot;,              Postprocessor);

  appendDeprecatedMooseObjectTask(&quot;add_user_object&quot;,      Corrector);
  registerMooseObjectTask(&quot;add_corrector&quot;,                Corrector,                 false);
  appendDeprecatedMooseObjectTask(&quot;add_user_object&quot;,      MeshModifier);
  registerMooseObjectTask(&quot;add_mesh_modifier&quot;,            MeshModifier,              false);

  registerMooseObjectTask(&quot;add_postprocessor&quot;,            Postprocessor,             false);
  registerMooseObjectTask(&quot;add_vector_postprocessor&quot;,     VectorPostprocessor,       false);
  registerMooseObjectTask(&quot;add_reporter&quot;,                 Reporter,                  false);

  registerMooseObjectTask(&quot;add_positions&quot;,                Positions,                 false);
  registerMooseObjectTask(&quot;add_times&quot;,                    Times,                     false);

  registerMooseObjectTask(&quot;add_indicator&quot;,                Indicator,                 false);
  registerMooseObjectTask(&quot;add_marker&quot;,                   Marker,                    false);

  registerMooseObjectTask(&quot;add_multi_app&quot;,                MultiApp,                  false);
  registerMooseObjectTask(&quot;add_transfer&quot;,                 Transfer,                  false);

  registerMooseObjectTask(&quot;add_output&quot;,                   Output,                    false);

  registerMooseObjectTask(&quot;add_control&quot;,                  Control,                   false);
  registerMooseObjectTask(&quot;add_chain_control&quot;,            ChainControl,              false);
  registerMooseObjectTask(&quot;add_partitioner&quot;,              MoosePartitioner,          false);

  // clang-format on

  registerTask(&quot;dynamic_object_registration&quot;, false);
  registerTask(&quot;common_output&quot;, true);
  registerTask(&quot;setup_recover_file_base&quot;, true);
  registerTask(&quot;recover_meta_data&quot;, true);

  registerTask(&quot;add_bounds_vectors&quot;, false);
  registerTask(&quot;add_periodic_bc&quot;, false);
  registerTask(&quot;add_aux_variable&quot;, false);
  registerTask(&quot;add_external_aux_variables&quot;, true);
  registerTask(&quot;add_variable&quot;, false);
  registerTask(&quot;add_mortar_variable&quot;, false);

  registerTask(&quot;execute_mesh_generators&quot;, true);
  registerTask(&quot;uniform_refine_mesh&quot;, false);
  registerTask(&quot;prepare_mesh&quot;, false);
  registerTask(&quot;delete_remote_elements_after_late_geometric_ghosting&quot;, false);
  registerTask(&quot;setup_mesh_complete&quot;, true); // calls prepare
  registerTask(&quot;post_mesh_prepared&quot;, false);
  registerTask(&quot;add_geometric_rm&quot;, false);
  registerTask(&quot;attach_geometric_rm&quot;, true);
  registerTask(&quot;attach_geometric_rm_final&quot;, true);

  registerTask(&quot;init_displaced_problem&quot;, false);

  registerTask(&quot;add_algebraic_rm&quot;, false);
  registerTask(&quot;attach_algebraic_rm&quot;, true);
  registerTask(&quot;add_coupling_rm&quot;, false);
  registerTask(&quot;attach_coupling_rm&quot;, true);
  registerTask(&quot;init_problem&quot;, true);
  registerTask(&quot;check_copy_nodal_vars&quot;, true);
  registerTask(&quot;copy_nodal_vars&quot;, true);
  registerTask(&quot;copy_nodal_aux_vars&quot;, true);
  registerTask(&quot;copy_vars_physics&quot;, false);
  registerTask(&quot;setup_postprocessor_data&quot;, false);
  registerTask(&quot;setup_time_steppers&quot;, true);

  registerTask(&quot;setup_dampers&quot;, true);
  registerTask(&quot;check_integrity&quot;, true);
  registerTask(&quot;resolve_optional_materials&quot;, true);
  registerTask(&quot;check_integrity_early&quot;, true);
  registerTask(&quot;check_integrity_early_physics&quot;, false);
  registerTask(&quot;setup_quadrature&quot;, true);
  registerTask(&quot;create_tagged_matrices&quot;, true);

  registerTask(&quot;mesh_modifiers&quot;, false);

  /// Additional Actions
  registerTask(&quot;no_action&quot;, false); // Used for Empty Action placeholders
  registerTask(&quot;set_global_params&quot;, false);
  registerTask(&quot;setup_adaptivity&quot;, false);
  registerTask(&quot;meta_action&quot;, false);
  registerTask(&quot;setup_residual_debug&quot;, false);
  registerTask(&quot;setup_oversampling&quot;, false);
  registerTask(&quot;deprecated_block&quot;, false);
  registerTask(&quot;set_adaptivity_options&quot;, false);
  registerTask(&quot;add_mortar_interface&quot;, false);
  registerTask(&quot;coupling_functor_check&quot;, true);
  registerTask(&quot;add_master_action_material&quot;, false);
  registerTask(&quot;setup_projected_properties&quot;, false);
  registerTask(&quot;create_application_block&quot;, false);

  // Dummy Actions (useful for sync points in the dependencies)
  registerTask(&quot;setup_function_complete&quot;, false);
  registerTask(&quot;setup_variable_complete&quot;, false);
  registerTask(&quot;setup_executioner_complete&quot;, false);
  registerTask(&quot;ready_to_init&quot;, true);

  // Output related actions
  registerTask(&quot;add_output_aux_variables&quot;, true);
  registerTask(&quot;check_output&quot;, true);
  registerTask(&quot;declare_late_reporters&quot;, true);

  registerTask(&quot;create_problem_default&quot;, true);
  registerTask(&quot;create_problem_custom&quot;, false);
  registerTask(&quot;create_problem_complete&quot;, false);

  registerTask(&quot;add_default_nonlinear_convergence&quot;, true);
  registerTask(&quot;add_default_multiapp_fixed_point_convergence&quot;, true);
  registerTask(&quot;add_default_steady_state_convergence&quot;, true);

  registerTask(&quot;chain_control_setup&quot;, true);
  registerTask(&quot;start_webservercontrol&quot;, true);

  // Action for setting up the signal-based checkpoint
  registerTask(&quot;auto_checkpoint_action&quot;, true);
  /**************************/
  /****** Dependencies ******/
  /**************************/
  /**
   * The following is the default set of action dependencies for a basic MOOSE problem.  The
   * formatting of this string is important.  Each line represents a set of dependencies that depend
   * on the previous line.  Items on the same line have equal weight and can be executed in any
   * order.
   *
   * Additional dependencies can be inserted later inside of user applications with calls to
   * ActionWarehouse::addDependency(&quot;task&quot;, &quot;pre_req&quot;)
   */

  // clang-format off
  syntax.addDependencySets(&quot;(meta_action)&quot;
                           &quot;(meta_action_component)&quot;
                           &quot;(dynamic_object_registration)&quot;
                           &quot;(common_output)&quot;
                           &quot;(set_global_params)&quot;
                           &quot;(setup_recover_file_base)&quot;
                           &quot;(check_copy_nodal_vars)&quot;
                           &quot;(setup_mesh)&quot;
                           &quot;(add_geometric_rm)&quot;
                           &quot;(add_partitioner)&quot;
                           &quot;(add_mesh_generator)&quot;
                           &quot;(create_added_mesh_generators)&quot;
                           &quot;(append_mesh_generator)&quot;
                           &quot;(execute_mesh_generators)&quot;
                           &quot;(recover_meta_data)&quot;
                           &quot;(set_mesh_base)&quot;
                           &quot;(attach_geometric_rm)&quot;
                           &quot;(init_mesh)&quot;
                           &quot;(prepare_mesh)&quot;
                           &quot;(add_mortar_interface)&quot;
                           &quot;(uniform_refine_mesh)&quot;
                           &quot;(setup_mesh_complete)&quot;
                           &quot;(post_mesh_prepared)&quot;
                           &quot;(determine_system_type)&quot;
                           &quot;(create_problem)&quot;
                           &quot;(create_problem_custom)&quot;
                           &quot;(create_problem_default)&quot;
                           &quot;(create_problem_complete)&quot;
                           &quot;(init_displaced_problem)&quot; // Problem must be init-ed before we start adding functors
                           &quot;(add_function)&quot;  // Functions can depend on scalar variables &amp; PPs, but this dependence can be
                                             // added on initialSetup() rather than construction
                           &quot;(init_component_physics)&quot; // components must add their blocks to physics before init_physics
                           &quot;(init_physics)&quot;
                           &quot;(setup_postprocessor_data)&quot;
                           &quot;(setup_time_integrator, setup_time_integrators)&quot;
                           &quot;(setup_executioner)&quot;
                           &quot;(setup_executioner_complete)&quot;
                           &quot;(setup_component)&quot;  // no particular reason for that placement
                           &quot;(read_executor)&quot;
                           &quot;(add_executor)&quot;
                           &quot;(check_integrity_early)&quot;
                           &quot;(setup_predictor)&quot;
                           &quot;(add_aux_variable, add_variable, add_elemental_field_variable,&quot;
                           &quot; add_external_aux_variables)&quot;
                           &quot;(add_variables_physics)&quot; // physics can skip adding variables if they already exist
                           &quot;(add_mortar_variable)&quot;
                           &quot;(setup_variable_complete)&quot;
                           &quot;(check_integrity_early_physics)&quot;  // checks that systems and variables are consistent
                           &quot;(setup_quadrature)&quot;
                           &quot;(add_convergence)&quot;
                           &quot;(add_default_nonlinear_convergence,&quot;
                           &quot; add_default_multiapp_fixed_point_convergence,&quot;
                           &quot; add_default_steady_state_convergence)&quot;
                           &quot;(add_positions)&quot;
                           &quot;(add_periodic_bc)&quot;
                           &quot;(add_user_object, add_corrector, add_mesh_modifier)&quot;
                           &quot;(add_field_split)&quot; // split objects required before field split preconditioner itself
                           &quot;(add_preconditioning)&quot; // preconditioner may introduce objects such as static condensation which influence the underlying types of tagged matrices
                           &quot;(create_tagged_matrices)&quot;
                           &quot;(add_distribution)&quot;
                           &quot;(add_sampler)&quot;
                           &quot;(setup_function_complete)&quot;
                           &quot;(setup_adaptivity)&quot;
                           &quot;(set_adaptivity_options)&quot;
                           &quot;(add_ic, add_fv_ic)&quot;
                           &quot;(add_ics_physics)&quot; // physics can skip adding initial conditions if they already exist
                           &quot;(add_constraint)&quot;
                           &quot;(add_times)&quot;
                           &quot;(add_time_stepper, add_time_steppers)&quot;
                           &quot;(compose_time_stepper)&quot;
                           &quot;(setup_time_steppers)&quot;
                           &quot;(ready_to_init)&quot;
                           &quot;(setup_dampers)&quot;
                           &quot;(setup_residual_debug)&quot;
                           &quot;(add_bounds_vectors)&quot;
                           &quot;(add_mesh_division)&quot;  // NearestPositionsDivision uses a Positions
                           &quot;(add_multi_app)&quot;
                           &quot;(add_transfer)&quot;
                           &quot;(copy_nodal_vars, copy_nodal_aux_vars, copy_vars_physics)&quot;
                           &quot;(add_material)&quot;
                           &quot;(add_master_action_material)&quot;
                           &quot;(add_functor_material)&quot;
                           &quot;(add_materials_physics)&quot;
                           &quot;(setup_projected_properties)&quot;
                           &quot;(add_output_aux_variables)&quot;
                           &quot;(add_output)&quot;
                           &quot;(auto_checkpoint_action)&quot;
                           &quot;(add_postprocessor)&quot;
                           &quot;(add_vector_postprocessor)&quot; // MaterialVectorPostprocessor requires this
                                                        // to be after material objects are created.
                           &quot;(add_reporter)&quot;
                           &quot;(declare_late_reporters)&quot;
                           &quot;(add_aux_kernel, add_bc, add_damper, add_dirac_kernel, add_kernel,&quot;
                           &quot; add_nodal_kernel, add_dg_kernel, add_fv_kernel, add_linear_fv_kernel,&quot;
                           &quot; add_fv_bc, add_linear_fv_bc, add_fv_ik, add_interface_kernel,&quot;
                           &quot; add_scalar_kernel, add_aux_scalar_kernel, add_indicator, add_marker,&quot;
                           &quot; add_bound, add_hybridized_kernel, add_hybridized_integrated_bc)&quot;
                           &quot;(resolve_optional_materials)&quot;
                           &quot;(add_algebraic_rm)&quot;
                           &quot;(add_coupling_rm)&quot;
                           &quot;(attach_geometric_rm_final)&quot;
                           &quot;(attach_algebraic_rm)&quot;
                           &quot;(attach_coupling_rm)&quot;
                           &quot;(coupling_functor_check)&quot;
                           &quot;(delete_remote_elements_after_late_geometric_ghosting)&quot;
                           &quot;(init_problem)&quot;
                           &quot;(add_control, add_chain_control)&quot;
                           &quot;(chain_control_setup)&quot;
                           &quot;(start_webservercontrol)&quot;
                           &quot;(check_output)&quot;
                           &quot;(check_integrity)&quot;
                           &quot;(create_application_block)&quot;);
  // clang-format on

#ifdef MOOSE_MFEM_ENABLED
  registerTask(&quot;add_mfem_problem_operator&quot;, true);
  addTaskDependency(&quot;add_mfem_problem_operator&quot;, &quot;init_mesh&quot;);
  addTaskDependency(&quot;add_variable&quot;, &quot;add_mfem_problem_operator&quot;);
  addTaskDependency(&quot;add_aux_variable&quot;, &quot;add_mfem_problem_operator&quot;);
  addTaskDependency(&quot;add_elemental_field_variable&quot;, &quot;add_mfem_problem_operator&quot;);
  addTaskDependency(&quot;add_bc&quot;, &quot;add_mfem_problem_operator&quot;);
  addTaskDependency(&quot;add_kernel&quot;, &quot;add_mfem_problem_operator&quot;);

  // add SubMeshes
  registerMooseObjectTask(&quot;add_mfem_submeshes&quot;, MFEMSubMesh, false);
  addTaskDependency(&quot;add_mfem_submeshes&quot;, &quot;create_problem_complete&quot;);

  // add SubMesh transfers
  appendMooseObjectTask(&quot;add_transfer&quot;, MFEMSubMeshTransfer);

  // add FESpaces
  registerMooseObjectTask(&quot;add_mfem_fespaces&quot;, MFEMFESpace, false);
  appendMooseObjectTask(&quot;add_mfem_fespaces&quot;, MFEMFECollection);
  addTaskDependency(&quot;add_mfem_fespaces&quot;, &quot;add_mfem_submeshes&quot;);
  addTaskDependency(&quot;add_variable&quot;, &quot;add_mfem_fespaces&quot;);
  addTaskDependency(&quot;add_aux_variable&quot;, &quot;add_mfem_fespaces&quot;);
  addTaskDependency(&quot;add_elemental_field_variable&quot;, &quot;add_mfem_fespaces&quot;);
  addTaskDependency(&quot;add_kernel&quot;, &quot;add_mfem_fespaces&quot;);

  // add complex kernels
  registerMooseObjectTask(&quot;add_mfem_complex_kernel_components&quot;, Kernel, false);
  registerMooseObjectTask(&quot;add_mfem_complex_bc_components&quot;, BoundaryCondition, false);
  addTaskDependency(&quot;add_mfem_complex_kernel_components&quot;, &quot;add_mfem_fespaces&quot;);
  addTaskDependency(&quot;add_mfem_complex_bc_components&quot;, &quot;add_mfem_fespaces&quot;);
  addTaskDependency(&quot;add_mfem_complex_kernel_components&quot;, &quot;add_kernel&quot;);
  addTaskDependency(&quot;add_mfem_complex_bc_components&quot;, &quot;add_bc&quot;);

  // set mesh FE space
  registerTask(&quot;set_mesh_fe_space&quot;, true);
  addTaskDependency(&quot;set_mesh_fe_space&quot;, &quot;add_variable&quot;);
  addTaskDependency(&quot;set_mesh_fe_space&quot;, &quot;init_mesh&quot;);

  // add preconditioning.
  registerMooseObjectTask(&quot;add_mfem_preconditioner&quot;, MFEMSolverBase, false);
  addTaskDependency(&quot;add_mfem_preconditioner&quot;, &quot;add_mfem_problem_operator&quot;);
  addTaskDependency(&quot;add_mfem_preconditioner&quot;, &quot;add_variable&quot;);

  // add solver.
  registerMooseObjectTask(&quot;add_mfem_solver&quot;, MFEMSolverBase, true);
  addTaskDependency(&quot;add_mfem_solver&quot;, &quot;add_mfem_preconditioner&quot;);
  addTaskDependency(&quot;add_mfem_solver&quot;, &quot;add_mfem_problem_operator&quot;);
#endif

  registerTask(&quot;parse_neml2&quot;, /*required=*/false);
  addTaskDependency(&quot;add_material&quot;, &quot;parse_neml2&quot;);
  addTaskDependency(&quot;add_user_object&quot;, &quot;parse_neml2&quot;);
}

/**
 * Multiple Action class can be associated with a single input file section, in which case all
 * associated Actions will be created and &quot;acted&quot; on when the associated input file section is
 * seen.*
 *
 * Example:
 *  &quot;setup_mesh&quot; &lt;-----------&gt; SetupMeshAction &lt;---------
 *                                                        \
 *                                                         [Mesh]
 *                                                        /
 * &quot;setup_mesh_complete&quot; &lt;---&gt; SetupMeshCompleteAction &lt;-
 *
 *
 * Action classes can also be registered to act on more than one input file section for a different
 * task if similar logic can work in multiple cases
 *
 * Example:
 * &quot;add_variable&quot; &lt;-----                       -&gt; [Variables/ *]
 *                       \                   /
 *                        CopyNodalVarsAction
 *                       /                   \
 * &quot;add_aux_variable&quot; &lt;-                       -&gt; [AuxVariables/ *]
 *
 *
 * Note: Placeholder &quot;no_action&quot; actions must be put in places where it is possible to match an
 *       object with a star or a more specific parent later on. (i.e. where one needs to negate the
 *       &#x27;*&#x27; matching prematurely).
 */
void
registerActions(Syntax &amp; syntax, ActionFactory &amp; action_factory)
{
  mooseDeprecated(&quot;use registerAll instead of registerActions&quot;);
  registerActions(syntax, action_factory, {&quot;MooseApp&quot;});
}

void
registerActions(Syntax &amp; syntax,
                ActionFactory &amp; action_factory,
                const std::set&lt;std::string&gt; &amp; obj_labels)
{
  Registry::registerActionsTo(action_factory, obj_labels);

  // Add these actions here so they are always executed last, without setting any dependency
  registerTask(&quot;dump_objects&quot;, false);
  registerTask(&quot;finish_input_file_output&quot;, false);
}

void
associateSyntaxInner(Syntax &amp; syntax, ActionFactory &amp; /*action_factory*/)
{
  /**
   * Note: the optional third parameter is used to differentiate which task is
   * satisfied based on the syntax encountered for classes which are registered
   * to satisfy more than one task
   */
  registerSyntax(&quot;DiffusionCG&quot;, &quot;Physics/Diffusion/ContinuousGalerkin/*&quot;);
  registerSyntax(&quot;DiffusionFV&quot;, &quot;Physics/Diffusion/FiniteVolume/*&quot;);

  registerSyntax(&quot;AddActionComponentAction&quot;, &quot;ActionComponents/*&quot;);
  registerSyntax(&quot;CombineComponentsMeshes&quot;, &quot;ActionComponents&quot;);

  registerSyntaxTask(&quot;CopyNodalVarsAction&quot;, &quot;Variables/*&quot;, &quot;check_copy_nodal_vars&quot;);
  registerSyntaxTask(&quot;CopyNodalVarsAction&quot;, &quot;Variables/*&quot;, &quot;copy_nodal_vars&quot;);
  registerSyntaxTask(&quot;CopyNodalVarsAction&quot;, &quot;AuxVariables/*&quot;, &quot;check_copy_nodal_vars&quot;);
  registerSyntaxTask(&quot;CopyNodalVarsAction&quot;, &quot;AuxVariables/*&quot;, &quot;copy_nodal_aux_vars&quot;);

  registerSyntaxTask(&quot;AddKernelAction&quot;, &quot;Kernels/*&quot;, &quot;add_kernel&quot;);
  registerSyntaxTask(&quot;AddNodalKernelAction&quot;, &quot;NodalKernels/*&quot;, &quot;add_nodal_kernel&quot;);
  registerSyntaxTask(&quot;AddKernelAction&quot;, &quot;AuxKernels/*&quot;, &quot;add_aux_kernel&quot;);

  registerSyntaxTask(&quot;AddHDGKernelAction&quot;, &quot;HDGKernels/*&quot;, &quot;add_hybridized_kernel&quot;);

  registerSyntax(&quot;AddAuxKernelAction&quot;, &quot;AuxVariables/*/AuxKernel&quot;);

  registerSyntaxTask(&quot;AddScalarKernelAction&quot;, &quot;ScalarKernels/*&quot;, &quot;add_scalar_kernel&quot;);
  registerSyntaxTask(&quot;AddScalarKernelAction&quot;, &quot;AuxScalarKernels/*&quot;, &quot;add_aux_scalar_kernel&quot;);

  registerSyntaxTask(&quot;AddBCAction&quot;, &quot;BCs/*&quot;, &quot;add_bc&quot;);

  registerSyntax(&quot;CreateProblemAction&quot;, &quot;Problem&quot;);
  registerSyntax(&quot;DynamicObjectRegistrationAction&quot;, &quot;Problem&quot;);

  registerSyntax(&quot;SetupMeshAction&quot;, &quot;Mesh&quot;);
  registerSyntax(&quot;SetupMeshCompleteAction&quot;, &quot;Mesh&quot;);
  // Components should be able create a Mesh without a Mesh block
  registerSyntax(&quot;CreateMeshSetupActionsForComponents&quot;, &quot;ActionComponents&quot;);
  registerSyntax(&quot;CreateDisplacedProblemAction&quot;, &quot;Mesh&quot;);
  registerSyntax(&quot;DisplayGhostingAction&quot;, &quot;Mesh&quot;);
  registerSyntax(&quot;AddMeshGeneratorAction&quot;, &quot;Mesh/*&quot;);
  registerSyntaxTask(&quot;EmptyAction&quot;, &quot;Mesh/BatchMeshGeneratorAction&quot;, &quot;no_action&quot;);
  registerSyntax(&quot;BatchMeshGeneratorAction&quot;, &quot;Mesh/BatchMeshGeneratorAction/*&quot;);
  registerSyntax(&quot;ElementIDOutputAction&quot;, &quot;Mesh&quot;);
  syntax.registerSyntaxType(&quot;Mesh/*&quot;, &quot;MeshGeneratorName&quot;);

  registerSyntax(&quot;AddFunctionAction&quot;, &quot;Functions/*&quot;);
  syntax.registerSyntaxType(&quot;Functions/*&quot;, &quot;FunctionName&quot;);

  registerSyntax(&quot;AddMeshDivisionAction&quot;, &quot;MeshDivisions/*&quot;);
  syntax.registerSyntaxType(&quot;MeshDivisions/*&quot;, &quot;MeshDivisionName&quot;);
  registerSyntax(&quot;AddConvergenceAction&quot;, &quot;Convergence/*&quot;);
  syntax.registerSyntaxType(&quot;Convergence/*&quot;, &quot;ConvergenceName&quot;);

  registerSyntax(&quot;GlobalParamsAction&quot;, &quot;GlobalParams&quot;);

  registerSyntax(&quot;AddDistributionAction&quot;, &quot;Distributions/*&quot;);
  syntax.registerSyntaxType(&quot;Distributions/*&quot;, &quot;DistributionName&quot;);

  registerSyntax(&quot;AddSamplerAction&quot;, &quot;Samplers/*&quot;);
  syntax.registerSyntaxType(&quot;Samplers/*&quot;, &quot;SamplerName&quot;);

  registerSyntax(&quot;SetupDebugAction&quot;, &quot;Debug&quot;);
  registerSyntax(&quot;SetupResidualDebugAction&quot;, &quot;Debug&quot;);

  /// Variable/AuxVariable Actions
  registerSyntax(&quot;AddVariableAction&quot;, &quot;Variables/*&quot;);
  syntax.registerSyntaxType(&quot;Variables/*&quot;, &quot;VariableName&quot;);
  syntax.registerSyntaxType(&quot;Variables/*&quot;, &quot;NonlinearVariableName&quot;);

  registerSyntax(&quot;AddICAction&quot;, &quot;Variables/*/InitialCondition&quot;);
  registerSyntax(&quot;AddFVICAction&quot;, &quot;Variables/*/FVInitialCondition&quot;);

  registerSyntax(&quot;AddAuxVariableAction&quot;, &quot;AuxVariables/*&quot;);
  syntax.registerSyntaxType(&quot;AuxVariables/*&quot;, &quot;VariableName&quot;);
  syntax.registerSyntaxType(&quot;AuxVariables/*&quot;, &quot;AuxVariableName&quot;);

  registerSyntax(&quot;AddICAction&quot;, &quot;AuxVariables/*/InitialCondition&quot;);
  registerSyntax(&quot;AddFVICAction&quot;, &quot;AuxVariables/*/FVInitialCondition&quot;);

  registerSyntaxTask(&quot;EmptyAction&quot;, &quot;BCs/Periodic&quot;, &quot;no_action&quot;); // placeholder
  registerSyntax(&quot;AddPeriodicBCAction&quot;, &quot;BCs/Periodic/*&quot;);

  registerSyntaxTask(&quot;AddInitialConditionAction&quot;, &quot;ICs/*&quot;, &quot;add_ic&quot;);
  registerSyntaxTask(&quot;AddFVInitialConditionAction&quot;, &quot;FVICs/*&quot;, &quot;add_fv_ic&quot;);

  registerSyntax(&quot;AddMaterialAction&quot;, &quot;Materials/*&quot;);
  syntax.registerSyntaxType(&quot;Materials/*&quot;, &quot;MaterialName&quot;);

  registerSyntax(&quot;AddFunctorMaterialAction&quot;, &quot;FunctorMaterials/*&quot;);
  syntax.registerSyntaxType(&quot;FunctorMaterials/*&quot;, &quot;MaterialName&quot;);

  registerSyntax(&quot;AddPostprocessorAction&quot;, &quot;Postprocessors/*&quot;);
  syntax.registerSyntaxType(&quot;Postprocessors/*&quot;, &quot;PostprocessorName&quot;);
  syntax.registerSyntaxType(&quot;Postprocessors/*&quot;, &quot;UserObjectName&quot;);

  registerSyntax(&quot;AddVectorPostprocessorAction&quot;, &quot;VectorPostprocessors/*&quot;);
  syntax.registerSyntaxType(&quot;VectorPostprocessors/*&quot;, &quot;VectorPostprocessorName&quot;);

  registerSyntax(&quot;AddReporterAction&quot;, &quot;Reporters/*&quot;);
  syntax.registerSyntaxType(&quot;Reporters/*&quot;, &quot;ReporterName&quot;);

  registerSyntax(&quot;AddPositionsAction&quot;, &quot;Positions/*&quot;);
  syntax.registerSyntaxType(&quot;Positions/*&quot;, &quot;PositionsName&quot;);

  registerSyntax(&quot;AddTimesAction&quot;, &quot;Times/*&quot;);
  syntax.registerSyntaxType(&quot;Times/*&quot;, &quot;TimesName&quot;);

  registerSyntax(&quot;AddDamperAction&quot;, &quot;Dampers/*&quot;);

  registerSyntax(&quot;AddOutputAction&quot;, &quot;Outputs/*&quot;);
  registerSyntax(&quot;CommonOutputAction&quot;, &quot;Outputs&quot;);
  registerSyntax(&quot;MaterialOutputAction&quot;, &quot;Outputs&quot;);
  registerSyntax(&quot;AutoCheckpointAction&quot;, &quot;Outputs&quot;);
  syntax.registerSyntaxType(&quot;Outputs/*&quot;, &quot;OutputName&quot;);

  // Note: Preconditioner Actions will be built by this setup action
  registerSyntax(&quot;SetupPreconditionerAction&quot;, &quot;Preconditioning/*&quot;);
  registerSyntax(&quot;AddFieldSplitAction&quot;, &quot;Preconditioning/*/*&quot;);

  registerSyntax(&quot;CreateExecutionerAction&quot;, &quot;Executioner&quot;);
  registerSyntax(&quot;ReadExecutorParamsAction&quot;, &quot;Executors/*&quot;);

  registerSyntaxTask(&quot;AddTimeStepperAction&quot;, &quot;Executioner/TimeSteppers/*&quot;, &quot;add_time_steppers&quot;);
  registerSyntaxTask(&quot;AddTimeStepperAction&quot;, &quot;Executioner/TimeStepper&quot;, &quot;add_time_stepper&quot;);
  registerSyntaxTask(
      &quot;ComposeTimeStepperAction&quot;, &quot;Executioner/TimeSteppers&quot;, &quot;compose_time_stepper&quot;);
  registerSyntaxTask(
      &quot;SetupTimeIntegratorAction&quot;, &quot;Executioner/TimeIntegrators/*&quot;, &quot;setup_time_integrators&quot;);
  registerSyntaxTask(
      &quot;SetupTimeIntegratorAction&quot;, &quot;Executioner/TimeIntegrator&quot;, &quot;setup_time_integrator&quot;);
  syntax.registerSyntaxType(&quot;Executors/*&quot;, &quot;ExecutorName&quot;);

  registerSyntax(&quot;SetupQuadratureAction&quot;, &quot;Executioner/Quadrature&quot;);
  registerSyntax(&quot;SetupPredictorAction&quot;, &quot;Executioner/Predictor&quot;);
#ifdef LIBMESH_ENABLE_AMR
  registerSyntax(&quot;AdaptivityAction&quot;, &quot;Executioner/Adaptivity&quot;);
#endif

  registerSyntax(&quot;PartitionerAction&quot;, &quot;Mesh/Partitioner&quot;);

  registerSyntax(&quot;AddDiracKernelAction&quot;, &quot;DiracKernels/*&quot;);

  registerSyntax(&quot;AddDGKernelAction&quot;, &quot;DGKernels/*&quot;);
  registerSyntax(&quot;AddFVKernelAction&quot;, &quot;FVKernels/*&quot;);
  registerSyntax(&quot;AddFVBCAction&quot;, &quot;FVBCs/*&quot;);
  registerSyntax(&quot;AddLinearFVBCAction&quot;, &quot;LinearFVBCs/*&quot;);
  registerSyntax(&quot;AddFVInterfaceKernelAction&quot;, &quot;FVInterfaceKernels/*&quot;);
  registerSyntax(&quot;CheckFVBCAction&quot;, &quot;FVBCs&quot;);

  registerSyntax(&quot;AddLinearFVKernelAction&quot;, &quot;LinearFVKernels/*&quot;);

  registerSyntax(&quot;AddInterfaceKernelAction&quot;, &quot;InterfaceKernels/*&quot;);

  registerSyntax(&quot;AddConstraintAction&quot;, &quot;Constraints/*&quot;);

  registerSyntax(&quot;AddControlAction&quot;, &quot;Controls/*&quot;);
  registerSyntax(&quot;AddChainControlAction&quot;, &quot;ChainControls/*&quot;);
  registerSyntax(&quot;AddBoundAction&quot;, &quot;Bounds/*&quot;);
  registerSyntax(&quot;AddBoundsVectorsAction&quot;, &quot;Bounds&quot;);

  // UserObject and some derived classes
  registerSyntax(&quot;AddUserObjectAction&quot;, &quot;UserObjects/*&quot;);
  syntax.registerSyntaxType(&quot;UserObjects/*&quot;, &quot;UserObjectName&quot;);

  registerSyntax(&quot;AddCorrectorAction&quot;, &quot;Correctors/*&quot;);
  syntax.registerSyntaxType(&quot;Correctors/*&quot;, &quot;UserObjectName&quot;);

  registerSyntax(&quot;AddMeshModifiersAction&quot;, &quot;MeshModifiers/*&quot;);
  syntax.registerSyntaxType(&quot;MeshModifiers/*&quot;, &quot;UserObjectName&quot;);

  registerSyntax(&quot;AddNodalNormalsAction&quot;, &quot;NodalNormals&quot;);

  // Indicator
  registerSyntax(&quot;AddElementalFieldAction&quot;, &quot;Adaptivity/Indicators/*&quot;);
  registerSyntax(&quot;AddIndicatorAction&quot;, &quot;Adaptivity/Indicators/*&quot;);
  syntax.registerSyntaxType(&quot;Adaptivity/Indicators/*&quot;, &quot;IndicatorName&quot;);

  // Marker
  registerSyntax(&quot;AddElementalFieldAction&quot;, &quot;Adaptivity/Markers/*&quot;);
  registerSyntax(&quot;AddMarkerAction&quot;, &quot;Adaptivity/Markers/*&quot;);
  syntax.registerSyntaxType(&quot;Adaptivity/Markers/*&quot;, &quot;MarkerName&quot;);

  // New Adaptivity System
  registerSyntax(&quot;SetAdaptivityOptionsAction&quot;, &quot;Adaptivity&quot;);

  // Deprecated Block
  registerSyntax(&quot;DeprecatedBlockAction&quot;, &quot;DeprecatedBlock&quot;);

  // Multi Apps
  registerSyntax(&quot;AddMultiAppAction&quot;, &quot;MultiApps/*&quot;);
  syntax.registerSyntaxType(&quot;MultiApps/*&quot;, &quot;MultiAppName&quot;);

  // Transfers
  registerSyntax(&quot;AddTransferAction&quot;, &quot;Transfers/*&quot;);

  // Material derivative test
  registerSyntaxTask(&quot;EmptyAction&quot;, &quot;Debug/MaterialDerivativeTest&quot;, &quot;no_action&quot;); // placeholder
  registerSyntax(&quot;MaterialDerivativeTestAction&quot;, &quot;Debug/MaterialDerivativeTest/*&quot;);

  registerSyntax(&quot;ProjectedStatefulMaterialStorageAction&quot;, &quot;ProjectedStatefulMaterialStorage/*&quot;);

  // Application Block System
  registerSyntax(&quot;CreateApplicationBlockAction&quot;, &quot;Application&quot;);

#ifdef MOOSE_MFEM_ENABLED
  registerSyntaxTask(&quot;AddMFEMSubMeshAction&quot;, &quot;SubMeshes/*&quot;, &quot;add_mfem_submeshes&quot;);
  registerSyntaxTask(&quot;AddMFEMFESpaceAction&quot;, &quot;FESpaces/*&quot;, &quot;add_mfem_fespaces&quot;);
  registerSyntaxTask(
      &quot;AddMFEMComplexKernelComponentAction&quot;, &quot;Kernels/*/*&quot;, &quot;add_mfem_complex_kernel_components&quot;);
  registerSyntaxTask(
      &quot;AddMFEMComplexBCComponentAction&quot;, &quot;BCs/*/*&quot;, &quot;add_mfem_complex_bc_components&quot;);
  registerSyntaxTask(&quot;AddMFEMPreconditionerAction&quot;, &quot;Preconditioner/*&quot;, &quot;add_mfem_preconditioner&quot;);
  registerSyntaxTask(&quot;AddMFEMSolverAction&quot;, &quot;Solver&quot;, &quot;add_mfem_solver&quot;);
#endif

  registerSyntax(&quot;NEML2ActionCommon&quot;, &quot;NEML2&quot;);
  registerSyntax(&quot;NEML2Action&quot;, &quot;NEML2/*&quot;);

  addActionTypes(syntax);
}

void
associateSyntax(Syntax &amp; syntax, ActionFactory &amp; action_factory)
{
  associateSyntaxInner(syntax, action_factory);
  registerActions(syntax, action_factory);
}

void
setSolverDefaults(FEProblemBase &amp; problem)
{
  // May be a touch expensive to create a new DM every time, but probably safer to do it this way
  Moose::PetscSupport::petscSetDefaults(problem);
}

MPI_Comm
swapLibMeshComm(MPI_Comm new_comm)
{
  MPI_Comm old_comm = PETSC_COMM_WORLD;
  PETSC_COMM_WORLD = new_comm;
  return old_comm;
}

static bool _color_console = isatty(fileno(stdout));

bool
colorConsole()
{
  return _color_console;
}

bool
setColorConsole(bool use_color, bool force)
{
  _color_console = (isatty(fileno(stdout)) || force) &amp;&amp; use_color;
  return _color_console;
}

ScopedThrowOnError::ScopedThrowOnError(const bool throw_on_error)
  : _throw_on_error_before(Moose::_throw_on_error)
{
  mooseAssert(!libMesh::Threads::in_threads, &quot;Cannot be used in threads&quot;);
  Moose::_throw_on_error = throw_on_error;
}

ScopedThrowOnError::ScopedThrowOnError() : ScopedThrowOnError(true) {}

ScopedThrowOnError::~ScopedThrowOnError() { Moose::_throw_on_error = _throw_on_error_before; }

ScopedDeprecatedIsError::ScopedDeprecatedIsError(const bool deprecated_is_error)
  : _deprecated_is_error_before(Moose::_deprecated_is_error)
{
  mooseAssert(!libMesh::Threads::in_threads, &quot;Cannot be used in threads&quot;);
  Moose::_deprecated_is_error = deprecated_is_error;
}

ScopedDeprecatedIsError::ScopedDeprecatedIsError() : ScopedDeprecatedIsError(true) {}

ScopedDeprecatedIsError::~ScopedDeprecatedIsError()
{
  Moose::_deprecated_is_error = _deprecated_is_error_before;
}

std::string
hitMessagePrefix(const hit::Node &amp; node)
{
  // Strip meaningless line and column number for CLI args
  if (node.filename() == &quot;CLI_ARGS&quot;)
    return &quot;CLI_ARGS:\n&quot;;
  // If using the root node, don&#x27;t add line info
  if (node.isRoot())
    return node.filename() + &quot;:\n&quot;;
  return node.fileLocation() + &quot;:\n&quot;;
}

bool _warnings_are_errors = false;
bool _deprecated_is_error = false;
bool _throw_on_error = false;
bool _throw_on_warning = false;
int interrupt_signal_number = 0;
bool show_trace = true;
bool show_multiple = false;

} // namespace Moose
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
<!DOCTYPE html><head><meta charset="UTF-8"><title>MooseVariableBase | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="387c6a6a-03d8-4754-8e3b-f02877127a7a" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="885b5eab-3553-4136-9abc-331c0f9ef351" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d33e46b5-6435-4d74-b747-cd1223cf1e7f" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="7f723164-0d76-4481-a060-219004a545bc" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="80e8aa48-4902-4742-8fde-3457c8bd61e7"><i class="material-icons">menu</i></a><ul class="sidenav" id="80e8aa48-4902-4742-8fde-3457c8bd61e7"><li><a href="#!" class="dropdown-trigger" data-target="9fd2a61b-0c6b-4d4e-8b15-47d27f36070e" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="5cfd0db0-1fff-418d-8457-73616abcad9b" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1d77ce37-c015-48b1-9305-7503e8279ede" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="0f46c162-9081-4081-9c5c-2a2427f9b1cb" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="387c6a6a-03d8-4754-8e3b-f02877127a7a"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="885b5eab-3553-4136-9abc-331c0f9ef351"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="d33e46b5-6435-4d74-b747-cd1223cf1e7f"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="7f723164-0d76-4481-a060-219004a545bc"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="9fd2a61b-0c6b-4d4e-8b15-47d27f36070e"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="5cfd0db0-1fff-418d-8457-73616abcad9b"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="1d77ce37-c015-48b1-9305-7503e8279ede"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="0f46c162-9081-4081-9c5c-2a2427f9b1cb"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="147eff1f-e1e5-4128-a962-486bfda7cebf" data-section-level="1" data-section-text="MooseVariableBase"><h1 id="moosevariablebase">MooseVariableBase</h1><p>Base class for Moose variables. This should never be the terminal object type</p><p>The current class hierarchy for Moose variables is shown below:</p><div class="card moose-float" style="width:50%;"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/variables/moose_variable_hierarchy.svg" alt="Moose variable hierarchy."></img></picture><p class="moose-caption"><span class="moose-caption-text">Moose variable hierarchy.</span></p></div></div><p><code>MooseVariableBase</code> is the primitive base class from which all variables inherit. It includes methods for accessing the variable finite element type and order, degrees of freedom, scaling factor, name, and associated <a href="../../syntax/Systems/index.html">SystemBase</a>. Two classes inherit directly from <code>MooseVariableBase</code>: <a href="MooseVariable.html">MooseVariableFEBase</a> and <a href="MooseVariableScalar.html">MooseVariableScalar</a>. <code>MooseVariableScalar</code> represents a Moose variable that is constant over the spatial domain. It has a number of degrees of freedom equal to the order of the variable, e.g. the following variable block would declare a <code>MooseVariableScalar</code> with two associated degrees of freedom:</p><pre style="max-height:350px;"><code class="language-text">
[AuxVariables]
  [aux_scalar]
    order = SECOND
    family = SCALAR
  []
[]
</code></pre><p><code>MooseVariableFEBase</code> is an abstract class that encompasses all finite-element type variables; all variables that vary spatially ultimately inherit from <code>MooseVariableFEBase</code>. The class implements all the relevant variable methods other than those that return the actual variable solution or variable shape functions, since the return type in the latter case depends on whether the finite-element variable is scalar-valued (single-component) or vector-valued (multi-component) in nature. The existence of the <code>MooseVariableFEBase</code> class allows construction of containers that hold both single- and multi-component finite element variables. This is useful for instance in the <code>Assembly</code> class where we can abstract the coupling matrix entries or in Jacobian computing objects like <code>Kernels</code> when we want to fetch the numerical ID of the variable using <code>coupled</code>. Moreover, this design structure mirrors that of the <code>FE</code> design in LibMesh, where <code>FEAbstract</code> is an abstract base class that implements all methods independent of <code>FE</code> type and the class template <code>FEGenericBase&lt;T&gt;</code> implements the type dependent methods analogous to <code>MooseVariableFE&lt;T&gt;</code>.</p><p><code>MooseVariableFE&lt;T&gt;</code> implements methods that return the variable&#x27;s solution and its associated shape functions. Additionally, it contains the methods responsible for computing the variable solution at quadrature points given the degree of freedom values computed from the previous nonlinear solution. &quot;Standard&quot; or &quot;traditional&quot; finite element variables that are single-component are instantiated with the template argument <code>Real</code>; these hold variables of finite element families <code>LAGRANGE</code>, <code>MONOMIAL</code>, <code>HERMITE</code>, etc. Multi-component vector finite element variables are instantiated with the template argument <code>RealVectorValue</code> and currently encompass the finite element families <code>LAGRANGE_VEC</code>, <code>MONOMIAL_VEC</code>, <code>NEDELEC_ONE</code> and <code>RAVIART_THOMAS</code>. <code>NEDELEC_ONE</code> and <code>RAVIART_THOMAS</code> are useful for electromagnetic applications or for general PDEs that involve a curl or a divergence operation, respectively. <code>LAGRANGE_VEC</code> is potentially useful for solid mechanics or Navier-Stokes simulations where historically displacement or velocity variables have been broken up component-wise. To hide the templating of the Moose variable system from other framework code, <code>MooseVariableFE&lt;Real&gt;</code> and <code>MooseVariableFE&lt;RealVectorValue&gt;</code> have been aliased to <code>MooseVariable</code> and <code>VectorMooseVariable</code> respectively.</p><p>Finally, <code>MooseVariableConstMonomial</code> is a class that takes advantage of its finite element type (constant value on an element) to optimize its solution computing routines. Consequently, it overrides the <code>computeElemValues</code> and similar methods of <code>MooseVariableFE&lt;Real&gt;</code>.</p><section id="0aff35ed-cf48-454d-a7eb-5b470b422f3e" data-section-level="2" data-section-text="Accessors"><h2 id="accessors">Accessors</h2><p>There are a myriad of ways to access Moose variables from user interfaces. We&#x27;ll outline a few below.</p></section><section id="853ebebe-8bf7-4bcf-984b-c60f0206044a" data-section-level="2" data-section-text="Restart"><h2 id="restart">Restart</h2><p>Variables can be restarted/initialized from variable values in a file on disk by setting the parameter <code>initial_from_file_var = source_var_name</code> in the variable sub-block, where <code>source_var_name</code> is the name of the source variable in the file. Note that the user will also have to set parameters in the <code>[Mesh]</code> block in order for this to work, as described for example in the documentation of the <a href="../meshgenerators/FileMeshGenerator.html">FileMeshGenerator</a>.</p><section id="d6f574f7-e18a-4d1e-a2c7-bb3088e254d7" data-section-level="3" data-section-text="SystemBase"><h3 id="systembase">SystemBase</h3><p>It&#x27;s common for interface objects (<code>Kernel</code> objects for example) to have a <code>_sys</code> member. The <code>_sys</code> member has the following variable accessor methods which take a <code>THREAD_ID</code> and either a <code>std::string</code> variable name or <code>unsigned</code> variable ID as arguments:</p><ul class="browser-default"><li><p><code>getVariable</code>: returns a reference to a <code>MooseVariableFEBase</code>. Useful when access to the variable finite element solution or shape functions is not needed </p></li><li><p><code>getFieldVariable</code>: this is a templated method that takes as its template argument either <code>Real</code> or <code>RealVectorValue</code> and returns a reference to a <code>MooseVariable</code> or a <code>VectorMooseVariable</code> respectively. Useful when the user knows and needs the complete type </p></li><li><p><code>getScalarVariable</code>: returns a reference to a <code>MooseVariableScalar</code></p></li></ul><p>These getter methods ultimately query different map containers in the <code>VariableWarehouse</code>.</p></section><section id="35ecf9e3-2db2-4e1f-b5d1-e537751bedbb" data-section-level="3" data-section-text="SubProblem"><h3 id="subproblem">SubProblem</h3><p>Another common interface object member is <code>_subproblem</code>. <code>_subproblem</code> has the following accessors methods which take <code>THREAD_ID</code> and a <code>std::string</code> variable name as arguments (note that accessors through variable IDs do not exist through <code>SubProblem</code>):</p><ul class="browser-default"><li><p><code>getVariable</code>: returns a reference to a <code>MooseVariableFEBase</code>. Useful when access to the variable finite element solution or shape functions is not needed. Calls <code>SystemBase::getVariable</code> </p></li><li><p><code>getStandardVariable</code>: returns a reference to a <code>MooseVariable</code>. Useful when the user knows and needs the complete type. Calls <code>SystemBase::getFieldVariable&lt;Real&gt;</code> </p></li><li><p><code>getVectorVariable</code>: returns a reference to a <code>VectorMooseVariable</code>. Useful when the user knows and needs the complete type. Calls <code>SystemBase::getFieldVariable&lt;RealVectorValue&gt;</code> </p></li><li><p><code>getScalarVariable</code>: returns a reference to a <code>MooseVariableScalar</code></p></li></ul><p>Note that the template abstraction available in <code>SystemBase</code> is not available in <code>SubProblem</code>. This is because the accessor methods in <code>SubProblem</code> are pure virtual, i.e. their implementations are made in derived classes which eliminates the choice of a templated accessor method in the base <code>SubProblem</code> class.</p></section><section id="d898e2a8-0cba-426b-a75d-0e101143f2e0" data-section-level="3" data-section-text="Coupleable"><h3 id="coupleable">Coupleable</h3><p>Since most interface objects already supply the user with the primary variable, the most common way a user should be accessing Moose variables is through <code>Coupleable</code> methods. The following accessor methods return actual Moose variable objects and take as arguments the variable name and the &quot;component&quot; which is used when the user passes in multiple variables to a single <code>CoupledVar</code> parameter:</p><ul class="browser-default"><li><p><code>getFEVar</code>: returns a pointer to a <code>MooseVariableFEBase</code>. Useful when access to the variable finite element solution or shape functions is not needed </p></li><li><p><code>getVar</code>: returns a pointer to a <code>MooseVariable</code>. Useful when the complete type is needed </p></li><li><p><code>getVectorVar</code>: returns a pointer to a <code>VectorMooseVariable</code>. Useful when the complete type is needed</p></li></ul><p>When the user/developer wants access to multiple/all coupled variables, they can call the following methods which take no arguments:</p><ul class="browser-default"><li><p><code>getCoupledMooseVars</code>: returns <strong>all</strong> coupled Moose variables, i.e. both single-component <code>MooseVariables</code> and multi-component <code>VectorMooseVariables</code>. Consequently the return type is <code>std::vector&lt;MooseVariableFEBase *&gt;</code> </p></li><li><p><code>getCoupledStandardMooseVars</code>: returns all coupled single-component <code>MooseVariables</code> as a <code>std::vector&lt;MooseVariable *&gt;</code> </p></li><li><p><code>getCoupledVectorMooseVars</code>: returns all coupled multi-component <code>VectorMooseVariables</code> as a <code>std::vector&lt;VectorMooseVariable *&gt;</code> </p></li><li><p><code>getCoupledMooseScalarVars</code>: returns all coupled <code>MooseVariableScalars</code> as a <code>std::vector&lt;MooseVariableScalar *&gt;</code></p></li></ul><p>Often times there is no need for the user/developer to access the actual Moose variable object. Instead they require the variable finite element solution or gradient. Some of these methods are exemplified below:</p><ul class="browser-default"><li><p><code>coupledValue</code>: takes a variable name (should correspond to a <strong>single-component</strong> <code>MooseVariable</code>) and returns the finite element solution at the quadrature points (<code>VariableValue</code>) </p></li><li><p><code>coupledVectorValue</code>: takes a variable name (should correspond to a <strong>multi-component</strong> <code>VectorMooseVariable</code>) and returns the finite element solution at the quadrature points (<code>VectorVariableValue</code>) </p></li><li><p><code>coupledGradient</code>: takes a variable name (should correspond to a <strong>single-component</strong> <code>MooseVariable</code>) and returns the finite element solution gradient at the quadrature points (<code>VariableGradient</code>) </p></li><li><p><code>coupledCurl</code>: takes a variable name (should correspond to a <strong>multi-component</strong> <code>VectorMooseVariable</code>) and returns the curl of the finite element solution at the quadrature points (<code>VectorVariableCurl</code>)</p></li></ul></section><section id="fd667dbb-6a0e-4d8e-bb10-d8aeeaede138" data-section-level="3" data-section-text="Variable functor evaluation"><h3 id="functor-vars">Variable functor evaluation</h3><p>Derived field classes of <code>MooseVariableBase</code>, e.g. derivatives of the class template <code>MooseVariableField&lt;T&gt;</code> inherit from the <a href="../../syntax/Functors/index.html"><code>Moose::Functor</code></a>. Quadrature-based overloads of the <code>evaluate</code> method are implemented in <code>MooseVariableField&lt;T&gt;</code>. The <code>ElemQpArg</code> and <code>ElemSideQpArg</code> <code>evaluate</code> overloads do true on-the-fly computation of the solution based on the information contained within the argument, e.g. they perform calls to libMesh <code>FE::reinit</code> methods after attaching the quadrature rule provided within the calling argument. The <code>ElementType</code> overload, however, simply queries methods like <code>adSln()</code>, <code>slnOld()</code>, <code>slnOlder()</code>, <code>adSlnNeighbor()</code>, and <code>slnOldNeighbor()</code>. The success of this latter overload depends on the fact that the variable has already been reinit&#x27;d on the requested element or neighbor type. If a user is unsure whether this precondition will be met, then they should call the likely slower but more flexible <code>ElemQpArg</code> overload. For an overview of the different spatial overloads available for functors, please see <a href="../../syntax/Functors/index.html#spatial-overloads">Spatial arguments to functors</a>.</p><p>Finite-volume-centric <code>evaluate</code> overloads are individually implemented in <code>MooseVariableFE&lt;T&gt;</code> and <code>MooseVariableFV&lt;T&gt;</code> class templates. The finite element &quot;implementations&quot; currently just error out at run-time if called, but these could be non-trivially implemented if on-the-fly evaluation of FE variables coupled into FV physics becomes important. <code>MooseVariableFV&lt;T&gt;</code> implementations of the finite-volume-centric <code>evaluate</code> overloads leverage pre-existing methods like <code>getExtrapolatedBoundaryFaceValue</code>, <code>getInternalFaceValue</code>, and <code>getDirichletBoundaryFaceValue</code> when called with face-like arguments, and <code>getElemValue</code> and <code>getNeighborValue</code> when called with element-like arguments.</p></section></section><section id="f0b93729-a15a-449f-848d-a4345596b0b3" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="5dba1ca1-9605-41df-ba4c-b79c35a70e07" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">array</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">True to make this variable a array variable regardless of number of components. If 'components' > 1, this will automatically be set to true.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>True to make this variable a array variable regardless of number of components. If 'components' > 1, this will automatically be set to true.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">array_var_component_names</span><span class="moose-parameter-header-description">Only for use with array variables, allows setting custom names for each array variable component. If this not set, the default name for each array variable componenet is `base_name`+'_'+component number. If used, a name must be provided for each component and the values are used to name the components as `base_name`+'_'+ `array_var_component_names[component]`.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Only for use with array variables, allows setting custom names for each array variable component. If this not set, the default name for each array variable componenet is `base_name`+'_'+component number. If used, a name must be provided for each component and the values are used to name the components as `base_name`+'_'+ `array_var_component_names[component]`.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">block</span><span class="moose-parameter-header-description">The list of blocks (ids or names) that this object will be applied</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of blocks (ids or names) that this object will be applied</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">components</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">Number of components for an array variable</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Number of components for an array variable</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">disable_p_refinement</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">True to disable p-refinement for this variable. Note that because this happens on the family basis, users need to have this flag consistently set for all variables in the same family. Currently MOOSE disables p-refinement for variables in the following families by default: LAGRANGE NEDELEC_ONE RAVIART_THOMAS LAGRANGE_VEC CLOUGH BERNSTEIN and RATIONAL_BERNSTEIN.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>True to disable p-refinement for this variable. Note that because this happens on the family basis, users need to have this flag consistently set for all variables in the same family. Currently MOOSE disables p-refinement for variables in the following families by default: LAGRANGE NEDELEC_ONE RAVIART_THOMAS LAGRANGE_VEC CLOUGH BERNSTEIN and RATIONAL_BERNSTEIN.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">family</span><span class="moose-parameter-header-default">LAGRANGE</span><span class="moose-parameter-header-description">Specifies the family of FE shape functions to use for this variable.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>LAGRANGE</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>LAGRANGE, MONOMIAL, HERMITE, SCALAR, HIERARCHIC, CLOUGH, XYZ, SZABAB, BERNSTEIN, L2_LAGRANGE, L2_HIERARCHIC, NEDELEC_ONE, LAGRANGE_VEC, MONOMIAL_VEC, RAVIART_THOMAS, RATIONAL_BERNSTEIN, SIDE_HIERARCHIC, L2_HIERARCHIC_VEC, L2_LAGRANGE_VEC, L2_RAVIART_THOMAS</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Specifies the family of FE shape functions to use for this variable.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">fv</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">True to make this variable a finite volume variable</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>True to make this variable a finite volume variable</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">initial_condition</span><span class="moose-parameter-header-description">Specifies a constant initial condition for this variable</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;double&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Specifies a constant initial condition for this variable</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">initial_from_file_var</span><span class="moose-parameter-header-description">Gives the name of a variable for which to read an initial condition from a mesh file</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::string</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Gives the name of a variable for which to read an initial condition from a mesh file</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">order</span><span class="moose-parameter-header-default">FIRST</span><span class="moose-parameter-header-description">Order of the FE shape function to use for this variable (additional orders not listed here are allowed, depending on the family).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>FIRST</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>CONSTANT, FIRST, SECOND, THIRD, FOURTH, FIFTH, SIXTH, SEVENTH, EIGHTH, NINTH, TENTH, ELEVENTH, TWELFTH, THIRTEENTH, FOURTEENTH, FIFTEENTH, SIXTEENTH, SEVENTEENTH, EIGHTTEENTH, NINETEENTH, TWENTIETH, TWENTYFIRST, TWENTYSECOND, TWENTYTHIRD, TWENTYFOURTH, TWENTYFIFTH, TWENTYSIXTH, TWENTYSEVENTH, TWENTYEIGHTH, TWENTYNINTH, THIRTIETH, THIRTYFIRST, THIRTYSECOND, THIRTYTHIRD, THIRTYFOURTH, THIRTYFIFTH, THIRTYSIXTH, THIRTYSEVENTH, THIRTYEIGHTH, THIRTYNINTH, FORTIETH, FORTYFIRST, FORTYSECOND, FORTYTHIRD</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Order of the FE shape function to use for this variable (additional orders not listed here are allowed, depending on the family).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">solver_sys</span><span class="moose-parameter-header-default">nl0</span><span class="moose-parameter-header-description">If this variable is a solver variable, this is the solver system to which it should be added.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nl0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>SolverSystemName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>If this variable is a solver variable, this is the solver system to which it should be added.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="b4210e80-9f80-4561-a236-6f321c106b17" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">eigen</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">True to make this variable an eigen variable</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>True to make this variable an eigen variable</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">outputs</span><span class="moose-parameter-header-description">Vector of output names where you would like to restrict the output of variables(s) associated with this object</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;OutputName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Vector of output names where you would like to restrict the output of variables(s) associated with this object</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">scaling</span><span class="moose-parameter-header-description">Specifies a scaling factor to apply to this variable</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;double&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Specifies a scaling factor to apply to this variable</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_dual</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">True to use dual basis for Lagrange multipliers</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>True to use dual basis for Lagrange multipliers</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section></section></section></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
<!DOCTYPE html><head><meta charset="UTF-8"><title>MeshGenerator | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="ba16a615-7e7a-4b2f-a533-16c8a3a0e232" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="166d9204-9d81-4b13-90c9-5dee1fc92678" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b0e61dc6-09ca-4ea4-8aca-90a9bb99e5a7" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="66456c3c-c885-4541-98c6-573b40758ba6" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="77ac41ad-94fb-4f4c-b306-64928d8a338e"><i class="material-icons">menu</i></a><ul class="sidenav" id="77ac41ad-94fb-4f4c-b306-64928d8a338e"><li><a href="#!" class="dropdown-trigger" data-target="d5c171af-6feb-4fa4-9ff2-b133945f48c3" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="399a1263-5515-464e-9ffc-42fb2861ed84" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="dbb4eccb-857d-4249-83f5-8d83da98d6a3" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="bc6cabc6-5640-4853-b7a5-de95c5c6f294" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="ba16a615-7e7a-4b2f-a533-16c8a3a0e232"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="166d9204-9d81-4b13-90c9-5dee1fc92678"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="b0e61dc6-09ca-4ea4-8aca-90a9bb99e5a7"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="66456c3c-c885-4541-98c6-573b40758ba6"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="d5c171af-6feb-4fa4-9ff2-b133945f48c3"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="399a1263-5515-464e-9ffc-42fb2861ed84"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="dbb4eccb-857d-4249-83f5-8d83da98d6a3"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="bc6cabc6-5640-4853-b7a5-de95c5c6f294"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="e778040c-23aa-4063-896e-a41a1a266fab" data-section-level="1" data-section-text="MeshGenerator"><h1 id="meshgenerator">MeshGenerator</h1><p>This is the base class for the <code>MeshGenerator</code> system.</p><p>There are two types of mesh generators:</p><ul class="browser-default"><li><p>Those who create a mesh (examples: <a href="GeneratedMeshGenerator.html">GeneratedMeshGenerator</a>, <a href="AnnularMeshGenerator.html">AnnularMeshGenerator</a>, <a href="FileMeshGenerator.html">FileMeshGenerator</a>). </p></li><li><p>Those who modify an existing mesh (examples: <a href="MeshExtruderGenerator.html">MeshExtruderGenerator</a>, <a href="StitchMeshGenerator.html">StitchMeshGenerator</a>, <a href="RenameBlockGenerator.html">RenameBlockGenerator</a>, <a href="RenameBoundaryGenerator.html">RenameBoundaryGenerator</a>).</p></li></ul><p>The purpose of these objects is to create complex meshes using only one input file. Indeed, you can use several MeshGenerator blocks in your input file. Those represent the different steps necessary to create your complex mesh. Note that an option exists for printing mesh information to screen (see <a href="MeshGenerator.html#showing-mesh-information">Showing Mesh Information</a>) for tracking down problems when generating complex meshes with multiple mesh generators.</p><section id="da40ab5c-07be-4a48-8eeb-f02fdd3abc9b" data-section-level="2" data-section-text="Input File Example"><h2 id="input-file-example">Input File Example</h2><pre style="max-height:350px;"><code class="language-text">
[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 3
    ny = 3
    nz = 3
  []

  [tmg]
    type = TiledMeshGenerator
    input = gmg
    x_width = 1
    y_width = 1
    z_width = 1

    left_boundary = left
    right_boundary = right
    top_boundary = top
    bottom_boundary = bottom
    front_boundary = front
    back_boundary = back

    x_tiles = 2
    y_tiles = 1
    z_tiles = 5
  []
[]

[Outputs]
  exodus = true
[]
</code></pre><p>Let&#x27;s analyze the different steps. First, we use a <a href="GeneratedMeshGenerator.html">GeneratedMeshGenerator</a> to create a 3D mesh labeled <code>gmg</code> (here it&#x27;s simply a regular cube). After that, we use this mesh as an input (via <code>input = gmg</code>) to create a larger mesh using a <a href="TiledMeshGenerator.html">TiledMeshGenerator</a>.</p></section><section id="671249f2-b973-42d0-b7ac-996c9cb04e0a" data-section-level="2" data-section-text="Developing a MeshGenerator"><h2 id="developing-a-meshgenerator">Developing a MeshGenerator</h2><p>For mesh generators that create a mesh, care must be taken as to the parallel type of the mesh. You will override the <code>generate()</code> method, obtain a base mesh object, and then return your generated mesh. For obtaining the base mesh object, there are three options:</p><ul class="browser-default"><li><p>If the mesh to be generated is agnostic to the parallel type (that is, it can be either replicated or distributed), use <code>MeshGenerator::buildMeshBaseObject()</code> to generate the base mesh. See <a href="GeneratedMeshGenerator.html">GeneratedMeshGenerator</a> for an example. </p></li><li><p>If the mesh to be generated is only replicated, use <code>MeshGenerator::buildReplicatedMesh()</code> to generate the base mesh. </p></li><li><p>If the mesh to be generated is only distributed, use <code>MeshGenerator::buildDistributedMesh()</code> to generate the base mesh. See <a href="DistributedRectilinearMeshGenerator.html">DistributedRectilinearMeshGenerator</a> for an example.</p></li></ul><p>You should <strong>only</strong> use these APIs to create the base mesh in generators that create meshes. This is very important, because the internal preparation of the meshes for use is dependent on the parallel type of the mesh.</p><p>For mesh generators that modify an existing mesh, you should have as an input parameter a <code>MeshGeneratorName</code> (or multiple, as a <code>std::vector&lt;MeshGeneratorName&gt;</code> if applicable) to obtain the mesh(es) to modify. You can then obtain said meshes via <code>MeshGenerator::getMesh()</code> and <code>MeshGenerator::getMeshByName()</code>. For examples, see <a href="RenameBoundaryGenerator.html">RenameBoundaryGenerator</a> and <a href="StitchMeshGenerator.html">StitchMeshGenerator</a>. You then act on said meshes by overriding the <code>generate()</code> method, and returning the resulting mesh.</p><section id="c974282e-117b-4f5a-922f-f3bd59d68b0d" data-section-level="3" data-section-text="Using Sub MeshGenerators"><h3 id="using-sub-meshgenerators">Using Sub MeshGenerators</h3><p>Your mesh generator can instantiate subgenerators itself, to create existing meshes for the primary generator to combine and/or modify.  The easiest way to do this is to call <code>MeshGenerator::addMeshSubgenerator()</code>, which takes as arguments the generator class name and object name to instantiate, followed by an arbitrary number of name/value pairs of subgenerator parameters to set. Sub generators can be chained together by coupling them via input parameters, that is, setting input names as the names of other sub generators. To obtain a mesh from a sub generator, use the same <code>MeshGenerator::getMeshByName()</code> API as described above but with the name of the created sub generator.</p><p>If you wish to use an input mesh from the primary generator as an input to a sub generator, you must first call <code>MeshGenerator::declareMeshForSub()</code> or <code>MeshGenerator::declareMeshForSubByName()</code> to declare said input as a dependency for the sub generator instead of the generator that creates the sub generator.</p></section><section id="5caf0ee8-64db-4c95-8fb4-662d4c9234c7" data-section-level="3" data-section-text="Declaring a Null or Dummy Input"><h3 id="declaring-a-null-or-dummy-input">Declaring a Null or Dummy Input</h3><p>By default, the MeshGenerator system assumes that all parameters of type <code>MeshGeneratorName</code> or <code>std::vector&lt;MeshGeneratorName&gt;</code> are to be used as mesh inputs. If one of said names is not found, an error will be reported stating that the input mesh cannot be found. There exist cases where you want to allow the user to provide a &quot;null&quot; or dummy value for an input. An example is letting the user define a hole in a mesh pattern.</p><p>You may do this by using the <code>MeshGenerator::declareNullMeshName()</code> API. This API takes a name that is to be considered unused as an input mesh. Any input with this name will not be searched for as an existing MeshGenerator mesh and will return an uninitialized mesh when using the input mesh getters (<code>MeshGenerator::getMesh()</code>, etc).</p></section></section><section id="0e085064-11da-4ecd-98fc-d0a437d09871" data-section-level="2" data-section-text="Showing Mesh Information"><h2 id="showing-mesh-information">Showing Mesh Information</h2><p>The parameter <a href="#24379809-4db2-4fd3-8859-fde0e5b03a69" class="moose-modal-link modal-trigger">&quot;show_info&quot;</a> prints to screen detailed information about a mesh immediately after it is generated. It can be used to quickly verify properties about the mesh such as: sidesets, subdomains, and volumes.</p><p>Take the simple example:</p><pre style="max-height:350px;"><code class="language-text">
[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    ny = 2
    show_info = true
  []
</code></pre><p>The above will result in on-screen output similar to the following (ran with two processes):</p><pre style="max-height:350px;"><code class="language-text">
GeneratedMeshGenerator &#x27;gmg&#x27;:  Mesh Information:
GeneratedMeshGenerator &#x27;gmg&#x27;:   elem_dimensions()={2}
GeneratedMeshGenerator &#x27;gmg&#x27;:   spatial_dimension()=2
GeneratedMeshGenerator &#x27;gmg&#x27;:   n_nodes()=25
GeneratedMeshGenerator &#x27;gmg&#x27;:     n_local_nodes()=15
GeneratedMeshGenerator &#x27;gmg&#x27;:   n_elem()=16
GeneratedMeshGenerator &#x27;gmg&#x27;:     n_local_elem()=8
GeneratedMeshGenerator &#x27;gmg&#x27;:     n_active_elem()=16
GeneratedMeshGenerator &#x27;gmg&#x27;:   n_subdomains()=1
GeneratedMeshGenerator &#x27;gmg&#x27;:   n_partitions()=2
GeneratedMeshGenerator &#x27;gmg&#x27;:   n_processors()=2
GeneratedMeshGenerator &#x27;gmg&#x27;:   n_threads()=1
GeneratedMeshGenerator &#x27;gmg&#x27;:   processor_id()=0
GeneratedMeshGenerator &#x27;gmg&#x27;:   is_prepared()=true
GeneratedMeshGenerator &#x27;gmg&#x27;:   is_replicated()=true
GeneratedMeshGenerator &#x27;gmg&#x27;:
GeneratedMeshGenerator &#x27;gmg&#x27;:  Mesh Bounding Box:
GeneratedMeshGenerator &#x27;gmg&#x27;:   Minimum: (x,y,z)=(       0,        0,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:   Maximum: (x,y,z)=(       1,        1,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:   Delta:   (x,y,z)=(       1,        1,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:
GeneratedMeshGenerator &#x27;gmg&#x27;:  Mesh Element Type(s):
GeneratedMeshGenerator &#x27;gmg&#x27;:   QUAD4
GeneratedMeshGenerator &#x27;gmg&#x27;:
GeneratedMeshGenerator &#x27;gmg&#x27;:  Mesh Nodesets:
GeneratedMeshGenerator &#x27;gmg&#x27;:   None
GeneratedMeshGenerator &#x27;gmg&#x27;:
GeneratedMeshGenerator &#x27;gmg&#x27;:  Mesh Sidesets:
GeneratedMeshGenerator &#x27;gmg&#x27;:   Sideset 0 (bottom), 4 sides (EDGE2), 4 elems (QUAD4), 5 nodes
GeneratedMeshGenerator &#x27;gmg&#x27;:    Side volume: 1
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box minimum: (x,y,z)=(       0,        0,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box maximum: (x,y,z)=(       1,        0,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box delta: (x,y,z)=(       1,        0,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:   Sideset 1 (right), 4 sides (EDGE2), 4 elems (QUAD4), 5 nodes
GeneratedMeshGenerator &#x27;gmg&#x27;:    Side volume: 1
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box minimum: (x,y,z)=(       1,        0,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box maximum: (x,y,z)=(       1,        1,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box delta: (x,y,z)=(       0,        1,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:   Sideset 2 (top), 4 sides (EDGE2), 4 elems (QUAD4), 5 nodes
GeneratedMeshGenerator &#x27;gmg&#x27;:    Side volume: 1
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box minimum: (x,y,z)=(       0,        1,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box maximum: (x,y,z)=(       1,        1,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box delta: (x,y,z)=(       1,        0,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:   Sideset 3 (left), 4 sides (EDGE2), 4 elems (QUAD4), 5 nodes
GeneratedMeshGenerator &#x27;gmg&#x27;:    Side volume: 1
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box minimum: (x,y,z)=(       0,        0,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box maximum: (x,y,z)=(       0,        1,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box delta: (x,y,z)=(       0,        1,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:
GeneratedMeshGenerator &#x27;gmg&#x27;:  Mesh Edgesets:
GeneratedMeshGenerator &#x27;gmg&#x27;:   None
GeneratedMeshGenerator &#x27;gmg&#x27;:
GeneratedMeshGenerator &#x27;gmg&#x27;:  Mesh Subdomains:
GeneratedMeshGenerator &#x27;gmg&#x27;:   Subdomain 0: 16 elems (QUAD4, 16 active), 25 active nodes
GeneratedMeshGenerator &#x27;gmg&#x27;:    Volume: 1
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box minimum: (x,y,z)=(       0,        0,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box maximum: (x,y,z)=(       1,        1,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:    Bounding box delta: (x,y,z)=(       1,        1,        0)
GeneratedMeshGenerator &#x27;gmg&#x27;:   Global mesh volume = 1
</code></pre><p>The parameter <a href="#74b4a539-8ee3-4f0f-bf09-08fb25367b5d" class="moose-modal-link modal-trigger">&quot;output&quot;</a> enables the output of a mesh file immediately after it is generated. It can be used to view the intermediate meshes block during mesh generation.</p><p>Take the simple example:</p><pre style="max-height:350px;"><code class="language-moose">[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  [left]
    type = GeneratedMeshGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Create a line, square, or cube mesh with uniformly spaced or biased elements.&quot;, &quot;href&quot;: &quot;GeneratedMeshGenerator.html&quot;}&gt;&gt;&gt;
    dim&lt;&lt;&lt;{&quot;description&quot;: &quot;The dimension of the mesh to be generated&quot;}&gt;&gt;&gt; = 2
    nx&lt;&lt;&lt;{&quot;description&quot;: &quot;Number of elements in the X direction&quot;}&gt;&gt;&gt; = 16
    ny&lt;&lt;&lt;{&quot;description&quot;: &quot;Number of elements in the Y direction&quot;}&gt;&gt;&gt; = 16
    xmin&lt;&lt;&lt;{&quot;description&quot;: &quot;Lower X Coordinate of the generated mesh&quot;}&gt;&gt;&gt; = -3
    xmax&lt;&lt;&lt;{&quot;description&quot;: &quot;Upper X Coordinate of the generated mesh&quot;}&gt;&gt;&gt; = 0
    ymin&lt;&lt;&lt;{&quot;description&quot;: &quot;Lower Y Coordinate of the generated mesh&quot;}&gt;&gt;&gt; = -5
    ymax&lt;&lt;&lt;{&quot;description&quot;: &quot;Upper Y Coordinate of the generated mesh&quot;}&gt;&gt;&gt; = 5
    output&lt;&lt;&lt;{&quot;description&quot;: &quot;Whether or not to output the mesh file after generating the mesh&quot;}&gt;&gt;&gt; = true
  []
  [right]
    type = GeneratedMeshGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Create a line, square, or cube mesh with uniformly spaced or biased elements.&quot;, &quot;href&quot;: &quot;GeneratedMeshGenerator.html&quot;}&gt;&gt;&gt;
    dim&lt;&lt;&lt;{&quot;description&quot;: &quot;The dimension of the mesh to be generated&quot;}&gt;&gt;&gt; = 2
    nx&lt;&lt;&lt;{&quot;description&quot;: &quot;Number of elements in the X direction&quot;}&gt;&gt;&gt; = 3
    ny&lt;&lt;&lt;{&quot;description&quot;: &quot;Number of elements in the Y direction&quot;}&gt;&gt;&gt; = 3
    xmin&lt;&lt;&lt;{&quot;description&quot;: &quot;Lower X Coordinate of the generated mesh&quot;}&gt;&gt;&gt; = 3
    xmax&lt;&lt;&lt;{&quot;description&quot;: &quot;Upper X Coordinate of the generated mesh&quot;}&gt;&gt;&gt; = 6
    ymin&lt;&lt;&lt;{&quot;description&quot;: &quot;Lower Y Coordinate of the generated mesh&quot;}&gt;&gt;&gt; = -5
    ymax&lt;&lt;&lt;{&quot;description&quot;: &quot;Upper Y Coordinate of the generated mesh&quot;}&gt;&gt;&gt; = 5
  []

  [left_and_right]
    type = MeshCollectionGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Collects multiple meshes into a single (unconnected) mesh.&quot;, &quot;href&quot;: &quot;MeshCollectionGenerator.html&quot;}&gt;&gt;&gt;
    inputs&lt;&lt;&lt;{&quot;description&quot;: &quot;The input MeshGenerators.&quot;}&gt;&gt;&gt; = &#x27;left right&#x27;
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#634a471f-5cff-4011-b66b-a468e5bedc7a">(moose/test/tests/meshgenerators/output_intermediate_mesh/output_intermediate_mesh.i)</a><p>The above will result in an intermediate mesh file &#x27;left_in.e&#x27; in addition to the final mesh file &#x27;output_intermediate_mesh_in.e&#x27; when ran in mesh only mode.</p></section><section id="d793720c-fc86-430a-b208-73e7901cc52c" data-section-level="2" data-section-text="Using data - driven generation"><h2 id="using-data-driven-generation">Using data-driven generation</h2><p>The system optionally supports the capability to do &quot;data-driven&quot; generation. With data-driven generation, a <code>generateData()</code> method is overriden on each generator and said generator is set to support this generation by calling</p><pre style="max-height:350px;"><code class="language-text">
MeshGenerator::setHasGenerateData(params);
</code></pre><p>within the parameters of the generator.</p><p>The parameter <a href="#4625b319-53ce-479d-8a08-79cab94d4b7f" class="moose-modal-link modal-trigger">&quot;data_driven_generator&quot;</a> is then set in the top level <code>Mesh</code> block, in which you set the name of the generator that will consume data-driven generators. When this is set, all parents of the generator described in the parameter will generate only by calling <code>generateData()</code>, and not <code>generate()</code>. Thus, they will simply generate metadata and not an actual mesh. The generator that is set in <a href="#45d40615-c40d-405f-9066-342520e71e7c" class="moose-modal-link modal-trigger">&quot;data_driven_generator&quot;</a> will call <code>generate()</code>, and all other dependents will as well. All sub-generators of a generator that is ran in data-only mode will also be ran in data-only mode.</p><p>Note that all generators that have this method enabled will always call <code>generateData()</code> during generation, and will only call <code>generate()</code> afterwards if they are not the parent to a generator that is data-driven.</p><p>This is an advanced method that requires a heavy understanding of all generators that exist in the generation tree, and thus it is not enabled by default. To enable it, the parameter <code>allow_data_driven_mesh_generation</code> on your application can be set to true.</p></section><section id="c576a1ec-50a7-4353-b19d-30104a87995b" data-section-level="2" data-section-text="Generating CSG Models"><h2 id="generating-csg-models">Generating CSG Models</h2><p>The system optionally supports the generation of base data for a <span>Constructive Solid Geometry (CSG)</span>. In this execution setting, a <code>CSGBase</code> object is created, which contains the surfaces, cells, and universes needed to define the equivalent MOOSE geometry as a CSG model for use with downstream Monte Carlo codes. <span class="tooltipped" data-tooltip="Constructive Solid Geometry" data-position="top" data-delay="50">CSG</span> generation is triggered using the <code>--csg-only</code> command line option, and a <code>generateCSG()</code> method is overridden for each generator that is defined within the mesh input file. In order to indicate to the mesh generation system that <span class="tooltipped" data-tooltip="Constructive Solid Geometry" data-position="top" data-delay="50">CSG</span> generation is supported, the following call for <code>setHasGenerateCSG</code> is made within the parameters of the generator:</p><pre style="max-height:350px;"><code class="language-cpp">  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#54985fef-e916-4e96-944e-0d623be8d191">(moose/test/src/csg/ExampleCSGInfiniteSquareMeshGenerator.C)</a><p>When running with <code>--csg-only</code> as a command line option, all mesh generators that are part of the input file will call <code>generateData()</code> and then <code>generateCSG()</code> instead of <code>generate()</code>. The logic for defining the <code>CSGBase</code> object should be contained within the <code>generateCSG()</code> routine for each mesh generator. No finite element mesh is created using this execution mode.</p><p>For more information about the theory of <span class="tooltipped" data-tooltip="Constructive Solid Geometry" data-position="top" data-delay="50">CSG</span> as a geometry representation, please see <a href="../../syntax/CSG/index.html">Constructive Solid Geometry</a>. Additional information about implementing <code>generateCSG()</code> methods for each mesh generator can be found in <a href="../csg/CSGBase.html">CSGBase</a>. </p></section></section><div class="moose-modal modal" id="24379809-4db2-4fd3-8859-fde0e5b03a69"><div class="modal-content"><h4>show_info</h4><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not to show mesh info after generating the mesh (bounding box, element types, sidesets, nodesets, subdomains, etc)</p></div></div><div class="moose-modal modal" id="74b4a539-8ee3-4f0f-bf09-08fb25367b5d"><div class="modal-content"><h4>output</h4><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not to output the mesh file after generating the mesh</p></div></div><div class="moose-modal modal" id="634a471f-5cff-4011-b66b-a468e5bedc7a"><div class="modal-content"><h4>(moose/test/tests/meshgenerators/output_intermediate_mesh/output_intermediate_mesh.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  [left]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 16
    ny = 16
    xmin = -3
    xmax = 0
    ymin = -5
    ymax = 5
    output = true
  []
  [right]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 3
    ny = 3
    xmin = 3
    xmax = 6
    ymin = -5
    ymax = 5
  []

  [left_and_right]
    type = MeshCollectionGenerator
    inputs = &#x27;left right&#x27;
  []
[]

</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="4625b319-53ce-479d-8a08-79cab94d4b7f"><div class="modal-content"><h4>data_driven_generator</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::string</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Set to make all dependencies of this mesh generator run in data driven mode, where a mesh is not generated</p></div></div><div class="moose-modal modal" id="45d40615-c40d-405f-9066-342520e71e7c"><div class="modal-content"><h4>data_driven_generator</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::string</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Set to make all dependencies of this mesh generator run in data driven mode, where a mesh is not generated</p></div></div><div class="moose-modal modal" id="54985fef-e916-4e96-944e-0d623be8d191"><div class="modal-content"><h4>(moose/test/src/csg/ExampleCSGInfiniteSquareMeshGenerator.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ExampleCSGInfiniteSquareMeshGenerator.h&quot;
#include &quot;CSGBase.h&quot;
#include &quot;CSGPlane.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ExampleCSGInfiniteSquareMeshGenerator);

InputParameters
ExampleCSGInfiniteSquareMeshGenerator::validParams()
{
  InputParameters params = MeshGenerator::validParams();

  params.addRequiredParam&lt;Real&gt;(&quot;side_length&quot;, &quot;Side length of infinite square.&quot;);
  params.addParam&lt;MeshGeneratorName&gt;(
      &quot;fill&quot;, &quot;optional input lattice mesh generator to fill generated cell with.&quot;);
  // Declare that this generator has a generateCSG method
  MeshGenerator::setHasGenerateCSG(params);
  return params;
}

ExampleCSGInfiniteSquareMeshGenerator::ExampleCSGInfiniteSquareMeshGenerator(
    const InputParameters &amp; params)
  : MeshGenerator(params),
    _side_length(getParam&lt;Real&gt;(&quot;side_length&quot;)),
    _input_fill_name(isParamValid(&quot;fill&quot;) ? getParam&lt;MeshGeneratorName&gt;(&quot;fill&quot;) : &quot;&quot;),
    _has_fill(isParamValid(&quot;fill&quot;))
{
  if (_has_fill)
  {
    _input_fill_mg_ptr = &amp;getMesh(&quot;fill&quot;);
    _input_fill_csg = &amp;getCSGBase(&quot;fill&quot;);
  }
}

std::unique_ptr&lt;MeshBase&gt;
ExampleCSGInfiniteSquareMeshGenerator::generate()
{
  auto null_mesh = nullptr;
  return null_mesh;
}

std::unique_ptr&lt;CSG::CSGBase&gt;
ExampleCSGInfiniteSquareMeshGenerator::generateCSG()
{
  // name of the current mesh generator to use for naming generated objects
  auto mg_name = this-&gt;name();

  // initialize a CSGBase object
  auto csg_obj = std::make_unique&lt;CSG::CSGBase&gt;();

  // Add surfaces and halfspaces corresponding to 4 planes of infinite square
  std::vector&lt;std::vector&lt;Point&gt;&gt; points_on_planes{{Point(1. * _side_length / 2., 0., 0.),
                                                    Point(1. * _side_length / 2., 1., 0.),
                                                    Point(1. * _side_length / 2., 0., 1.)},
                                                   {Point(-1. * _side_length / 2., 0., 0.),
                                                    Point(-1. * _side_length / 2., 1., 0.),
                                                    Point(-1. * _side_length / 2., 0., 1.)},
                                                   {Point(0., 1. * _side_length / 2., 0.),
                                                    Point(1., 1. * _side_length / 2., 0.),
                                                    Point(0., 1. * _side_length / 2., 1.)},
                                                   {Point(0., -1. * _side_length / 2., 0.),
                                                    Point(1., -1. * _side_length / 2., 0.),
                                                    Point(0., -1. * _side_length / 2., 1.)}};
  std::vector&lt;std::string&gt; surf_names{&quot;plus_x&quot;, &quot;minus_x&quot;, &quot;plus_y&quot;, &quot;minus_y&quot;};

  // initialize cell region to be updated
  CSG::CSGRegion region;

  // set the center of the prism to be used for determining half-spaces
  const auto centroid = Point(0, 0, 0);

  for (unsigned int i = 0; i &lt; points_on_planes.size(); ++i)
  {
    // object name includes the mesh generator name for uniqueness
    const auto surf_name = mg_name + &quot;_surf_&quot; + surf_names[i];
    // create the plane for one face of the prism
    std::unique_ptr&lt;CSG::CSGSurface&gt; plane_ptr = std::make_unique&lt;CSG::CSGPlane&gt;(
        surf_name, points_on_planes[i][0], points_on_planes[i][1], points_on_planes[i][2]);
    auto &amp; csg_plane = csg_obj-&gt;addSurface(std::move(plane_ptr));
    // determine where the plane is in relation to the centroid to be able to set the half-space
    const auto region_direction = csg_plane.getHalfspaceFromPoint(centroid);
    // half-space is either positive (+plane_ptr) or negative (-plane_ptr)
    // depending on the direction to the centroid
    auto halfspace =
        ((region_direction == CSG::CSGSurface::Halfspace::POSITIVE) ? +csg_plane : -csg_plane);
    // check if this is the first half-space to be added to the region,
    // if not, update the existing region with the intersection of the regions (&amp;=)
    if (region.getRegionType() == CSG::CSGRegion::RegionType::EMPTY)
      region = halfspace;
    else
      region &amp;= halfspace;
  }

  // create the cell defined by the surfaces and region just created
  const auto cell_name = mg_name + &quot;_square_cell&quot;;
  // determine fill: either from input fill mesh generator or default material
  if (_has_fill)
  {
    // join the fill CSGBase into the current CSGBase &amp; use the lattice as the fill
    csg_obj-&gt;joinOtherBase(std::move(*_input_fill_csg));
    // assume input MG is a lattice type for sake of this example/test
    const CSG::CSGLattice &amp; lattice = csg_obj-&gt;getLatticeByName(_input_fill_name + &quot;_lattice&quot;);
    csg_obj-&gt;createCell(cell_name, lattice, region);
  }
  else // default material fill
  {
    const auto material_name = &quot;square_material&quot;;
    csg_obj-&gt;createCell(cell_name, material_name, region);
  }

  return csg_obj;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
<!DOCTYPE html><head><meta charset="UTF-8"><title>Boundary 2 DDelaunayGenerator | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="c5885bc9-0263-4017-86f4-ffec1a78f7c7" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="813f6574-9a0a-418a-9216-7a0e5e5a428c" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="423fa336-da7e-4adb-838a-89a39984f7d7" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="19347d35-7cc9-4568-8ac6-1973ea21d9bf" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="11470d96-cb25-4fc4-950d-a4e2c59e3e8a"><i class="material-icons">menu</i></a><ul class="sidenav" id="11470d96-cb25-4fc4-950d-a4e2c59e3e8a"><li><a href="#!" class="dropdown-trigger" data-target="3751a46f-c4dc-43d0-895b-d9217c9d35e9" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="7f24efe5-1f5c-4706-81b6-d541b615ffca" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="e9588975-f485-4a12-84f1-d48ca4aa9f75" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="2f3bccb3-e1e2-40f6-aaf1-fd85e396107d" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="c5885bc9-0263-4017-86f4-ffec1a78f7c7"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="813f6574-9a0a-418a-9216-7a0e5e5a428c"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="423fa336-da7e-4adb-838a-89a39984f7d7"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="19347d35-7cc9-4568-8ac6-1973ea21d9bf"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="3751a46f-c4dc-43d0-895b-d9217c9d35e9"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="7f24efe5-1f5c-4706-81b6-d541b615ffca"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="e9588975-f485-4a12-84f1-d48ca4aa9f75"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="2f3bccb3-e1e2-40f6-aaf1-fd85e396107d"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="099df76c-b2d0-4fce-9469-927b8a0387bb" data-section-level="1" data-section-text="Boundary 2 DDelaunayGenerator"><h1 id="boundary-2-ddelaunaygenerator">Boundary2DDelaunayGenerator</h1><p>Mesh generator that convert a 2D surface given as one or a few boundaries of a 3D mesh into a 2D mesh using Delaunay triangulation.</p><section id="6596ae29-4257-4b99-8bbd-0c4d01d08093" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p>This <code>Boundary2DDelaunayGenerator</code> utilizes the 2D triangulation capabilities in the XY-plane, which is adopted by <a href="XYDelaunayGenerator.html"><code>XYDelaunayGenerator</code></a> and extends it to support more generalized 2D surface cases. The input of this generator is not limited to a 2D mesh residing in the XY-plane. Instead, it can accept a 2D mesh with curvature in the 3D space.</p><p>The input of this mesh generator is defined by a mesh name (<a href="#602a6a17-029e-4300-9354-5bdb391e86ee" class="moose-modal-link modal-trigger">&quot;input&quot;</a>) along with a list of boundary names (<a href="#4ecba232-ed41-492e-ad03-00835e8758f2" class="moose-modal-link modal-trigger">&quot;boundary_names&quot;</a>) within it. The generator will extract the specified boundaries from the input mesh and generate a 2D mesh through Delaunay triangulation based on them. The output mesh can be further processed and then used as input for 3D Delaunay mesh generation (<a href="XYZDelaunayGenerator.html">XYZelaunayGenerator</a>). This mesh generator also supports hole meshes defined as boundaries (<a href="#d6c316cb-1930-499e-8872-cfbef3c11f59" class="moose-modal-link modal-trigger">&quot;hole_boundary_names&quot;</a>) in the input mesh as well as the automatic area control (<a href="#a4dde19f-cfd8-4e43-acbe-d42c6232641d" class="moose-modal-link modal-trigger">&quot;use_auto_area_func&quot;</a>).</p></section><section id="c6d3fa9e-fb2b-4c8b-a09f-96c716f4a627" data-section-level="2" data-section-text="Methods"><h2 id="methods">Methods</h2><p>The same methods adopted by <a href="XYDelaunayGenerator.html"><code>XYDelaunayGenerator</code></a> are called by this mesh generator. To support a generalized 2D surface (see <a href="#bdry_2d_delaunay">Figure 1</a>a), the following approaches are implemented:</p><ul class="browser-default"><li><p>An average normal vector of the given 2D surface is computed based on the normal vectors of the elements weighted by their areas. </p></li><li><p>The 2D surface is then rotated and translated so that its centroid is on the XY-plane and the average normal vector is aligned with the Z-axis (see <a href="#bdry_2d_delaunay">Figure 1</a>b). </p></li><li><p>The 2D surface is projected onto the XY-plane so that the triangulation method can be applied (see <a href="#bdry_2d_delaunay">Figure 1</a>c). </p></li><li><p>The new 2D mesh in the XY-plane is generated through Delaunay triangulation (same as <a href="XYDelaunayGenerator.html"><code>XYDelaunayGenerator</code></a>)(see <a href="#bdry_2d_delaunay">Figure 1</a>d). </p></li><li><p>The new 2D mesh is reversely projected back to the original 3D space based on the original 2D surface. </p></li><li><p>The new 2D mesh is translated and rotated back to the original position of the 2D surface (see <a href="#bdry_2d_delaunay">Figure 1</a>e). </p></li><li><p>Optionally, the nodes in the new 2D mesh can be corrected using a provided level set function of the surface (<a href="#9a8d6828-1936-46ba-911c-6d8cee04802b" class="moose-modal-link modal-trigger">&quot;level_set&quot;</a>)(see <a href="#bdry_2d_delaunay">Figure 1</a>f).</p></li></ul><div class="card moose-float" style="width:80%;" id="bdry_2d_delaunay"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/framework/meshgenerators/bdry_2d_delaunay.png" alt="The workflow of the `Boundary2DDelaunayGenerator` mesh generator."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 1: </span><span class="moose-caption-text" id="bdry_2d_delaunay">The workflow of the <code>Boundary2DDelaunayGenerator</code> mesh generator.</span></p></div></div><p>As projection is used to enable the triangulation of the 2D surface, it is crucial to limit the angle deviation of the element normals in the 2D mesh from the average normal vector of the surface. This is controlled by the <a href="#cb163559-489a-43c1-b527-c59dd6e5f14a" class="moose-modal-link modal-trigger">&quot;max_angle_deviation&quot;</a> parameter. Deviation must be less than 90 degrees to avert overlapping elements. The projection also introduces errors in the element area control. The actual element area to be controlled are the projected areas of the elements in the 2D mesh. A projection correction method will potentially be developed in the future.</p></section><section id="57f52f35-31bc-48bf-82ae-abf5771d4fd3" data-section-level="2" data-section-text="Application"><h2 id="application">Application</h2><p>One common application of this mesh generator is to prepare 2D surface meshes to be used as input for 3D Delaunay mesh generation(<a href="XYZDelaunayGenerator.html">XYZelaunayGenerator</a>). For a raw 3D mesh with a closed 2D surface, the 2D surface can be divided into multiple regions to be compatible with the triangulation method with projection. <code>Boundary2DDelaunayGenerator</code> can be used to generate the 2D surface mesh with better mesh density and quality control. Especially, the surface generated by mesh cutting (e.g., <a href="CutMeshByPlaneGenerator.html"><code>CutMeshByPlaneGenerator</code></a> and <a href="CutMeshByLevelSetGenerator.html"><code>CutMeshByLevelSetGenerator</code></a>) can be improved. The generated 2D surfaces can then be stitched together to form a closed surface mesh for 3D Delaunay mesh generation. An example is give in <a href="#xyzd_example">Listing 1</a> with visualization in <a href="#example_cylinder">Figure 2</a>.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 1: </span><span class="moose-caption-text" id="xyzd_example">Example input file to use <code>Boundary2DDelaunayGenerator</code> to prepare a cylinder surface mesh for 3D Delaunay mesh generation.</span></p><pre style="max-height:350px;"><code class="language-moose">[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  [circle]
    type = ConcentricCircleMeshGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;This ConcentricCircleMeshGenerator source code is to generate concentric circle meshes.&quot;, &quot;href&quot;: &quot;ConcentricCircleMeshGenerator.html&quot;}&gt;&gt;&gt;
    has_outer_square&lt;&lt;&lt;{&quot;description&quot;: &quot;It determines if meshes for a outer square are added to concentric circle meshes.&quot;}&gt;&gt;&gt; = false
    radii&lt;&lt;&lt;{&quot;description&quot;: &quot;Radii of major concentric circles&quot;}&gt;&gt;&gt; = 1
    num_sectors&lt;&lt;&lt;{&quot;description&quot;: &quot;num_sectors % 2 = 0, num_sectors &gt; 0Number of azimuthal sectors in each quadrant&#x27;num_sectors&#x27; must be an even number.&quot;}&gt;&gt;&gt; = 4
    rings&lt;&lt;&lt;{&quot;description&quot;: &quot;Number of rings in each circle or in the enclosing square&quot;}&gt;&gt;&gt; = 1
    preserve_volumes&lt;&lt;&lt;{&quot;description&quot;: &quot;Volume of concentric circles can be preserved using this function.&quot;}&gt;&gt;&gt; = false
  []
  [side]
    type = SideSetsAroundSubdomainGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Adds element faces that are on the exterior of the given block to the sidesets specified&quot;, &quot;href&quot;: &quot;SideSetsAroundSubdomainGenerator.html&quot;}&gt;&gt;&gt;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh we want to modify&quot;}&gt;&gt;&gt; = circle
    new_boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary names to create on the supplied subdomain&quot;}&gt;&gt;&gt; = side
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The blocks around which to create sidesets&quot;}&gt;&gt;&gt; = 1
  []
  [extrude]
    type = AdvancedExtruderGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Extrudes a 1D mesh into 2D, or a 2D mesh into 3D, can have a variable height for each elevation, variable number of layers within each elevation, variable growth factors of axial element sizes within each elevation and remap subdomain_ids, boundary_ids and element extra integers within each elevation as well as interface boundaries between neighboring elevation layers.&quot;, &quot;href&quot;: &quot;AdvancedExtruderGenerator.html&quot;}&gt;&gt;&gt;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh to extrude&quot;}&gt;&gt;&gt; = side
    heights&lt;&lt;&lt;{&quot;description&quot;: &quot;The height of each elevation&quot;}&gt;&gt;&gt; = &#x27;2&#x27;
    num_layers&lt;&lt;&lt;{&quot;description&quot;: &quot;The number of layers for each elevation - must be num_elevations in length!&quot;}&gt;&gt;&gt; = &#x27;3&#x27;
    direction&lt;&lt;&lt;{&quot;description&quot;: &quot;A vector that points in the direction to extrude (note, this will be normalized internally - so don&#x27;t worry about it here)&quot;}&gt;&gt;&gt; = &#x27;0 0 1&#x27;
  []
  [side_1]
    type = ParsedGenerateSideset&lt;&lt;&lt;{&quot;description&quot;: &quot;A MeshGenerator that adds element sides to a sideset if the centroid of the side satisfies the `combinatorial_geometry` expression.&quot;, &quot;href&quot;: &quot;ParsedGenerateSideset.html&quot;}&gt;&gt;&gt;
    combinatorial_geometry&lt;&lt;&lt;{&quot;description&quot;: &quot;Function expression encoding a combinatorial geometry&quot;}&gt;&gt;&gt; = &#x27;x&gt;=0&amp;y&gt;=0&#x27;
    new_sideset_name&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the new sideset&quot;}&gt;&gt;&gt; = &#x27;side_1&#x27;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh we want to modify&quot;}&gt;&gt;&gt; = &#x27;extrude&#x27;
    included_boundaries&lt;&lt;&lt;{&quot;description&quot;: &quot;A set of boundary names or ids whose sides will be included in the new sidesets.  A side is only added if it also belongs to one of these boundaries.&quot;}&gt;&gt;&gt; = &#x27;side&#x27;
  []
  [bd_1]
    type = Boundary2DDelaunayGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Mesh generator that convert a 2D surface given as one or a few boundaries of a 3D mesh into a 2D mesh using Delaunay triangulation.&quot;, &quot;href&quot;: &quot;Boundary2DDelaunayGenerator.html&quot;}&gt;&gt;&gt;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh we want to modify&quot;}&gt;&gt;&gt; = side_1
    boundary_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The boundaries to be used&quot;}&gt;&gt;&gt; = &#x27;side_1&#x27;
    use_auto_area_func&lt;&lt;&lt;{&quot;description&quot;: &quot;Use the automatic area function for the triangle meshing region.&quot;}&gt;&gt;&gt; = true
  []
  [side_2]
    type = ParsedGenerateSideset&lt;&lt;&lt;{&quot;description&quot;: &quot;A MeshGenerator that adds element sides to a sideset if the centroid of the side satisfies the `combinatorial_geometry` expression.&quot;, &quot;href&quot;: &quot;ParsedGenerateSideset.html&quot;}&gt;&gt;&gt;
    combinatorial_geometry&lt;&lt;&lt;{&quot;description&quot;: &quot;Function expression encoding a combinatorial geometry&quot;}&gt;&gt;&gt; = &#x27;x&lt;0&amp;y&gt;=0&#x27;
    new_sideset_name&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the new sideset&quot;}&gt;&gt;&gt; = &#x27;side_2&#x27;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh we want to modify&quot;}&gt;&gt;&gt; = &#x27;extrude&#x27;
    included_boundaries&lt;&lt;&lt;{&quot;description&quot;: &quot;A set of boundary names or ids whose sides will be included in the new sidesets.  A side is only added if it also belongs to one of these boundaries.&quot;}&gt;&gt;&gt; = &#x27;side&#x27;
  []
  [bd_2]
    type = Boundary2DDelaunayGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Mesh generator that convert a 2D surface given as one or a few boundaries of a 3D mesh into a 2D mesh using Delaunay triangulation.&quot;, &quot;href&quot;: &quot;Boundary2DDelaunayGenerator.html&quot;}&gt;&gt;&gt;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh we want to modify&quot;}&gt;&gt;&gt; = side_2
    boundary_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The boundaries to be used&quot;}&gt;&gt;&gt; = &#x27;side_2&#x27;
    use_auto_area_func&lt;&lt;&lt;{&quot;description&quot;: &quot;Use the automatic area function for the triangle meshing region.&quot;}&gt;&gt;&gt; = true
  []
  [side_3]
    type = ParsedGenerateSideset&lt;&lt;&lt;{&quot;description&quot;: &quot;A MeshGenerator that adds element sides to a sideset if the centroid of the side satisfies the `combinatorial_geometry` expression.&quot;, &quot;href&quot;: &quot;ParsedGenerateSideset.html&quot;}&gt;&gt;&gt;
    combinatorial_geometry&lt;&lt;&lt;{&quot;description&quot;: &quot;Function expression encoding a combinatorial geometry&quot;}&gt;&gt;&gt; = &#x27;x&lt;0&amp;y&lt;0&#x27;
    new_sideset_name&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the new sideset&quot;}&gt;&gt;&gt; = &#x27;side_3&#x27;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh we want to modify&quot;}&gt;&gt;&gt; = &#x27;extrude&#x27;
    included_boundaries&lt;&lt;&lt;{&quot;description&quot;: &quot;A set of boundary names or ids whose sides will be included in the new sidesets.  A side is only added if it also belongs to one of these boundaries.&quot;}&gt;&gt;&gt; = &#x27;side&#x27;
  []
  [bd_3]
    type = Boundary2DDelaunayGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Mesh generator that convert a 2D surface given as one or a few boundaries of a 3D mesh into a 2D mesh using Delaunay triangulation.&quot;, &quot;href&quot;: &quot;Boundary2DDelaunayGenerator.html&quot;}&gt;&gt;&gt;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh we want to modify&quot;}&gt;&gt;&gt; = side_3
    boundary_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The boundaries to be used&quot;}&gt;&gt;&gt; = &#x27;side_3&#x27;
    use_auto_area_func&lt;&lt;&lt;{&quot;description&quot;: &quot;Use the automatic area function for the triangle meshing region.&quot;}&gt;&gt;&gt; = true
  []
  [side_4]
    type = ParsedGenerateSideset&lt;&lt;&lt;{&quot;description&quot;: &quot;A MeshGenerator that adds element sides to a sideset if the centroid of the side satisfies the `combinatorial_geometry` expression.&quot;, &quot;href&quot;: &quot;ParsedGenerateSideset.html&quot;}&gt;&gt;&gt;
    combinatorial_geometry&lt;&lt;&lt;{&quot;description&quot;: &quot;Function expression encoding a combinatorial geometry&quot;}&gt;&gt;&gt; = &#x27;x&gt;=0&amp;y&lt;0&#x27;
    new_sideset_name&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the new sideset&quot;}&gt;&gt;&gt; = &#x27;side_4&#x27;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh we want to modify&quot;}&gt;&gt;&gt; = &#x27;extrude&#x27;
    included_boundaries&lt;&lt;&lt;{&quot;description&quot;: &quot;A set of boundary names or ids whose sides will be included in the new sidesets.  A side is only added if it also belongs to one of these boundaries.&quot;}&gt;&gt;&gt; = &#x27;side&#x27;
  []
  [bd_4]
    type = Boundary2DDelaunayGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Mesh generator that convert a 2D surface given as one or a few boundaries of a 3D mesh into a 2D mesh using Delaunay triangulation.&quot;, &quot;href&quot;: &quot;Boundary2DDelaunayGenerator.html&quot;}&gt;&gt;&gt;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh we want to modify&quot;}&gt;&gt;&gt; = side_4
    boundary_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The boundaries to be used&quot;}&gt;&gt;&gt; = &#x27;side_4&#x27;
    use_auto_area_func&lt;&lt;&lt;{&quot;description&quot;: &quot;Use the automatic area function for the triangle meshing region.&quot;}&gt;&gt;&gt; = true
  []
  [bd_bot]
    type = Boundary2DDelaunayGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Mesh generator that convert a 2D surface given as one or a few boundaries of a 3D mesh into a 2D mesh using Delaunay triangulation.&quot;, &quot;href&quot;: &quot;Boundary2DDelaunayGenerator.html&quot;}&gt;&gt;&gt;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh we want to modify&quot;}&gt;&gt;&gt; = extrude
    boundary_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The boundaries to be used&quot;}&gt;&gt;&gt; = &#x27;2&#x27;
    use_auto_area_func&lt;&lt;&lt;{&quot;description&quot;: &quot;Use the automatic area function for the triangle meshing region.&quot;}&gt;&gt;&gt; = true
  []
  [bd_top]
    type = Boundary2DDelaunayGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Mesh generator that convert a 2D surface given as one or a few boundaries of a 3D mesh into a 2D mesh using Delaunay triangulation.&quot;, &quot;href&quot;: &quot;Boundary2DDelaunayGenerator.html&quot;}&gt;&gt;&gt;
    input&lt;&lt;&lt;{&quot;description&quot;: &quot;The mesh we want to modify&quot;}&gt;&gt;&gt; = extrude
    boundary_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The boundaries to be used&quot;}&gt;&gt;&gt; = &#x27;3&#x27;
    use_auto_area_func&lt;&lt;&lt;{&quot;description&quot;: &quot;Use the automatic area function for the triangle meshing region.&quot;}&gt;&gt;&gt; = true
  []
  [smg]
    type = StitchMeshGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Allows multiple mesh files to be stitched together to form a single mesh.&quot;, &quot;href&quot;: &quot;StitchMeshGenerator.html&quot;}&gt;&gt;&gt;
    inputs&lt;&lt;&lt;{&quot;description&quot;: &quot;The input MeshGenerators.&quot;}&gt;&gt;&gt; = &#x27;bd_1 bd_2 bd_3 bd_4 bd_top bd_bot&#x27;
    clear_stitched_boundary_ids&lt;&lt;&lt;{&quot;description&quot;: &quot;Whether or not to clear the stitched boundary IDs&quot;}&gt;&gt;&gt; = true
    stitch_boundaries_pairs&lt;&lt;&lt;{&quot;description&quot;: &quot;Pairs of boundaries to be stitched together between the 1st mesh in inputs and each consecutive mesh&quot;}&gt;&gt;&gt; = &#x27;0 0;0 0;0 0;0 0;0 0&#x27;
    merge_boundaries_with_same_name&lt;&lt;&lt;{&quot;description&quot;: &quot;If the input meshes have boundaries with the same name (but different IDs), merge them&quot;}&gt;&gt;&gt; = true
    prevent_boundary_ids_overlap&lt;&lt;&lt;{&quot;description&quot;: &quot;Whether to re-number boundaries in stitched meshes to prevent merging of unrelated boundaries&quot;}&gt;&gt;&gt; = false
  []
  [xyzd]
    type = XYZDelaunayGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Creates tetrahedral 3D meshes within boundaries defined by input meshes.&quot;, &quot;href&quot;: &quot;XYZDelaunayGenerator.html&quot;}&gt;&gt;&gt;
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The input MeshGenerator defining the output outer boundary. The input mesh (the output mesh of the input mesh generator) can either include 3D volume elements or 2D surface elements.&quot;}&gt;&gt;&gt; = smg
    desired_volume&lt;&lt;&lt;{&quot;description&quot;: &quot;Desired (maximum) tetrahedral volume, or 0 to skip uniform refinement&quot;}&gt;&gt;&gt; = 1
    output_subdomain_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Subdomain name to set on new triangles.&quot;}&gt;&gt;&gt; = &#x27;matrix&#x27;
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#97975ffb-2a03-4261-91c2-e41be043f8d6">(moose/test/tests/meshgenerators/boundary_2d_delaunay_generator/cylinder.i)</a></div></div><div class="card moose-float" style="width:80%;" id="example_cylinder"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/framework/meshgenerators/cylinder.png" alt="The workflow of the `Boundary2DDelaunayGenerator` mesh generator."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 2: </span><span class="moose-caption-text" id="example_cylinder">The workflow of the <code>Boundary2DDelaunayGenerator</code> mesh generator.</span></p></div></div></section><section id="a7bd51c4-8b1f-4e9a-a14b-6fa9abbd05ef" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="05a5b57b-fff9-478e-954a-211b41ebecf4" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">boundary_names</span><span class="moose-parameter-header-description">The boundaries to be used</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;BoundaryName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The boundaries to be used</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">input</span><span class="moose-parameter-header-description">The mesh we want to modify</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MeshGeneratorName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The mesh we want to modify</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="cec2bbb5-4001-4ce5-ac9f-9d6ba99f05d9" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">epsilon</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">Fuzzy comparison tolerance</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Fuzzy comparison tolerance</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">hole_boundary_names</span><span class="moose-parameter-header-description">The optional boundaries to be used as the holes in the mesh during triangulation. Note that this is a vector of vectors, which allows each hole to be defined as a combination of multiple boundaries.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::vector&lt;BoundaryName&gt;&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The optional boundaries to be used as the holes in the mesh during triangulation. Note that this is a vector of vectors, which allows each hole to be defined as a combination of multiple boundaries.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">level_set</span><span class="moose-parameter-header-description">Level set used to achieve more accurate reverse projection compared to interpolation.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::string</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Level set used to achieve more accurate reverse projection compared to interpolation.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">max_angle_deviation</span><span class="moose-parameter-header-default">60</span><span class="moose-parameter-header-description">Maximum angle deviation from the global average normal vector in the input mesh.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>60</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-doc-range"><span>Range:</span>max_angle_deviation>0 & max_angle_deviation<90</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Maximum angle deviation from the global average normal vector in the input mesh.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">max_level_set_correction_iterations</span><span class="moose-parameter-header-default">3</span><span class="moose-parameter-header-description">Maximum number of iterations to correct the nodes based on the level set function.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>3</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Maximum number of iterations to correct the nodes based on the level set function.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">output_external_boundary_name</span><span class="moose-parameter-header-description">The optional name of the external boundary of the mesh to generate. If not provided, the external boundary will be have a trivial id of 0.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>BoundaryName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The optional name of the external boundary of the mesh to generate. If not provided, the external boundary will be have a trivial id of 0.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="c91487df-7586-4975-9032-b6cf83294068" data-section-level="3" data-section-text="Automatic Triangle Meshing Area Control Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">auto_area_func_default_size</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">Background size for automatic area function, or 0 to use non background size</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Background size for automatic area function, or 0 to use non background size</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">auto_area_func_default_size_dist</span><span class="moose-parameter-header-default">-1</span><span class="moose-parameter-header-description">Effective distance of background size for automatic area function, or negative to use non background size</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>-1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Effective distance of background size for automatic area function, or negative to use non background size</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">auto_area_function_num_points</span><span class="moose-parameter-header-default">10</span><span class="moose-parameter-header-description">Maximum number of nearest points used for the inverse distance interpolation algorithm for automatic area function calculation.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>10</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Maximum number of nearest points used for the inverse distance interpolation algorithm for automatic area function calculation.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">auto_area_function_power</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">Polynomial power of the inverse distance interpolation algorithm for automatic area function calculation.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-doc-range"><span>Range:</span>auto_area_function_power>0</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Polynomial power of the inverse distance interpolation algorithm for automatic area function calculation.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_auto_area_func</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Use the automatic area function for the triangle meshing region.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Use the automatic area function for the triangle meshing region.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Automatic Triangle Meshing Area Control Parameters</h3></summary></details></section><section id="c389e8b4-5daf-466b-b125-aa26a889e34d" data-section-level="3" data-section-text="Parsed Expression Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">disable_fpoptimizer</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Disable the function parser algebraic optimizer</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Disable the function parser algebraic optimizer</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable_ad_cache</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Enable caching of function derivatives for faster startup time</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Enable caching of function derivatives for faster startup time</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable_auto_optimize</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Enable automatic immediate optimization of derivatives</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Enable automatic immediate optimization of derivatives</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable_jit</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Enable just-in-time compilation of function expressions for faster evaluation</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Enable just-in-time compilation of function expressions for faster evaluation</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">evalerror_behavior</span><span class="moose-parameter-header-default">nan</span><span class="moose-parameter-header-description">What to do if evaluation error occurs. Options are to pass a nan, pass a nan with a warning, throw a error, or throw an exception</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nan</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nan, nan_warning, error, exception</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>What to do if evaluation error occurs. Options are to pass a nan, pass a nan with a warning, throw a error, or throw an exception</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Parsed Expression Advanced Parameters</h3></summary></details></section><section id="8848b77f-965d-4f77-a389-f73d8d5f331a" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">save_with_name</span><span class="moose-parameter-header-description">Keep the mesh from this mesh generator in memory with the name specified</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::string</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Keep the mesh from this mesh generator in memory with the name specified</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="b81ba071-0fe5-443c-a151-75d23e4968ae" data-section-level="3" data-section-text="Debugging Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">nemesis</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not to output the mesh file in the nemesisformat (only if output = true)</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not to output the mesh file in the nemesisformat (only if output = true)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">output</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not to output the mesh file after generating the mesh</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not to output the mesh file after generating the mesh</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">show_info</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not to show mesh info after generating the mesh (bounding box, element types, sidesets, nodesets, subdomains, etc)</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not to show mesh info after generating the mesh (bounding box, element types, sidesets, nodesets, subdomains, etc)</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Debugging Parameters</h3></summary></details></section></section></section><div class="moose-modal modal" id="602a6a17-029e-4300-9354-5bdb391e86ee"><div class="modal-content"><h4>input</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MeshGeneratorName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The mesh we want to modify</p></div></div><div class="moose-modal modal" id="4ecba232-ed41-492e-ad03-00835e8758f2"><div class="modal-content"><h4>boundary_names</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;BoundaryName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The boundaries to be used</p></div></div><div class="moose-modal modal" id="d6c316cb-1930-499e-8872-cfbef3c11f59"><div class="modal-content"><h4>hole_boundary_names</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::vector&lt;BoundaryName&gt;&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The optional boundaries to be used as the holes in the mesh during triangulation. Note that this is a vector of vectors, which allows each hole to be defined as a combination of multiple boundaries.</p></div></div><div class="moose-modal modal" id="a4dde19f-cfd8-4e43-acbe-d42c6232641d"><div class="modal-content"><h4>use_auto_area_func</h4><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Use the automatic area function for the triangle meshing region.</p></div></div><div class="moose-modal modal" id="9a8d6828-1936-46ba-911c-6d8cee04802b"><div class="modal-content"><h4>level_set</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::string</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Level set used to achieve more accurate reverse projection compared to interpolation.</p></div></div><div class="moose-modal modal" id="cb163559-489a-43c1-b527-c59dd6e5f14a"><div class="modal-content"><h4>max_angle_deviation</h4><p class="moose-parameter-description-default"><span>Default:</span>60</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-doc-range"><span>Range:</span>max_angle_deviation>0 & max_angle_deviation<90</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Maximum angle deviation from the global average normal vector in the input mesh.</p></div></div><div class="moose-modal modal" id="97975ffb-2a03-4261-91c2-e41be043f8d6"><div class="modal-content"><h4>(moose/test/tests/meshgenerators/boundary_2d_delaunay_generator/cylinder.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  [circle]
    type = ConcentricCircleMeshGenerator
    has_outer_square = false
    radii = 1
    num_sectors = 4
    rings = 1
    preserve_volumes = false
  []
  [side]
    type = SideSetsAroundSubdomainGenerator
    input = circle
    new_boundary = side
    block = 1
  []
  [extrude]
    type = AdvancedExtruderGenerator
    input = side
    heights = &#x27;2&#x27;
    num_layers = &#x27;3&#x27;
    direction = &#x27;0 0 1&#x27;
  []
  [side_1]
    type = ParsedGenerateSideset
    combinatorial_geometry = &#x27;x&gt;=0&amp;y&gt;=0&#x27;
    new_sideset_name = &#x27;side_1&#x27;
    input = &#x27;extrude&#x27;
    included_boundaries = &#x27;side&#x27;
  []
  [bd_1]
    type = Boundary2DDelaunayGenerator
    input = side_1
    boundary_names = &#x27;side_1&#x27;
    use_auto_area_func = true
  []
  [side_2]
    type = ParsedGenerateSideset
    combinatorial_geometry = &#x27;x&lt;0&amp;y&gt;=0&#x27;
    new_sideset_name = &#x27;side_2&#x27;
    input = &#x27;extrude&#x27;
    included_boundaries = &#x27;side&#x27;
  []
  [bd_2]
    type = Boundary2DDelaunayGenerator
    input = side_2
    boundary_names = &#x27;side_2&#x27;
    use_auto_area_func = true
  []
  [side_3]
    type = ParsedGenerateSideset
    combinatorial_geometry = &#x27;x&lt;0&amp;y&lt;0&#x27;
    new_sideset_name = &#x27;side_3&#x27;
    input = &#x27;extrude&#x27;
    included_boundaries = &#x27;side&#x27;
  []
  [bd_3]
    type = Boundary2DDelaunayGenerator
    input = side_3
    boundary_names = &#x27;side_3&#x27;
    use_auto_area_func = true
  []
  [side_4]
    type = ParsedGenerateSideset
    combinatorial_geometry = &#x27;x&gt;=0&amp;y&lt;0&#x27;
    new_sideset_name = &#x27;side_4&#x27;
    input = &#x27;extrude&#x27;
    included_boundaries = &#x27;side&#x27;
  []
  [bd_4]
    type = Boundary2DDelaunayGenerator
    input = side_4
    boundary_names = &#x27;side_4&#x27;
    use_auto_area_func = true
  []
  [bd_bot]
    type = Boundary2DDelaunayGenerator
    input = extrude
    boundary_names = &#x27;2&#x27;
    use_auto_area_func = true
  []
  [bd_top]
    type = Boundary2DDelaunayGenerator
    input = extrude
    boundary_names = &#x27;3&#x27;
    use_auto_area_func = true
  []
  [smg]
    type = StitchMeshGenerator
    inputs = &#x27;bd_1 bd_2 bd_3 bd_4 bd_top bd_bot&#x27;
    clear_stitched_boundary_ids = true
    stitch_boundaries_pairs = &#x27;0 0;0 0;0 0;0 0;0 0&#x27;
    merge_boundaries_with_same_name = true
    prevent_boundary_ids_overlap = false
  []
  [xyzd]
    type = XYZDelaunayGenerator
    boundary = smg
    desired_volume = 1
    output_subdomain_name = &#x27;matrix&#x27;
  []
[]

[Problem]
  solve = false
[]

[Executioner]
  type = Transient
  num_steps = 1
[]

[Postprocessors]
  [area]
    type = VolumePostprocessor
  []
[]

[Outputs]
  [csv]
    type = CSV
    execute_on = &#x27;FINAL&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
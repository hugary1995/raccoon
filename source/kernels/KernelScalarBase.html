<!DOCTYPE html><head><meta charset="UTF-8"><title>KernelScalarBase | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="4617220a-cc83-46d9-9120-9691a26f1e57" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="89e5bbc5-8529-4832-b744-5a0d08aec4db" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ceabb79e-958d-4c8c-905c-7efd10a5d32a" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b8b76593-e28c-4168-9f76-e3950b4d1883" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="5c1aa2f5-5e32-4e2c-875c-59f44f8e2e2c"><i class="material-icons">menu</i></a><ul class="sidenav" id="5c1aa2f5-5e32-4e2c-875c-59f44f8e2e2c"><li><a href="#!" class="dropdown-trigger" data-target="873ef6c3-220f-427e-a780-0f314922a796" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f781527b-8104-4b23-9df1-849f155e96f0" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="5a5252dc-3c5b-4d4a-b77e-15776e8c9276" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d41e31cb-c94c-458a-9bfa-fbc61391ac68" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="4617220a-cc83-46d9-9120-9691a26f1e57"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="89e5bbc5-8529-4832-b744-5a0d08aec4db"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="ceabb79e-958d-4c8c-905c-7efd10a5d32a"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="b8b76593-e28c-4168-9f76-e3950b4d1883"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="873ef6c3-220f-427e-a780-0f314922a796"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="f781527b-8104-4b23-9df1-849f155e96f0"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="5a5252dc-3c5b-4d4a-b77e-15776e8c9276"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="d41e31cb-c94c-458a-9bfa-fbc61391ac68"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="bf5f3555-0416-4525-8149-36c69f8c2122" data-section-level="1" data-section-text="KernelScalarBase"><h1 id="kernelscalarbase">KernelScalarBase</h1><p>The <code>KernelScalarBase</code> is part of the scalar augmentation system to complement the <a href="../../syntax/ScalarKernels/index.html">ScalarKernel</a> class. Its principal purpose is to add standard quadrature loops and assembly routines to handle the contributions from a single added scalar variable to a <a href="../../syntax/Kernels/index.html">Kernel</a> class, including the entire row of the Jacobian. These routines will assist with representing weak form terms in a partial differential equation involving scalar variables integrated over the interior of a domain. As usual, this piece of physics is referred to as the &quot;residual&quot; and is evaluated at integration quadrature points within that domain. To implement your own physics in MOOSE, you create your own kernel by subclassing the MOOSE <code>KernelScalarBase</code> class.</p><p>The Kernel scalar augmentation system supports the use of <span>automatic differentiation (AD)</span> for residual calculations, as such there are two options for creating field-scalar coupling objects: <code>KernelScalarBase</code> and <code>ADKernelScalarBase</code>. To further understand automatic differentiation, please refer to the <a href="../../automatic_differentiation/index.html">Automatic Differentiation</a> page for more information.</p><p>Developers should read all sections; users can find <a href="KernelScalarBase.html#KSB-parameters">Parameters</a> described at the bottom.</p><section id="43ac86d8-dfcb-48e8-8fa4-31774fca2ca5" data-section-level="2" data-section-text="Creation of Kernel Scalar Coupling Classes"><h2 id="KSB-coupling">Creation of Kernel Scalar Coupling Classes</h2><p>Each <code>Kernel</code> object has a <strong>focus</strong> field variable or spatial variable; its job is to contribute to the residual as well as the row of the Jacobian matrix. Herein, as in the source code of <code>Kernels</code>, this spatial variable will be called <code>_var</code>. In a coupled (multi-physics) weak form, all domain integral terms containing the test function of <code>_var</code> are potential candidates for <code>Kernel</code> contributions.</p><p>The philosophy of the scalar augmentation class <code>KernelScalarBase</code> is to add a focus scalar variable referred to as <code>_kappa</code> to the <code>Kernel</code> object so that all terms in the coupled weak form that involve <code>_var</code>, <code>_kappa</code>, and/or their test functions can be assembled in one or multiple class instances. This philosophy is similar to how the lower dimensional variable <code>_lambda</code> is added to the element faces of <code>DGKernel</code> and <code>IntegratedBC</code> objects associated with the hybrid finite element method (HFEM). Documentation for that approach can be found <a href="../dgkernels/HFEMDiffusion.html">HFEMDiffusion</a> and <a href="../bcs/HFEMDirichletBC.html">HFEMDirichletBC</a> along with the base classes <code>DGLowerDKernel</code> and <code>LowerDIntegratedBC</code>.</p><p>In a <code>KernelScalarBase</code> subclass, a naming scheme is established for the quadrature point methods of the two variable types: methods contributing to the test function of <code>_kappa</code> have &quot;Scalar&quot; near the front and methods contributing to the trial function of scalar variables in the Jacobian have &quot;Scalar&quot; at the end. The <code>computeScalarQpResidual()</code> function <strong>should</strong> be overridden (see <a href="KernelScalarBase.html#KSB-parameters">Parameters</a> for cases where the scalar should be suppressed). The <code>computeQpResidual()</code> function <strong>must</strong> be overridden as usual for <code>Kernels</code>, although it may return zero.</p><p>For non-AD objects, several contributions to the Jacobian matrix can be optionally overridden for use in Newton-type nonlinear solvers. As mentioned later, the developer should choose and document which terms (rows) of the residual and terms (rows and columns) of the Jacobian will be attributed to an instance of the developed class. These choices can be motivated by whether some terms in the weak form can be or have already been implemented within other MOOSE classes.</p><ul class="browser-default"><li><p><code>computeQpJacobian()</code>: Jacobian component d-<code>_var</code>-residual / d-<code>_var</code> </p></li><li><p><code>computeQpOffDiagJacobian(jvar_num)</code>: off-diagonal Jacobian component d-<code>_var</code>-residual / d-<code>jvar</code> </p></li><li><p><code>computeQpOffDiagJacobianScalar(svar_num)</code>: off-diagonal Jacobian component d-<code>_var</code>-residual / d-<code>svar</code> </p></li><li><p><code>computeScalarQpJacobian()</code>: Jacobian component d-<code>_kappa</code>-residual / d-<code>_kappa</code> </p></li><li><p><code>computeScalarQpOffDiagJacobian(jvar_num)</code>: off-diagonal Jacobian component d-<code>_kappa</code>-residual / d-<code>jvar</code> </p></li><li><p><code>computeScalarQpOffDiagJacobianScalar(svar_num)</code>: off-diagonal Jacobian component d-<code>_kappa</code>-residual / d-<code>svar</code></p></li></ul><p>Examples of some of these methods are shown below in <a href="KernelScalarBase.html#KSB-examples">Examples from Source Code</a>. Loops over the coupled variables wrap around these quadrature loops. The integer for the spatial variable is <code>jvar_num</code> and the integer for the scalar variable is <code>svar_num</code>.</p><p>Also, there are some pre-calculation routines that are called within the quadrature loop once before the loop over spatial variable test and shape functions as well as before the loop over scalar components. These methods are useful for material or stabilization calculations.</p><ul class="browser-default"><li><p><code>initScalarQpResidual()</code>: evaluations depending on qp but independent of test functions </p></li><li><p><code>initScalarQpJacobian(jvar_num)</code>: evaluations depending on qp but independent of test and shape functions </p></li><li><p><code>initScalarQpOffDiagJacobian(jsvar)</code>: evaluations depending on qp but independent of test and shape functions</p></li></ul><p>In addition to those mentioned in the <a href="../../syntax/Kernels/index.html">Kernel</a> documentation, you have access to several member variables inside your <code>KernelScalarBase</code> class for computing the residual and Jacobian values in the above mentioned functions:</p><ul class="browser-default"><li><p><code>_h</code>, <code>_l</code>: indices for the current test and trial scalar component respectively. </p></li><li><p><code>_kappa</code>: value of the scalar variable this Kernel operates on; indexed by <code>_h</code> (i.e. <code>_kappa[_h]</code>). </p></li><li><p><code>_kappa_var</code>: ID number of this scalar variable; useful to differentiate from others. </p></li><li><p><code>_k_order</code>: order (number of components) of the scalar variable.</p></li></ul><p>Since the test and trial &quot;shape&quot; functions of a scalar are &quot;1&quot;, variables are not required for that value. Examples of the source codes below demonstrate this fact.</p><div class="card moose-alert moose-alert-warning"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">warning</i><span class="moose-alert-title-brand">warning:</span>AD global indexing required</div><div class="card-content"><div class="moose-alert-content"><p><code>ADKernelScalarBase</code> only works with MOOSE configured with global AD indexing (the default).</p></div></div></div><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Parallelization of scalar contributions</div><div class="card-content"><div class="moose-alert-content"><p>While these quadrature loops are convenient for implementation in a single object, the speed of parallel execution may be slower due to the sequential assembly needed from each element assembling to the same scalar variable <code>_kappa</code>. For greater speed, the developer may instead implement the terms for <code>computeScalarQpResidual()</code> and <code>computeScalarQpJacobian()</code> through a derived class of <code>ElementIntegralUserObject</code> as discussed at <a href="../../syntax/ScalarKernels/index.html#couple-spatial">Coupling with Spatial Variables</a>.</p></div></div></div></section><section id="9c60d847-11f9-4fe3-aebc-606a42dab43a" data-section-level="2" data-section-text="Examples from Source Code"><h2 id="KSB-examples">Examples from Source Code</h2><p>As mentioned, the <code>computeScalarQpResidual</code> method <strong>should</strong> be overridden for both flavors of kernels, non-AD and AD. As an example, consider the scalar residual weak form term of the <a href="ScalarLMKernel.html"><code>ScalarLMKernel</code></a> class:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-93b8a374-55e7-4c48-9e56-e2997282204b"></span><span class="moose-katex-equation-number">(1)</span><script>var element = document.getElementById("moose-equation-93b8a374-55e7-4c48-9e56-e2997282204b");katex.render("  F^{(\\lambda)} \\equiv \\int_{\\Omega} \\phi^h \\;\\text{d}\\Omega - V_0 = 0 ", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>The <a href="ScalarLMKernel.html"><code>ScalarLMKernel</code></a> class is implemented using the <a href="GenericKernelScalar.html"><code>GenericKernelScalar</code></a> template class to contain both the AD and non-AD versions within the same source files. The <code>computeScalarQpResidual</code> method for this class is provided in <a href="#scalar-kernel-non-ad-residual">Listing 1</a>, where <code>_value/_pp_value</code> is equal to <span class="moose-katex-inline-equation" id="moose-equation-40e3018c-cd3b-420b-abec-2101b4d6bf09"><script>var element = document.getElementById("moose-equation-40e3018c-cd3b-420b-abec-2101b4d6bf09");katex.render("V_0", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 1: </span><span class="moose-caption-text" id="scalar-kernel-non-ad-residual">The C++ weak-form residual statement of <a href="#moose-equation-93b8a374-55e7-4c48-9e56-e2997282204b">Eq. (1)</a>.</span></p><pre style="max-height:350px;"><code class="language-cpp">template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpResidual()
{
  return _u[_qp] - _value / _pp_value;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#77c40c08-b496-4ee5-b729-4d93718eda36">(moose/framework/src/kernels/ScalarLMKernel.C)</a></div></div><p>Meanwhile, the contribution to the spatial variable residual of this object is associated with <a href="#moose-equation-32be0892-84c5-43a9-9717-c0a3eccb0c3f">Eq. (2)</a> and implemented in <a href="#kernel-non-ad-residual">Listing 2</a> (note that the scalar variable <code>_kappa</code> is termed as <span class="moose-katex-inline-equation" id="moose-equation-0effd6a3-3054-482c-9bc8-a8537d205b2e"><script>var element = document.getElementById("moose-equation-0effd6a3-3054-482c-9bc8-a8537d205b2e");katex.render("\\lambda^h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> in this weak form).</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-32be0892-84c5-43a9-9717-c0a3eccb0c3f"></span><span class="moose-katex-equation-number">(2)</span><script>var element = document.getElementById("moose-equation-32be0892-84c5-43a9-9717-c0a3eccb0c3f");katex.render("  F^{(\\phi)}_i \\equiv \\lambda^h \\int_{\\Omega} \\varphi_i \\;\\text{d}\\Omega ", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 2: </span><span class="moose-caption-text" id="kernel-non-ad-residual">The C++ weak-form residual statement of <a href="#moose-equation-32be0892-84c5-43a9-9717-c0a3eccb0c3f">Eq. (2)</a>.</span></p><pre style="max-height:350px;"><code class="language-cpp">template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpResidual()
{
  return _kappa[0] * _test[_i][_qp];
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#922a01b0-100c-4879-959d-adfbf2520beb">(moose/framework/src/kernels/ScalarLMKernel.C)</a></div></div><p>This object also overrides the <code>computeScalarQpOffDiagJacobian</code> method to define the Jacobian term related to <a href="#moose-equation-93b8a374-55e7-4c48-9e56-e2997282204b">Eq. (1)</a> as shown in <a href="#non-ad-s-v-jacobian">Listing 3</a>.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 3: </span><span class="moose-caption-text" id="non-ad-s-v-jacobian">The C++ weak-form Jacobian for d-<code>_kappa</code>-residual / d-<code>jvar</code>.</span></p><pre style="max-height:350px;"><code class="language-cpp">template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpOffDiagJacobian(unsigned int jvar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeScalarQpOffDiagJacobian should not be called. Check &quot;
              &quot;computeOffDiagJacobian &quot;
              &quot;implementation.&quot;);
  if (jvar == _var.number())
    return _phi[_j][_qp];
  else
    return 0.;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#a54c1afe-31d4-49d2-b92a-d3aab5818922">(moose/framework/src/kernels/ScalarLMKernel.C)</a></div></div><p>Notice that there is a conditional to confirm that the coupled <code>jvar</code> is the focus variable <code>_var</code>, otherwise it returns zero. Also, this method only returns a &quot;Real&quot; value since this method is only called by the non-AD version of the class during Jacobian computation; an assert is used to verify this intention.</p><p>Similarly, it also overrides the <code>computeQpOffDiagJacobianScalar</code> method to define the Jacobian term related to <a href="#moose-equation-32be0892-84c5-43a9-9717-c0a3eccb0c3f">Eq. (2)</a> as shown in <a href="#non-ad-v-s-jacobian">Listing 4</a>.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 4: </span><span class="moose-caption-text" id="non-ad-v-s-jacobian">The C++ weak-form Jacobian for d-<code>_var</code>-residual / d-<code>svar</code>.</span></p><pre style="max-height:350px;"><code class="language-cpp">template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpOffDiagJacobianScalar(unsigned int svar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeQpOffDiagJacobianScalar should not be called. Check &quot;
              &quot;computeOffDiagJacobianScalar &quot;
              &quot;implementation.&quot;);
  if (svar == _kappa_var)
    return _test[_i][_qp];
  else
    return 0.;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#d2f4b23b-5d91-40d4-9333-00d7d92107ac">(moose/framework/src/kernels/ScalarLMKernel.C)</a></div></div><p>Also notice the conditional that confirms the coupled <code>svar</code> is the focus scalar <code>_kappa</code>, otherwise it returns zero.</p><p>Depending upon the weak form and its coupling terms between spatial and scalar variables, not all of the methods listed in <a href="KernelScalarBase.html#KSB-coupling">Creation of Kernel Scalar Coupling Classes</a> need to be overridden.</p><p>The AD version of this object, <a href="ADScalarLMKernel.html"><code>ADScalarLMKernel</code></a>, only requires the residual implementation. A solely AD source file would only need to override <code>computeScalarQpResidual</code> and <code>computeQpResidual</code> and leave all the Jacobian methods as base definitions, which return zero. See <a href="../constraints/MortarScalarBase.html">MortarScalarBase</a> for examples of AD-only and non-AD separate classes.</p><p>As a more complicated example of the scalar augmentation system for kernels, the SolidMechanics test app contains headers, source, and test files for an alternative implementation of the &quot;HomogenizedTotalLagrangianStressDivergence&quot; system from the SolidMechanics module. This Kernel is designated with the suffix &quot;S&quot; to distinguish from the existing objects in the module. Also, there are other intermediate classes such as &quot;TotalLagrangianStressDivergence&quot; that are also designated with an &quot;S&quot; suffix. These other classes are needed since the lower class needs to also derive from <code>KernelScalarBase</code>. Meanwhile, they do not need the <code>scalar_variable</code> parameter and function identically to their original module source object; see the <a href="KernelScalarBase.html#KSB-parameters">Parameters</a> section for a comment about leaving this parameter blank.</p><p>The scalar augmentation system is designed such that multiple scalar variables can be coupled to an instance of the Kernel class, each focusing on one scalar from the list. This approach is similar to how SolidMechanics module classes operator on one component variable of the displacement vector field and are coupled to the other components. The developer can decide how to organize the coupling and off-diagonal Jacobian terms in a logical way and document this for the user.</p></section><section id="6d4ca1db-9e99-498c-8ad2-93428ed94516" data-section-level="2" data-section-text="Parameters"><h2 id="KSB-parameters">Parameters</h2><p>There is one required parameters the user must supply for a kernel derived from <code>KernelScalarBase</code>:</p><ul class="browser-default"><li><p><code>scalar_variable</code>: the focus scalar variable of the kernel, for which assembly of the residual and Jacobian contributions will occur. It must be a <code>MooseScalarVariable</code>. This parameter may be renamed in a derived class to be more physically meaningful.</p></li></ul><p>If the <code>scalar_variable</code> parameter is not specified, then the derived class will behave identically to a regular <code>Kernel</code>, namely without any scalar functionality. This feature is useful if the scalar augmentation in inserted into a class structure with several levels and not all derived members use scalar variables.</p><p>As an example, the parameter listing is shown below for the <code>ScalarLMKernel</code> object with the <code>scalar_variable</code> parameter renamed to <code>kappa</code>:</p><pre style="max-height:350px;"><code class="language-moose">[Kernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/index.html&quot;}&gt;&gt;&gt;]
  [diff]
    type = Diffusion&lt;&lt;&lt;{&quot;description&quot;: &quot;The Laplacian operator ($-\\nabla \\cdot \\nabla u$), with the weak form of $(\\nabla \\phi_i, \\nabla u_h)$.&quot;, &quot;href&quot;: &quot;Diffusion.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = u
  []

  [ffnk]
    type = BodyForce&lt;&lt;&lt;{&quot;description&quot;: &quot;Demonstrates the multiple ways that scalar values can be introduced into kernels, e.g. (controllable) constants, functions, and postprocessors. Implements the weak form $(\\psi_i, -f)$.&quot;, &quot;href&quot;: &quot;BodyForce.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = u
    function&lt;&lt;&lt;{&quot;description&quot;: &quot;A function that describes the body force&quot;}&gt;&gt;&gt; = ffn
  []

  [sk_lm]
    type = ScalarLMKernel&lt;&lt;&lt;{&quot;description&quot;: &quot;This class is used to enforce integral of phi = V_0 with a Lagrange multiplier approach.&quot;, &quot;href&quot;: &quot;ScalarLMKernel.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = u
    kappa&lt;&lt;&lt;{&quot;description&quot;: &quot;Primary coupled scalar variable&quot;}&gt;&gt;&gt; = lambda
    pp_name&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the Postprocessor containing the volume of the domain.&quot;}&gt;&gt;&gt; = pp
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Given (constant) which we want the integral of the solution variable to match.&quot;}&gt;&gt;&gt; = 2.666666666666666
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#3ffa1a6d-fc16-4646-afbd-7cff2d3ec9f5">(moose/test/tests/kernels/scalar_kernel_constraint/scalar_constraint_kernel.i)</a><p>Note: to avoid an error message &quot;Variable &#x27;kappa&#x27; does not exist in this system&quot;, the following block should be added to the input file:</p><pre style="max-height:350px;"><code class="language-moose">[Problem&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Problem/index.html&quot;}&gt;&gt;&gt;]
  kernel_coverage_check = false
  error_on_jacobian_nonzero_reallocation = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#f737d825-7363-4530-beff-bdaf43b5e65f">(moose/test/tests/kernels/scalar_kernel_constraint/scalar_constraint_kernel.i)</a><p>There are also some optional parameters that can be supplied to <code>KernelScalarBase</code> classes. They are:</p><ul class="browser-default"><li><p><code>compute_scalar_residuals</code>: Whether to compute scalar residuals. This will automatically be set to false if a <code>scalar_variable</code> parameter is not supplied. Other cases where the user may want to set this to false is during testing when the scalar variable is an <code>AuxVariable</code> and not a solution variable in the system. </p></li><li><p><code>compute_field_residuals</code>: Whether to compute residuals for the primal field variable. If several <code>KernelScalarBase</code> objects are used in the input file to compute different rows (i.e. different variables) of the global residual, then some objects can be targeted to field variable rows and others to scalar variable rows.</p></li></ul></section></section><div class="moose-modal modal" id="77c40c08-b496-4ee5-b729-4d93718eda36"><div class="modal-content"><h4>(moose/framework/src/kernels/ScalarLMKernel.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ScalarLMKernel.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ScalarLMKernel);
registerMooseObject(&quot;MooseApp&quot;, ADScalarLMKernel);

template &lt;bool is_ad&gt;
InputParameters
ScalarLMKernelTempl&lt;is_ad&gt;::validParams()
{
  InputParameters params = GenericKernelScalar&lt;is_ad&gt;::validParams();
  params.addClassDescription(&quot;This class is used to enforce integral of phi = V_0 with a &quot;
                             &quot;Lagrange multiplier approach.&quot;);
  params.renameCoupledVar(&quot;scalar_variable&quot;, &quot;kappa&quot;, &quot;Primary coupled scalar variable&quot;);
  params.addRequiredParam&lt;PostprocessorName&gt;(
      &quot;pp_name&quot;, &quot;Name of the Postprocessor containing the volume of the domain.&quot;);
  params.addRequiredParam&lt;Real&gt;(
      &quot;value&quot;, &quot;Given (constant) which we want the integral of the solution variable to match.&quot;);

  return params;
}

template &lt;bool is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::ScalarLMKernelTempl(const InputParameters &amp; parameters)
  : GenericKernelScalar&lt;is_ad&gt;(parameters),
    _value(this-&gt;template getParam&lt;Real&gt;(&quot;value&quot;)),
    _pp_value(this-&gt;getPostprocessorValue(&quot;pp_name&quot;))
{
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpResidual()
{
  return _kappa[0] * _test[_i][_qp];
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpResidual()
{
  return _u[_qp] - _value / _pp_value;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpJacobian()
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(
      !is_ad,
      &quot;In ADScalarLMKernel, computeScalarQpJacobian should not be called. Check computeJacobian &quot;
      &quot;implementation.&quot;);
  return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpOffDiagJacobianScalar(unsigned int svar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeQpOffDiagJacobianScalar should not be called. Check &quot;
              &quot;computeOffDiagJacobianScalar &quot;
              &quot;implementation.&quot;);
  if (svar == _kappa_var)
    return _test[_i][_qp];
  else
    return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpOffDiagJacobian(unsigned int jvar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeScalarQpOffDiagJacobian should not be called. Check &quot;
              &quot;computeOffDiagJacobian &quot;
              &quot;implementation.&quot;);
  if (jvar == _var.number())
    return _phi[_j][_qp];
  else
    return 0.;
}

template class ScalarLMKernelTempl&lt;false&gt;;
template class ScalarLMKernelTempl&lt;true&gt;;
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="922a01b0-100c-4879-959d-adfbf2520beb"><div class="modal-content"><h4>(moose/framework/src/kernels/ScalarLMKernel.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ScalarLMKernel.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ScalarLMKernel);
registerMooseObject(&quot;MooseApp&quot;, ADScalarLMKernel);

template &lt;bool is_ad&gt;
InputParameters
ScalarLMKernelTempl&lt;is_ad&gt;::validParams()
{
  InputParameters params = GenericKernelScalar&lt;is_ad&gt;::validParams();
  params.addClassDescription(&quot;This class is used to enforce integral of phi = V_0 with a &quot;
                             &quot;Lagrange multiplier approach.&quot;);
  params.renameCoupledVar(&quot;scalar_variable&quot;, &quot;kappa&quot;, &quot;Primary coupled scalar variable&quot;);
  params.addRequiredParam&lt;PostprocessorName&gt;(
      &quot;pp_name&quot;, &quot;Name of the Postprocessor containing the volume of the domain.&quot;);
  params.addRequiredParam&lt;Real&gt;(
      &quot;value&quot;, &quot;Given (constant) which we want the integral of the solution variable to match.&quot;);

  return params;
}

template &lt;bool is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::ScalarLMKernelTempl(const InputParameters &amp; parameters)
  : GenericKernelScalar&lt;is_ad&gt;(parameters),
    _value(this-&gt;template getParam&lt;Real&gt;(&quot;value&quot;)),
    _pp_value(this-&gt;getPostprocessorValue(&quot;pp_name&quot;))
{
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpResidual()
{
  return _kappa[0] * _test[_i][_qp];
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpResidual()
{
  return _u[_qp] - _value / _pp_value;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpJacobian()
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(
      !is_ad,
      &quot;In ADScalarLMKernel, computeScalarQpJacobian should not be called. Check computeJacobian &quot;
      &quot;implementation.&quot;);
  return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpOffDiagJacobianScalar(unsigned int svar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeQpOffDiagJacobianScalar should not be called. Check &quot;
              &quot;computeOffDiagJacobianScalar &quot;
              &quot;implementation.&quot;);
  if (svar == _kappa_var)
    return _test[_i][_qp];
  else
    return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpOffDiagJacobian(unsigned int jvar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeScalarQpOffDiagJacobian should not be called. Check &quot;
              &quot;computeOffDiagJacobian &quot;
              &quot;implementation.&quot;);
  if (jvar == _var.number())
    return _phi[_j][_qp];
  else
    return 0.;
}

template class ScalarLMKernelTempl&lt;false&gt;;
template class ScalarLMKernelTempl&lt;true&gt;;
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="a54c1afe-31d4-49d2-b92a-d3aab5818922"><div class="modal-content"><h4>(moose/framework/src/kernels/ScalarLMKernel.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ScalarLMKernel.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ScalarLMKernel);
registerMooseObject(&quot;MooseApp&quot;, ADScalarLMKernel);

template &lt;bool is_ad&gt;
InputParameters
ScalarLMKernelTempl&lt;is_ad&gt;::validParams()
{
  InputParameters params = GenericKernelScalar&lt;is_ad&gt;::validParams();
  params.addClassDescription(&quot;This class is used to enforce integral of phi = V_0 with a &quot;
                             &quot;Lagrange multiplier approach.&quot;);
  params.renameCoupledVar(&quot;scalar_variable&quot;, &quot;kappa&quot;, &quot;Primary coupled scalar variable&quot;);
  params.addRequiredParam&lt;PostprocessorName&gt;(
      &quot;pp_name&quot;, &quot;Name of the Postprocessor containing the volume of the domain.&quot;);
  params.addRequiredParam&lt;Real&gt;(
      &quot;value&quot;, &quot;Given (constant) which we want the integral of the solution variable to match.&quot;);

  return params;
}

template &lt;bool is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::ScalarLMKernelTempl(const InputParameters &amp; parameters)
  : GenericKernelScalar&lt;is_ad&gt;(parameters),
    _value(this-&gt;template getParam&lt;Real&gt;(&quot;value&quot;)),
    _pp_value(this-&gt;getPostprocessorValue(&quot;pp_name&quot;))
{
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpResidual()
{
  return _kappa[0] * _test[_i][_qp];
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpResidual()
{
  return _u[_qp] - _value / _pp_value;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpJacobian()
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(
      !is_ad,
      &quot;In ADScalarLMKernel, computeScalarQpJacobian should not be called. Check computeJacobian &quot;
      &quot;implementation.&quot;);
  return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpOffDiagJacobianScalar(unsigned int svar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeQpOffDiagJacobianScalar should not be called. Check &quot;
              &quot;computeOffDiagJacobianScalar &quot;
              &quot;implementation.&quot;);
  if (svar == _kappa_var)
    return _test[_i][_qp];
  else
    return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpOffDiagJacobian(unsigned int jvar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeScalarQpOffDiagJacobian should not be called. Check &quot;
              &quot;computeOffDiagJacobian &quot;
              &quot;implementation.&quot;);
  if (jvar == _var.number())
    return _phi[_j][_qp];
  else
    return 0.;
}

template class ScalarLMKernelTempl&lt;false&gt;;
template class ScalarLMKernelTempl&lt;true&gt;;
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="d2f4b23b-5d91-40d4-9333-00d7d92107ac"><div class="modal-content"><h4>(moose/framework/src/kernels/ScalarLMKernel.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ScalarLMKernel.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ScalarLMKernel);
registerMooseObject(&quot;MooseApp&quot;, ADScalarLMKernel);

template &lt;bool is_ad&gt;
InputParameters
ScalarLMKernelTempl&lt;is_ad&gt;::validParams()
{
  InputParameters params = GenericKernelScalar&lt;is_ad&gt;::validParams();
  params.addClassDescription(&quot;This class is used to enforce integral of phi = V_0 with a &quot;
                             &quot;Lagrange multiplier approach.&quot;);
  params.renameCoupledVar(&quot;scalar_variable&quot;, &quot;kappa&quot;, &quot;Primary coupled scalar variable&quot;);
  params.addRequiredParam&lt;PostprocessorName&gt;(
      &quot;pp_name&quot;, &quot;Name of the Postprocessor containing the volume of the domain.&quot;);
  params.addRequiredParam&lt;Real&gt;(
      &quot;value&quot;, &quot;Given (constant) which we want the integral of the solution variable to match.&quot;);

  return params;
}

template &lt;bool is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::ScalarLMKernelTempl(const InputParameters &amp; parameters)
  : GenericKernelScalar&lt;is_ad&gt;(parameters),
    _value(this-&gt;template getParam&lt;Real&gt;(&quot;value&quot;)),
    _pp_value(this-&gt;getPostprocessorValue(&quot;pp_name&quot;))
{
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpResidual()
{
  return _kappa[0] * _test[_i][_qp];
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpResidual()
{
  return _u[_qp] - _value / _pp_value;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpJacobian()
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(
      !is_ad,
      &quot;In ADScalarLMKernel, computeScalarQpJacobian should not be called. Check computeJacobian &quot;
      &quot;implementation.&quot;);
  return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpOffDiagJacobianScalar(unsigned int svar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeQpOffDiagJacobianScalar should not be called. Check &quot;
              &quot;computeOffDiagJacobianScalar &quot;
              &quot;implementation.&quot;);
  if (svar == _kappa_var)
    return _test[_i][_qp];
  else
    return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpOffDiagJacobian(unsigned int jvar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeScalarQpOffDiagJacobian should not be called. Check &quot;
              &quot;computeOffDiagJacobian &quot;
              &quot;implementation.&quot;);
  if (jvar == _var.number())
    return _phi[_j][_qp];
  else
    return 0.;
}

template class ScalarLMKernelTempl&lt;false&gt;;
template class ScalarLMKernelTempl&lt;true&gt;;
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="3ffa1a6d-fc16-4646-afbd-7cff2d3ec9f5"><div class="modal-content"><h4>(moose/test/tests/kernels/scalar_kernel_constraint/scalar_constraint_kernel.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [exact_fn]
    type = ParsedFunction
    expression = &#x27;x*x+y*y&#x27;
  []

  [ffn]
    type = ParsedFunction
    expression = -4
  []

  [bottom_bc_fn]
    type = ParsedFunction
    expression = -2*y
  []

  [right_bc_fn]
    type = ParsedFunction
    expression =  2*x
  []

  [top_bc_fn]
    type = ParsedFunction
    expression =  2*y
  []

  [left_bc_fn]
    type = ParsedFunction
    expression = -2*x
  []
[]

[Variables]
  [u]
    family = LAGRANGE
    order = SECOND
  []
  [lambda]
    family = SCALAR
    order = FIRST
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = u
  []

  [ffnk]
    type = BodyForce
    variable = u
    function = ffn
  []

  [sk_lm]
    type = ScalarLMKernel
    variable = u
    kappa = lambda
    pp_name = pp
    value = 2.666666666666666
  []
[]

[Problem]
  kernel_coverage_check = false
  error_on_jacobian_nonzero_reallocation = true
[]

[BCs]
  [bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bottom_bc_fn
  []
  [right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = right_bc_fn
  []
  [top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = top_bc_fn
  []
  [left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = left_bc_fn
  []
[]

[Postprocessors]
  # integrate the volume of domain since original objects set
  # int(phi)=V0, rather than int(phi-V0)=0
  [pp]
    type = FunctionElementIntegral
    function = 1
    execute_on = initial
  []
  [l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Preconditioning]
  [pc]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  []
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-9
  l_tol = 1.e-10
  nl_max_its = 10
  # This example builds an indefinite matrix, so &quot;-pc_type hypre -pc_hypre_type boomeramg&quot; cannot
  # be used reliably on this problem
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;lu       NONZERO&#x27;
  # This is a linear problem, so we don&#x27;t need to recompute the
  # Jacobian. This isn&#x27;t a big deal for a Steady problems, however, as
  # there is only one solve.
  solve_type = &#x27;LINEAR&#x27;
[]

[Outputs]
  exodus = true
  hide = lambda
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="f737d825-7363-4530-beff-bdaf43b5e65f"><div class="modal-content"><h4>(moose/test/tests/kernels/scalar_kernel_constraint/scalar_constraint_kernel.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [exact_fn]
    type = ParsedFunction
    expression = &#x27;x*x+y*y&#x27;
  []

  [ffn]
    type = ParsedFunction
    expression = -4
  []

  [bottom_bc_fn]
    type = ParsedFunction
    expression = -2*y
  []

  [right_bc_fn]
    type = ParsedFunction
    expression =  2*x
  []

  [top_bc_fn]
    type = ParsedFunction
    expression =  2*y
  []

  [left_bc_fn]
    type = ParsedFunction
    expression = -2*x
  []
[]

[Variables]
  [u]
    family = LAGRANGE
    order = SECOND
  []
  [lambda]
    family = SCALAR
    order = FIRST
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = u
  []

  [ffnk]
    type = BodyForce
    variable = u
    function = ffn
  []

  [sk_lm]
    type = ScalarLMKernel
    variable = u
    kappa = lambda
    pp_name = pp
    value = 2.666666666666666
  []
[]

[Problem]
  kernel_coverage_check = false
  error_on_jacobian_nonzero_reallocation = true
[]

[BCs]
  [bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bottom_bc_fn
  []
  [right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = right_bc_fn
  []
  [top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = top_bc_fn
  []
  [left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = left_bc_fn
  []
[]

[Postprocessors]
  # integrate the volume of domain since original objects set
  # int(phi)=V0, rather than int(phi-V0)=0
  [pp]
    type = FunctionElementIntegral
    function = 1
    execute_on = initial
  []
  [l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Preconditioning]
  [pc]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  []
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-9
  l_tol = 1.e-10
  nl_max_its = 10
  # This example builds an indefinite matrix, so &quot;-pc_type hypre -pc_hypre_type boomeramg&quot; cannot
  # be used reliably on this problem
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;lu       NONZERO&#x27;
  # This is a linear problem, so we don&#x27;t need to recompute the
  # Jacobian. This isn&#x27;t a big deal for a Steady problems, however, as
  # there is only one solve.
  solve_type = &#x27;LINEAR&#x27;
[]

[Outputs]
  exodus = true
  hide = lambda
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
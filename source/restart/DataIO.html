<!DOCTYPE html><head><meta charset="UTF-8"><title>DataIO | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="0ddd9658-bafe-4d45-b330-045579c5f95f" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="3bebb9d9-1117-4699-b11d-988328b33e02" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="7de4c2e4-e5e1-42ae-b5ba-17c1cbbff561" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="69d8a6fe-ff25-447d-8499-725081c22b11" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="48e5ee9f-d955-420d-af0c-2825263452f2"><i class="material-icons">menu</i></a><ul class="sidenav" id="48e5ee9f-d955-420d-af0c-2825263452f2"><li><a href="#!" class="dropdown-trigger" data-target="27b10441-0b54-417b-88fb-7e60cbb4f31f" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="7a7f4298-282a-42c1-8481-1dd59422ec08" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="6422bd70-e630-4526-8d81-22bd43c7b66d" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="80826fec-4f66-434c-aee2-7d968e9f7dce" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="0ddd9658-bafe-4d45-b330-045579c5f95f"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="3bebb9d9-1117-4699-b11d-988328b33e02"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="7de4c2e4-e5e1-42ae-b5ba-17c1cbbff561"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="69d8a6fe-ff25-447d-8499-725081c22b11"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="27b10441-0b54-417b-88fb-7e60cbb4f31f"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="7a7f4298-282a-42c1-8481-1dd59422ec08"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="6422bd70-e630-4526-8d81-22bd43c7b66d"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="80826fec-4f66-434c-aee2-7d968e9f7dce"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="8818504c-cad6-4def-a778-832559c99bdf" data-section-level="1" data-section-text="DataIO"><h1 id="dataio">DataIO</h1><p>The DataIO.h/.C files contain the declaration and definitions for MOOSE&#x27;s templated <code>dataLoad/dataStore</code> methods. These methods are scattered around the framework, modules and user applications and are used to store stateful information that cannot be recalculated during a restore operation. These methods enable MOOSE&#x27;s checkpointing and restarting operations which enable several key capabilities in the MOOSE framework including:</p><ul class="browser-default"><li><p>Checkpointing -&gt; the ability to terminate an application and restart it where you left off (useful for batch cluster systems). </p></li><li><p>Picard Iteration -&gt; The ability to converge a &quot;tightly&quot; coupled multiApp simulation. </p></li><li><p>Restart -&gt; the ability to save stateful data for a restart type simulation when using checkpoint format</p></li></ul><section id="d8c07f8c-3436-4b57-9509-71d2b151e61b" data-section-level="2" data-section-text="What is stateful data ?"><h2 id="what-is-stateful-data">What is stateful data?</h2><p>Stateful data is any value, container of values, or complex data structure that cannot be recomputed from other available information such as coupled values or field variables. Additionally, it&#x27;s not any data that is not directly owned by your object.</p><p>Here are a couple of examples to consider before defining a dataLoad/dataStore routine:</p><ul class="browser-default"><li><p>If you have an object that produces a value based on an &quot;old&quot; value of a coupled variable, your object does <strong>not</strong> contain any stateful data because it is a simple calculation based on a piece of information not owned by your object. No action is necessary for your object to be &quot;restartable&quot;. </p></li><li><p>If your object has a data structure consisting of a vector of pairs of IDs and Real numbers that are computed from a Material property, your object does <strong>not</strong> contain any stateful data and no action is necessary for your object to be &quot;restartable&quot;. </p></li><li><p>If your object has a simple Boolean used to indicate whether or not you have calculated some quantity before, that you set when you run some routine. Your object <strong>does</strong> contain stateful information since the state of that value depends on internal logic in your object. For this scenario, you will need to ask Moose to store your Boolean as &quot;restartableData&quot;. See <a href="DataIO.html#declareRestartableData">declareRestartableData</a>. </p></li><li><p>If your object contains a dataStructure of some custom type that you produce internally and retrieve existing values from over the coarse of the simulation, you have a stateful data and may need to define the dataLoad and dataStore functions in your object. See <a href="DataIO.html#declareRestartableData">declareRestartableData</a>, and <a href="DataIO.html#dataStore_dataLoad">dataStore/dataLoad routines</a>.</p></li></ul></section><section id="fe5a0c25-dbe6-4604-adec-187b62dbd635" data-section-level="2" data-section-text="declareRestartableData"><h2 id="declareRestartableData">declareRestartableData</h2><p>The declareRestartableData method is used to tell MOOSE that you would like to save some part of your object in a <a href="Backup.html">Backup</a> object. This method is templated and declared here:</p><pre style="max-height:350px;"><code class="language-cpp">protected:
  /**
   * Declare a piece of data as &quot;restartable&quot; and initialize it.
   * This means that in the event of a restart this piece of data
   * will be restored back to its previous value.
   *
   * NOTE: This returns a _reference_!  Make sure you store it in a _reference_!
   *
   * @param data_name The name of the data (usually just use the same name as the member variable)
   * @param args Arguments to forward to the constructor of the data
   */
  template &lt;typename T, typename... Args&gt;
  T &amp; declareRestartableData(const std::string &amp; data_name, Args &amp;&amp;... args);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#8cf866cb-d2a4-4f5b-bf51-471ca2f46766">(moose/framework/include/restart/Restartable.h)</a><p>This method is templated, so MOOSE will return a reference to the type that you request and manage the data storage for you. For all built-in types and combinations of containers and built-in types. This is all that needs to be done. If your type or your container of types is custom, you will have to define the dataLoad and dataStore routines to tell MOOSE how to serialize your new type.</p></section><section id="fe90abbe-61c5-4894-821f-51a56f5764f0" data-section-level="2" data-section-text="dataStore / dataLoad routines"><h2 id="dataStore_dataLoad">dataStore/dataLoad routines</h2><p>If any object has requested a restartable piece of data that contains or is a custom type, both the dataStore and dataLoad will need to be defined. These functions describe how to serialize a custom type.</p><p>The declarations for the two methods that may need to be specialized for your application take on a form similar to this:</p><pre style="max-height:350px;"><code class="language-cpp">// *************** Global Load Declarations *****************
template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, T &amp; v, void * /*context*/)
{
  stream.read((char *)&amp;v, sizeof(v));
  mooseAssert(!stream.bad(), &quot;Failed to load&quot;);
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#50f5dbc6-2768-434e-bdb8-75518481a579">(moose/framework/include/restart/DataIO.h)</a><pre style="max-height:350px;"><code class="language-cpp">// *************** Global Store Declarations *****************
template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, T &amp; v, void * /*context*/)
{
#ifdef LIBMESH_HAVE_CXX11_TYPE_TRAITS
  static_assert(std::is_polymorphic&lt;T&gt;::value == false,
                &quot;Cannot serialize a class that has virtual &quot;
                &quot;members!\nWrite a custom dataStore() &quot;
                &quot;template specialization!\n\n&quot;);
  static_assert(std::is_trivially_copyable&lt;T&gt;::value,
                &quot;Cannot serialize a class that is not trivially copyable!\nWrite a custom &quot;
                &quot;dataStore() template specialization!\n\n&quot;);
#endif
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#b9668210-664e-4042-b1b1-c5b18810e0ac">(moose/framework/include/restart/DataIO.h)</a><section id="5cb244e0-fc5e-4f3d-b774-71f2886086a8" data-section-level="3" data-section-text="Example"><h3 id="example">Example</h3><p>Typically, the serialization routine can be defined in terms of serializing the individual fields in your custom type. For example. If you had a class <code>Foo</code> that contained a few plain old data types, you&#x27;d just define the load and store terms in terms of the combination of those POD types in order.</p><pre style="max-height:350px;"><code class="language-cpp">
class Foo
{
  int bar;
  std::string baz;
  std::vector&lt;unsigned int&gt; qux;
};


// Definition
template &lt;&gt;
void
dataStore(std::ostream &amp; stream, Foo &amp; foo, void * context)
{
  // Defined in terms of the simple types that MOOSE already knows how to store
  storeHelper(stream, foo.bar, context);
  storeHelper(stream, foo.baz, context);
  storeHelper(stream, foo.qux, context);
}

template &lt;&gt;
void
dataLoad(std::istream &amp; stream, Foo &amp; foo, void * context)
{
  // Defined in terms of the simple types that MOOSE already knows how to read.
  // Note the order of the calls, they should match the dataStore routine since each
  // type is being read from the stream.
  loadHelper(stream, foo.bar, context);
  loadHelper(stream, foo.baz, context);
  loadHelper(stream, foo.qux, context);
}
</code></pre></section></section></section><div class="moose-modal modal" id="8cf866cb-d2a4-4f5b-bf51-471ca2f46766"><div class="modal-content"><h4>(moose/framework/include/restart/Restartable.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

// MOOSE includes
#include &quot;MooseTypes.h&quot;
#include &quot;RestartableData.h&quot;

// Forward declarations
class PostprocessorData;
class SubProblem;
class InputParameters;
class MooseObject;
class MooseApp;
class MooseMesh;

/**
 * A class for creating restricted objects
 * \see BlockRestartable BoundaryRestartable
 */
class Restartable
{
public:
  /**
   * Wrapper class for restartable data that is &quot;managed.&#x27;
   *
   * Managed here means that the destruction of the data
   * is managed by the reciever and not the app.
   *
   * When this wrapper is destructed, the underlying
   * restartable data is also destructed. This allows for
   * proper construction ordered destruction.
   */
  template &lt;typename T&gt;
  class ManagedValue
  {
  public:
    ManagedValue(RestartableData&lt;T&gt; &amp; value) : _value(value) {}

    /**
     * Destructor.
     *
     * Destructs the managed restartable data.
     */
    ~ManagedValue() { _value.reset(); }

    /**
     * Get the restartable value.
     */
    ///@{
    const T &amp; get() const { return _value.get(); }
    T &amp; set() { return _value.set(); }
    ///@}

  private:
    /// The underlying data
    RestartableData&lt;T&gt; &amp; _value;
  };

  /**
   * Class constructor
   *
   * @param moose_object The MooseObject that this interface is being implemented on.
   * @param system_name The name of the MOOSE system.  ie &quot;Kernel&quot;, &quot;BCs&quot;, etc.  Should roughly
   * correspond to the section in the input file so errors are easy to understand.
   *
   * This method will forward the thread id if it exists in the moose_object parameters. Delegates
   * to the &quot;MooseApp &amp;&quot; constructor.
   */
  Restartable(const MooseObject * moose_object, const std::string &amp; system_name);

  /**
   * Class constructor
   *
   * Similar to the other class constructor but also accepts an individual thread ID. If this
   * method is used, no thread ID in the parameters object is used. Delegates to the &quot;MooseApp &amp;&quot;
   * constructor.
   */
  Restartable(const MooseObject * moose_object, const std::string &amp; system_name, THREAD_ID tid);

  /**
   * This class constructor is used for non-Moose-based objects like interfaces. A name for the
   * storage as well as a system name must be passed in along with the thread ID explicitly.
   * @param moose_app Reference to the application
   * @param name The name which is used when constructing the full-names of the restartable data.
   *             It is used with the following logic: `system_name/name/data_name`.
   *             (e.g. UserObjects/diffusion_kernel/coefficient). In most of the cases this is the
   *             name of the moose object.
   * @param system_name The name of the system where this object belongs to.
   * @param tid The thread ID.
   * @param read_only Switch to restrict the data for read-only.
   * @param metaname The name of the datamap where the restartable objects should be registered to.
   */
  Restartable(MooseApp &amp; moose_app,
              const std::string &amp; name,
              const std::string &amp; system_name,
              THREAD_ID tid,
              const bool read_only = false,
              const RestartableDataMapName &amp; metaname = &quot;&quot;);

#ifdef MOOSE_KOKKOS_ENABLED
  /**
   * Special constructor used for Kokkos functor copy during parallel dispatch
   */
  Restartable(const Restartable &amp; object, const Moose::Kokkos::FunctorCopy &amp; key);
#endif

protected:
  /**
   * Declare a piece of data as &quot;restartable&quot; and initialize it.
   * This means that in the event of a restart this piece of data
   * will be restored back to its previous value.
   *
   * NOTE: This returns a _reference_!  Make sure you store it in a _reference_!
   *
   * @param data_name The name of the data (usually just use the same name as the member variable)
   * @param args Arguments to forward to the constructor of the data
   */
  template &lt;typename T, typename... Args&gt;
  T &amp; declareRestartableData(const std::string &amp; data_name, Args &amp;&amp;... args);

  /**
   * Declares a piece of &quot;managed&quot; restartable data and initialize it.
   *
   * Here, &quot;managed&quot; restartable data means that the caller can destruct this data
   * upon destruction of the return value of this method. Therefore, this
   * ManagedValue&lt;T&gt; wrapper should survive after the final calls to dataStore()
   * for it. That is... at the very end.
   *
   * This is needed for objects whose destruction ordering is important, and
   * enables natural c++ destruction in reverse construction order of the object
   * that declares it.
   *
   * See delcareRestartableData and declareRestartableDataWithContext for more information.
   */
  template &lt;typename T, typename... Args&gt;
  ManagedValue&lt;T&gt; declareManagedRestartableDataWithContext(const std::string &amp; data_name,
                                                           void * context,
                                                           Args &amp;&amp;... args);

  /**
   * Declare a piece of data as &quot;restartable&quot; and initialize it
   * Similar to `declareRestartableData` but returns a const reference to the object.
   * Forwarded arguments are not allowed in this case because we assume that the
   * object is restarted and we won&#x27;t need different constructors to initialize it.
   *
   * NOTE: This returns a _const reference_!  Make sure you store it in a _const reference_!
   *
   * @param data_name The name of the data (usually just use the same name as the member variable)
   */
  template &lt;typename T, typename... Args&gt;
  const T &amp; getRestartableData(const std::string &amp; data_name) const;

  /**
   * Declare a piece of data as &quot;restartable&quot; and initialize it.
   * This means that in the event of a restart this piece of data
   * will be restored back to its previous value.
   *
   * NOTE: This returns a _reference_!  Make sure you store it in a _reference_!
   *
   * @param data_name The name of the data (usually just use the same name as the member variable)
   * @param context Context pointer that will be passed to the load and store functions
   * @param args Arguments to forward to the constructor of the data
   */
  template &lt;typename T, typename... Args&gt;
  T &amp;
  declareRestartableDataWithContext(const std::string &amp; data_name, void * context, Args &amp;&amp;... args);

  /**
   * Declare a piece of data as &quot;recoverable&quot; and initialize it.
   * This means that in the event of a restart this piece of data
   * will be restored back to its previous value.
   *
   * Note - this data will NOT be restored on _Restart_!
   *
   * NOTE: This returns a _reference_!  Make sure you store it in a _reference_!
   *
   * @param data_name The name of the data (usually just use the same name as the member variable)
   * @param args Arguments to forward to the constructor of the data
   */
  template &lt;typename T, typename... Args&gt;
  T &amp; declareRecoverableData(const std::string &amp; data_name, Args &amp;&amp;... args);

  /**
   * Declare a piece of data as &quot;restartable&quot;.
   * This means that in the event of a restart this piece of data
   * will be restored back to its previous value.
   *
   * NOTE: This returns a _reference_!  Make sure you store it in a _reference_!
   *
   * @param data_name The name of the data (usually just use the same name as the member variable)
   * @param object_name A supplied name for the object that is declaring this data.
   * @param args Arguments to forward to the constructor of the data
   */
  template &lt;typename T, typename... Args&gt;
  T &amp; declareRestartableDataWithObjectName(const std::string &amp; data_name,
                                           const std::string &amp; object_name,
                                           Args &amp;&amp;... args);

  /**
   * Declare a piece of data as &quot;restartable&quot;.
   * This means that in the event of a restart this piece of data
   * will be restored back to its previous value.
   *
   * NOTE: This returns a _reference_!  Make sure you store it in a _reference_!
   *
   * @param data_name The name of the data (usually just use the same name as the member variable)
   * @param object_name A supplied name for the object that is declaring this data.
   * @param context Context pointer that will be passed to the load and store functions
   * @param args Arguments to forward to the constructor of the data
   */
  template &lt;typename T, typename... Args&gt;
  T &amp; declareRestartableDataWithObjectNameWithContext(const std::string &amp; data_name,
                                                      const std::string &amp; object_name,
                                                      void * context,
                                                      Args &amp;&amp;... args);

  /**
   * Gets the name of a piece of restartable data given a data name, adding
   * the system name and object name prefix.
   *
   * This should only be used in this interface and in testing.
   */
  std::string restartableName(const std::string &amp; data_name) const;

  /// Reference to the application
  MooseApp &amp; _restartable_app;

  /// The system name this object is in
  const std::string _restartable_system_name;

  /// The thread ID for this object
  const THREAD_ID _restartable_tid;

  /// Flag for toggling read only status (see ReporterData)
  const bool _restartable_read_only;

private:
  /// Restartable metadata name
  const RestartableDataMapName _metaname;

  /// The name of the object
  std::string _restartable_name;

  /// Helper function for actually registering the restartable data.
  RestartableDataValue &amp; registerRestartableDataOnApp(std::unique_ptr&lt;RestartableDataValue&gt; data,
                                                      THREAD_ID tid) const;

  /// Helper function for actually registering the restartable data.
  void registerRestartableNameWithFilterOnApp(const std::string &amp; name,
                                              Moose::RESTARTABLE_FILTER filter);

  /**
   * Helper function for declaring restartable data. We use this function to reduce code duplication
   * when returning const/nonconst references to the data.
   *
   * @param data_name The name of the data (usually just use the same name as the member variable)
   * @param context Context pointer that will be passed to the load and store functions
   * @param args Arguments to forward to the constructor of the data
   */
  template &lt;typename T, typename... Args&gt;
  RestartableData&lt;T&gt; &amp; declareRestartableDataHelper(const std::string &amp; data_name,
                                                    void * context,
                                                    Args &amp;&amp;... args) const;
};

template &lt;typename T, typename... Args&gt;
T &amp;
Restartable::declareRestartableData(const std::string &amp; data_name, Args &amp;&amp;... args)
{
  return declareRestartableDataWithContext&lt;T&gt;(data_name, nullptr, std::forward&lt;Args&gt;(args)...);
}

template &lt;typename T, typename... Args&gt;
Restartable::ManagedValue&lt;T&gt;
Restartable::declareManagedRestartableDataWithContext(const std::string &amp; data_name,
                                                      void * context,
                                                      Args &amp;&amp;... args)
{
  auto &amp; data_ptr =
      declareRestartableDataHelper&lt;T&gt;(data_name, context, std::forward&lt;Args&gt;(args)...);
  return Restartable::ManagedValue&lt;T&gt;(data_ptr);
}

template &lt;typename T, typename... Args&gt;
const T &amp;
Restartable::getRestartableData(const std::string &amp; data_name) const
{
  return declareRestartableDataHelper&lt;T&gt;(data_name, nullptr).get();
}

template &lt;typename T, typename... Args&gt;
T &amp;
Restartable::declareRestartableDataWithContext(const std::string &amp; data_name,
                                               void * context,
                                               Args &amp;&amp;... args)
{
  return declareRestartableDataHelper&lt;T&gt;(data_name, context, std::forward&lt;Args&gt;(args)...).set();
}

template &lt;typename T, typename... Args&gt;
RestartableData&lt;T&gt; &amp;
Restartable::declareRestartableDataHelper(const std::string &amp; data_name,
                                          void * context,
                                          Args &amp;&amp;... args) const
{
  const auto full_name = restartableName(data_name);

  // Here we will create the RestartableData even though we may not use this instance.
  // If it&#x27;s already in use, the App will return a reference to the existing instance and we&#x27;ll
  // return that one instead. We might refactor this to have the app create the RestartableData
  // at a later date.
  auto data_ptr =
      std::make_unique&lt;RestartableData&lt;T&gt;&gt;(full_name, context, std::forward&lt;Args&gt;(args)...);
  auto &amp; restartable_data_ref = static_cast&lt;RestartableData&lt;T&gt; &amp;&gt;(
      registerRestartableDataOnApp(std::move(data_ptr), _restartable_tid));

  return restartable_data_ref;
}

template &lt;typename T, typename... Args&gt;
T &amp;
Restartable::declareRestartableDataWithObjectName(const std::string &amp; data_name,
                                                  const std::string &amp; object_name,
                                                  Args &amp;&amp;... args)
{
  return declareRestartableDataWithObjectNameWithContext&lt;T&gt;(
      data_name, object_name, nullptr, std::forward&lt;Args&gt;(args)...);
}

template &lt;typename T, typename... Args&gt;
T &amp;
Restartable::declareRestartableDataWithObjectNameWithContext(const std::string &amp; data_name,
                                                             const std::string &amp; object_name,
                                                             void * context,
                                                             Args &amp;&amp;... args)
{
  std::string old_name = _restartable_name;

  _restartable_name = object_name;

  T &amp; value = declareRestartableDataWithContext&lt;T&gt;(data_name, context, std::forward&lt;Args&gt;(args)...);

  _restartable_name = old_name;

  return value;
}

template &lt;typename T, typename... Args&gt;
T &amp;
Restartable::declareRecoverableData(const std::string &amp; data_name, Args &amp;&amp;... args)
{
  const auto full_name = restartableName(data_name);

  registerRestartableNameWithFilterOnApp(full_name, Moose::RESTARTABLE_FILTER::RECOVERABLE);

  return declareRestartableDataWithContext&lt;T&gt;(data_name, nullptr, std::forward&lt;Args&gt;(args)...);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="50f5dbc6-2768-434e-bdb8-75518481a579"><div class="modal-content"><h4>(moose/framework/include/restart/DataIO.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

// MOOSE includes
#include &quot;ADReal.h&quot;
#include &quot;MooseTypes.h&quot;
#include &quot;HashMap.h&quot;
#include &quot;MooseError.h&quot;
#include &quot;RankTwoTensor.h&quot;
#include &quot;RankThreeTensor.h&quot;
#include &quot;RankFourTensor.h&quot;
#include &quot;ColumnMajorMatrix.h&quot;
#include &quot;UniqueStorage.h&quot;
#include &quot;TwoVector.h&quot;

#include &quot;libmesh/parallel.h&quot;
#include &quot;libmesh/parameters.h&quot;
#include &quot;libmesh/numeric_vector.h&quot;

#ifdef LIBMESH_HAVE_CXX11_TYPE_TRAITS
#include &lt;type_traits&gt;
#endif

// C++ includes
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;memory&gt;
#include &lt;optional&gt;

namespace libMesh
{
template &lt;typename T&gt;
class DenseMatrix;
template &lt;typename T&gt;
class DenseVector;
template &lt;typename T&gt;
class VectorValue;
template &lt;typename T&gt;
class TensorValue;
class Elem;
class Point;
}

/**
 * Scalar helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, P &amp; data, void * context);

/**
 * Vector helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::vector&lt;P&gt; &amp; data, void * context);

/**
 * Shared pointer helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::shared_ptr&lt;P&gt; &amp; data, void * context);

/**
 * Unique pointer helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::unique_ptr&lt;P&gt; &amp; data, void * context);

/**
 * Set helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::set&lt;P&gt; &amp; data, void * context);

/**
 * Map helper routine
 */
template &lt;typename P, typename Q&gt;
inline void storeHelper(std::ostream &amp; stream, std::map&lt;P, Q&gt; &amp; data, void * context);

/**
 * Unordered_map helper routine
 */
template &lt;typename P, typename Q&gt;
inline void storeHelper(std::ostream &amp; stream, std::unordered_map&lt;P, Q&gt; &amp; data, void * context);

/**
 * Optional helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::optional&lt;P&gt; &amp; data, void * context);

/**
 * HashMap helper routine
 */
template &lt;typename P, typename Q&gt;
inline void storeHelper(std::ostream &amp; stream, HashMap&lt;P, Q&gt; &amp; data, void * context);

/**
 * UniqueStorage helper routine
 */
template &lt;typename T&gt;
inline void storeHelper(std::ostream &amp; stream, UniqueStorage&lt;T&gt; &amp; data, void * context);

/**
 * Scalar helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, P &amp; data, void * context);

/**
 * Vector helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::vector&lt;P&gt; &amp; data, void * context);

/**
 * Shared Pointer helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::shared_ptr&lt;P&gt; &amp; data, void * context);

/**
 * Unique Pointer helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::unique_ptr&lt;P&gt; &amp; data, void * context);

/**
 * Set helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::set&lt;P&gt; &amp; data, void * context);

/**
 * Map helper routine
 */
template &lt;typename P, typename Q&gt;
inline void loadHelper(std::istream &amp; stream, std::map&lt;P, Q&gt; &amp; data, void * context);

/**
 * Unordered_map helper routine
 */
template &lt;typename P, typename Q&gt;
inline void loadHelper(std::istream &amp; stream, std::unordered_map&lt;P, Q&gt; &amp; data, void * context);

/**
 * Optional helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::optional&lt;P&gt; &amp; data, void * context);

/**
 * Hashmap helper routine
 */
template &lt;typename P, typename Q&gt;
inline void loadHelper(std::istream &amp; stream, HashMap&lt;P, Q&gt; &amp; data, void * context);

/**
 * UniqueStorage helper routine
 */
template &lt;typename T&gt;
inline void loadHelper(std::istream &amp; stream, UniqueStorage&lt;T&gt; &amp; data, void * context);

template &lt;typename T&gt;
inline void dataStore(std::ostream &amp; stream, T &amp; v, void * /*context*/);

// DO NOT MODIFY THE NEXT LINE - It is used by MOOSEDocs
// *************** Global Store Declarations *****************
template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, T &amp; v, void * /*context*/)
{
#ifdef LIBMESH_HAVE_CXX11_TYPE_TRAITS
  static_assert(std::is_polymorphic&lt;T&gt;::value == false,
                &quot;Cannot serialize a class that has virtual &quot;
                &quot;members!\nWrite a custom dataStore() &quot;
                &quot;template specialization!\n\n&quot;);
  static_assert(std::is_trivially_copyable&lt;T&gt;::value,
                &quot;Cannot serialize a class that is not trivially copyable!\nWrite a custom &quot;
                &quot;dataStore() template specialization!\n\n&quot;);
#endif

  stream.write((char *)&amp;v, sizeof(v));
  mooseAssert(!stream.bad(), &quot;Failed to store&quot;);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; /*stream*/, T *&amp; /*v*/, void * /*context*/)
{
  mooseError(&quot;Attempting to store a raw pointer type: \&quot;&quot;,
             libMesh::demangle(typeid(T).name()),
             &quot; *\&quot; as restartable data!\nWrite a custom dataStore() template specialization!\n\n&quot;);
}

void dataStore(std::ostream &amp; stream, Point &amp; p, void * context);

template &lt;typename T, typename U&gt;
inline void
dataStore(std::ostream &amp; stream, std::pair&lt;T, U&gt; &amp; p, void * context)
{
  storeHelper(stream, p.first, context);
  storeHelper(stream, p.second, context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::vector&lt;T&gt; &amp; v, void * context)
{
  // First store the size of the vector
  unsigned int size = v.size();
  dataStore(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
    storeHelper(stream, v[i], context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::shared_ptr&lt;T&gt; &amp; v, void * context)
{
  T * tmp = v.get();

  storeHelper(stream, tmp, context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::unique_ptr&lt;T&gt; &amp; v, void * context)
{
  T * tmp = v.get();

  storeHelper(stream, tmp, context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::set&lt;T&gt; &amp; s, void * context)
{
  // First store the size of the set
  unsigned int size = s.size();
  dataStore(stream, size, nullptr);

  typename std::set&lt;T&gt;::iterator it = s.begin();
  typename std::set&lt;T&gt;::iterator end = s.end();

  for (; it != end; ++it)
  {
    T &amp; x = const_cast&lt;T &amp;&gt;(*it);
    storeHelper(stream, x, context);
  }
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::list&lt;T&gt; &amp; l, void * context)
{
  // First store the size of the set
  unsigned int size = l.size();
  dataStore(stream, size, nullptr);

  typename std::list&lt;T&gt;::iterator it = l.begin();
  typename std::list&lt;T&gt;::iterator end = l.end();

  for (; it != end; ++it)
  {
    T &amp; x = const_cast&lt;T &amp;&gt;(*it);
    storeHelper(stream, x, context);
  }
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::deque&lt;T&gt; &amp; l, void * context)
{
  // First store the size of the container
  unsigned int size = l.size();
  dataStore(stream, size, nullptr);

  typename std::deque&lt;T&gt;::iterator it = l.begin();
  typename std::deque&lt;T&gt;::iterator end = l.end();

  for (; it != end; ++it)
  {
    T &amp; x = const_cast&lt;T &amp;&gt;(*it);
    storeHelper(stream, x, context);
  }
}

template &lt;typename T, typename U&gt;
inline void
dataStore(std::ostream &amp; stream, std::map&lt;T, U&gt; &amp; m, void * context)
{
  // First store the size of the map
  unsigned int size = m.size();
  dataStore(stream, size, nullptr);

  typename std::map&lt;T, U&gt;::iterator it = m.begin();
  typename std::map&lt;T, U&gt;::iterator end = m.end();

  for (; it != end; ++it)
  {
    T &amp; key = const_cast&lt;T &amp;&gt;(it-&gt;first);

    storeHelper(stream, key, context);

    storeHelper(stream, it-&gt;second, context);
  }
}

template &lt;typename T, typename U&gt;
inline void
dataStore(std::ostream &amp; stream, std::unordered_map&lt;T, U&gt; &amp; m, void * context)
{
  // First store the size of the map
  unsigned int size = m.size();
  dataStore(stream, size, nullptr);

  typename std::unordered_map&lt;T, U&gt;::iterator it = m.begin();
  typename std::unordered_map&lt;T, U&gt;::iterator end = m.end();

  for (; it != end; ++it)
  {
    T &amp; key = const_cast&lt;T &amp;&gt;(it-&gt;first);

    storeHelper(stream, key, context);

    storeHelper(stream, it-&gt;second, context);
  }
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::unordered_set&lt;T&gt; &amp; s, void * context)
{
  // First store the size of the set
  std::size_t size = s.size();
  dataStore(stream, size, nullptr);

  for (auto &amp; element : s)
    dataStore(stream, element, context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::optional&lt;T&gt; &amp; m, void * context)
{
  bool has_value = m.has_value();
  dataStore(stream, has_value, nullptr);

  if (has_value)
    storeHelper(stream, *m, context);
}

template &lt;typename T, typename U&gt;
inline void
dataStore(std::ostream &amp; stream, HashMap&lt;T, U&gt; &amp; m, void * context)
{
  // First store the size of the map
  unsigned int size = m.size();
  dataStore(stream, size, nullptr);

  typename HashMap&lt;T, U&gt;::iterator it = m.begin();
  typename HashMap&lt;T, U&gt;::iterator end = m.end();

  for (; it != end; ++it)
  {
    T &amp; key = const_cast&lt;T &amp;&gt;(it-&gt;first);

    storeHelper(stream, key, context);

    storeHelper(stream, it-&gt;second, context);
  }
}

template &lt;typename T, int Rows, int Cols&gt;
void
dataStore(std::ostream &amp; stream, Eigen::Matrix&lt;T, Rows, Cols&gt; &amp; v, void * context)
{
  auto m = cast_int&lt;unsigned int&gt;(v.rows());
  dataStore(stream, m, context);
  auto n = cast_int&lt;unsigned int&gt;(v.cols());
  dataStore(stream, n, context);
  for (const auto i : make_range(m))
    for (const auto j : make_range(n))
    {
      auto &amp; r = v(i, j);
      dataStore(stream, r, context);
    }
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, GenericTwoVector&lt;T&gt; &amp; v, void * context)
{
  dataStore(stream, static_cast&lt;Eigen::Matrix&lt;T, 2, 1&gt; &amp;&gt;(v), context);
}

// Specializations (defined in .C)
template &lt;&gt;
void dataStore(std::ostream &amp; stream, Real &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, std::string &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, VariableName &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, UserObjectName &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, bool &amp; v, void * context);
// Vectors of bools are special
// https://en.wikipedia.org/w/index.php?title=Sequence_container_(C%2B%2B)&amp;oldid=767869909#Specialization_for_bool
template &lt;&gt;
void dataStore(std::ostream &amp; stream, std::vector&lt;bool&gt; &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, const Elem *&amp; e, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, const Node *&amp; n, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, Elem *&amp; e, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, Node *&amp; n, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, std::stringstream &amp; s, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, ADReal &amp; dn, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, libMesh::Parameters &amp; p, void * context);

template &lt;&gt;
/**
 * Stores an owned numeric vector.
 *
 * This should be used in lieu of the NumericVector&lt;Number&gt; &amp; implementation
 * when the vector may not necessarily be initialized yet on the loading of
 * the data. It stores the partitioning (total and local number of entries).
 *
 * Requirements: the unique_ptr must exist (cannot be null), the vector
 * cannot be ghosted, and the provided context must be the Communicator.
 */
void dataStore(std::ostream &amp; stream,
               std::unique_ptr&lt;libMesh::NumericVector&lt;libMesh::Number&gt;&gt; &amp; v,
               void * context);

template &lt;std::size_t N&gt;
inline void
dataStore(std::ostream &amp; stream, std::array&lt;ADReal, N&gt; &amp; dn, void * context)
{
  for (std::size_t i = 0; i &lt; N; ++i)
    dataStore(stream, dn[i], context);
}

template &lt;std::size_t N&gt;
inline void
dataStore(std::ostream &amp; stream, ADReal (&amp;dn)[N], void * context)
{
  for (std::size_t i = 0; i &lt; N; ++i)
    dataStore(stream, dn[i], context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, libMesh::NumericVector&lt;T&gt; &amp; v, void * context)
{
  v.close();

  numeric_index_type size = v.local_size();

  for (numeric_index_type i = v.first_local_index(); i &lt; v.first_local_index() + size; i++)
  {
    T r = v(i);
    dataStore(stream, r, context);
  }
}

template &lt;&gt;
void dataStore(std::ostream &amp; stream, Vec &amp; v, void * context);

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, DenseVector&lt;T&gt; &amp; v, void * context)
{
  unsigned int m = v.size();
  dataStore(stream, m, nullptr);
  for (unsigned int i = 0; i &lt; v.size(); i++)
  {
    T r = v(i);
    dataStore(stream, r, context);
  }
}

template &lt;typename T&gt;
void dataStore(std::ostream &amp; stream, libMesh::TensorValue&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void dataStore(std::ostream &amp; stream, libMesh::DenseMatrix&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void dataStore(std::ostream &amp; stream, libMesh::VectorValue&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, RankTwoTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataStore(stream, rtt._coords, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, RankThreeTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataStore(stream, rtt._vals, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, RankFourTensorTempl&lt;T&gt; &amp; rft, void * context)
{
  dataStore(stream, rft._vals, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, SymmetricRankTwoTensorTempl&lt;T&gt; &amp; srtt, void * context)
{
  dataStore(stream, srtt._vals, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, SymmetricRankFourTensorTempl&lt;T&gt; &amp; srft, void * context)
{
  dataStore(stream, srft._vals, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, ColumnMajorMatrixTempl&lt;T&gt; &amp; cmm, void * context)
{
  dataStore(stream, cmm._values, context);
}

// DO NOT MODIFY THE NEXT LINE - It is used by MOOSEDocs
// *************** Global Load Declarations *****************
template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, T &amp; v, void * /*context*/)
{
  stream.read((char *)&amp;v, sizeof(v));
  mooseAssert(!stream.bad(), &quot;Failed to load&quot;);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; /*stream*/, T *&amp; /*v*/, void * /*context*/)
{
  mooseError(&quot;Attempting to load a raw pointer type: \&quot;&quot;,
             libMesh::demangle(typeid(T).name()),
             &quot; *\&quot; as restartable data!\nWrite a custom dataLoad() template specialization!\n\n&quot;);
}

template &lt;typename T, typename U&gt;
inline void
dataLoad(std::istream &amp; stream, std::pair&lt;T, U&gt; &amp; p, void * context)
{
  loadHelper(stream, p.first, context);
  loadHelper(stream, p.second, context);
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::vector&lt;T&gt; &amp; v, void * context)
{
  // First read the size of the vector
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  v.resize(size);

  for (unsigned int i = 0; i &lt; size; i++)
    loadHelper(stream, v[i], context);
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::shared_ptr&lt;T&gt; &amp; v, void * context)
{
  T * tmp = v.get();

  loadHelper(stream, tmp, context);
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::unique_ptr&lt;T&gt; &amp; v, void * context)
{
  T * tmp = v.get();

  loadHelper(stream, tmp, context);
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::set&lt;T&gt; &amp; s, void * context)
{
  // First read the size of the set
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T data;
    loadHelper(stream, data, context);
    s.insert(std::move(data));
  }
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::list&lt;T&gt; &amp; l, void * context)
{
  // First read the size of the set
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T data;
    loadHelper(stream, data, context);
    l.push_back(std::move(data));
  }
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::deque&lt;T&gt; &amp; l, void * context)
{
  // First read the size of the container
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T data;
    loadHelper(stream, data, context);
    l.push_back(std::move(data));
  }
}

template &lt;typename T, typename U&gt;
inline void
dataLoad(std::istream &amp; stream, std::map&lt;T, U&gt; &amp; m, void * context)
{
  m.clear();

  // First read the size of the map
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T key;
    loadHelper(stream, key, context);

    U &amp; value = m[key];
    loadHelper(stream, value, context);
  }
}

template &lt;typename T, typename U&gt;
inline void
dataLoad(std::istream &amp; stream, std::unordered_map&lt;T, U&gt; &amp; m, void * context)
{
  m.clear();

  // First read the size of the map
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T key;
    loadHelper(stream, key, context);

    U &amp; value = m[key];
    loadHelper(stream, value, context);
  }
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::unordered_set&lt;T&gt; &amp; s, void * context)
{
  s.clear();

  // First read the size of the set
  std::size_t size = 0;
  dataLoad(stream, size, nullptr);
  s.reserve(size);

  for (std::size_t i = 0; i &lt; size; i++)
  {
    T element;
    dataLoad(stream, element, context);
    s.insert(element);
  }
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::optional&lt;T&gt; &amp; m, void * context)
{
  bool has_value;
  dataLoad(stream, has_value, nullptr);

  if (has_value)
  {
    m = T{};
    loadHelper(stream, *m, context);
  }
  else
    m.reset();
}

template &lt;typename T, typename U&gt;
inline void
dataLoad(std::istream &amp; stream, HashMap&lt;T, U&gt; &amp; m, void * context)
{
  // First read the size of the map
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T key;
    loadHelper(stream, key, context);

    U &amp; value = m[key];
    loadHelper(stream, value, context);
  }
}

template &lt;typename T, int Rows, int Cols&gt;
void
dataLoad(std::istream &amp; stream, Eigen::Matrix&lt;T, Rows, Cols&gt; &amp; v, void * context)
{
  unsigned int m = 0;
  dataLoad(stream, m, context);
  unsigned int n = 0;
  dataLoad(stream, n, context);
  v.resize(m, n);
  for (const auto i : make_range(m))
    for (const auto j : make_range(n))
    {
      T r{};
      dataLoad(stream, r, context);
      v(i, j) = r;
    }
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, GenericTwoVector&lt;T&gt; &amp; v, void * context)
{
  dataLoad(stream, static_cast&lt;Eigen::Matrix&lt;T, 2, 1&gt; &amp;&gt;(v), context);
}

// Specializations (defined in .C)
template &lt;&gt;
void dataLoad(std::istream &amp; stream, Real &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, std::string &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, VariableName &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, UserObjectName &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, bool &amp; v, void * /*context*/);
// Vectors of bools are special
// https://en.wikipedia.org/w/index.php?title=Sequence_container_(C%2B%2B)&amp;oldid=767869909#Specialization_for_bool
template &lt;&gt;
void dataLoad(std::istream &amp; stream, std::vector&lt;bool&gt; &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, const Elem *&amp; e, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, const Node *&amp; e, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, Elem *&amp; e, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, Node *&amp; e, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, std::stringstream &amp; s, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, ADReal &amp; dn, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, libMesh::Parameters &amp; p, void * context);
template &lt;&gt;
/**
 * Loads an owned numeric vector.
 *
 * This is used in lieu of the NumericVector&lt;double&gt; &amp; implementation when
 * the vector may not necessarily be initialized yet on the loading of the data.
 *
 * If \p is not null, it must have the same global and local sizes that it
 * was stored with. In this case, the data is simply filled into the vector.
 *
 * If \p is null, it will be constructed with the type (currently just a
 * PetscVector) stored and initialized with the global and local sizes stored.
 * The data will then be filled after initialization.
 *
 * Requirements: the vector cannot be ghosted, the provided context must be
 * the Communicator, and if \p v is initialized, it must have the same global
 * and local sizes that the vector was stored with.
 */
void dataLoad(std::istream &amp; stream,
              std::unique_ptr&lt;libMesh::NumericVector&lt;libMesh::Number&gt;&gt; &amp; v,
              void * context);

template &lt;std::size_t N&gt;
inline void
dataLoad(std::istream &amp; stream, std::array&lt;ADReal, N&gt; &amp; dn, void * context)
{
  for (std::size_t i = 0; i &lt; N; ++i)
    dataLoad(stream, dn[i], context);
}

template &lt;std::size_t N&gt;
inline void
dataLoad(std::istream &amp; stream, ADReal (&amp;dn)[N], void * context)
{
  for (std::size_t i = 0; i &lt; N; ++i)
    dataLoad(stream, dn[i], context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, libMesh::NumericVector&lt;T&gt; &amp; v, void * context)
{
  numeric_index_type size = v.local_size();
  for (numeric_index_type i = v.first_local_index(); i &lt; v.first_local_index() + size; i++)
  {
    T r = 0;
    dataLoad(stream, r, context);
    v.set(i, r);
  }
  v.close();
}

template &lt;&gt;
void dataLoad(std::istream &amp; stream, Vec &amp; v, void * context);

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, DenseVector&lt;T&gt; &amp; v, void * context)
{
  unsigned int n = 0;
  dataLoad(stream, n, nullptr);
  v.resize(n);
  for (unsigned int i = 0; i &lt; n; i++)
  {
    T r = 0;
    dataLoad(stream, r, context);
    v(i) = r;
  }
}

template &lt;typename T&gt;
void dataLoad(std::istream &amp; stream, libMesh::TensorValue&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void dataLoad(std::istream &amp; stream, libMesh::DenseMatrix&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void dataLoad(std::istream &amp; stream, libMesh::VectorValue&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, RankTwoTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataLoad(stream, rtt._coords, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, RankThreeTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataLoad(stream, rtt._vals, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, RankFourTensorTempl&lt;T&gt; &amp; rft, void * context)
{
  dataLoad(stream, rft._vals, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, SymmetricRankTwoTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataLoad(stream, rtt._vals, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, SymmetricRankFourTensorTempl&lt;T&gt; &amp; rft, void * context)
{
  dataLoad(stream, rft._vals, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, ColumnMajorMatrixTempl&lt;T&gt; &amp; cmm, void * context)
{
  dataLoad(stream, cmm._values, context);
}

// Scalar Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, P &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Vector Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::vector&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// std::shared_ptr Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::shared_ptr&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// std::unique Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::unique_ptr&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Set Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::set&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Map Helper Function
template &lt;typename P, typename Q&gt;
inline void
storeHelper(std::ostream &amp; stream, std::map&lt;P, Q&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Unordered_map Helper Function
template &lt;typename P, typename Q&gt;
inline void
storeHelper(std::ostream &amp; stream, std::unordered_map&lt;P, Q&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Optional Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::optional&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// HashMap Helper Function
template &lt;typename P, typename Q&gt;
inline void
storeHelper(std::ostream &amp; stream, HashMap&lt;P, Q&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

/**
 * UniqueStorage helper routine
 *
 * The data within the UniqueStorage object cannot be null. The helper
 * for unique_ptr&lt;T&gt; is called to store the data.
 */
template &lt;typename T&gt;
inline void
storeHelper(std::ostream &amp; stream, UniqueStorage&lt;T&gt; &amp; data, void * context)
{
  std::size_t size = data.size();
  dataStore(stream, size, nullptr);

  for (const auto i : index_range(data))
  {
    mooseAssert(data.hasValue(i), &quot;Data doesn&#x27;t have a value&quot;);
    storeHelper(stream, data.pointerValue(i), context);
  }
}

// Scalar Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, P &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Vector Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::vector&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// std::shared_ptr Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::shared_ptr&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Unique Pointer Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::unique_ptr&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Set Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::set&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Map Helper Function
template &lt;typename P, typename Q&gt;
inline void
loadHelper(std::istream &amp; stream, std::map&lt;P, Q&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Unordered_map Helper Function
template &lt;typename P, typename Q&gt;
inline void
loadHelper(std::istream &amp; stream, std::unordered_map&lt;P, Q&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Optional Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::optional&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// HashMap Helper Function
template &lt;typename P, typename Q&gt;
inline void
loadHelper(std::istream &amp; stream, HashMap&lt;P, Q&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

/**
 * UniqueStorage Helper Function
 *
 * The unique_ptr&lt;T&gt; loader is called to load the data. That is,
 * you will likely need a specialization of unique_ptr&lt;T&gt; that will
 * appropriately construct and then fill the piece of data.
 */
template &lt;typename T&gt;
inline void
loadHelper(std::istream &amp; stream, UniqueStorage&lt;T&gt; &amp; data, void * context)
{
  std::size_t size;
  dataLoad(stream, size, nullptr);
  data.resize(size);

  for (const auto i : index_range(data))
    loadHelper(stream, data.pointerValue(i), context);
}

void dataLoad(std::istream &amp; stream, Point &amp; p, void * context);

#ifndef TIMPI_HAVE_STRING_PACKING
/**
 * The following methods are specializations for using the libMesh::Parallel::packed_range_*
 * routines
 * for std::strings. These are here because the dataLoad/dataStore routines create raw string
 * buffers that can be communicated in a standard way using packed ranges.
 */
namespace libMesh
{
namespace Parallel
{
template &lt;typename T&gt;
class Packing&lt;std::basic_string&lt;T&gt;&gt;
{
public:
  static const unsigned int size_bytes = 4;

  typedef T buffer_type;

  static unsigned int get_string_len(typename std::vector&lt;T&gt;::const_iterator in)
  {
    unsigned int string_len = reinterpret_cast&lt;const unsigned char &amp;&gt;(in[size_bytes - 1]);
    for (signed int i = size_bytes - 2; i &gt;= 0; --i)
    {
      string_len *= 256;
      string_len += reinterpret_cast&lt;const unsigned char &amp;&gt;(in[i]);
    }
    return string_len;
  }

  static unsigned int packed_size(typename std::vector&lt;T&gt;::const_iterator in)
  {
    return get_string_len(in) + size_bytes;
  }

  static unsigned int packable_size(const std::basic_string&lt;T&gt; &amp; s, const void *)
  {
    return s.size() + size_bytes;
  }

  template &lt;typename Iter&gt;
  static void pack(const std::basic_string&lt;T&gt; &amp; b, Iter data_out, const void *)
  {
    unsigned int string_len = b.size();
    for (unsigned int i = 0; i != size_bytes; ++i)
    {
      *data_out++ = (string_len % 256);
      string_len /= 256;
    }

    std::copy(b.begin(), b.end(), data_out);
  }

  static std::basic_string&lt;T&gt; unpack(typename std::vector&lt;T&gt;::const_iterator in, void *)
  {
    unsigned int string_len = get_string_len(in);

    std::ostringstream oss;
    for (unsigned int i = 0; i &lt; string_len; ++i)
      oss &lt;&lt; reinterpret_cast&lt;const unsigned char &amp;&gt;(in[i + size_bytes]);

    in += size_bytes + string_len;

    return oss.str();
  }
};

} // namespace Parallel

} // namespace libMesh

#endif
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="b9668210-664e-4042-b1b1-c5b18810e0ac"><div class="modal-content"><h4>(moose/framework/include/restart/DataIO.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

// MOOSE includes
#include &quot;ADReal.h&quot;
#include &quot;MooseTypes.h&quot;
#include &quot;HashMap.h&quot;
#include &quot;MooseError.h&quot;
#include &quot;RankTwoTensor.h&quot;
#include &quot;RankThreeTensor.h&quot;
#include &quot;RankFourTensor.h&quot;
#include &quot;ColumnMajorMatrix.h&quot;
#include &quot;UniqueStorage.h&quot;
#include &quot;TwoVector.h&quot;

#include &quot;libmesh/parallel.h&quot;
#include &quot;libmesh/parameters.h&quot;
#include &quot;libmesh/numeric_vector.h&quot;

#ifdef LIBMESH_HAVE_CXX11_TYPE_TRAITS
#include &lt;type_traits&gt;
#endif

// C++ includes
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;memory&gt;
#include &lt;optional&gt;

namespace libMesh
{
template &lt;typename T&gt;
class DenseMatrix;
template &lt;typename T&gt;
class DenseVector;
template &lt;typename T&gt;
class VectorValue;
template &lt;typename T&gt;
class TensorValue;
class Elem;
class Point;
}

/**
 * Scalar helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, P &amp; data, void * context);

/**
 * Vector helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::vector&lt;P&gt; &amp; data, void * context);

/**
 * Shared pointer helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::shared_ptr&lt;P&gt; &amp; data, void * context);

/**
 * Unique pointer helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::unique_ptr&lt;P&gt; &amp; data, void * context);

/**
 * Set helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::set&lt;P&gt; &amp; data, void * context);

/**
 * Map helper routine
 */
template &lt;typename P, typename Q&gt;
inline void storeHelper(std::ostream &amp; stream, std::map&lt;P, Q&gt; &amp; data, void * context);

/**
 * Unordered_map helper routine
 */
template &lt;typename P, typename Q&gt;
inline void storeHelper(std::ostream &amp; stream, std::unordered_map&lt;P, Q&gt; &amp; data, void * context);

/**
 * Optional helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::optional&lt;P&gt; &amp; data, void * context);

/**
 * HashMap helper routine
 */
template &lt;typename P, typename Q&gt;
inline void storeHelper(std::ostream &amp; stream, HashMap&lt;P, Q&gt; &amp; data, void * context);

/**
 * UniqueStorage helper routine
 */
template &lt;typename T&gt;
inline void storeHelper(std::ostream &amp; stream, UniqueStorage&lt;T&gt; &amp; data, void * context);

/**
 * Scalar helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, P &amp; data, void * context);

/**
 * Vector helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::vector&lt;P&gt; &amp; data, void * context);

/**
 * Shared Pointer helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::shared_ptr&lt;P&gt; &amp; data, void * context);

/**
 * Unique Pointer helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::unique_ptr&lt;P&gt; &amp; data, void * context);

/**
 * Set helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::set&lt;P&gt; &amp; data, void * context);

/**
 * Map helper routine
 */
template &lt;typename P, typename Q&gt;
inline void loadHelper(std::istream &amp; stream, std::map&lt;P, Q&gt; &amp; data, void * context);

/**
 * Unordered_map helper routine
 */
template &lt;typename P, typename Q&gt;
inline void loadHelper(std::istream &amp; stream, std::unordered_map&lt;P, Q&gt; &amp; data, void * context);

/**
 * Optional helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::optional&lt;P&gt; &amp; data, void * context);

/**
 * Hashmap helper routine
 */
template &lt;typename P, typename Q&gt;
inline void loadHelper(std::istream &amp; stream, HashMap&lt;P, Q&gt; &amp; data, void * context);

/**
 * UniqueStorage helper routine
 */
template &lt;typename T&gt;
inline void loadHelper(std::istream &amp; stream, UniqueStorage&lt;T&gt; &amp; data, void * context);

template &lt;typename T&gt;
inline void dataStore(std::ostream &amp; stream, T &amp; v, void * /*context*/);

// DO NOT MODIFY THE NEXT LINE - It is used by MOOSEDocs
// *************** Global Store Declarations *****************
template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, T &amp; v, void * /*context*/)
{
#ifdef LIBMESH_HAVE_CXX11_TYPE_TRAITS
  static_assert(std::is_polymorphic&lt;T&gt;::value == false,
                &quot;Cannot serialize a class that has virtual &quot;
                &quot;members!\nWrite a custom dataStore() &quot;
                &quot;template specialization!\n\n&quot;);
  static_assert(std::is_trivially_copyable&lt;T&gt;::value,
                &quot;Cannot serialize a class that is not trivially copyable!\nWrite a custom &quot;
                &quot;dataStore() template specialization!\n\n&quot;);
#endif

  stream.write((char *)&amp;v, sizeof(v));
  mooseAssert(!stream.bad(), &quot;Failed to store&quot;);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; /*stream*/, T *&amp; /*v*/, void * /*context*/)
{
  mooseError(&quot;Attempting to store a raw pointer type: \&quot;&quot;,
             libMesh::demangle(typeid(T).name()),
             &quot; *\&quot; as restartable data!\nWrite a custom dataStore() template specialization!\n\n&quot;);
}

void dataStore(std::ostream &amp; stream, Point &amp; p, void * context);

template &lt;typename T, typename U&gt;
inline void
dataStore(std::ostream &amp; stream, std::pair&lt;T, U&gt; &amp; p, void * context)
{
  storeHelper(stream, p.first, context);
  storeHelper(stream, p.second, context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::vector&lt;T&gt; &amp; v, void * context)
{
  // First store the size of the vector
  unsigned int size = v.size();
  dataStore(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
    storeHelper(stream, v[i], context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::shared_ptr&lt;T&gt; &amp; v, void * context)
{
  T * tmp = v.get();

  storeHelper(stream, tmp, context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::unique_ptr&lt;T&gt; &amp; v, void * context)
{
  T * tmp = v.get();

  storeHelper(stream, tmp, context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::set&lt;T&gt; &amp; s, void * context)
{
  // First store the size of the set
  unsigned int size = s.size();
  dataStore(stream, size, nullptr);

  typename std::set&lt;T&gt;::iterator it = s.begin();
  typename std::set&lt;T&gt;::iterator end = s.end();

  for (; it != end; ++it)
  {
    T &amp; x = const_cast&lt;T &amp;&gt;(*it);
    storeHelper(stream, x, context);
  }
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::list&lt;T&gt; &amp; l, void * context)
{
  // First store the size of the set
  unsigned int size = l.size();
  dataStore(stream, size, nullptr);

  typename std::list&lt;T&gt;::iterator it = l.begin();
  typename std::list&lt;T&gt;::iterator end = l.end();

  for (; it != end; ++it)
  {
    T &amp; x = const_cast&lt;T &amp;&gt;(*it);
    storeHelper(stream, x, context);
  }
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::deque&lt;T&gt; &amp; l, void * context)
{
  // First store the size of the container
  unsigned int size = l.size();
  dataStore(stream, size, nullptr);

  typename std::deque&lt;T&gt;::iterator it = l.begin();
  typename std::deque&lt;T&gt;::iterator end = l.end();

  for (; it != end; ++it)
  {
    T &amp; x = const_cast&lt;T &amp;&gt;(*it);
    storeHelper(stream, x, context);
  }
}

template &lt;typename T, typename U&gt;
inline void
dataStore(std::ostream &amp; stream, std::map&lt;T, U&gt; &amp; m, void * context)
{
  // First store the size of the map
  unsigned int size = m.size();
  dataStore(stream, size, nullptr);

  typename std::map&lt;T, U&gt;::iterator it = m.begin();
  typename std::map&lt;T, U&gt;::iterator end = m.end();

  for (; it != end; ++it)
  {
    T &amp; key = const_cast&lt;T &amp;&gt;(it-&gt;first);

    storeHelper(stream, key, context);

    storeHelper(stream, it-&gt;second, context);
  }
}

template &lt;typename T, typename U&gt;
inline void
dataStore(std::ostream &amp; stream, std::unordered_map&lt;T, U&gt; &amp; m, void * context)
{
  // First store the size of the map
  unsigned int size = m.size();
  dataStore(stream, size, nullptr);

  typename std::unordered_map&lt;T, U&gt;::iterator it = m.begin();
  typename std::unordered_map&lt;T, U&gt;::iterator end = m.end();

  for (; it != end; ++it)
  {
    T &amp; key = const_cast&lt;T &amp;&gt;(it-&gt;first);

    storeHelper(stream, key, context);

    storeHelper(stream, it-&gt;second, context);
  }
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::unordered_set&lt;T&gt; &amp; s, void * context)
{
  // First store the size of the set
  std::size_t size = s.size();
  dataStore(stream, size, nullptr);

  for (auto &amp; element : s)
    dataStore(stream, element, context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::optional&lt;T&gt; &amp; m, void * context)
{
  bool has_value = m.has_value();
  dataStore(stream, has_value, nullptr);

  if (has_value)
    storeHelper(stream, *m, context);
}

template &lt;typename T, typename U&gt;
inline void
dataStore(std::ostream &amp; stream, HashMap&lt;T, U&gt; &amp; m, void * context)
{
  // First store the size of the map
  unsigned int size = m.size();
  dataStore(stream, size, nullptr);

  typename HashMap&lt;T, U&gt;::iterator it = m.begin();
  typename HashMap&lt;T, U&gt;::iterator end = m.end();

  for (; it != end; ++it)
  {
    T &amp; key = const_cast&lt;T &amp;&gt;(it-&gt;first);

    storeHelper(stream, key, context);

    storeHelper(stream, it-&gt;second, context);
  }
}

template &lt;typename T, int Rows, int Cols&gt;
void
dataStore(std::ostream &amp; stream, Eigen::Matrix&lt;T, Rows, Cols&gt; &amp; v, void * context)
{
  auto m = cast_int&lt;unsigned int&gt;(v.rows());
  dataStore(stream, m, context);
  auto n = cast_int&lt;unsigned int&gt;(v.cols());
  dataStore(stream, n, context);
  for (const auto i : make_range(m))
    for (const auto j : make_range(n))
    {
      auto &amp; r = v(i, j);
      dataStore(stream, r, context);
    }
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, GenericTwoVector&lt;T&gt; &amp; v, void * context)
{
  dataStore(stream, static_cast&lt;Eigen::Matrix&lt;T, 2, 1&gt; &amp;&gt;(v), context);
}

// Specializations (defined in .C)
template &lt;&gt;
void dataStore(std::ostream &amp; stream, Real &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, std::string &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, VariableName &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, UserObjectName &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, bool &amp; v, void * context);
// Vectors of bools are special
// https://en.wikipedia.org/w/index.php?title=Sequence_container_(C%2B%2B)&amp;oldid=767869909#Specialization_for_bool
template &lt;&gt;
void dataStore(std::ostream &amp; stream, std::vector&lt;bool&gt; &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, const Elem *&amp; e, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, const Node *&amp; n, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, Elem *&amp; e, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, Node *&amp; n, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, std::stringstream &amp; s, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, ADReal &amp; dn, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, libMesh::Parameters &amp; p, void * context);

template &lt;&gt;
/**
 * Stores an owned numeric vector.
 *
 * This should be used in lieu of the NumericVector&lt;Number&gt; &amp; implementation
 * when the vector may not necessarily be initialized yet on the loading of
 * the data. It stores the partitioning (total and local number of entries).
 *
 * Requirements: the unique_ptr must exist (cannot be null), the vector
 * cannot be ghosted, and the provided context must be the Communicator.
 */
void dataStore(std::ostream &amp; stream,
               std::unique_ptr&lt;libMesh::NumericVector&lt;libMesh::Number&gt;&gt; &amp; v,
               void * context);

template &lt;std::size_t N&gt;
inline void
dataStore(std::ostream &amp; stream, std::array&lt;ADReal, N&gt; &amp; dn, void * context)
{
  for (std::size_t i = 0; i &lt; N; ++i)
    dataStore(stream, dn[i], context);
}

template &lt;std::size_t N&gt;
inline void
dataStore(std::ostream &amp; stream, ADReal (&amp;dn)[N], void * context)
{
  for (std::size_t i = 0; i &lt; N; ++i)
    dataStore(stream, dn[i], context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, libMesh::NumericVector&lt;T&gt; &amp; v, void * context)
{
  v.close();

  numeric_index_type size = v.local_size();

  for (numeric_index_type i = v.first_local_index(); i &lt; v.first_local_index() + size; i++)
  {
    T r = v(i);
    dataStore(stream, r, context);
  }
}

template &lt;&gt;
void dataStore(std::ostream &amp; stream, Vec &amp; v, void * context);

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, DenseVector&lt;T&gt; &amp; v, void * context)
{
  unsigned int m = v.size();
  dataStore(stream, m, nullptr);
  for (unsigned int i = 0; i &lt; v.size(); i++)
  {
    T r = v(i);
    dataStore(stream, r, context);
  }
}

template &lt;typename T&gt;
void dataStore(std::ostream &amp; stream, libMesh::TensorValue&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void dataStore(std::ostream &amp; stream, libMesh::DenseMatrix&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void dataStore(std::ostream &amp; stream, libMesh::VectorValue&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, RankTwoTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataStore(stream, rtt._coords, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, RankThreeTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataStore(stream, rtt._vals, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, RankFourTensorTempl&lt;T&gt; &amp; rft, void * context)
{
  dataStore(stream, rft._vals, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, SymmetricRankTwoTensorTempl&lt;T&gt; &amp; srtt, void * context)
{
  dataStore(stream, srtt._vals, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, SymmetricRankFourTensorTempl&lt;T&gt; &amp; srft, void * context)
{
  dataStore(stream, srft._vals, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, ColumnMajorMatrixTempl&lt;T&gt; &amp; cmm, void * context)
{
  dataStore(stream, cmm._values, context);
}

// DO NOT MODIFY THE NEXT LINE - It is used by MOOSEDocs
// *************** Global Load Declarations *****************
template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, T &amp; v, void * /*context*/)
{
  stream.read((char *)&amp;v, sizeof(v));
  mooseAssert(!stream.bad(), &quot;Failed to load&quot;);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; /*stream*/, T *&amp; /*v*/, void * /*context*/)
{
  mooseError(&quot;Attempting to load a raw pointer type: \&quot;&quot;,
             libMesh::demangle(typeid(T).name()),
             &quot; *\&quot; as restartable data!\nWrite a custom dataLoad() template specialization!\n\n&quot;);
}

template &lt;typename T, typename U&gt;
inline void
dataLoad(std::istream &amp; stream, std::pair&lt;T, U&gt; &amp; p, void * context)
{
  loadHelper(stream, p.first, context);
  loadHelper(stream, p.second, context);
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::vector&lt;T&gt; &amp; v, void * context)
{
  // First read the size of the vector
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  v.resize(size);

  for (unsigned int i = 0; i &lt; size; i++)
    loadHelper(stream, v[i], context);
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::shared_ptr&lt;T&gt; &amp; v, void * context)
{
  T * tmp = v.get();

  loadHelper(stream, tmp, context);
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::unique_ptr&lt;T&gt; &amp; v, void * context)
{
  T * tmp = v.get();

  loadHelper(stream, tmp, context);
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::set&lt;T&gt; &amp; s, void * context)
{
  // First read the size of the set
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T data;
    loadHelper(stream, data, context);
    s.insert(std::move(data));
  }
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::list&lt;T&gt; &amp; l, void * context)
{
  // First read the size of the set
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T data;
    loadHelper(stream, data, context);
    l.push_back(std::move(data));
  }
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::deque&lt;T&gt; &amp; l, void * context)
{
  // First read the size of the container
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T data;
    loadHelper(stream, data, context);
    l.push_back(std::move(data));
  }
}

template &lt;typename T, typename U&gt;
inline void
dataLoad(std::istream &amp; stream, std::map&lt;T, U&gt; &amp; m, void * context)
{
  m.clear();

  // First read the size of the map
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T key;
    loadHelper(stream, key, context);

    U &amp; value = m[key];
    loadHelper(stream, value, context);
  }
}

template &lt;typename T, typename U&gt;
inline void
dataLoad(std::istream &amp; stream, std::unordered_map&lt;T, U&gt; &amp; m, void * context)
{
  m.clear();

  // First read the size of the map
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T key;
    loadHelper(stream, key, context);

    U &amp; value = m[key];
    loadHelper(stream, value, context);
  }
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::unordered_set&lt;T&gt; &amp; s, void * context)
{
  s.clear();

  // First read the size of the set
  std::size_t size = 0;
  dataLoad(stream, size, nullptr);
  s.reserve(size);

  for (std::size_t i = 0; i &lt; size; i++)
  {
    T element;
    dataLoad(stream, element, context);
    s.insert(element);
  }
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::optional&lt;T&gt; &amp; m, void * context)
{
  bool has_value;
  dataLoad(stream, has_value, nullptr);

  if (has_value)
  {
    m = T{};
    loadHelper(stream, *m, context);
  }
  else
    m.reset();
}

template &lt;typename T, typename U&gt;
inline void
dataLoad(std::istream &amp; stream, HashMap&lt;T, U&gt; &amp; m, void * context)
{
  // First read the size of the map
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T key;
    loadHelper(stream, key, context);

    U &amp; value = m[key];
    loadHelper(stream, value, context);
  }
}

template &lt;typename T, int Rows, int Cols&gt;
void
dataLoad(std::istream &amp; stream, Eigen::Matrix&lt;T, Rows, Cols&gt; &amp; v, void * context)
{
  unsigned int m = 0;
  dataLoad(stream, m, context);
  unsigned int n = 0;
  dataLoad(stream, n, context);
  v.resize(m, n);
  for (const auto i : make_range(m))
    for (const auto j : make_range(n))
    {
      T r{};
      dataLoad(stream, r, context);
      v(i, j) = r;
    }
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, GenericTwoVector&lt;T&gt; &amp; v, void * context)
{
  dataLoad(stream, static_cast&lt;Eigen::Matrix&lt;T, 2, 1&gt; &amp;&gt;(v), context);
}

// Specializations (defined in .C)
template &lt;&gt;
void dataLoad(std::istream &amp; stream, Real &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, std::string &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, VariableName &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, UserObjectName &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, bool &amp; v, void * /*context*/);
// Vectors of bools are special
// https://en.wikipedia.org/w/index.php?title=Sequence_container_(C%2B%2B)&amp;oldid=767869909#Specialization_for_bool
template &lt;&gt;
void dataLoad(std::istream &amp; stream, std::vector&lt;bool&gt; &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, const Elem *&amp; e, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, const Node *&amp; e, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, Elem *&amp; e, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, Node *&amp; e, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, std::stringstream &amp; s, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, ADReal &amp; dn, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, libMesh::Parameters &amp; p, void * context);
template &lt;&gt;
/**
 * Loads an owned numeric vector.
 *
 * This is used in lieu of the NumericVector&lt;double&gt; &amp; implementation when
 * the vector may not necessarily be initialized yet on the loading of the data.
 *
 * If \p is not null, it must have the same global and local sizes that it
 * was stored with. In this case, the data is simply filled into the vector.
 *
 * If \p is null, it will be constructed with the type (currently just a
 * PetscVector) stored and initialized with the global and local sizes stored.
 * The data will then be filled after initialization.
 *
 * Requirements: the vector cannot be ghosted, the provided context must be
 * the Communicator, and if \p v is initialized, it must have the same global
 * and local sizes that the vector was stored with.
 */
void dataLoad(std::istream &amp; stream,
              std::unique_ptr&lt;libMesh::NumericVector&lt;libMesh::Number&gt;&gt; &amp; v,
              void * context);

template &lt;std::size_t N&gt;
inline void
dataLoad(std::istream &amp; stream, std::array&lt;ADReal, N&gt; &amp; dn, void * context)
{
  for (std::size_t i = 0; i &lt; N; ++i)
    dataLoad(stream, dn[i], context);
}

template &lt;std::size_t N&gt;
inline void
dataLoad(std::istream &amp; stream, ADReal (&amp;dn)[N], void * context)
{
  for (std::size_t i = 0; i &lt; N; ++i)
    dataLoad(stream, dn[i], context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, libMesh::NumericVector&lt;T&gt; &amp; v, void * context)
{
  numeric_index_type size = v.local_size();
  for (numeric_index_type i = v.first_local_index(); i &lt; v.first_local_index() + size; i++)
  {
    T r = 0;
    dataLoad(stream, r, context);
    v.set(i, r);
  }
  v.close();
}

template &lt;&gt;
void dataLoad(std::istream &amp; stream, Vec &amp; v, void * context);

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, DenseVector&lt;T&gt; &amp; v, void * context)
{
  unsigned int n = 0;
  dataLoad(stream, n, nullptr);
  v.resize(n);
  for (unsigned int i = 0; i &lt; n; i++)
  {
    T r = 0;
    dataLoad(stream, r, context);
    v(i) = r;
  }
}

template &lt;typename T&gt;
void dataLoad(std::istream &amp; stream, libMesh::TensorValue&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void dataLoad(std::istream &amp; stream, libMesh::DenseMatrix&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void dataLoad(std::istream &amp; stream, libMesh::VectorValue&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, RankTwoTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataLoad(stream, rtt._coords, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, RankThreeTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataLoad(stream, rtt._vals, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, RankFourTensorTempl&lt;T&gt; &amp; rft, void * context)
{
  dataLoad(stream, rft._vals, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, SymmetricRankTwoTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataLoad(stream, rtt._vals, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, SymmetricRankFourTensorTempl&lt;T&gt; &amp; rft, void * context)
{
  dataLoad(stream, rft._vals, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, ColumnMajorMatrixTempl&lt;T&gt; &amp; cmm, void * context)
{
  dataLoad(stream, cmm._values, context);
}

// Scalar Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, P &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Vector Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::vector&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// std::shared_ptr Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::shared_ptr&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// std::unique Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::unique_ptr&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Set Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::set&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Map Helper Function
template &lt;typename P, typename Q&gt;
inline void
storeHelper(std::ostream &amp; stream, std::map&lt;P, Q&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Unordered_map Helper Function
template &lt;typename P, typename Q&gt;
inline void
storeHelper(std::ostream &amp; stream, std::unordered_map&lt;P, Q&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Optional Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::optional&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// HashMap Helper Function
template &lt;typename P, typename Q&gt;
inline void
storeHelper(std::ostream &amp; stream, HashMap&lt;P, Q&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

/**
 * UniqueStorage helper routine
 *
 * The data within the UniqueStorage object cannot be null. The helper
 * for unique_ptr&lt;T&gt; is called to store the data.
 */
template &lt;typename T&gt;
inline void
storeHelper(std::ostream &amp; stream, UniqueStorage&lt;T&gt; &amp; data, void * context)
{
  std::size_t size = data.size();
  dataStore(stream, size, nullptr);

  for (const auto i : index_range(data))
  {
    mooseAssert(data.hasValue(i), &quot;Data doesn&#x27;t have a value&quot;);
    storeHelper(stream, data.pointerValue(i), context);
  }
}

// Scalar Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, P &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Vector Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::vector&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// std::shared_ptr Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::shared_ptr&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Unique Pointer Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::unique_ptr&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Set Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::set&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Map Helper Function
template &lt;typename P, typename Q&gt;
inline void
loadHelper(std::istream &amp; stream, std::map&lt;P, Q&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Unordered_map Helper Function
template &lt;typename P, typename Q&gt;
inline void
loadHelper(std::istream &amp; stream, std::unordered_map&lt;P, Q&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Optional Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::optional&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// HashMap Helper Function
template &lt;typename P, typename Q&gt;
inline void
loadHelper(std::istream &amp; stream, HashMap&lt;P, Q&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

/**
 * UniqueStorage Helper Function
 *
 * The unique_ptr&lt;T&gt; loader is called to load the data. That is,
 * you will likely need a specialization of unique_ptr&lt;T&gt; that will
 * appropriately construct and then fill the piece of data.
 */
template &lt;typename T&gt;
inline void
loadHelper(std::istream &amp; stream, UniqueStorage&lt;T&gt; &amp; data, void * context)
{
  std::size_t size;
  dataLoad(stream, size, nullptr);
  data.resize(size);

  for (const auto i : index_range(data))
    loadHelper(stream, data.pointerValue(i), context);
}

void dataLoad(std::istream &amp; stream, Point &amp; p, void * context);

#ifndef TIMPI_HAVE_STRING_PACKING
/**
 * The following methods are specializations for using the libMesh::Parallel::packed_range_*
 * routines
 * for std::strings. These are here because the dataLoad/dataStore routines create raw string
 * buffers that can be communicated in a standard way using packed ranges.
 */
namespace libMesh
{
namespace Parallel
{
template &lt;typename T&gt;
class Packing&lt;std::basic_string&lt;T&gt;&gt;
{
public:
  static const unsigned int size_bytes = 4;

  typedef T buffer_type;

  static unsigned int get_string_len(typename std::vector&lt;T&gt;::const_iterator in)
  {
    unsigned int string_len = reinterpret_cast&lt;const unsigned char &amp;&gt;(in[size_bytes - 1]);
    for (signed int i = size_bytes - 2; i &gt;= 0; --i)
    {
      string_len *= 256;
      string_len += reinterpret_cast&lt;const unsigned char &amp;&gt;(in[i]);
    }
    return string_len;
  }

  static unsigned int packed_size(typename std::vector&lt;T&gt;::const_iterator in)
  {
    return get_string_len(in) + size_bytes;
  }

  static unsigned int packable_size(const std::basic_string&lt;T&gt; &amp; s, const void *)
  {
    return s.size() + size_bytes;
  }

  template &lt;typename Iter&gt;
  static void pack(const std::basic_string&lt;T&gt; &amp; b, Iter data_out, const void *)
  {
    unsigned int string_len = b.size();
    for (unsigned int i = 0; i != size_bytes; ++i)
    {
      *data_out++ = (string_len % 256);
      string_len /= 256;
    }

    std::copy(b.begin(), b.end(), data_out);
  }

  static std::basic_string&lt;T&gt; unpack(typename std::vector&lt;T&gt;::const_iterator in, void *)
  {
    unsigned int string_len = get_string_len(in);

    std::ostringstream oss;
    for (unsigned int i = 0; i &lt; string_len; ++i)
      oss &lt;&lt; reinterpret_cast&lt;const unsigned char &amp;&gt;(in[i + size_bytes]);

    in += size_bytes + string_len;

    return oss.str();
  }
};

} // namespace Parallel

} // namespace libMesh

#endif
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
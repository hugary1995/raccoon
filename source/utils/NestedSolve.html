<!DOCTYPE html><head><meta charset="UTF-8"><title>NestedSolve | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="8af58dec-12be-4f92-9718-57a2619c7632" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="439446f1-c13b-4c6a-9c1e-48c7cc319f44" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8a12fd83-3ee6-42fa-922b-b1fa72b649f2" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="54b0bfe0-ce1f-4a15-90a7-84d72c79af62" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="b285c6b6-5d54-49f9-972a-f721f13a2018"><i class="material-icons">menu</i></a><ul class="sidenav" id="b285c6b6-5d54-49f9-972a-f721f13a2018"><li><a href="#!" class="dropdown-trigger" data-target="1391008b-6fd8-4368-b5ed-af53bc677cfc" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="c89f136c-8fbf-43ec-bfd1-054723892efa" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="80784d7d-71a4-40bf-95e4-551f665db4a8" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="369b4a78-3740-4644-9cad-68d2a3337bb2" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="8af58dec-12be-4f92-9718-57a2619c7632"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="439446f1-c13b-4c6a-9c1e-48c7cc319f44"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="8a12fd83-3ee6-42fa-922b-b1fa72b649f2"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="54b0bfe0-ce1f-4a15-90a7-84d72c79af62"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="1391008b-6fd8-4368-b5ed-af53bc677cfc"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="c89f136c-8fbf-43ec-bfd1-054723892efa"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="80784d7d-71a4-40bf-95e4-551f665db4a8"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="369b4a78-3740-4644-9cad-68d2a3337bb2"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="e394f94f-bc5e-44b3-914f-d3e5a88075a9" data-section-level="1" data-section-text="NestedSolve"><h1 id="nestedsolve">NestedSolve</h1><section id="6ebb87f2-16aa-4546-afde-bd5d8913fb2f" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p>The <code>NestedSolve</code> utility class implements a nonlinear solve for NxN systems. It can be used in Kernels, Materials, and UserObjects to compute quantities given by the solution of a nonlinear equation system rather than a closed form expression.</p><p>Such a nonlinear equation system is defined by a residual function and a Jacobian function. These functions are provided as C++11 lambda expression. A lambda expression can access all local and member variables from the enclosing scope. In this application that mainly refers to coupled variable values and material properties available in the class the NestedSolve is utilized.</p><section id="8e1aa804-d6b0-4930-8d14-89f641ce0d63" data-section-level="3" data-section-text="Basic API"><h3 id="basic-api">Basic API</h3><p><code>NestedSolve</code> is a C++ class object needs to be instantiated (constructed) to set up a solver environment. This solver environment can be a local or member variable of the object it is used within.</p><p>The purpose of the solve environment is to store <em>solver options</em>, such as tolerances, and <em>solver state</em>, such as convergence reason or failure state of the previous solve. A solve environment can be reused for multiple solves.</p><p>The main API of <code>NestedSolve</code> is the <code>nonlinear</code> member function, which exists in two flavors:</p><ol class="browser-default" start="1"><li><p><code>NestedSolve::nonlinear(T &amp; guess, L compute)</code>, which takes a writable reference to a variable if type <code>T</code> that contains an initial guess for the solution going into the function, and the solution once the call completes. <code>compute</code> is a lambda expression that takes references to the current solution value, the residual, and the Jacobian, and needs to update the latter two. </p></li><li><p><code>NestedSolve::nonlinear(T &amp; guess, LR computeResidual, LJ computeJacobian)</code> behaves largely similar to the first overload, but it takes two separate lambdas for computing the residual and the Jacobian independently. This enables the efficient use of line search and trust region algorithms internally.</p></li></ol></section><section id="b985fe91-0e21-4020-9958-75ebb267310b" data-section-level="3" data-section-text="Supported data types"><h3 id="supported-data-types">Supported data types</h3><p>The recommended data types for the solution/residual (<code>T</code>) and Jacobian are Eigen&#x27;s dynamic size Matrix objects. the <code>NestedSolve::Value&lt;&gt;</code> and <code>NestedSolve::Jacobian&lt;&gt;</code> typedefs are available as shortcuts for those types.</p><p>Specializations and overloads exist for the <code>nonlinear</code> solve API to deal with the special cases of 1x1 systems (with the solution,residual, and Jacobians being <code>Real</code> scalars), and for 3x3 systems (with the solution and residual being <code>RealVectorValues</code> and Jacobians being <code>RankTwoTensor</code> values). The correct overload is picked based on the type <code>T</code> of the initial <code>guess</code> parameter.</p></section><section id="db2d7ea3-fc65-427c-9270-9cd5e2b604e9" data-section-level="3" data-section-text="Checking convergence state"><h3 id="checking-convergence-state">Checking convergence state</h3><p>The state of a solve can be checked using the <code>getSolve()</code> method. This returns an enumeration describing how the solve converged or if it did not converge. The enumeration can take the following values:</p><ul class="browser-default"><li><p><code>NestedSolve::State::NONE</code>: No solve has begun. This is the initial value. </p></li><li><p><code>NestedSolve::State::CONVERGED_ABS</code>: The solve converged due to meeting an absolute tolerance. </p></li><li><p><code>NestedSolve::State::CONVERGED_REL</code>: The solve converged due to meeting a relative tolerance. </p></li><li><p><code>NestedSolve::State::EXACT_GUESS</code>: The solve converged due to the initial guess giving a zero residual. </p></li><li><p><code>NestedSolve::State::NOT_CONVERGED</code>: The solve did not converge.</p></li></ul><p>Note that in the case that both the absolute and relative tolerances being met simultaneously, the value <code>NestedSolve::State::CONVERGED_REL</code> will be returned.</p></section></section><section id="a2e5be2e-1263-42e1-8397-b33af8e26971" data-section-level="2" data-section-text="Example"><h2 id="example">Example</h2><section id="71e859c3-bb65-4aa9-b8d9-d0901b54dad8" data-section-level="3" data-section-text="Basic usage"><h3 id="basic-usage">Basic usage</h3><p>We first construct a <code>NestedSolve</code> object. This object can be reused for multiple solves, and could be a member of the class you are using it in.</p><pre style="max-height:350px;"><code class="language-text">
NestedSolve solver;
</code></pre><p>Next we set the solution (vector) type. <code>NestedSolve::Value&lt;&gt;</code> is a dynamically sized vector class from the Eigen library. Eigen uses the <code>&lt;&lt;</code> operator to initialize such a vector (two components in this case).</p><pre style="max-height:350px;"><code class="language-text">
NestedSolve::Value&lt;&gt; solution(2);
solution &lt;&lt; 1.98, 1.02;
</code></pre><p>Next we set a custom relative tolerance. The default value here is 1e-8.</p><pre style="max-height:350px;"><code class="language-text">
solver.setRelativeTolerance(1e-10);
</code></pre><p>Next we define the residual and Jacobian functions. Here we use a single lambda with three arguments:</p><ol class="browser-default" start="1"><li><p>The first argument is the current guess for the solution and is the _input_ to the functions, it is a vector of length N (or a scalar). </p></li><li><p>Argument two is a writable reference to the residual vector (of the same size as the current guess), the value of which is to be calculated by the lambda. </p></li><li><p>This is followed by the Jacobian matrix of the system, the derivative of the residual vector with respect to the guess/solution.</p></li></ol><pre style="max-height:350px;"><code class="language-text">
auto compute = [&amp;](const NestedSolve::Value&lt;&gt; &amp; guess,
                   NestedSolve::Value&lt;&gt; &amp; residual,
                   NestedSolve::Jacobian&lt;&gt; &amp; jacobian) {
  residual(0) = guess(0) + guess(0) * guess(1) - 4;
  residual(1) = guess(0) + guess(1) - 3;

  jacobian(0, 0) = 1 + guess(1);
  jacobian(0, 1) = guess(0);
  jacobian(1, 0) = 1;
  jacobian(1, 1) = 1;
};
</code></pre><p>Note that <code>jacobian(i,j)</code> is the derivative of <code>residual(i)</code> with respect to <code>guess(j)</code>.</p><p>Lastly we pass the initial guess along with the residual/Jacobian <code>compute</code> lambda to the <code>NestedSolve::nonlinear</code> method.</p><pre style="max-height:350px;"><code class="language-text">
solver.nonlinear(solution, compute);
</code></pre><p><code>solution</code> will now be updated from the initial guess to the actual solution of the system.</p><p>Then to check that the solve was successful, one can do the following:</p><pre style="max-height:350px;"><code class="language-text">
if (solver.getState() == NestedSolve::State::NOT_CONVERGED)
{
  // Take some action for the case of no convergence.
}
</code></pre></section><section id="e1b318ed-28f7-4f55-bf72-9adaccc09826" data-section-level="3" data-section-text="Powell ' s Dogleg method solver"><h3 id="powell-s-dogleg-method-solver">Powell&#x27;s Dogleg method solver</h3><p>While the previous example used a single lambda to compute residual and Jacobian at the same time, we can instead change the code to have separate lambdas to allow independent calculation of residual and Jacobian. This facilitates the use of solver methods that evaluate the residual more frequently than the Jacobian, such as line search and trust region strategies.</p><pre style="max-height:350px;"><code class="language-text">
auto computeResidual = [&amp;](const NestedSolve::Value&lt;&gt; &amp; guess,
                           NestedSolve::Value&lt;&gt; &amp; residual) {
  residual(0) = guess(0) + guess(0) * guess(1) - 4;
  residual(1) = guess(0) + guess(1) - 3;
};

auto computeJacobian = [&amp;](const NestedSolve::Value&lt;&gt; &amp; guess,
                           NestedSolve::Jacobian&lt;&gt; &amp; jacobian) {
  jacobian(0, 0) = 1 + guess(1);
  jacobian(0, 1) = guess(0);
  jacobian(1, 0) = 1;
  jacobian(1, 1) = 1;
};
</code></pre><p>We then use the three argument version of the <code>nonlinear</code> method</p><pre style="max-height:350px;"><code class="language-text">
solver.nonlinear(solution, computeResidual, computeJacobian);
</code></pre></section></section></section></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
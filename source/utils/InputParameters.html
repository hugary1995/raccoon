<!DOCTYPE html><head><meta charset="UTF-8"><title>InputParameters | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="bb3dd3b1-6371-4776-82e1-95bc1d8b258f" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="78db2040-64c8-4041-8842-618ac54f4f91" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8e5f5c53-3251-43bf-bd77-efa491728124" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ebad9561-280d-4b9d-be4d-2dcadfe4e3de" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="09d2b3d4-2bf5-436c-8abf-93300f865891"><i class="material-icons">menu</i></a><ul class="sidenav" id="09d2b3d4-2bf5-436c-8abf-93300f865891"><li><a href="#!" class="dropdown-trigger" data-target="591f930f-4aae-48d6-86a8-5dbc1775ef90" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="a16f5656-ff57-4b03-9df7-5bd77fe14a80" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9ffcd5e6-f749-48f4-a761-2425004a8979" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="7aaf9687-5bd1-4500-a511-accef7a1b84d" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="bb3dd3b1-6371-4776-82e1-95bc1d8b258f"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="78db2040-64c8-4041-8842-618ac54f4f91"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="8e5f5c53-3251-43bf-bd77-efa491728124"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="ebad9561-280d-4b9d-be4d-2dcadfe4e3de"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="591f930f-4aae-48d6-86a8-5dbc1775ef90"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="a16f5656-ff57-4b03-9df7-5bd77fe14a80"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="9ffcd5e6-f749-48f4-a761-2425004a8979"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="7aaf9687-5bd1-4500-a511-accef7a1b84d"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="ab32b088-84c1-4f44-86e3-2fcea7fcc705" data-section-level="1" data-section-text="InputParameters"><h1 id="inputparameters">InputParameters</h1><p>To simplify and unify the creation of all simulation objects in MOOSE, all input parameters must be declared and populated through a single &quot;InputParameters&quot; object. This ensures that every constructor in MOOSE is uniform and ensures that every object can be created through MOOSE&#x27;s Factory pattern. The InputParameters object is a collection of parameters, each one with separate attributes that can be used to finely control the behavior of the underlying object. For example, parameters can be marked as required or optional, be provided with a default or not, and be used to enhance GUI interfaces that may be used to programmatically generate input files for MOOSE.</p><p>The complete list of attributes for each input parameter:</p><pre style="max-height:350px;"><code class="language-cpp">  struct Metadata
  {
    std::string _doc_string;
    /// The developer-designated unit of the parameter for use in documentation
    std::string _doc_unit;
    /// The custom type that will be printed in the YAML dump for a parameter if supplied
    std::string _custom_type;
    /// The data pertaining to a command line parameter (empty if not a command line param)
    std::optional&lt;CommandLineMetadata&gt; _cl_data;
    /// The searched path information pertaining to a DataFileName parameter
    std::optional&lt;Moose::DataFileUtils::Path&gt; _data_file_name_path;
    /// The names of the parameters organized into groups
    std::string _group;
    /// The map of functions used for range checked parameters
    std::string _range_function;
    /// directions for auto build vectors (base_, 5) -&gt; &quot;base_0 base_1 base_2 base_3 base_4&quot;)
    std::pair&lt;std::string, std::string&gt; _autobuild_vecs;
    /// True for parameters that are required (i.e. will cause an abort if not supplied)
    bool _required = false;
    /**
     * Whether the parameter is either explicitly set or provided a default value when added
     * Note: We do not store MooseEnum names in valid params, instead we ask MooseEnums whether
     *       they are valid or not.
     */
    bool _valid = false;
    /// The set of parameters that will NOT appear in the the dump of the parser tree
    bool _is_private = false;
    bool _have_coupled_default = false;
    /// The default value for optionally coupled variables
    std::vector&lt;Real&gt; _coupled_default = {0};
    /// True if a parameters value was set by addParam, and not set again.
    bool _set_by_add_param = false;
    /// The reserved option names for a parameter
    std::set&lt;std::string&gt; _reserved_values;
    /// If non-empty, this parameter is deprecated.
    std::string _deprecation_message;
    /// Original location of parameter node; used for error messages
    const hit::Node * _hit_node;
    /// True if the parameters is controllable
    bool _controllable = false;
    /// Controllable execute flag restriction
    std::set&lt;ExecFlagType&gt; _controllable_flags;
    /// whether user setting of this parameter should be ignored
    bool _ignore = false;
  };
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#21508fda-da63-48dc-91d6-a23b9e65def9">(moose/framework/include/utils/InputParameters.h)</a><section id="d35aad2d-1ff0-4f45-ba26-f511cea3d1ce" data-section-level="2" data-section-text="Applying or Transferring Common Parameters"><h2 id="applying-or-transferring-common-parameters">Applying or Transferring Common Parameters</h2><p>When building a custom Action, it is often useful to read in several parameters that will be used to directly set parameters on objects being built by the custom Action. The <code>InputParameters</code> object contains a few useful methods for applying or transferring common parameters to avoid several manual lines for setting these parameters. See the utility methods and corresponding documentation here:</p><pre style="max-height:350px;"><code class="language-cpp">  // BEGIN APPLY PARAMETER METHODS
  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param exclude A vector of parameters to exclude
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must be valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private (unless \p allow_private = true)
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applyParameters(const InputParameters &amp; common,
                       const std::vector&lt;std::string&gt; &amp; exclude = {},
                       const bool allow_private = false);

  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param include A vector of parameters to apply
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applySpecificParameters(const InputParameters &amp; common,
                               const std::vector&lt;std::string&gt; &amp; include,
                               bool allow_private = false);

  /**
   * Apply values from a single parameter in common, to a single parameter stored in this object
   * @param common The set of InputParameters from which to extract parameters from
   * @param common_name The name within common from which to get the parameter values
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (except if override_default is set)
   *   (4) Both cannot be private
   */
  void applyParameter(const InputParameters &amp; common,
                      const std::string &amp; common_name,
                      bool allow_private = false,
                      bool override_default = false);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#d93b5d68-61cc-41de-9cd5-7e809ba16057">(moose/framework/include/utils/InputParameters.h)</a></section><section id="6660947c-0c6a-428b-910e-de606d795fc8" data-section-level="2" data-section-text="Range Checked Parameters"><h2 id="range-checked-parameters">Range Checked Parameters</h2><p>The InputParameters object supports parsed expressions for various bounds checking of the user input so that custom logic does not need to be implemented in every end-user object. The range checking expression is always the second to last parameter right before the doc string.</p><pre style="max-height:350px;"><code class="language-cpp">  // BEGIN RANGE CHECKED PARAMETER METHODS
  /**
   * These methods add an range checked parameters. A lower and upper bound can be supplied and the
   * supplied parameter will be checked to fall within that range.
   */
  template &lt;typename T&gt;
  void addRequiredRangeCheckedParam(const std::string &amp; name,
                                    const std::string &amp; parsed_function,
                                    const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const T &amp; value,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#a276b890-7b18-4a0b-b644-1f1be27dee36">(moose/framework/include/utils/InputParameters.h)</a></section><section id="46d47de9-e138-492c-a14e-3308328f5a23" data-section-level="2" data-section-text="Deprecating coupled variables"><h2 id="deprecating-coupled-variables">Deprecating coupled variables</h2><p>The <code>InputParameters</code> class provides a convenient method for deprecating coupled variable names called <code>addDeprecatedCoupledVar</code>. The method takes three arguments. The first corresponds to the deprecated name; the second argument is the new, blessed name that users should use. This name should have a corresponding <code>params.addCoupledVar(&#x27;blessed_name&#x27;, &#x27;blessed_name_doc_string&#x27;)</code> in the relevant <code>Class::validParams()</code> block. The final optional argument is the date that the deprecated variable name will be removed. </p></section></section><div class="moose-modal modal" id="21508fda-da63-48dc-91d6-a23b9e65def9"><div class="modal-content"><h4>(moose/framework/include/utils/InputParameters.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

// MOOSE includes
#include &quot;MooseUtils.h&quot;
#include &quot;MooseError.h&quot;
#include &quot;MooseTypes.h&quot;
#include &quot;MultiMooseEnum.h&quot;
#include &quot;ExecFlagEnum.h&quot;
#include &quot;Conversion.h&quot;
#include &quot;DataFileUtils.h&quot;
#include &quot;MoosePassKey.h&quot;

#include &quot;libmesh/parameters.h&quot;

#ifdef LIBMESH_HAVE_FPARSER
#include &quot;libmesh/fparser.hh&quot;
#else
template &lt;typename T&gt;
class FunctionParserBase
{
}
#endif

#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;mutex&gt;
#include &lt;optional&gt;
#include &lt;filesystem&gt;
#include &lt;regex&gt;

#include &lt;gtest/gtest.h&gt;

// Forward declarations
class Action;
class ActionFactory;
class Factory;
class FEProblemBase;
class InputParameters;
class MooseEnum;
class MooseObject;
class MultiMooseEnum;
class Problem;
namespace hit
{
class Node;
}
namespace Moose
{
class Builder;
}
class CommandLine;

/**
 * The main MOOSE class responsible for handling user-defined
 * parameters in almost every MOOSE system.
 */
class InputParameters : public libMesh::Parameters
{
public:
  InputParameters(const InputParameters &amp; rhs);
  InputParameters(const Parameters &amp; rhs);

  virtual ~InputParameters() = default;

  virtual void clear() override;

  /**
   * Structure for storing information about a command line parameter
   */
  struct CommandLineMetadata
  {
    enum ArgumentType
    {
      NONE,
      OPTIONAL,
      REQUIRED
    };

    /// The syntax for the parameter
    std::string syntax;
    /// The switches for the parameter (i.e., [-t, --timing])
    std::vector&lt;std::string&gt; switches;
    /// The type of argument
    ArgumentType argument_type;
    /// Whether or not the argument is required
    bool required;
    /// Whether or not the parameter was set by the CommandLine
    bool set_by_command_line = false;
    /// Whether or not the parameter is global (passed to MultiApps)
    bool global = false;
  };

  /**
   * Class that is used as a parameter to setHitNode() that allows only
   * relevant classes to set the hit node
   */
  class SetHitNodeKey
  {
    friend class Action;
    friend class ActionFactory;
    friend class Moose::Builder;
    friend class Factory;
    friend class FEProblemBase;
    friend class InputParameters;
    FRIEND_TEST(InputParametersTest, fileNames);
    SetHitNodeKey() {}
    SetHitNodeKey(const SetHitNodeKey &amp;) {}
  };

  /**
   * Class that is used as a parameter to setHitNode(param) that allows only
   * relevant classes to set the hit node
   */
  class SetParamHitNodeKey
  {
    friend class Moose::Builder;
    FRIEND_TEST(InputParametersTest, fileNames);
    SetParamHitNodeKey() {}
    SetParamHitNodeKey(const SetParamHitNodeKey &amp;) {}
  };

  /**
   * Determines whether or not the given type is a type that is supported for
   * a command line parameter.
   *
   * In particular, whether or not CommandLine::populateCommandLineParams
   * supports extracting these types.
   */
  template &lt;typename T&gt;
  struct isValidCommandLineType
  {
    static constexpr bool value =
        std::is_same_v&lt;T, std::string&gt; || std::is_same_v&lt;T, std::vector&lt;std::string&gt;&gt; ||
        std::is_same_v&lt;T, Real&gt; || std::is_same_v&lt;T, unsigned int&gt; || std::is_same_v&lt;T, int&gt; ||
        std::is_same_v&lt;T, bool&gt; || std::is_same_v&lt;T, MooseEnum&gt;;
  };

  /**
   * This method adds a description of the class that will be displayed
   * in the input file syntax dump
   */
  void addClassDescription(const std::string &amp; doc_string);

  /**
   * Returns the class description
   */
  std::string getClassDescription() const;

  /**
   * Override from libMesh to set user-defined attributes on our parameter
   */
  virtual void set_attributes(const std::string &amp; name, bool inserted_only) override;

  /**
   * @return The deprecated parameter message for the given parameter, if any
   */
  std::optional&lt;std::string&gt; queryDeprecatedParamMessage(const std::string &amp; name) const;

  /// This functions is called in set as a &#x27;callback&#x27; to avoid code duplication
  template &lt;typename T&gt;
  void setHelper(const std::string &amp; name);

  /**
   * Returns a writable reference to the named parameters.  Note: This is not a virtual
   * function! Use caution when comparing to the parent class implementation
   * @param name The name of the parameter to set
   * @param quiet_mode When true the parameter is kept with set_by_add_param=true,
   * this is generally not needed.
   *
   * &quot;quite_mode&quot; returns a writable reference to the named parameter, without setting
   * set_by_add_param to false. Using this method of set will make the parameter to continue to
   * behave if its value where set ONLY by addParam and not by any other method.
   *
   * This was added for handling parameters in the Output objects that have behavior dependent
   * on whether the user modified the parameters.
   *
   */
  template &lt;typename T&gt;
  T &amp; set(const std::string &amp; name, bool quiet_mode = false);

  /**
   * Given a series of parameters names and values, sets each name to
   * the corresponding value.  Any number of name, value pairs can be
   * supplied.
   *
   * Note that each \p value must be of the correct type for the
   * parameter of that name, not merely of a type convertible to the
   * correct type.
   *
   * @param name The name of the first parameter to set
   */
  template &lt;typename T, typename... Ts&gt;
  void setParameters(const std::string &amp; name, const T &amp; value, Ts... extra_input_parameters);

  /**
   * Runs a range on the supplied parameter if it exists and throws an error if that check fails.
   * @returns Optional of whether or not the error is a user error (false = developer error) and
   * the associated error
   *
   * If \p include_param_path = true, include the parameter path in the error message
   */
  ///@{
  template &lt;typename T, typename UP_T&gt;
  std::optional&lt;std::pair&lt;bool, std::string&gt;&gt;
  rangeCheck(const std::string &amp; full_name,
             const std::string &amp; short_name,
             const InputParameters::Parameter&lt;T&gt; &amp; param,
             const bool include_param_path = true);
  template &lt;typename T, typename UP_T&gt;
  std::optional&lt;std::pair&lt;bool, std::string&gt;&gt;
  rangeCheck(const std::string &amp; full_name,
             const std::string &amp; short_name,
             const InputParameters::Parameter&lt;std::vector&lt;T&gt;&gt; &amp; param,
             const bool include_param_path = true);
  ///@}
  /**
   * Verifies that the requested parameter exists and is not NULL and returns it to the caller.
   * The template parameter must be a pointer or an error will be thrown.
   */
  template &lt;typename T&gt;
  T getCheckedPointerParam(const std::string &amp; name, const std::string &amp; error_string = &quot;&quot;) const;

  /**
   * This method adds a parameter and documentation string to the InputParameters
   * object that will be extracted from the input file.  If the parameter is
   * missing in the input file, an error will be thrown
   */
  template &lt;typename T&gt;
  void addRequiredParam(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * This version of addRequiredParam is here for a consistent use with MooseEnums.  Use of
   * this function for any other type will throw an error.
   */
  template &lt;typename T&gt;
  void
  addRequiredParam(const std::string &amp; name, const T &amp; moose_enum, const std::string &amp; doc_string);

  ///@{
  /**
   * These methods add an optional parameter and a documentation string to the InputParameters
   * object. The first version of this function takes a default value which is used if the parameter
   * is not found in the input file. The second method will leave the parameter uninitialized but
   * can be checked with &quot;isParamValid&quot; before use.
   */
  template &lt;typename T, typename S&gt;
  void addParam(const std::string &amp; name, const S &amp; value, const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addParam(const std::string &amp; name, const std::string &amp; doc_string);
  ///@}

  /**
   * Enable support for initializer lists as default arguments for container type.
   */
  template &lt;typename T&gt;
  void addParam(const std::string &amp; name,
                const std::initializer_list&lt;typename T::value_type&gt; &amp; value,
                const std::string &amp; doc_string)
  {
    addParam&lt;T&gt;(name, T{value}, doc_string);
  }

  ///@{
  // BEGIN RANGE CHECKED PARAMETER METHODS
  /**
   * These methods add an range checked parameters. A lower and upper bound can be supplied and the
   * supplied parameter will be checked to fall within that range.
   */
  template &lt;typename T&gt;
  void addRequiredRangeCheckedParam(const std::string &amp; name,
                                    const std::string &amp; parsed_function,
                                    const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const T &amp; value,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  // END RANGE CHECKED PARAMETER METHODS
  ///@}

  /**
   * These methods add an option parameter and with a customer type to the InputParameters object.
   * The custom type will be output in YAML dumps and can be used within the GUI application.
   */
  template &lt;typename T&gt;
  void addRequiredCustomTypeParam(const std::string &amp; name,
                                  const std::string &amp; custom_type,
                                  const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCustomTypeParam(const std::string &amp; name,
                          const T &amp; value,
                          const std::string &amp; custom_type,
                          const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCustomTypeParam(const std::string &amp; name,
                          const std::string &amp; custom_type,
                          const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addDeprecatedCustomTypeParam(const std::string &amp; name,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_msg);

  /**
   * These method add a parameter to the InputParameters object which can be retrieved like any
   * other parameter. This parameter however is not printed in the Input file syntax dump or web
   * page dump so does not take a documentation string.  The first version of this function takes an
   * optional default value.
   */
  template &lt;typename T&gt;
  void addPrivateParam(const std::string &amp; name, const T &amp; value);
  template &lt;typename T&gt;
  void addPrivateParam(const std::string &amp; name);

  /**
   * Add parameters for retrieval from the command line.
   *
   * NOTE: This ONLY works for App objects!  This is not valid for normal MOOSE objects!
   *
   * @param name The name of the parameter
   * @param syntax Space separated list of command-line switch syntax that can set this option
   * @param doc_string Documentation.  This will be shown for --help
   */
  template &lt;typename T&gt;
  void addRequiredCommandLineParam(const std::string &amp; name,
                                   const std::string &amp; syntax,
                                   const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const T &amp; value,
                           const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const std::initializer_list&lt;typename T::value_type&gt; &amp; value,
                           const std::string &amp; doc_string)
  {
    addCommandLineParam&lt;T&gt;(name, syntax, T{value}, doc_string);
  }

  /**
   * Add a command line parameter with an optional value.
   *
   * This is a deprecated option and only remains for two parameters:
   * &quot;mesh_only&quot; and &quot;recover&quot;. There are issues with command line
   * parameters with optional values because if a value following
   * one of these is a hit cli parameter, we don&#x27;t know if we should
   * apply it to the optional option or as a hit parameter.
   *
   * It is also allowed for &quot;run&quot; as we take all arguments past
   * --run and pass to python.
   *
   * @param name The name of the parameer
   * @param syntax Space separated list of command-line switch syntax that can set this option
   * @param value The default value to assign
   * @param doc_string Documentation.  This will be shown for --help
   */
  template &lt;typename T&gt;
  void addOptionalValuedCommandLineParam(const std::string &amp; name,
                                         const std::string &amp; syntax,
                                         const T &amp; value,
                                         const std::string &amp; doc_string);

  /**
   * Sets the command line parameter with \p name as global.
   *
   * Global here means that it will be passed to all child MultiApps.
   */
  void setGlobalCommandLineParam(const std::string &amp; name);

  /**
   * @param name The name of the parameter
   * @param value The default value of this parameter if it requires one
   * @param doc_string Documentation.  This will be shown for --help
   * @param deprecation_message The message that will will print about why this param was
   * deprecated.  It might mention the &quot;new way&quot;.
   */
  template &lt;typename T&gt;
  void addDeprecatedParam(const std::string &amp; name,
                          const T &amp; value,
                          const std::string &amp; doc_string,
                          const std::string &amp; deprecation_message);

  template &lt;typename T&gt;
  void addDeprecatedParam(const std::string &amp; name,
                          const std::string &amp; doc_string,
                          const std::string &amp; deprecation_message);

  /**
   * This method checks to make sure that we aren&#x27;t adding a parameter with the same name but a
   * different type.  It
   * throws a MooseError if an inconsistent type is detected. While this state is supported by
   * libMesh it brings
   * nothing but blood and tears for those who try ;)
   *
   * @param name the name of the parameter
   */
  template &lt;typename T&gt;
  void checkConsistentType(const std::string &amp; name) const;

  /**
   * @return Whether or not the parameter \p name is a command line parameter
   */
  bool isCommandLineParameter(const std::string &amp; name) const;

  /**
   * @return Queries for the command line metadata for the parameter \p name
   *
   * Will return an empty optional if the parameter is not a command line param.
   */
  std::optional&lt;InputParameters::CommandLineMetadata&gt;
  queryCommandLineMetadata(const std::string &amp; name) const;

  /**
   * @return The command line metadata for the parameter \p name.
   */
  const InputParameters::CommandLineMetadata &amp;
  getCommandLineMetadata(const std::string &amp; name) const;

  /**
   * Class that is used as a parameter to commandLineParamSet() that allows only
   * the CommandLine to set that a parmeter is set by the command line
   */
  class CommandLineParamSetKey
  {
    friend class CommandLine;
    FRIEND_TEST(InputParametersTest, commandLineParamSetNotCLParam);
    CommandLineParamSetKey() {}
    CommandLineParamSetKey(const CommandLineParamSetKey &amp;) {}
  };
  /**
   * Marks the command line parameter \p name as set by the CommandLine.
   *
   * Protected by the CommandLineParamSetKey so that only the CommandLine can call this.
   */
  void commandLineParamSet(const std::string &amp; name, const CommandLineParamSetKey);

  /**
   * Get the documentation string for a parameter
   */
  const std::string &amp; getDescription(const std::string &amp; name) const;

  /**
   * This method takes a space delimited list of parameter names and adds them to the specified
   * group name.
   * This information is used in the GUI to group parameters into logical sections.
   */
  void addParamNamesToGroup(const std::string &amp; space_delim_names, const std::string group_name);

  /**
   * This method renames a parameter group
   * @param old_name previous name of the parameter group
   * @param new_name new name of the parameter group
   */
  void renameParameterGroup(const std::string &amp; old_name, const std::string &amp; new_name);

  /**
   * This method retrieves the group name for the passed parameter name if one exists.  Otherwise an
   * empty string is returned.
   */
  std::string getGroupName(const std::string &amp; param_name) const;

  /**
   * This method suppresses an inherited parameter so that it isn&#x27;t required or valid
   * in the derived class. The parameter is added to the private parameter list.
   * Suppressing a parameter can have dire consequences.
   * Use at your own risk!
   */
  template &lt;typename T&gt;
  void suppressParameter(const std::string &amp; name);

  /**
   * Changes the parameter to be required.
   * @param name The parameter name
   */
  template &lt;typename T&gt;
  void makeParamRequired(const std::string &amp; name);

  /**
   * Changes the parameter to not be required.
   * @param name The parameter name
   */
  template &lt;typename T&gt;
  void makeParamNotRequired(const std::string &amp; name);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   */
  void addCoupledVar(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * This method adds a deprecated coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found. The doc string for the deprecated variable will be
   * constructed from the doc string for the new variable. A deprecation message will also be
   * automatically generated
   */
  void addDeprecatedCoupledVar(const std::string &amp; old_name,
                               const std::string &amp; new_name,
                               const std::string &amp; removal_date = &quot;&quot;);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   *
   * Also - you can provide a default value for this variable in the case that an actual variable is
   * not provided.
   */
  void addCoupledVar(const std::string &amp; name, const Real value, const std::string &amp; doc_string);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   *
   * Also - you can provide a vector of values for this variable in the case that an actual variable
   * is not provided.
   */
  void addCoupledVar(const std::string &amp; name,
                     const std::vector&lt;Real&gt; &amp; value,
                     const std::string &amp; doc_string);

  ///@{
  /**
   * These methods add a coupled variable name pair. The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found.
   *
   * This version of the method will build a vector if the given the base_name and num_name
   * parameters exist
   * in the input file:
   *   e.g.
   *   [./foo]
   *     ...
   *     some_base = base_
   *     some_num  = 5
   *   [../]
   *
   *   # The coupling parameter will be passed this vector: &quot;base_0 base_1 base_2 base_3 base_4&quot;
   */
  void addCoupledVarWithAutoBuild(const std::string &amp; name,
                                  const std::string &amp; base_name,
                                  const std::string &amp; num_name,
                                  const std::string &amp; doc_string);
  void addRequiredCoupledVarWithAutoBuild(const std::string &amp; name,
                                          const std::string &amp; base_name,
                                          const std::string &amp; num_name,
                                          const std::string &amp; doc_string);
  ///@}

  /**
   * Utility functions for retrieving one of the MooseTypes variables into the common &quot;string&quot; base
   * class.
   * Scalar and Vector versions are supplied
   */
  std::string getMooseType(const std::string &amp; name) const;
  std::vector&lt;std::string&gt; getVecMooseType(const std::string &amp; name) const;

  /**
   * @returns Whether or not these parameters are for a MooseBase object, that is,
   * one with a name and type.
   *
   * Needed so that we can produce richer errors from within InputParameters
   * that have the context of the underlying object, if possible.
   */
  bool isMooseBaseObject() const;

  /**
   * @return The object type represented by these parameters, if any
   */
  const std::string * queryObjectType() const;

  /**
   * @returns The underlying owning object type, for MooseBase objects with parameters
   *
   * Will error if a type does not exist
   */
  const std::string &amp; getObjectType() const;
  /**
   * @returns The underlying owning object name, for MooseBase objects with parameters
   */
  const std::string &amp; getObjectName() const;

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable.  If the coupled variable is not supplied in the input
   * file, and error is thrown.
   *
   * Version 2: An auto built vector will be built from the base_name and num_name param. See
   * addCoupledVar for an example
   */
  void addRequiredCoupledVar(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * Returns the documentation string for the specified parameter name
   */
  std::string getDocString(const std::string &amp; name) const;

  /**
   * Set the doc string of a parameter.
   *
   * This method is generally used from within the validParams function to modify the documentation
   * for an
   * existing parameter, such as a parameter that is supplied from an interface class.
   */
  void setDocString(const std::string &amp; name, const std::string &amp; doc);

  /**
   * Returns the documentation unit string for the specified parameter name
   */
  std::string getDocUnit(const std::string &amp; name) const;

  /**
   * Set the unit string of a parameter.
   *
   * This method is only used within MooseDocs and the input syntax dump in order to provide a
   * developer-expected unit for software quality assurance purposes.
   */
  void setDocUnit(const std::string &amp; name, const std::string &amp; doc_unit);

  /**
   * Returns a boolean indicating whether the specified parameter is required or not
   */
  bool isParamRequired(const std::string &amp; name) const;

  /**
   * Forces parameter of given name to be not required regardless of type
   */
  void makeParamNotRequired(const std::string &amp; name);

  /**
   * This method returns parameters that have been initialized in one fashion or another,
   * i.e. The value was supplied as a default argument or read and properly converted from
   * the input file
   */
  bool isParamValid(const std::string &amp; name) const;

  /**
   * Returns whether or not the parameter was set due to addParam. If not then it was either set
   * programmatically
   * or was read through the input file.
   */
  bool isParamSetByAddParam(const std::string &amp; name) const;

  /**
   * Returns True if the parameters is deprecated.
   */
  bool isParamDeprecated(const std::string &amp; name) const;

  /**
   * This method returns true if all of the parameters in this object are valid
   * (i.e. isParamValid(name) == true - for all parameters)
   */
  bool areAllRequiredParamsValid() const;

  /**
   * Prints the type of the requested parameter by name
   */
  std::string type(const std::string &amp; name) const;

  /**
   * Returns a Boolean indicating whether the specified parameter is private or not
   */
  bool isPrivate(const std::string &amp; name) const;

  /**
   * Declare the given parameters as controllable
   */
  void declareControllable(const std::string &amp; name, std::set&lt;ExecFlagType&gt; execute_flags = {});

  /**
   * Marker a parameter that has been changed by the Control system (this is for output purposes)
   */
  void markControlled(const std::string &amp; name);

  /**
   * Returns a Boolean indicating whether the specified parameter is controllable
   */
  bool isControllable(const std::string &amp; name) const;

  /**
   * Return the allowed execute flags for a controllable parameter
   */
  const std::set&lt;ExecFlagType&gt; &amp; getControllableExecuteOnTypes(const std::string &amp; name) const;

  /**
   * This method must be called from every base &quot;Moose System&quot; to create linkage with the Action
   * System.
   * See &quot;Moose.C&quot; for the registerMooseObjectTask() calls.
   */
  void registerBase(const std::string &amp; value);

  /**
   * @return Whether or not the object has a registered base
   *
   * The base is registered with registerBase()
   */
  bool hasBase() const;

  /**
   * @return The base system of the object these parameters are for, if any
   *
   * Set via registerBase().
   */
  const std::string &amp; getBase() const;

  /**
   * This method is used to define the MOOSE system name that is used by the TheWarehouse object
   * for storing objects to be retrieved for execution. The base class of every object class
   * that will be called for execution (e.g., UserObject objects) should call this method.
   *
   * This is different from registerBase because the name supplied to registerBase is used to
   * associate syntax, but the objects created often go to the same objects for execution, as is
   * the case for Postprocessor object which are executed with UserObjects.
   *
   * See the AttribSystem object for use Attribute.h/C.
   */
  void registerSystemAttributeName(const std::string &amp; value);

  /**
   * Get the system attribute name if it was registered. Otherwise throw an error.
   * See the AttribSystem object for use Attribute.h/C.
   */
  const std::string &amp; getSystemAttributeName() const;

  /**
   * This method is here to indicate which Moose types a particular Action may build. It takes a
   * space delimited list of registered MooseObjects.  TODO: For now we aren&#x27;t actually checking
   * this list when we build objects. Since individual actions can do whatever they want it&#x27;s not
   * exactly trivial to check this without changing the user API.  This function properly restricts
   * the syntax and YAML dumps.
   */
  void registerBuildableTypes(const std::string &amp; names);

  /**
   * Tells MOOSE about a RelationshipManager that this object needs.  RelationshipManagers
   * handle element &quot;ghosting&quot;, &quot;non-local DOF access&quot; and &quot;sparsity pattern&quot; relationships.
   *
   * Basically: if this object needs non-local (ie non-current-element) data access then you
   * probably need a relationship manager
   *
   * @param name The name of the RelationshipManager type
   * @param rm_type The type (GEOMETRIC/ALGEBRAIC) of the RelationshipManger.  Note: You can use
   * boolean logic to to &quot;or&quot; RelationshipManagerTypes together to make a RelationshipManager that
   * is multi-typed.
   * @param input_parameter_callback This is a function pointer that will get called to fill in the
   * RelationShipManager&#x27;s InputParameters.  See MooseTypes.h for the signature of this function.
   */
  void addRelationshipManager(
      const std::string &amp; name,
      Moose::RelationshipManagerType rm_type,
      Moose::RelationshipManagerInputParameterCallback input_parameter_callback = nullptr);

  /**
   * Clears all currently registered RelationshipManagers
   */
  void clearRelationshipManagers() { _buildable_rm_types.clear(); }

  /**
   * Returns the list of buildable types as a std::vector&lt;std::string&gt;
   */
  const std::vector&lt;std::string&gt; &amp; getBuildableTypes() const;

  /**
   * Returns the list of buildable (or required) RelationshipManager object types for this object.
   */
  const std::vector&lt;std::tuple&lt;std::string,
                               Moose::RelationshipManagerType,
                               Moose::RelationshipManagerInputParameterCallback&gt;&gt; &amp;
  getBuildableRelationshipManagerTypes() const;

  ///@{
  /**
   * Mutators for controlling whether or not the outermost level of syntax will be collapsed when
   * printed.
   */
  void collapseSyntaxNesting(bool collapse);
  bool collapseSyntaxNesting() const;
  ///@}

  ///@{
  /**
   * Mutators for controlling whether or not the outermost level of syntax will be collapsed when
   * printed.
   */
  void mooseObjectSyntaxVisibility(bool visibility);
  bool mooseObjectSyntaxVisibility() const;
  ///@}

  ///@{
  /**
   * Copy and Copy/Add operators for the InputParameters object
   */
  using Parameters::operator=;
  using Parameters::operator+=;
  InputParameters &amp; operator=(const InputParameters &amp; rhs);
  InputParameters &amp; operator+=(const InputParameters &amp; rhs);
  ///@}

  /**
   * This function checks parameters stored in the object to make sure they are in the correct
   * state as the user expects:
   *   Required parameters are verified as valid meaning that they were either initialized when
   *   they were created, or were read from an input file or some other valid source
   */
  void checkParams(const std::string &amp; parsing_syntax);

  /**
   * Performs a range check on the parameter (which must have a range check)
   *
   * @param value The parameter value
   * @param long_name The full path to the parameter
   * @param short_name The name of the parameter
   * @param include_param_path Whether or not to include the parameter path in errors
   * @return An error, if any; first is whether or not it is a user error and second is the message
   */
  std::optional&lt;std::pair&lt;bool, std::string&gt;&gt; parameterRangeCheck(const Parameters::Value &amp; value,
                                                                  const std::string &amp; long_name,
                                                                  const std::string &amp; short_name,
                                                                  const bool include_param_path);

  /**
   * Finalizes the parameters, which must be done before constructing any objects
   * with these parameters (to be called in the corresponding factories).
   * typed parameters.
   *
   * This calls checkParams() and sets up the absolute paths for all file name.
   */
  void finalize(const std::string &amp; parsing_syntax);

  /**
   * @return A file base to associate with these parameters.
   *
   * Optionally, an input parameter can be provided via \p param_name.
   *
   * If the parameter is provided, we have the following options:
   * - The parameter itself has a hit node set (context for that parameter)
   * - The InputParameters object has a hit node set (context for all parameters)
   * - Neither of the above and we die
   *
   * In the event that a the parameter is set via command line, this will
   * attempt to look at the parameter&#x27;s parents to find a suitable context.
   */
  std::filesystem::path
  getFileBase(const std::optional&lt;std::string&gt; &amp; param_name = std::optional&lt;std::string&gt;()) const;

  /**
   * Methods returning iterators to the coupled variables names stored in this
   * InputParameters object
   */
  inline std::set&lt;std::string&gt;::const_iterator coupledVarsBegin() const
  {
    return _coupled_vars.begin();
  }
  inline std::set&lt;std::string&gt;::const_iterator coupledVarsEnd() const
  {
    return _coupled_vars.end();
  }

  /**
   * Return the coupled variable parameter names.
   */
  const std::set&lt;std::string&gt; &amp; getCoupledVariableParamNames() const { return _coupled_vars; }

  /**
   * Return the new to deprecated variable name map
   */
  const std::unordered_map&lt;std::string, std::string&gt; &amp; getNewToDeprecatedVarMap() const
  {
    return _new_to_deprecated_coupled_vars;
  }

  /// Return whether a parameter has a range check
  bool isRangeChecked(const std::string &amp; param_name) const;

  /// Return the range check function for any parameter (empty string if it is not range checked)
  std::string rangeCheckedFunction(const std::string &amp; name) const;

  /// Return whether a parameter has a default
  bool hasDefault(const std::string &amp; param_name) const;

  /**
   * Return whether or not the coupled variable exists
   * @param coupling_name The name of the coupled variable to test for
   * @return True if the variable exists in the coupled variables for this InputParameters object
   */
  bool hasCoupledValue(const std::string &amp; coupling_name) const;

  /**
   * Return whether or not the requested parameter has a default coupled value.
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   */
  bool hasDefaultCoupledValue(const std::string &amp; coupling_name) const;

  /**
   * Get the default value for an optionally coupled variable.
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   * @param i By default 0, in general the index of the requested coupled default value.
   */
  Real defaultCoupledValue(const std::string &amp; coupling_name, unsigned int i = 0) const;

  /**
   * Get the number of defaulted coupled value entries
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   */
  unsigned int numberDefaultCoupledValues(const std::string &amp; coupling_name) const;

  /**
   * Set the default value for an optionally coupled variable (called by the Parser).
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   * @param value Default value to set.
   * @param i By default 0, in general the index of the requested coupled default value.
   */
  void defaultCoupledValue(const std::string &amp; coupling_name, Real value, unsigned int i = 0);

  /**
   * Returns the auto build vectors for all parameters.
   */
  std::map&lt;std::string, std::pair&lt;std::string, std::string&gt;&gt; getAutoBuildVectors() const;

  // BEGIN APPLY PARAMETER METHODS
  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param exclude A vector of parameters to exclude
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must be valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private (unless \p allow_private = true)
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applyParameters(const InputParameters &amp; common,
                       const std::vector&lt;std::string&gt; &amp; exclude = {},
                       const bool allow_private = false);

  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param include A vector of parameters to apply
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applySpecificParameters(const InputParameters &amp; common,
                               const std::vector&lt;std::string&gt; &amp; include,
                               bool allow_private = false);

  /**
   * Apply values from a single parameter in common, to a single parameter stored in this object
   * @param common The set of InputParameters from which to extract parameters from
   * @param common_name The name within common from which to get the parameter values
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (except if override_default is set)
   *   (4) Both cannot be private
   */
  void applyParameter(const InputParameters &amp; common,
                      const std::string &amp; common_name,
                      bool allow_private = false,
                      bool override_default = false);
  // END APPLY PARAMETER METHODS

  /**
   * Apply properties of a single coupled variable in common, to a single coupled variable stored in
   * this object
   * @param common The set of InputParameters from which to extract the coupled variable&#x27;s
   * properties
   * @param var_name The name of the coupled variable whose properties are to be applied
   *
   * In order to apply the properties, both the local parameters and the common parameters must
   * have a coupled variable with name var_name
   */
  void applyCoupledVar(const InputParameters &amp; common, const std::string &amp; var_name);

  /**
   * Deprecated method.  Use isParamSetByUser() instead.
   */
  bool paramSetByUser(const std::string &amp; name) const;

  /**
   * Method returns true if the parameter was set by the user
   * @param name The parameter name
   */
  bool isParamSetByUser(const std::string &amp; name) const;

  /**
   * Method returns true if the parameter is defined for any type. If the
   * type is known, use have_parameter&lt;T&gt;() instead.
   * @param name The parameter name
   */
  bool isParamDefined(const std::string &amp; name) const;

  ///@{
  /*
   * These methods are here to retrieve parameters for scalar and vector types respectively. We will
   * throw errors
   * when returning most scalar and vector types.
   */
  template &lt;typename T&gt;
  static const T &amp; getParamHelper(const std::string &amp; name, const InputParameters &amp; pars);
  ///@}

  using Parameters::get;

  /// Combine two vector parameters into a single vector of pairs
  template &lt;typename R1,
            typename R2,
            typename V1 = typename std::conditional&lt;std::is_same&lt;R1, MooseEnumItem&gt;::value,
                                                    MultiMooseEnum,
                                                    std::vector&lt;R1&gt;&gt;::type,
            typename V2 = typename std::conditional&lt;std::is_same&lt;R2, MooseEnumItem&gt;::value,
                                                    MultiMooseEnum,
                                                    std::vector&lt;R2&gt;&gt;::type&gt;
  std::vector&lt;std::pair&lt;R1, R2&gt;&gt; get(const std::string &amp; param1, const std::string &amp; param2) const;

  /**
   * @returns list of all parameters
   */
  std::set&lt;std::string&gt; getParametersList() const;

  /**
   * Return list of controllable parameters
   */
  std::set&lt;std::string&gt; getControllableParameters() const;

  /**
   * Return names of parameters within a group.
   */
  std::set&lt;std::string&gt; getGroupParameters(const std::string &amp; group) const;

  /**
   * Provide a set of reserved values for a parameter. These are values that are in addition
   * to the normal set of values the parameter can take.
   */
  void setReservedValues(const std::string &amp; name, const std::set&lt;std::string&gt; &amp; reserved);

  /**
   * Get a set of reserved parameter values.
   * Returns a set by value since we can return an empty set.
   */
  std::set&lt;std::string&gt; reservedValues(const std::string &amp; name) const;

  /**
   * @return A string representing the location (i.e. filename,linenum) in the input text for the
   * block containing parameters for this object.
   */
  std::string blockLocation() const;

  /**
   * @return A string representing the full HIT parameter path from the input file (e.g.
   * &quot;Mesh/foo&quot;) for the block containing parameters for this object.
   */
  std::string blockFullpath() const;

  /**
   * @return The hit node associated with setting the parameter \p param, if any
   */
  const hit::Node * getHitNode(const std::string &amp; param) const;
  /**
   * Sets the hit node associated with the parameter \p param to \p node
   *
   * Is protected to be called by only the Builder via the SetParamHitNodeKey.
   */
  void setHitNode(const std::string &amp; param, const hit::Node &amp; node, const SetParamHitNodeKey);

  /**
   * @return A string representing the location in the input text the parameter originated from
   * (i.e. filename,linenum) for the given param
   */
  std::string inputLocation(const std::string &amp; param) const;

  /**
   * @return A string representing the full HIT parameter path from the input file (e.g.
   * &quot;Mesh/foo/bar&quot; for param &quot;bar&quot;) for the given param.
   */
  std::string paramFullpath(const std::string &amp; param) const;

  /**
   * Returns a prefix containing the parameter name and location (if available)
   */
  std::string paramLocationPrefix(const std::string &amp; param) const;

  /**
   * @return A message used as a prefix for output relating to a parameter.
   *
   * Will first prefix with a path to the parameter, or the parameter that
   * resulted in the creation of these parameters, if available. The message
   * will then be prefixed with the block path to the parameter, if available.
   */
  template &lt;typename... Args&gt;
  std::string paramMessage(const std::string &amp; param, Args... args) const;

  /**
   * Emits an error prefixed with the object information, if available.
   */
  template &lt;typename... Args&gt;
  [[noreturn]] void mooseError(Args &amp;&amp;... args) const;

  /**
   * Emits a parameter error prefixed with the parameter location and
   * object information if available.
   */
  template &lt;typename... Args&gt;
  [[noreturn]] void paramError(const std::string &amp; param, Args... args) const;

  /**
   * @return A string representing the raw, unmodified token text for the given param.
   * This is only set if this parameter is parsed from hit
   */
  std::string rawParamVal(const std::string &amp; param) const;

  /**
   * Informs this object that values for this parameter set from the input file or from the command
   * line should be ignored
   */
  template &lt;typename T&gt;
  void ignoreParameter(const std::string &amp; name);

  /**
   * Whether to ignore the value of an input parameter set in the input file or from the command
   * line.
   */
  bool shouldIgnore(const std::string &amp; name);

  /**
   * @returns True if the parameter with name \p name is of type T.
   */
  template &lt;typename T&gt;
  bool isType(const std::string &amp; name) const;

  /**
   * Determine the actual variable name from the given variable \emph parameter name
   * @param var_param_name the name of the variable parameter, e.g. &#x27;variable&#x27;
   * @param moose_object_with_var_param_name the name of the moose object holding the variable
   * parameter. Used for potential error messaging
   */
  std::string varName(const std::string &amp; var_param_name,
                      const std::string &amp; moose_object_with_var_param_name) const;

  /**
   * Rename a parameter and provide a new documentation string
   * @param old_name The old name of the parameter
   * @param new_name The new name of the parameter
   * @param new_docstring The new documentation string for the parameter
   *                      If left empty, uses the old docstring for the renamed parameter
   */
  void renameParam(const std::string &amp; old_name,
                   const std::string &amp; new_name,
                   const std::string &amp; new_docstring);

  /**
   * Rename a coupled variable and provide a new documentation string
   * @param old_name The old name of the coupled variable
   * @param new_name The new name of the coupled variable
   * @param new_docstring The new documentation string for the coupled variable
   */
  void renameCoupledVar(const std::string &amp; old_name,
                        const std::string &amp; new_name,
                        const std::string &amp; new_docstring);

  void deprecateParam(const std::string &amp; old_name,
                      const std::string &amp; new_name,
                      const std::string &amp; removal_date);

  void deprecateCoupledVar(const std::string &amp; old_name,
                           const std::string &amp; new_name,
                           const std::string &amp; removal_date);

  /**
   * Checks whether the provided name is a renamed parameter name. If so we return the &#x27;new&#x27; name.
   * If not we return the incoming name
   * @param name The name to check for whether it is a renamed name
   * @return The new name if the incoming \p name is a renamed name, else \p name
   */
  std::string checkForRename(const std::string &amp; name) const;

  /**
   * A wrapper around the \p Parameters base class method. Checks for parameter rename before
   * calling the base class method
   * @param name The name to query the parameter values map with
   * @return The parameter value corresponding to the (possibly renamed) name
   */
  template &lt;typename T&gt;
  const T &amp; get(std::string_view name) const;

  /**
   * A wrapper around the \p Parameters base class method. Checks for parameter rename before
   * calling the base class method. This method tells whether a parameter with a known type is
   * defined. If the type is unknown, use isParamDefined().
   * @param name The name to query the parameter values map with
   * @return Whether there is a key in the parameter values map corresponding to the (possibly
   * renamed) name
   */
  template &lt;typename T&gt;
  bool have_parameter(std::string_view name) const;

  /**
   * A routine to transfer a parameter from one class&#x27; validParams to another
   * @param source_param The parameters list holding the param we would like to transfer
   * @param name The name of the parameter to transfer
   * @param new_description A new description of the parameter. If unspecified, uses the
   * source_params&#x27;
   */
  template &lt;typename T&gt;
  void transferParam(const InputParameters &amp; source_param,
                     const std::string &amp; name,
                     const std::string &amp; new_name = &quot;&quot;,
                     const std::string &amp; new_description = &quot;&quot;);

  /**
   * Return all the aliased names associated with \p param_name. The returned container will always
   * contain \p param_name itself. Other aliases in addition to \p param_name will include the base
   * class parameter name if \p param_name is the derived class parameter name, or deprecated names
   * that \p param_name is meant to replace.
   * @param param_name The name of the parameter that we want to lookup aliases for. This parameter
   * name must exist in our metadata and parameter names to values map, e.g. this parameter must
   * represent the derived class parameter name if a base class parameter has been renamed or the
   * blessed parameter name in situations where associated parameter names have been deprecated
   * @return All aliases which logically resolve-to/are-associated-with \p param_name, including \p
   * param_name itself
   */
  std::vector&lt;std::string&gt; paramAliases(const std::string &amp; param_name) const;

  /**
   * @return The hit node that represents the syntax responsible for creating
   * these parameters, if any
   */
  const hit::Node * getHitNode() const { return _hit_node; }
  /**
   * Sets the hit node that represents the syntax responsible for creating
   * these parameters
   *
   * Is protected to be called by only the ActionFactory, Builder, and Factory
   * via the SetHitNodeKey.
   */
  void setHitNode(const hit::Node &amp; node, const SetHitNodeKey) { _hit_node = &amp;node; }

  /**
   * @return Whether or not finalize() has been called
   */
  bool isFinalized() const { return _finalized; }

  /**
   * @return The DataFileName path for the parameter \p name (if any).
   */
  std::optional&lt;Moose::DataFileUtils::Path&gt; queryDataFileNamePath(const std::string &amp; name) const;

  /**
   * Entrypoint for the Builder to setup a std::vector&lt;VariableName&gt; parameter,
   * which will setup the default variable names if appropriate
   *
   * @param names The variable names
   * @param node The hit node that produced this parameter
   * @return An error message, if any
   */
  std::optional&lt;std::string&gt; setupVariableNames(std::vector&lt;VariableName&gt; &amp; names,
                                                const hit::Node &amp; node,
                                                const Moose::PassKey&lt;Moose::Builder&gt;);

private:
  // Private constructor so that InputParameters can only be created in certain places.
  InputParameters();

  /**
   * Method to terminate the recursive setParameters definition
   */
  void setParameters() {}

  template &lt;typename T&gt;
  static constexpr bool isFunctorNameType();

  /**
   * Appends description of what a functor is to a doc string.
   */
  template &lt;typename T&gt;
  std::string appendFunctorDescription(const std::string &amp; doc_string) const;

  /**
   * Private method for setting deprecated coupled variable documentation strings
   */
  void setDeprecatedVarDocString(const std::string &amp; new_name, const std::string &amp; doc_string);

  void renameParamInternal(const std::string &amp; old_name,
                           const std::string &amp; new_name,
                           const std::string &amp; docstring,
                           const std::string &amp; removal_date);

  void renameCoupledVarInternal(const std::string &amp; old_name,
                                const std::string &amp; new_name,
                                const std::string &amp; docstring,
                                const std::string &amp; removal_date);

  /**
   * Get the context associated with a parameter for a message.
   * @param param The parameter name
   * @return Pair that is the string prefix for the parameter (fullpath) and a pointer to the best
   * hit node that can be associated with the parameter (if any)
   */
  std::pair&lt;std::string, const hit::Node *&gt; paramMessageContext(const std::string &amp; param) const;
  /**
   * Get a prefix for messages associated with a parameter.
   *
   * Will include the best file path possible for the parameter and the parameter&#x27;s fullpath.
   */
  std::string paramMessagePrefix(const std::string &amp; param) const;

  struct Metadata
  {
    std::string _doc_string;
    /// The developer-designated unit of the parameter for use in documentation
    std::string _doc_unit;
    /// The custom type that will be printed in the YAML dump for a parameter if supplied
    std::string _custom_type;
    /// The data pertaining to a command line parameter (empty if not a command line param)
    std::optional&lt;CommandLineMetadata&gt; _cl_data;
    /// The searched path information pertaining to a DataFileName parameter
    std::optional&lt;Moose::DataFileUtils::Path&gt; _data_file_name_path;
    /// The names of the parameters organized into groups
    std::string _group;
    /// The map of functions used for range checked parameters
    std::string _range_function;
    /// directions for auto build vectors (base_, 5) -&gt; &quot;base_0 base_1 base_2 base_3 base_4&quot;)
    std::pair&lt;std::string, std::string&gt; _autobuild_vecs;
    /// True for parameters that are required (i.e. will cause an abort if not supplied)
    bool _required = false;
    /**
     * Whether the parameter is either explicitly set or provided a default value when added
     * Note: We do not store MooseEnum names in valid params, instead we ask MooseEnums whether
     *       they are valid or not.
     */
    bool _valid = false;
    /// The set of parameters that will NOT appear in the the dump of the parser tree
    bool _is_private = false;
    bool _have_coupled_default = false;
    /// The default value for optionally coupled variables
    std::vector&lt;Real&gt; _coupled_default = {0};
    /// True if a parameters value was set by addParam, and not set again.
    bool _set_by_add_param = false;
    /// The reserved option names for a parameter
    std::set&lt;std::string&gt; _reserved_values;
    /// If non-empty, this parameter is deprecated.
    std::string _deprecation_message;
    /// Original location of parameter node; used for error messages
    const hit::Node * _hit_node;
    /// True if the parameters is controllable
    bool _controllable = false;
    /// Controllable execute flag restriction
    std::set&lt;ExecFlagType&gt; _controllable_flags;
    /// whether user setting of this parameter should be ignored
    bool _ignore = false;
  };

  Metadata &amp; at(const std::string &amp; param_name)
  {
    const auto param = checkForRename(param_name);
    if (_params.count(param) == 0)
      mooseError(&quot;param &#x27;&quot;, param, &quot;&#x27; not present in InputParams&quot;);
    return _params[param];
  }
  const Metadata &amp; at(const std::string &amp; param_name) const
  {
    const auto param = checkForRename(param_name);
    if (_params.count(param) == 0)
      mooseError(&quot;param &#x27;&quot;, param, &quot;&#x27; not present in InputParams&quot;);
    return _params.at(param);
  }

  /**
   * Toggle the availability of the copy constructor
   *
   * When MooseObject is created via the Factory this flag is set to false, so when a MooseObject is
   * created if
   * the constructor is not a const reference an error is produced. This method allows the
   * InputParameterWarehouse
   * to disable copying.
   */
  void allowCopy(bool status) { _allow_copy = status; }

  /**
   * Make sure the parameter name doesn&#x27;t have any invalid characters.
   */
  void checkParamName(const std::string &amp; name) const;

  /**
   * This method is called when adding a Parameter with a default value, can be specialized for
   * non-matching types.
   */
  template &lt;typename T, typename S&gt;
  void setParamHelper(const std::string &amp; name, T &amp; l_value, const S &amp; r_value);

  /**
   * Helper for all of the addCommandLineParam() calls, which sets up _cl_data in the metadata
   *
   * @param name The parameter name
   * @param syntax The parameter syntax
   * @param required Whether or not the parameter is required
   * @param value_required Whethre or not the parameter requires a value
   */
  template &lt;typename T&gt;
  void addCommandLineParamHelper(const std::string &amp; name,
                                 const std::string &amp; syntax,
                                 const bool required,
                                 const bool value_required);

  /**
   * Internal helper for calling back to mooseError(), ideally from the underlying
   * MooseBase object if it is available (for more context)
   */
  [[noreturn]] void callMooseError(std::string msg,
                                   const bool with_prefix = true,
                                   const hit::Node * node = nullptr) const;

  /// The actual parameter data. Each Metadata object contains attributes for the corresponding
  /// parameter.
  std::map&lt;std::string, Metadata&gt; _params;

  /// The coupled variables set
  std::set&lt;std::string&gt; _coupled_vars;

  /// The class description for the owning object. This string is used in many places including
  /// mouse-over events, and external documentation produced from the source code.
  std::string _class_description;

  /// The parameter is used to restrict types that can be built.  Typically this is used for
  /// MooseObjectAction derived Actions.
  std::vector&lt;std::string&gt; _buildable_types;

  /// The RelationshipManagers that this object may either build or require.
  /// The optional second argument may be supplied to &quot;downgrade&quot; the functionality of the corresponding
  /// relationship manager (e.g. An AlgebraicRelationshipManager could be only used as a
  /// GeometricRelationshipManager for a given simulation).
  std::vector&lt;std::tuple&lt;std::string,
                         Moose::RelationshipManagerType,
                         Moose::RelationshipManagerInputParameterCallback&gt;&gt;
      _buildable_rm_types;

  /// This parameter collapses one level of nesting in the syntax blocks.  It is used
  /// in conjunction with MooseObjectAction derived Actions.
  bool _collapse_nesting;

  /// This parameter hides derived MOOSE object types from appearing in syntax dumps
  bool _moose_object_syntax_visibility;

  /// Flag for disabling deprecated parameters message, this is used by applyParameters to avoid
  /// dumping messages.
  bool _show_deprecated_message;

  /// A flag for toggling the error message in the copy constructor.
  bool _allow_copy;

  /// A map from deprecated coupled variable names to the new blessed name
  std::unordered_map&lt;std::string, std::string&gt; _new_to_deprecated_coupled_vars;

  /// A map from base-class/deprecated parameter names to derived-class/blessed parameter names and
  /// the deprecation messages in the case that the &quot;old&quot; parameter name is a deprecated parameter
  /// name. The deprecation message will be empty if the &quot;old&quot; parameter name represents a base
  /// class parameter name
  std::map&lt;std::string, std::pair&lt;std::string, std::string&gt;&gt; _old_to_new_name_and_dep;

  /// A map from derived-class/blessed parameter names to associated base-class/deprecated parameter
  /// names
  std::multimap&lt;std::string, std::string&gt; _new_to_old_names;

  /// The hit node representing the syntax that created these parameters, if any
  const hit::Node * _hit_node;

  /// Whether or not we&#x27;ve called finalize() on these parameters yet
  bool _finalized;

  // These are the only objects allowed to _create_ InputParameters
  friend InputParameters emptyInputParameters();
  friend class InputParameterWarehouse;
  friend class Parser;
  // for the printInputFile function in the action warehouse
  friend class ActionWarehouse;
};

template &lt;typename T&gt;
void
InputParameters::setHelper(const std::string &amp; /*name*/)
{
}

// Template and inline function implementations
template &lt;typename T&gt;
T &amp;
InputParameters::set(const std::string &amp; name_in, bool quiet_mode)
{
  const auto name = checkForRename(name_in);

  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  T &amp; result = this-&gt;Parameters::set&lt;T&gt;(name);

  if (quiet_mode)
    _params[name]._set_by_add_param = true;

  setHelper&lt;T&gt;(name);

  return result;
}

template &lt;typename T, typename... Ts&gt;
void
InputParameters::setParameters(const std::string &amp; name,
                               const T &amp; value,
                               Ts... extra_input_parameters)
{
  this-&gt;set&lt;T&gt;(name) = value;
  this-&gt;setParameters(extra_input_parameters...);
}

template &lt;typename T, typename UP_T&gt;
std::optional&lt;std::pair&lt;bool, std::string&gt;&gt;
InputParameters::rangeCheck(const std::string &amp; full_name,
                            const std::string &amp; short_name,
                            const InputParameters::Parameter&lt;std::vector&lt;T&gt;&gt; &amp; param,
                            const bool include_param_path)
{
  if (!isParamValid(short_name))
    return {};

  const auto &amp; range_function = _params[short_name]._range_function;
  if (range_function.empty())
    return {};

  /**
   * Automatically detect the variables used in the range checking expression.
   * We allow the following variables (where snam is the short_name of the parameter)
   *
   * snam       : tests every component in the vector
   *              &#x27;snam &gt; 0&#x27;
   * snam_size  : the size of the vector
   *              &#x27;snam_size = 5&#x27;
   * snam_i     : where i is a number from 0 to sname_size-1 tests a specific component
   *              &#x27;snam_0 &gt; snam_1&#x27;
   */
  FunctionParserBase&lt;UP_T&gt; fp;
  std::vector&lt;std::string&gt; vars;
  if (fp.ParseAndDeduceVariables(range_function, vars) != -1) // -1 for success
    return {{false,
             &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27; for parameter &quot; + short_name + &quot;&quot;}};

  // Fparser parameter buffer
  std::vector&lt;UP_T&gt; parbuf(vars.size());

  // parameter vector
  const std::vector&lt;T&gt; &amp; value = param.get();

  // iterate over all vector values (maybe ;)
  bool need_to_iterate = false;
  unsigned int i = 0;
  do
  {
    // set parameters
    for (unsigned int j = 0; j &lt; vars.size(); j++)
    {
      if (vars[j] == short_name)
      {
        if (value.size() == 0)
        {
          std::ostringstream oss;
          oss &lt;&lt; &quot;Range checking empty vector&quot;;
          if (include_param_path)
            oss &lt;&lt; &quot; parameter &quot; &lt;&lt; full_name;
          oss &lt;&lt; &quot;; expression = &#x27;&quot; &lt;&lt; range_function &lt;&lt; &quot;&#x27;&quot;;
          return {{true, oss.str()}};
        }

        parbuf[j] = value[i];
        need_to_iterate = true;
      }
      else if (vars[j] == short_name + &quot;_size&quot;)
        parbuf[j] = value.size();
      else
      {
        if (vars[j].substr(0, short_name.size() + 1) != short_name + &quot;_&quot;)
          return {{false, &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27;&quot;}};
        std::istringstream iss(vars[j]);
        iss.seekg(short_name.size() + 1);

        size_t index;
        if (iss &gt;&gt; index &amp;&amp; iss.eof())
        {
          if (index &gt;= value.size())
          {
            std::ostringstream oss;
            oss &lt;&lt; &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27;&quot;;
            if (include_param_path)
              oss &lt;&lt; &quot; for parameter &quot; &lt;&lt; full_name;
            oss &lt;&lt; &quot;; out of range variable &#x27;&quot; + vars[j] &lt;&lt; &quot;&#x27;&quot;;
            return {{true, oss.str()}};
          }
          parbuf[j] = value[index];
        }
        else
          return {{false,
                   &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27;; invalid variable &#x27;&quot; +
                       vars[j] + &quot;&#x27;&quot;}};
      }
    }

    // ensure range-checked input file parameter comparison functions
    // do absolute floating point comparisons instead of using a default epsilon.
    auto tmp_eps = fp.epsilon();
    fp.setEpsilon(0);
    UP_T result = fp.Eval(&amp;parbuf[0]);
    fp.setEpsilon(tmp_eps);

    // test function using the parameters determined above
    if (fp.EvalError())
      return {{false, &quot;Error evaluating expression &#x27;&quot; + range_function + &quot;&#x27;&quot;}};

    if (!result)
    {
      std::ostringstream oss;
      oss &lt;&lt; &quot;Range check failed&quot;;
      if (include_param_path)
        oss &lt;&lt; &quot; for parameter &quot; &lt;&lt; full_name;
      oss &lt;&lt; &quot;; expression = &#x27;&quot; &lt;&lt; range_function &lt;&lt; &quot;&#x27;&quot;;
      if (need_to_iterate)
        oss &lt;&lt; &quot;, component &quot; &lt;&lt; i;
      return {{true, oss.str()}};
    }

  } while (need_to_iterate &amp;&amp; ++i &lt; value.size());

  return {};
}

template &lt;typename T, typename UP_T&gt;
std::optional&lt;std::pair&lt;bool, std::string&gt;&gt;
InputParameters::rangeCheck(const std::string &amp; full_name,
                            const std::string &amp; short_name,
                            const InputParameters::Parameter&lt;T&gt; &amp; param,
                            const bool include_param_path)
{
  if (!isParamValid(short_name))
    return {};

  const auto &amp; range_function = _params[short_name]._range_function;
  if (range_function.empty())
    return {};

  // Parse the expression
  FunctionParserBase&lt;UP_T&gt; fp;
  if (fp.Parse(range_function, short_name) != -1) // -1 for success
    return {{false,
             &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27;&quot; + &quot; for parameter &quot; + short_name}};

  // ensure range-checked input file parameter comparison functions
  // do absolute floating point comparisons instead of using a default epsilon.
  auto tmp_eps = fp.epsilon();
  fp.setEpsilon(0);
  // We require a non-const value for the implicit upscaling of the parameter type
  std::vector&lt;UP_T&gt; value(1, param.get());
  UP_T result = fp.Eval(&amp;value[0]);
  fp.setEpsilon(tmp_eps);

  if (fp.EvalError())
    return {{true,
             &quot;Error evaluating expression &#x27;&quot; + range_function + &quot;&#x27; for parameter &quot; + short_name +
                 &quot;; perhaps you used the wrong variable name?&quot;}};

  if (!result)
  {
    std::ostringstream oss;
    oss &lt;&lt; &quot;Range check failed&quot;;
    if (include_param_path)
      oss &lt;&lt; &quot; for parameter &quot; &lt;&lt; full_name;
    oss &lt;&lt; &quot;; expression = &#x27;&quot; &lt;&lt; range_function &lt;&lt; &quot;&#x27;, value = &quot; &lt;&lt; value[0];
    return {{true, oss.str()}};
  }

  return {};
}

template &lt;typename T&gt;
T
InputParameters::getCheckedPointerParam(const std::string &amp; name_in,
                                        const std::string &amp; error_string) const
{
  const auto name = checkForRename(name_in);

  T param = this-&gt;get&lt;T&gt;(name);

  // Note: You will receive a compile error on this line if you attempt to pass a non-pointer
  // template type to this method
  if (!param)
    mooseError(&quot;Parameter &quot;, name, &quot; is NULL.\n&quot;, error_string);
  return this-&gt;get&lt;T&gt;(name);
}

template &lt;typename T&gt;
void
InputParameters::addRequiredParam(const std::string &amp; name, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  auto &amp; metadata = _params[name];
  metadata._required = true;
  if constexpr (isFunctorNameType&lt;T&gt;())
    metadata._doc_string = appendFunctorDescription&lt;T&gt;(doc_string);
  else
    metadata._doc_string = doc_string;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredParam(const std::string &amp; /*name*/,
                                  const T &amp; /*value*/,
                                  const std::string &amp; /*doc_string*/)
{
  mooseError(&quot;You cannot call addRequiredParam and supply a default value for this type, please &quot;
             &quot;use addParam instead&quot;);
}

template &lt;typename T, typename S&gt;
void
InputParameters::addParam(const std::string &amp; name, const S &amp; value, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  T &amp; l_value = InputParameters::set&lt;T&gt;(name);
  auto &amp; metadata = _params[name];
  if constexpr (isFunctorNameType&lt;T&gt;())
    metadata._doc_string = appendFunctorDescription&lt;T&gt;(doc_string);
  else
    metadata._doc_string = doc_string;

  // Set the parameter now
  setParamHelper(name, l_value, value);

  /* Indicate the default value, as set via addParam, is being used. The parameter is removed from
     the list whenever
     it changes, see set_attributes */
  metadata._set_by_add_param = true;
}

template &lt;typename T&gt;
void
InputParameters::addParam(const std::string &amp; name, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  if constexpr (isFunctorNameType&lt;T&gt;())
    _params[name]._doc_string = appendFunctorDescription&lt;T&gt;(doc_string);
  else
    _params[name]._doc_string = doc_string;
}

template &lt;typename T, typename S&gt;
void
InputParameters::setParamHelper(const std::string &amp; /*name*/, T &amp; l_value, const S &amp; r_value)
{
  l_value = r_value;
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParamHelper(const std::string &amp; name,
                                           const std::string &amp; syntax,
                                           const bool required,
                                           const bool value_required)
{
  static_assert(isValidCommandLineType&lt;T&gt;::value,
                &quot;This type is not a supported command line parameter type. See &quot;
                &quot;CommandLine::populateCommandLineParams to add it as a supported type.&quot;);

  auto &amp; cl_data = at(name)._cl_data;
  cl_data = CommandLineMetadata();

  // Split up the syntax by whitespace
  std::vector&lt;std::string&gt; syntax_split;
  MooseUtils::tokenize(syntax, syntax_split, 1, &quot; \t\n\v\f\r&quot;);

  // Set the single syntax string as the combined syntax with removed whitespace
  cl_data-&gt;syntax = MooseUtils::stringJoin(syntax_split);
  mooseAssert(cl_data-&gt;syntax.size(), &quot;Empty token&quot;);

  // Set the switches; only parse those that begin with &quot;-&quot; as we also
  // provide examples within the syntax
  for (const auto &amp; val : syntax_split)
    if (val.rfind(&quot;-&quot;, 0) == 0)
    {
      if (!std::regex_search(val, std::regex(&quot;^\\-+[a-zA-Z]&quot;)))
        mooseError(&quot;The switch &#x27;&quot;,
                   val,
                   &quot;&#x27; for the command line parameter &#x27;&quot;,
                   name,
                   &quot;&#x27; is invalid. It must begin with an alphabetical character.&quot;);

      cl_data-&gt;switches.push_back(val);
      libMesh::add_command_line_name(val);
    }

  cl_data-&gt;required = required;
  cl_data-&gt;global = false;

  // No arguments needed for a boolean parameter
  if constexpr (std::is_same_v&lt;T, bool&gt;)
  {
    (void)value_required; // purposely unused; doesn&#x27;t take a value
    cl_data-&gt;argument_type = CommandLineMetadata::ArgumentType::NONE;
  }
  // MooseEnums require a value
  else if constexpr (std::is_same_v&lt;T, MooseEnum&gt;)
  {
    (void)value_required; // purposely unused; always required
    cl_data-&gt;argument_type = CommandLineMetadata::ArgumentType::REQUIRED;
  }
  // The user didn&#x27;t specify a default, so a value is required
  else if (value_required)
    cl_data-&gt;argument_type = CommandLineMetadata::ArgumentType::REQUIRED;
  // Otherwise, it&#x27;s optional (user specified a default)
  else
    cl_data-&gt;argument_type = CommandLineMetadata::ArgumentType::OPTIONAL;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredRangeCheckedParam(const std::string &amp; name,
                                              const std::string &amp; parsed_function,
                                              const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRangeCheckedParam(const std::string &amp; name,
                                      const T &amp; value,
                                      const std::string &amp; parsed_function,
                                      const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRangeCheckedParam(const std::string &amp; name,
                                      const std::string &amp; parsed_function,
                                      const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredCustomTypeParam(const std::string &amp; name,
                                            const std::string &amp; custom_type,
                                            const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addCustomTypeParam(const std::string &amp; name,
                                    const T &amp; value,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addCustomTypeParam(const std::string &amp; name,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedCustomTypeParam(const std::string &amp; name,
                                              const std::string &amp; custom_type,
                                              const std::string &amp; doc_string,
                                              const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  addParam&lt;T&gt;(name, doc_string);
  auto &amp; metadata = _params[name];
  metadata._custom_type = custom_type;

  metadata._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

template &lt;typename T&gt;
void
InputParameters::addPrivateParam(const std::string &amp; name)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  _params[name]._is_private = true;
}

template &lt;typename T&gt;
void
InputParameters::addPrivateParam(const std::string &amp; name, const T &amp; value)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::set&lt;T&gt;(name) = value;
  auto &amp; metadata = _params[name];
  metadata._is_private = true;
  metadata._set_by_add_param = true;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredCommandLineParam(const std::string &amp; name,
                                             const std::string &amp; syntax,
                                             const std::string &amp; doc_string)
{
  static_assert(!std::is_same_v&lt;T, bool&gt;, &quot;Cannot be used for a bool&quot;);

  addRequiredParam&lt;T&gt;(name, doc_string);
  addCommandLineParamHelper&lt;T&gt;(name, syntax, /* required = */ true, /* value_required = */ true);
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParam(const std::string &amp; name,
                                     const std::string &amp; syntax,
                                     const std::string &amp; doc_string)
{
  static_assert(!std::is_same_v&lt;T, MooseEnum&gt;,
                &quot;addCommandLineParam() without a value cannot be used with a MooseEnum because a &quot;
                &quot;MooseEnum requires initialization&quot;);

  auto constexpr is_bool = std::is_same_v&lt;T, bool&gt;;
  if constexpr (is_bool)
    addParam&lt;T&gt;(name, false, doc_string);
  else
    addParam&lt;T&gt;(name, doc_string);

  addCommandLineParamHelper&lt;T&gt;(
      name, syntax, /* required = */ false, /* value_required = */ !is_bool);
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParam(const std::string &amp; name,
                                     const std::string &amp; syntax,
                                     const T &amp; value,
                                     const std::string &amp; doc_string)
{
  if constexpr (std::is_same_v&lt;T, bool&gt;)
    mooseAssert(!value, &quot;Default for bool must be false&quot;);

  addParam&lt;T&gt;(name, value, doc_string);
  addCommandLineParamHelper&lt;T&gt;(name, syntax, /* required = */ false, /* value_required = */ true);
}

template &lt;typename T&gt;
void
InputParameters::addOptionalValuedCommandLineParam(const std::string &amp; name,
                                                   const std::string &amp; syntax,
                                                   const T &amp; value,
                                                   const std::string &amp; doc_string)
{
  mooseAssert(name == &quot;csg_only&quot; || name == &quot;mesh_only&quot; || name == &quot;recover&quot; || name == &quot;run&quot;,
              &quot;Not supported for new parameters&quot;);
  static_assert(!std::is_same_v&lt;T, bool&gt;, &quot;Cannot be used for a bool (does not take a value)&quot;);
  addParam&lt;T&gt;(name, value, doc_string);
  addCommandLineParamHelper&lt;T&gt;(name, syntax, /* required = */ false, /* value_required = */ false);
}

template &lt;typename T&gt;
void
InputParameters::checkConsistentType(const std::string &amp; name_in) const
{
  const auto name = checkForRename(name_in);

  // If we don&#x27;t currently have the Parameter, can&#x27;t be any inconsistency
  InputParameters::const_iterator it = _values.find(name);
  if (it == _values.end())
    return;

  // Now, if we already have the Parameter, but it doesn&#x27;t have the
  // right type, throw an error.
  if (!this-&gt;Parameters::have_parameter&lt;T&gt;(name))
    mooseError(&quot;Attempting to set parameter \&quot;&quot;,
               name,
               &quot;\&quot; with type (&quot;,
               libMesh::demangle(typeid(T).name()),
               &quot;)\nbut the parameter already exists as type (&quot;,
               it-&gt;second-&gt;type(),
               &quot;)&quot;);
}

template &lt;typename T&gt;
void
InputParameters::suppressParameter(const std::string &amp; name_in)
{
  const auto name = checkForRename(name_in);
  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to suppress nonexistent parameter: &quot;, name);

  auto &amp; metadata = _params[name];
  metadata._required = false;
  metadata._is_private = true;
  metadata._controllable = false;
}

template &lt;typename T&gt;
void
InputParameters::ignoreParameter(const std::string &amp; name_in)
{
  const auto name = checkForRename(name_in);
  suppressParameter&lt;T&gt;(name);
  _params[name]._ignore = true;
}

template &lt;typename T&gt;
void
InputParameters::makeParamRequired(const std::string &amp; name_in)
{
  const auto name = checkForRename(name_in);

  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to require nonexistent parameter: &quot;, name);

  _params[name]._required = true;
}

template &lt;typename T&gt;
void
InputParameters::makeParamNotRequired(const std::string &amp; name_in)
{
  const auto name = checkForRename(name_in);

  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to un-require nonexistent parameter: &quot;, name);

  _params[name]._required = false;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedParam(const std::string &amp; name,
                                    const T &amp; value,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  mooseAssert(!_old_to_new_name_and_dep.count(name),
              &quot;Attempting to deprecate via addDeprecatedParam the parameter, &#x27;&quot;
                  &lt;&lt; name &lt;&lt; &quot;&#x27;, already deprecated via deprecateParam or renamed via renameParam&quot;);
  addParam&lt;T&gt;(name, value, doc_string);

  _params[name]._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedParam(const std::string &amp; name,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  mooseAssert(!_old_to_new_name_and_dep.count(name),
              &quot;Attempting to deprecate via addDeprecatedParam the parameter, &#x27;&quot;
                  &lt;&lt; name &lt;&lt; &quot;&#x27;, already deprecated via deprecateParam or renamed via renameParam&quot;);
  addParam&lt;T&gt;(name, doc_string);

  _params[name]._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

// Forward declare MooseEnum specializations for add*Param
template &lt;&gt;
void InputParameters::addRequiredParam&lt;MooseEnum&gt;(const std::string &amp; name,
                                                  const MooseEnum &amp; moose_enum,
                                                  const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                       const MultiMooseEnum &amp; moose_enum,
                                                       const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;std::vector&lt;MooseEnum&gt;&gt;(
    const std::string &amp; name,
    const std::vector&lt;MooseEnum&gt; &amp; moose_enums,
    const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;std::vector&lt;MultiMooseEnum&gt;&gt;(
    const std::string &amp; name,
    const std::vector&lt;MultiMooseEnum&gt; &amp; moose_enums,
    const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/,
                                          const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/,
                                               const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;std::vector&lt;MooseEnum&gt;&gt;(const std::string &amp; /*name*/,
                                                       const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;std::vector&lt;MultiMooseEnum&gt;&gt;(const std::string &amp; /*name*/,
                                                            const std::string &amp; /*doc_string*/);

template &lt;&gt;
void
InputParameters::addRequiredParam&lt;std::vector&lt;MultiMooseEnum&gt;&gt;(const std::string &amp; /*name*/,
                                                               const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addPrivateParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/);

template &lt;&gt;
void InputParameters::addPrivateParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/,
                                                    const std::string &amp; /*doc_string*/,
                                                    const std::string &amp; /*deprecation_message*/);

template &lt;&gt;
void
InputParameters::addDeprecatedParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/,
                                                    const std::string &amp; /*doc_string*/,
                                                    const std::string &amp; /*deprecation_message*/);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;std::vector&lt;MooseEnum&gt;&gt;(
    const std::string &amp; /*name*/,
    const std::string &amp; /*doc_string*/,
    const std::string &amp; /*deprecation_message*/);

// Forward declare specializations for setParamHelper
template &lt;&gt;
void InputParameters::setParamHelper&lt;PostprocessorName, Real&gt;(const std::string &amp; name,
                                                              PostprocessorName &amp; l_value,
                                                              const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;PostprocessorName, int&gt;(const std::string &amp; name,
                                                             PostprocessorName &amp; l_value,
                                                             const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;FunctionName, Real&gt;(const std::string &amp; /*name*/,
                                                         FunctionName &amp; l_value,
                                                         const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;FunctionName, int&gt;(const std::string &amp; /*name*/,
                                                        FunctionName &amp; l_value,
                                                        const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MaterialPropertyName, Real&gt;(const std::string &amp; /*name*/,
                                                                 MaterialPropertyName &amp; l_value,
                                                                 const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MaterialPropertyName, int&gt;(const std::string &amp; /*name*/,
                                                                MaterialPropertyName &amp; l_value,
                                                                const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MooseFunctorName, Real&gt;(const std::string &amp; /*name*/,
                                                             MooseFunctorName &amp; l_value,
                                                             const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MooseFunctorName, int&gt;(const std::string &amp; /*name*/,
                                                            MooseFunctorName &amp; l_value,
                                                            const int &amp; r_value);

template &lt;typename T&gt;
const T &amp;
InputParameters::getParamHelper(const std::string &amp; name_in, const InputParameters &amp; pars)
{
  const auto name = pars.checkForRename(name_in);

  if (!pars.isParamValid(name))
    pars.mooseError(&quot;The parameter \&quot;&quot;, name, &quot;\&quot; is being retrieved before being set.&quot;);

  return pars.get&lt;T&gt;(name);
}

// Declare specializations so we don&#x27;t fall back on the generic
// implementation, but the definition will be in InputParameters.C so
// we won&#x27;t need to bring in *MooseEnum header files here.
template &lt;&gt;
const MooseEnum &amp; InputParameters::getParamHelper&lt;MooseEnum&gt;(const std::string &amp; name,
                                                             const InputParameters &amp; pars);

template &lt;&gt;
const MultiMooseEnum &amp;
InputParameters::getParamHelper&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                const InputParameters &amp; pars);

template &lt;typename R1, typename R2, typename V1, typename V2&gt;
std::vector&lt;std::pair&lt;R1, R2&gt;&gt;
InputParameters::get(const std::string &amp; param1_in, const std::string &amp; param2_in) const
{
  const auto param1 = checkForRename(param1_in);
  const auto param2 = checkForRename(param2_in);

  const auto &amp; v1 = get&lt;V1&gt;(param1);
  const auto &amp; v2 = get&lt;V2&gt;(param2);

  auto controllable = getControllableParameters();
  if (controllable.count(param1) || controllable.count(param2))
    mooseError(&quot;Parameters &quot;,
               param1,
               &quot; and/or &quot;,
               param2 + &quot; are controllable parameters and cannot be retireved using &quot;
                        &quot;the MooseObject::getParam/InputParameters::get methods for pairs&quot;);

  if (v1.size() != v2.size())
    paramError(param1,
               &quot;Vector parameters &quot;,
               param1,
               &quot;(size: &quot;,
               v1.size(),
               &quot;) and &quot; + param2,
               &quot;(size: &quot;,
               v2.size(),
               &quot;) are of different lengths \n&quot;);

  std::vector&lt;std::pair&lt;R1, R2&gt;&gt; parameter_pairs;
  auto i1 = v1.begin();
  auto i2 = v2.begin();
  for (; i1 != v1.end() &amp;&amp; i2 != v2.end(); ++i1, ++i2)
    parameter_pairs.emplace_back(std::make_pair(*i1, *i2));
  return parameter_pairs;
}

InputParameters emptyInputParameters();

template &lt;typename T&gt;
bool
InputParameters::isType(const std::string &amp; name_in) const
{
  const auto name = checkForRename(name_in);

  if (!_params.count(name))
    mooseError(&quot;Parameter \&quot;&quot;, name, &quot;\&quot; is not valid.&quot;);
  return have_parameter&lt;T&gt;(name);
}

template &lt;typename T&gt;
const T &amp;
InputParameters::get(std::string_view name_in) const
{
  const auto name = checkForRename(std::string(name_in));

  return Parameters::get&lt;T&gt;(name);
}

template &lt;typename T&gt;
bool
InputParameters::have_parameter(std::string_view name_in) const
{
  const auto name = checkForRename(std::string(name_in));

  return Parameters::have_parameter&lt;T&gt;(name);
}

template &lt;typename T&gt;
void
InputParameters::transferParam(const InputParameters &amp; source_params,
                               const std::string &amp; name_in,
                               const std::string &amp; new_name,
                               const std::string &amp; new_description)
{
  const auto name = source_params.checkForRename(std::string(name_in));
  const auto p_name = new_name.empty() ? name_in : new_name;
  if (!source_params.have_parameter&lt;T&gt;(name) &amp;&amp; !source_params.hasCoupledValue(name))
    mooseError(&quot;The &#x27;&quot;,
               name_in,
               &quot;&#x27; parameter could not be transferred because it does not exist with type &#x27;&quot;,
               MooseUtils::prettyCppType&lt;T&gt;(),
               &quot;&#x27; in the source parameters&quot;);
  if (name != name_in)
    mooseWarning(&quot;The transferred parameter &quot; + name_in + &quot; is deprecated in favor of &quot; + name +
                 &quot; in the source parameters. The new name should likely be used for the parameter &quot;
                 &quot;transfer instead.&quot;);
  const std::string description =
      new_description.empty() ? source_params.getDescription(name) : new_description;

  if (source_params.isParamRequired(name))
  {
    // Check for a variable parameter
    if (source_params.hasCoupledValue(name))
      addRequiredCoupledVar(p_name, description);
    // Enums parameters have a default list of options
    else if constexpr (std::is_same_v&lt;MooseEnum, T&gt; || std::is_same_v&lt;MultiMooseEnum, T&gt;)
      addRequiredParam&lt;T&gt;(p_name, source_params.get&lt;T&gt;(name), description);
    else if (source_params.isRangeChecked(name))
      addRequiredRangeCheckedParam&lt;T&gt;(
          p_name, source_params.rangeCheckedFunction(name), description);
    else
      addRequiredParam&lt;T&gt;(p_name, description);
  }
  else
  {
    // Check for a variable parameter
    if (source_params.hasCoupledValue(name))
    {
      if (!source_params.hasDefaultCoupledValue(name))
        addCoupledVar(p_name, description);
      else if (source_params.numberDefaultCoupledValues(name) == 1)
        addCoupledVar(p_name, source_params.defaultCoupledValue(name), description);
      else
      {
        std::vector&lt;Real&gt; coupled_values;
        for (const auto i : libMesh::make_range(source_params.numberDefaultCoupledValues(name)))
          coupled_values.push_back(source_params.defaultCoupledValue(name, i));
        addCoupledVar(p_name, coupled_values, description);
      }
    }
    else if (source_params.isRangeChecked(name))
    {
      if (source_params.hasDefault(name))
        addRangeCheckedParam&lt;T&gt;(p_name,
                                source_params.get&lt;T&gt;(name),
                                source_params.rangeCheckedFunction(name),
                                description);
      else
        addRangeCheckedParam&lt;T&gt;(p_name, source_params.rangeCheckedFunction(name), description);
    }
    else if constexpr (std::is_same_v&lt;MooseEnum, T&gt; || std::is_same_v&lt;MultiMooseEnum, T&gt;)
      addParam&lt;T&gt;(p_name, source_params.get&lt;T&gt;(name), description);
    else
    {
      if (source_params.hasDefault(name))
        addParam&lt;T&gt;(p_name, source_params.get&lt;T&gt;(name), description);
      else
        addParam&lt;T&gt;(p_name, description);
    }
  }

  // Copy other attributes
  if (source_params.isPrivate(name))
    _params[p_name]._is_private = true;
  if (source_params.isControllable(name))
    _params[p_name]._controllable = true;
}

template &lt;typename... Args&gt;
[[noreturn]] void
InputParameters::mooseError(Args &amp;&amp;... args) const
{
  std::ostringstream oss;
  moose::internal::mooseStreamAll(oss, std::forward&lt;Args&gt;(args)...);
  callMooseError(oss.str());
}

template &lt;typename... Args&gt;
std::string
InputParameters::paramMessage(const std::string &amp; param, Args... args) const
{
  std::ostringstream oss;
  moose::internal::mooseStreamAll(oss, std::forward&lt;Args&gt;(args)...);
  return paramMessagePrefix(param) + oss.str();
}

template &lt;typename... Args&gt;
[[noreturn]] void
InputParameters::paramError(const std::string &amp; param, Args... args) const
{
  std::ostringstream oss;
  moose::internal::mooseStreamAll(oss, std::forward&lt;Args&gt;(args)...);
  const auto [prefix, node] = paramMessageContext(param);

  Moose::show_trace = false;
  callMooseError(prefix + oss.str(), false, node);
  Moose::show_trace = true;
}

namespace Moose
{
namespace internal
{
template &lt;typename T&gt;
constexpr T *
getNullptrExample()
{
  return nullptr;
}

#ifdef MOOSE_MFEM_ENABLED

template &lt;typename T&gt;
constexpr bool
isMFEMFunctorNameTypeHelper(T *)
{
  return std::is_same_v&lt;T, MFEMScalarCoefficientName&gt; ||
         std::is_same_v&lt;T, MFEMVectorCoefficientName&gt;;
}

template &lt;typename T, typename A&gt;
constexpr bool
isMFEMFunctorNameTypeHelper(std::vector&lt;T, A&gt; *)
{
  return isMFEMFunctorNameTypeHelper(getNullptrExample&lt;T&gt;());
}

#endif

template &lt;typename T&gt;
constexpr bool
isScalarFunctorNameTypeHelper(T *)
{
  return std::is_same_v&lt;T, MooseFunctorName&gt;
#ifdef MOOSE_MFEM_ENABLED
         || std::is_same_v&lt;T, MFEMScalarCoefficientName&gt;
#endif
      ;
}

template &lt;typename T, typename A&gt;
constexpr bool
isScalarFunctorNameTypeHelper(std::vector&lt;T, A&gt; *)
{
  return isScalarFunctorNameTypeHelper(getNullptrExample&lt;T&gt;());
}

template &lt;typename T&gt;
constexpr bool
isVectorFunctorNameTypeHelper(T *)
{
#ifdef MOOSE_MFEM_ENABLED
  return std::is_same_v&lt;T, MFEMVectorCoefficientName&gt;;
#else
  return false;
#endif
}

template &lt;typename T, typename A&gt;
constexpr bool
isVectorFunctorNameTypeHelper(std::vector&lt;T, A&gt; *)
{
  return isVectorFunctorNameTypeHelper(getNullptrExample&lt;T&gt;());
}

template &lt;typename T&gt;
constexpr bool
isFunctorNameTypeHelper(T * ex)
{
  return isScalarFunctorNameTypeHelper(ex) || isVectorFunctorNameTypeHelper(ex);
}
}
}

template &lt;typename T&gt;
constexpr bool
InputParameters::isFunctorNameType()
{
  return Moose::internal::isFunctorNameTypeHelper(Moose::internal::getNullptrExample&lt;T&gt;());
}

template &lt;typename T&gt;
std::string
InputParameters::appendFunctorDescription(const std::string &amp; doc_string) const
{
  auto numeric_value_type = []()
  {
    if constexpr (Moose::internal::isScalarFunctorNameTypeHelper(
                      Moose::internal::getNullptrExample&lt;T&gt;()))
      return &quot;number&quot;;
    else if constexpr (Moose::internal::isVectorFunctorNameTypeHelper(
                           Moose::internal::getNullptrExample&lt;T&gt;()))
      return &quot;numeric vector value (enclosed in curly braces)&quot;;
    else
    {
      mooseAssert(false, &quot;We control instantiations of this method&quot;);
      return &quot;&quot;;
    }
  };

  return MooseUtils::trim(doc_string, &quot;. &quot;) + &quot;. A functor is any of the following: a variable, &quot; +
         (
#ifdef MOOSE_MFEM_ENABLED
             Moose::internal::isMFEMFunctorNameTypeHelper(Moose::internal::getNullptrExample&lt;T&gt;())
                 ? &quot;an MFEM&quot;
                 :
#endif
                 &quot;a functor&quot;) +
         &quot; material property, a function, a postprocessor or a &quot; + numeric_value_type() + &quot;.&quot;;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="d93b5d68-61cc-41de-9cd5-7e809ba16057"><div class="modal-content"><h4>(moose/framework/include/utils/InputParameters.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

// MOOSE includes
#include &quot;MooseUtils.h&quot;
#include &quot;MooseError.h&quot;
#include &quot;MooseTypes.h&quot;
#include &quot;MultiMooseEnum.h&quot;
#include &quot;ExecFlagEnum.h&quot;
#include &quot;Conversion.h&quot;
#include &quot;DataFileUtils.h&quot;
#include &quot;MoosePassKey.h&quot;

#include &quot;libmesh/parameters.h&quot;

#ifdef LIBMESH_HAVE_FPARSER
#include &quot;libmesh/fparser.hh&quot;
#else
template &lt;typename T&gt;
class FunctionParserBase
{
}
#endif

#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;mutex&gt;
#include &lt;optional&gt;
#include &lt;filesystem&gt;
#include &lt;regex&gt;

#include &lt;gtest/gtest.h&gt;

// Forward declarations
class Action;
class ActionFactory;
class Factory;
class FEProblemBase;
class InputParameters;
class MooseEnum;
class MooseObject;
class MultiMooseEnum;
class Problem;
namespace hit
{
class Node;
}
namespace Moose
{
class Builder;
}
class CommandLine;

/**
 * The main MOOSE class responsible for handling user-defined
 * parameters in almost every MOOSE system.
 */
class InputParameters : public libMesh::Parameters
{
public:
  InputParameters(const InputParameters &amp; rhs);
  InputParameters(const Parameters &amp; rhs);

  virtual ~InputParameters() = default;

  virtual void clear() override;

  /**
   * Structure for storing information about a command line parameter
   */
  struct CommandLineMetadata
  {
    enum ArgumentType
    {
      NONE,
      OPTIONAL,
      REQUIRED
    };

    /// The syntax for the parameter
    std::string syntax;
    /// The switches for the parameter (i.e., [-t, --timing])
    std::vector&lt;std::string&gt; switches;
    /// The type of argument
    ArgumentType argument_type;
    /// Whether or not the argument is required
    bool required;
    /// Whether or not the parameter was set by the CommandLine
    bool set_by_command_line = false;
    /// Whether or not the parameter is global (passed to MultiApps)
    bool global = false;
  };

  /**
   * Class that is used as a parameter to setHitNode() that allows only
   * relevant classes to set the hit node
   */
  class SetHitNodeKey
  {
    friend class Action;
    friend class ActionFactory;
    friend class Moose::Builder;
    friend class Factory;
    friend class FEProblemBase;
    friend class InputParameters;
    FRIEND_TEST(InputParametersTest, fileNames);
    SetHitNodeKey() {}
    SetHitNodeKey(const SetHitNodeKey &amp;) {}
  };

  /**
   * Class that is used as a parameter to setHitNode(param) that allows only
   * relevant classes to set the hit node
   */
  class SetParamHitNodeKey
  {
    friend class Moose::Builder;
    FRIEND_TEST(InputParametersTest, fileNames);
    SetParamHitNodeKey() {}
    SetParamHitNodeKey(const SetParamHitNodeKey &amp;) {}
  };

  /**
   * Determines whether or not the given type is a type that is supported for
   * a command line parameter.
   *
   * In particular, whether or not CommandLine::populateCommandLineParams
   * supports extracting these types.
   */
  template &lt;typename T&gt;
  struct isValidCommandLineType
  {
    static constexpr bool value =
        std::is_same_v&lt;T, std::string&gt; || std::is_same_v&lt;T, std::vector&lt;std::string&gt;&gt; ||
        std::is_same_v&lt;T, Real&gt; || std::is_same_v&lt;T, unsigned int&gt; || std::is_same_v&lt;T, int&gt; ||
        std::is_same_v&lt;T, bool&gt; || std::is_same_v&lt;T, MooseEnum&gt;;
  };

  /**
   * This method adds a description of the class that will be displayed
   * in the input file syntax dump
   */
  void addClassDescription(const std::string &amp; doc_string);

  /**
   * Returns the class description
   */
  std::string getClassDescription() const;

  /**
   * Override from libMesh to set user-defined attributes on our parameter
   */
  virtual void set_attributes(const std::string &amp; name, bool inserted_only) override;

  /**
   * @return The deprecated parameter message for the given parameter, if any
   */
  std::optional&lt;std::string&gt; queryDeprecatedParamMessage(const std::string &amp; name) const;

  /// This functions is called in set as a &#x27;callback&#x27; to avoid code duplication
  template &lt;typename T&gt;
  void setHelper(const std::string &amp; name);

  /**
   * Returns a writable reference to the named parameters.  Note: This is not a virtual
   * function! Use caution when comparing to the parent class implementation
   * @param name The name of the parameter to set
   * @param quiet_mode When true the parameter is kept with set_by_add_param=true,
   * this is generally not needed.
   *
   * &quot;quite_mode&quot; returns a writable reference to the named parameter, without setting
   * set_by_add_param to false. Using this method of set will make the parameter to continue to
   * behave if its value where set ONLY by addParam and not by any other method.
   *
   * This was added for handling parameters in the Output objects that have behavior dependent
   * on whether the user modified the parameters.
   *
   */
  template &lt;typename T&gt;
  T &amp; set(const std::string &amp; name, bool quiet_mode = false);

  /**
   * Given a series of parameters names and values, sets each name to
   * the corresponding value.  Any number of name, value pairs can be
   * supplied.
   *
   * Note that each \p value must be of the correct type for the
   * parameter of that name, not merely of a type convertible to the
   * correct type.
   *
   * @param name The name of the first parameter to set
   */
  template &lt;typename T, typename... Ts&gt;
  void setParameters(const std::string &amp; name, const T &amp; value, Ts... extra_input_parameters);

  /**
   * Runs a range on the supplied parameter if it exists and throws an error if that check fails.
   * @returns Optional of whether or not the error is a user error (false = developer error) and
   * the associated error
   *
   * If \p include_param_path = true, include the parameter path in the error message
   */
  ///@{
  template &lt;typename T, typename UP_T&gt;
  std::optional&lt;std::pair&lt;bool, std::string&gt;&gt;
  rangeCheck(const std::string &amp; full_name,
             const std::string &amp; short_name,
             const InputParameters::Parameter&lt;T&gt; &amp; param,
             const bool include_param_path = true);
  template &lt;typename T, typename UP_T&gt;
  std::optional&lt;std::pair&lt;bool, std::string&gt;&gt;
  rangeCheck(const std::string &amp; full_name,
             const std::string &amp; short_name,
             const InputParameters::Parameter&lt;std::vector&lt;T&gt;&gt; &amp; param,
             const bool include_param_path = true);
  ///@}
  /**
   * Verifies that the requested parameter exists and is not NULL and returns it to the caller.
   * The template parameter must be a pointer or an error will be thrown.
   */
  template &lt;typename T&gt;
  T getCheckedPointerParam(const std::string &amp; name, const std::string &amp; error_string = &quot;&quot;) const;

  /**
   * This method adds a parameter and documentation string to the InputParameters
   * object that will be extracted from the input file.  If the parameter is
   * missing in the input file, an error will be thrown
   */
  template &lt;typename T&gt;
  void addRequiredParam(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * This version of addRequiredParam is here for a consistent use with MooseEnums.  Use of
   * this function for any other type will throw an error.
   */
  template &lt;typename T&gt;
  void
  addRequiredParam(const std::string &amp; name, const T &amp; moose_enum, const std::string &amp; doc_string);

  ///@{
  /**
   * These methods add an optional parameter and a documentation string to the InputParameters
   * object. The first version of this function takes a default value which is used if the parameter
   * is not found in the input file. The second method will leave the parameter uninitialized but
   * can be checked with &quot;isParamValid&quot; before use.
   */
  template &lt;typename T, typename S&gt;
  void addParam(const std::string &amp; name, const S &amp; value, const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addParam(const std::string &amp; name, const std::string &amp; doc_string);
  ///@}

  /**
   * Enable support for initializer lists as default arguments for container type.
   */
  template &lt;typename T&gt;
  void addParam(const std::string &amp; name,
                const std::initializer_list&lt;typename T::value_type&gt; &amp; value,
                const std::string &amp; doc_string)
  {
    addParam&lt;T&gt;(name, T{value}, doc_string);
  }

  ///@{
  // BEGIN RANGE CHECKED PARAMETER METHODS
  /**
   * These methods add an range checked parameters. A lower and upper bound can be supplied and the
   * supplied parameter will be checked to fall within that range.
   */
  template &lt;typename T&gt;
  void addRequiredRangeCheckedParam(const std::string &amp; name,
                                    const std::string &amp; parsed_function,
                                    const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const T &amp; value,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  // END RANGE CHECKED PARAMETER METHODS
  ///@}

  /**
   * These methods add an option parameter and with a customer type to the InputParameters object.
   * The custom type will be output in YAML dumps and can be used within the GUI application.
   */
  template &lt;typename T&gt;
  void addRequiredCustomTypeParam(const std::string &amp; name,
                                  const std::string &amp; custom_type,
                                  const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCustomTypeParam(const std::string &amp; name,
                          const T &amp; value,
                          const std::string &amp; custom_type,
                          const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCustomTypeParam(const std::string &amp; name,
                          const std::string &amp; custom_type,
                          const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addDeprecatedCustomTypeParam(const std::string &amp; name,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_msg);

  /**
   * These method add a parameter to the InputParameters object which can be retrieved like any
   * other parameter. This parameter however is not printed in the Input file syntax dump or web
   * page dump so does not take a documentation string.  The first version of this function takes an
   * optional default value.
   */
  template &lt;typename T&gt;
  void addPrivateParam(const std::string &amp; name, const T &amp; value);
  template &lt;typename T&gt;
  void addPrivateParam(const std::string &amp; name);

  /**
   * Add parameters for retrieval from the command line.
   *
   * NOTE: This ONLY works for App objects!  This is not valid for normal MOOSE objects!
   *
   * @param name The name of the parameter
   * @param syntax Space separated list of command-line switch syntax that can set this option
   * @param doc_string Documentation.  This will be shown for --help
   */
  template &lt;typename T&gt;
  void addRequiredCommandLineParam(const std::string &amp; name,
                                   const std::string &amp; syntax,
                                   const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const T &amp; value,
                           const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const std::initializer_list&lt;typename T::value_type&gt; &amp; value,
                           const std::string &amp; doc_string)
  {
    addCommandLineParam&lt;T&gt;(name, syntax, T{value}, doc_string);
  }

  /**
   * Add a command line parameter with an optional value.
   *
   * This is a deprecated option and only remains for two parameters:
   * &quot;mesh_only&quot; and &quot;recover&quot;. There are issues with command line
   * parameters with optional values because if a value following
   * one of these is a hit cli parameter, we don&#x27;t know if we should
   * apply it to the optional option or as a hit parameter.
   *
   * It is also allowed for &quot;run&quot; as we take all arguments past
   * --run and pass to python.
   *
   * @param name The name of the parameer
   * @param syntax Space separated list of command-line switch syntax that can set this option
   * @param value The default value to assign
   * @param doc_string Documentation.  This will be shown for --help
   */
  template &lt;typename T&gt;
  void addOptionalValuedCommandLineParam(const std::string &amp; name,
                                         const std::string &amp; syntax,
                                         const T &amp; value,
                                         const std::string &amp; doc_string);

  /**
   * Sets the command line parameter with \p name as global.
   *
   * Global here means that it will be passed to all child MultiApps.
   */
  void setGlobalCommandLineParam(const std::string &amp; name);

  /**
   * @param name The name of the parameter
   * @param value The default value of this parameter if it requires one
   * @param doc_string Documentation.  This will be shown for --help
   * @param deprecation_message The message that will will print about why this param was
   * deprecated.  It might mention the &quot;new way&quot;.
   */
  template &lt;typename T&gt;
  void addDeprecatedParam(const std::string &amp; name,
                          const T &amp; value,
                          const std::string &amp; doc_string,
                          const std::string &amp; deprecation_message);

  template &lt;typename T&gt;
  void addDeprecatedParam(const std::string &amp; name,
                          const std::string &amp; doc_string,
                          const std::string &amp; deprecation_message);

  /**
   * This method checks to make sure that we aren&#x27;t adding a parameter with the same name but a
   * different type.  It
   * throws a MooseError if an inconsistent type is detected. While this state is supported by
   * libMesh it brings
   * nothing but blood and tears for those who try ;)
   *
   * @param name the name of the parameter
   */
  template &lt;typename T&gt;
  void checkConsistentType(const std::string &amp; name) const;

  /**
   * @return Whether or not the parameter \p name is a command line parameter
   */
  bool isCommandLineParameter(const std::string &amp; name) const;

  /**
   * @return Queries for the command line metadata for the parameter \p name
   *
   * Will return an empty optional if the parameter is not a command line param.
   */
  std::optional&lt;InputParameters::CommandLineMetadata&gt;
  queryCommandLineMetadata(const std::string &amp; name) const;

  /**
   * @return The command line metadata for the parameter \p name.
   */
  const InputParameters::CommandLineMetadata &amp;
  getCommandLineMetadata(const std::string &amp; name) const;

  /**
   * Class that is used as a parameter to commandLineParamSet() that allows only
   * the CommandLine to set that a parmeter is set by the command line
   */
  class CommandLineParamSetKey
  {
    friend class CommandLine;
    FRIEND_TEST(InputParametersTest, commandLineParamSetNotCLParam);
    CommandLineParamSetKey() {}
    CommandLineParamSetKey(const CommandLineParamSetKey &amp;) {}
  };
  /**
   * Marks the command line parameter \p name as set by the CommandLine.
   *
   * Protected by the CommandLineParamSetKey so that only the CommandLine can call this.
   */
  void commandLineParamSet(const std::string &amp; name, const CommandLineParamSetKey);

  /**
   * Get the documentation string for a parameter
   */
  const std::string &amp; getDescription(const std::string &amp; name) const;

  /**
   * This method takes a space delimited list of parameter names and adds them to the specified
   * group name.
   * This information is used in the GUI to group parameters into logical sections.
   */
  void addParamNamesToGroup(const std::string &amp; space_delim_names, const std::string group_name);

  /**
   * This method renames a parameter group
   * @param old_name previous name of the parameter group
   * @param new_name new name of the parameter group
   */
  void renameParameterGroup(const std::string &amp; old_name, const std::string &amp; new_name);

  /**
   * This method retrieves the group name for the passed parameter name if one exists.  Otherwise an
   * empty string is returned.
   */
  std::string getGroupName(const std::string &amp; param_name) const;

  /**
   * This method suppresses an inherited parameter so that it isn&#x27;t required or valid
   * in the derived class. The parameter is added to the private parameter list.
   * Suppressing a parameter can have dire consequences.
   * Use at your own risk!
   */
  template &lt;typename T&gt;
  void suppressParameter(const std::string &amp; name);

  /**
   * Changes the parameter to be required.
   * @param name The parameter name
   */
  template &lt;typename T&gt;
  void makeParamRequired(const std::string &amp; name);

  /**
   * Changes the parameter to not be required.
   * @param name The parameter name
   */
  template &lt;typename T&gt;
  void makeParamNotRequired(const std::string &amp; name);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   */
  void addCoupledVar(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * This method adds a deprecated coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found. The doc string for the deprecated variable will be
   * constructed from the doc string for the new variable. A deprecation message will also be
   * automatically generated
   */
  void addDeprecatedCoupledVar(const std::string &amp; old_name,
                               const std::string &amp; new_name,
                               const std::string &amp; removal_date = &quot;&quot;);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   *
   * Also - you can provide a default value for this variable in the case that an actual variable is
   * not provided.
   */
  void addCoupledVar(const std::string &amp; name, const Real value, const std::string &amp; doc_string);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   *
   * Also - you can provide a vector of values for this variable in the case that an actual variable
   * is not provided.
   */
  void addCoupledVar(const std::string &amp; name,
                     const std::vector&lt;Real&gt; &amp; value,
                     const std::string &amp; doc_string);

  ///@{
  /**
   * These methods add a coupled variable name pair. The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found.
   *
   * This version of the method will build a vector if the given the base_name and num_name
   * parameters exist
   * in the input file:
   *   e.g.
   *   [./foo]
   *     ...
   *     some_base = base_
   *     some_num  = 5
   *   [../]
   *
   *   # The coupling parameter will be passed this vector: &quot;base_0 base_1 base_2 base_3 base_4&quot;
   */
  void addCoupledVarWithAutoBuild(const std::string &amp; name,
                                  const std::string &amp; base_name,
                                  const std::string &amp; num_name,
                                  const std::string &amp; doc_string);
  void addRequiredCoupledVarWithAutoBuild(const std::string &amp; name,
                                          const std::string &amp; base_name,
                                          const std::string &amp; num_name,
                                          const std::string &amp; doc_string);
  ///@}

  /**
   * Utility functions for retrieving one of the MooseTypes variables into the common &quot;string&quot; base
   * class.
   * Scalar and Vector versions are supplied
   */
  std::string getMooseType(const std::string &amp; name) const;
  std::vector&lt;std::string&gt; getVecMooseType(const std::string &amp; name) const;

  /**
   * @returns Whether or not these parameters are for a MooseBase object, that is,
   * one with a name and type.
   *
   * Needed so that we can produce richer errors from within InputParameters
   * that have the context of the underlying object, if possible.
   */
  bool isMooseBaseObject() const;

  /**
   * @return The object type represented by these parameters, if any
   */
  const std::string * queryObjectType() const;

  /**
   * @returns The underlying owning object type, for MooseBase objects with parameters
   *
   * Will error if a type does not exist
   */
  const std::string &amp; getObjectType() const;
  /**
   * @returns The underlying owning object name, for MooseBase objects with parameters
   */
  const std::string &amp; getObjectName() const;

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable.  If the coupled variable is not supplied in the input
   * file, and error is thrown.
   *
   * Version 2: An auto built vector will be built from the base_name and num_name param. See
   * addCoupledVar for an example
   */
  void addRequiredCoupledVar(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * Returns the documentation string for the specified parameter name
   */
  std::string getDocString(const std::string &amp; name) const;

  /**
   * Set the doc string of a parameter.
   *
   * This method is generally used from within the validParams function to modify the documentation
   * for an
   * existing parameter, such as a parameter that is supplied from an interface class.
   */
  void setDocString(const std::string &amp; name, const std::string &amp; doc);

  /**
   * Returns the documentation unit string for the specified parameter name
   */
  std::string getDocUnit(const std::string &amp; name) const;

  /**
   * Set the unit string of a parameter.
   *
   * This method is only used within MooseDocs and the input syntax dump in order to provide a
   * developer-expected unit for software quality assurance purposes.
   */
  void setDocUnit(const std::string &amp; name, const std::string &amp; doc_unit);

  /**
   * Returns a boolean indicating whether the specified parameter is required or not
   */
  bool isParamRequired(const std::string &amp; name) const;

  /**
   * Forces parameter of given name to be not required regardless of type
   */
  void makeParamNotRequired(const std::string &amp; name);

  /**
   * This method returns parameters that have been initialized in one fashion or another,
   * i.e. The value was supplied as a default argument or read and properly converted from
   * the input file
   */
  bool isParamValid(const std::string &amp; name) const;

  /**
   * Returns whether or not the parameter was set due to addParam. If not then it was either set
   * programmatically
   * or was read through the input file.
   */
  bool isParamSetByAddParam(const std::string &amp; name) const;

  /**
   * Returns True if the parameters is deprecated.
   */
  bool isParamDeprecated(const std::string &amp; name) const;

  /**
   * This method returns true if all of the parameters in this object are valid
   * (i.e. isParamValid(name) == true - for all parameters)
   */
  bool areAllRequiredParamsValid() const;

  /**
   * Prints the type of the requested parameter by name
   */
  std::string type(const std::string &amp; name) const;

  /**
   * Returns a Boolean indicating whether the specified parameter is private or not
   */
  bool isPrivate(const std::string &amp; name) const;

  /**
   * Declare the given parameters as controllable
   */
  void declareControllable(const std::string &amp; name, std::set&lt;ExecFlagType&gt; execute_flags = {});

  /**
   * Marker a parameter that has been changed by the Control system (this is for output purposes)
   */
  void markControlled(const std::string &amp; name);

  /**
   * Returns a Boolean indicating whether the specified parameter is controllable
   */
  bool isControllable(const std::string &amp; name) const;

  /**
   * Return the allowed execute flags for a controllable parameter
   */
  const std::set&lt;ExecFlagType&gt; &amp; getControllableExecuteOnTypes(const std::string &amp; name) const;

  /**
   * This method must be called from every base &quot;Moose System&quot; to create linkage with the Action
   * System.
   * See &quot;Moose.C&quot; for the registerMooseObjectTask() calls.
   */
  void registerBase(const std::string &amp; value);

  /**
   * @return Whether or not the object has a registered base
   *
   * The base is registered with registerBase()
   */
  bool hasBase() const;

  /**
   * @return The base system of the object these parameters are for, if any
   *
   * Set via registerBase().
   */
  const std::string &amp; getBase() const;

  /**
   * This method is used to define the MOOSE system name that is used by the TheWarehouse object
   * for storing objects to be retrieved for execution. The base class of every object class
   * that will be called for execution (e.g., UserObject objects) should call this method.
   *
   * This is different from registerBase because the name supplied to registerBase is used to
   * associate syntax, but the objects created often go to the same objects for execution, as is
   * the case for Postprocessor object which are executed with UserObjects.
   *
   * See the AttribSystem object for use Attribute.h/C.
   */
  void registerSystemAttributeName(const std::string &amp; value);

  /**
   * Get the system attribute name if it was registered. Otherwise throw an error.
   * See the AttribSystem object for use Attribute.h/C.
   */
  const std::string &amp; getSystemAttributeName() const;

  /**
   * This method is here to indicate which Moose types a particular Action may build. It takes a
   * space delimited list of registered MooseObjects.  TODO: For now we aren&#x27;t actually checking
   * this list when we build objects. Since individual actions can do whatever they want it&#x27;s not
   * exactly trivial to check this without changing the user API.  This function properly restricts
   * the syntax and YAML dumps.
   */
  void registerBuildableTypes(const std::string &amp; names);

  /**
   * Tells MOOSE about a RelationshipManager that this object needs.  RelationshipManagers
   * handle element &quot;ghosting&quot;, &quot;non-local DOF access&quot; and &quot;sparsity pattern&quot; relationships.
   *
   * Basically: if this object needs non-local (ie non-current-element) data access then you
   * probably need a relationship manager
   *
   * @param name The name of the RelationshipManager type
   * @param rm_type The type (GEOMETRIC/ALGEBRAIC) of the RelationshipManger.  Note: You can use
   * boolean logic to to &quot;or&quot; RelationshipManagerTypes together to make a RelationshipManager that
   * is multi-typed.
   * @param input_parameter_callback This is a function pointer that will get called to fill in the
   * RelationShipManager&#x27;s InputParameters.  See MooseTypes.h for the signature of this function.
   */
  void addRelationshipManager(
      const std::string &amp; name,
      Moose::RelationshipManagerType rm_type,
      Moose::RelationshipManagerInputParameterCallback input_parameter_callback = nullptr);

  /**
   * Clears all currently registered RelationshipManagers
   */
  void clearRelationshipManagers() { _buildable_rm_types.clear(); }

  /**
   * Returns the list of buildable types as a std::vector&lt;std::string&gt;
   */
  const std::vector&lt;std::string&gt; &amp; getBuildableTypes() const;

  /**
   * Returns the list of buildable (or required) RelationshipManager object types for this object.
   */
  const std::vector&lt;std::tuple&lt;std::string,
                               Moose::RelationshipManagerType,
                               Moose::RelationshipManagerInputParameterCallback&gt;&gt; &amp;
  getBuildableRelationshipManagerTypes() const;

  ///@{
  /**
   * Mutators for controlling whether or not the outermost level of syntax will be collapsed when
   * printed.
   */
  void collapseSyntaxNesting(bool collapse);
  bool collapseSyntaxNesting() const;
  ///@}

  ///@{
  /**
   * Mutators for controlling whether or not the outermost level of syntax will be collapsed when
   * printed.
   */
  void mooseObjectSyntaxVisibility(bool visibility);
  bool mooseObjectSyntaxVisibility() const;
  ///@}

  ///@{
  /**
   * Copy and Copy/Add operators for the InputParameters object
   */
  using Parameters::operator=;
  using Parameters::operator+=;
  InputParameters &amp; operator=(const InputParameters &amp; rhs);
  InputParameters &amp; operator+=(const InputParameters &amp; rhs);
  ///@}

  /**
   * This function checks parameters stored in the object to make sure they are in the correct
   * state as the user expects:
   *   Required parameters are verified as valid meaning that they were either initialized when
   *   they were created, or were read from an input file or some other valid source
   */
  void checkParams(const std::string &amp; parsing_syntax);

  /**
   * Performs a range check on the parameter (which must have a range check)
   *
   * @param value The parameter value
   * @param long_name The full path to the parameter
   * @param short_name The name of the parameter
   * @param include_param_path Whether or not to include the parameter path in errors
   * @return An error, if any; first is whether or not it is a user error and second is the message
   */
  std::optional&lt;std::pair&lt;bool, std::string&gt;&gt; parameterRangeCheck(const Parameters::Value &amp; value,
                                                                  const std::string &amp; long_name,
                                                                  const std::string &amp; short_name,
                                                                  const bool include_param_path);

  /**
   * Finalizes the parameters, which must be done before constructing any objects
   * with these parameters (to be called in the corresponding factories).
   * typed parameters.
   *
   * This calls checkParams() and sets up the absolute paths for all file name.
   */
  void finalize(const std::string &amp; parsing_syntax);

  /**
   * @return A file base to associate with these parameters.
   *
   * Optionally, an input parameter can be provided via \p param_name.
   *
   * If the parameter is provided, we have the following options:
   * - The parameter itself has a hit node set (context for that parameter)
   * - The InputParameters object has a hit node set (context for all parameters)
   * - Neither of the above and we die
   *
   * In the event that a the parameter is set via command line, this will
   * attempt to look at the parameter&#x27;s parents to find a suitable context.
   */
  std::filesystem::path
  getFileBase(const std::optional&lt;std::string&gt; &amp; param_name = std::optional&lt;std::string&gt;()) const;

  /**
   * Methods returning iterators to the coupled variables names stored in this
   * InputParameters object
   */
  inline std::set&lt;std::string&gt;::const_iterator coupledVarsBegin() const
  {
    return _coupled_vars.begin();
  }
  inline std::set&lt;std::string&gt;::const_iterator coupledVarsEnd() const
  {
    return _coupled_vars.end();
  }

  /**
   * Return the coupled variable parameter names.
   */
  const std::set&lt;std::string&gt; &amp; getCoupledVariableParamNames() const { return _coupled_vars; }

  /**
   * Return the new to deprecated variable name map
   */
  const std::unordered_map&lt;std::string, std::string&gt; &amp; getNewToDeprecatedVarMap() const
  {
    return _new_to_deprecated_coupled_vars;
  }

  /// Return whether a parameter has a range check
  bool isRangeChecked(const std::string &amp; param_name) const;

  /// Return the range check function for any parameter (empty string if it is not range checked)
  std::string rangeCheckedFunction(const std::string &amp; name) const;

  /// Return whether a parameter has a default
  bool hasDefault(const std::string &amp; param_name) const;

  /**
   * Return whether or not the coupled variable exists
   * @param coupling_name The name of the coupled variable to test for
   * @return True if the variable exists in the coupled variables for this InputParameters object
   */
  bool hasCoupledValue(const std::string &amp; coupling_name) const;

  /**
   * Return whether or not the requested parameter has a default coupled value.
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   */
  bool hasDefaultCoupledValue(const std::string &amp; coupling_name) const;

  /**
   * Get the default value for an optionally coupled variable.
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   * @param i By default 0, in general the index of the requested coupled default value.
   */
  Real defaultCoupledValue(const std::string &amp; coupling_name, unsigned int i = 0) const;

  /**
   * Get the number of defaulted coupled value entries
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   */
  unsigned int numberDefaultCoupledValues(const std::string &amp; coupling_name) const;

  /**
   * Set the default value for an optionally coupled variable (called by the Parser).
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   * @param value Default value to set.
   * @param i By default 0, in general the index of the requested coupled default value.
   */
  void defaultCoupledValue(const std::string &amp; coupling_name, Real value, unsigned int i = 0);

  /**
   * Returns the auto build vectors for all parameters.
   */
  std::map&lt;std::string, std::pair&lt;std::string, std::string&gt;&gt; getAutoBuildVectors() const;

  // BEGIN APPLY PARAMETER METHODS
  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param exclude A vector of parameters to exclude
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must be valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private (unless \p allow_private = true)
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applyParameters(const InputParameters &amp; common,
                       const std::vector&lt;std::string&gt; &amp; exclude = {},
                       const bool allow_private = false);

  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param include A vector of parameters to apply
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applySpecificParameters(const InputParameters &amp; common,
                               const std::vector&lt;std::string&gt; &amp; include,
                               bool allow_private = false);

  /**
   * Apply values from a single parameter in common, to a single parameter stored in this object
   * @param common The set of InputParameters from which to extract parameters from
   * @param common_name The name within common from which to get the parameter values
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (except if override_default is set)
   *   (4) Both cannot be private
   */
  void applyParameter(const InputParameters &amp; common,
                      const std::string &amp; common_name,
                      bool allow_private = false,
                      bool override_default = false);
  // END APPLY PARAMETER METHODS

  /**
   * Apply properties of a single coupled variable in common, to a single coupled variable stored in
   * this object
   * @param common The set of InputParameters from which to extract the coupled variable&#x27;s
   * properties
   * @param var_name The name of the coupled variable whose properties are to be applied
   *
   * In order to apply the properties, both the local parameters and the common parameters must
   * have a coupled variable with name var_name
   */
  void applyCoupledVar(const InputParameters &amp; common, const std::string &amp; var_name);

  /**
   * Deprecated method.  Use isParamSetByUser() instead.
   */
  bool paramSetByUser(const std::string &amp; name) const;

  /**
   * Method returns true if the parameter was set by the user
   * @param name The parameter name
   */
  bool isParamSetByUser(const std::string &amp; name) const;

  /**
   * Method returns true if the parameter is defined for any type. If the
   * type is known, use have_parameter&lt;T&gt;() instead.
   * @param name The parameter name
   */
  bool isParamDefined(const std::string &amp; name) const;

  ///@{
  /*
   * These methods are here to retrieve parameters for scalar and vector types respectively. We will
   * throw errors
   * when returning most scalar and vector types.
   */
  template &lt;typename T&gt;
  static const T &amp; getParamHelper(const std::string &amp; name, const InputParameters &amp; pars);
  ///@}

  using Parameters::get;

  /// Combine two vector parameters into a single vector of pairs
  template &lt;typename R1,
            typename R2,
            typename V1 = typename std::conditional&lt;std::is_same&lt;R1, MooseEnumItem&gt;::value,
                                                    MultiMooseEnum,
                                                    std::vector&lt;R1&gt;&gt;::type,
            typename V2 = typename std::conditional&lt;std::is_same&lt;R2, MooseEnumItem&gt;::value,
                                                    MultiMooseEnum,
                                                    std::vector&lt;R2&gt;&gt;::type&gt;
  std::vector&lt;std::pair&lt;R1, R2&gt;&gt; get(const std::string &amp; param1, const std::string &amp; param2) const;

  /**
   * @returns list of all parameters
   */
  std::set&lt;std::string&gt; getParametersList() const;

  /**
   * Return list of controllable parameters
   */
  std::set&lt;std::string&gt; getControllableParameters() const;

  /**
   * Return names of parameters within a group.
   */
  std::set&lt;std::string&gt; getGroupParameters(const std::string &amp; group) const;

  /**
   * Provide a set of reserved values for a parameter. These are values that are in addition
   * to the normal set of values the parameter can take.
   */
  void setReservedValues(const std::string &amp; name, const std::set&lt;std::string&gt; &amp; reserved);

  /**
   * Get a set of reserved parameter values.
   * Returns a set by value since we can return an empty set.
   */
  std::set&lt;std::string&gt; reservedValues(const std::string &amp; name) const;

  /**
   * @return A string representing the location (i.e. filename,linenum) in the input text for the
   * block containing parameters for this object.
   */
  std::string blockLocation() const;

  /**
   * @return A string representing the full HIT parameter path from the input file (e.g.
   * &quot;Mesh/foo&quot;) for the block containing parameters for this object.
   */
  std::string blockFullpath() const;

  /**
   * @return The hit node associated with setting the parameter \p param, if any
   */
  const hit::Node * getHitNode(const std::string &amp; param) const;
  /**
   * Sets the hit node associated with the parameter \p param to \p node
   *
   * Is protected to be called by only the Builder via the SetParamHitNodeKey.
   */
  void setHitNode(const std::string &amp; param, const hit::Node &amp; node, const SetParamHitNodeKey);

  /**
   * @return A string representing the location in the input text the parameter originated from
   * (i.e. filename,linenum) for the given param
   */
  std::string inputLocation(const std::string &amp; param) const;

  /**
   * @return A string representing the full HIT parameter path from the input file (e.g.
   * &quot;Mesh/foo/bar&quot; for param &quot;bar&quot;) for the given param.
   */
  std::string paramFullpath(const std::string &amp; param) const;

  /**
   * Returns a prefix containing the parameter name and location (if available)
   */
  std::string paramLocationPrefix(const std::string &amp; param) const;

  /**
   * @return A message used as a prefix for output relating to a parameter.
   *
   * Will first prefix with a path to the parameter, or the parameter that
   * resulted in the creation of these parameters, if available. The message
   * will then be prefixed with the block path to the parameter, if available.
   */
  template &lt;typename... Args&gt;
  std::string paramMessage(const std::string &amp; param, Args... args) const;

  /**
   * Emits an error prefixed with the object information, if available.
   */
  template &lt;typename... Args&gt;
  [[noreturn]] void mooseError(Args &amp;&amp;... args) const;

  /**
   * Emits a parameter error prefixed with the parameter location and
   * object information if available.
   */
  template &lt;typename... Args&gt;
  [[noreturn]] void paramError(const std::string &amp; param, Args... args) const;

  /**
   * @return A string representing the raw, unmodified token text for the given param.
   * This is only set if this parameter is parsed from hit
   */
  std::string rawParamVal(const std::string &amp; param) const;

  /**
   * Informs this object that values for this parameter set from the input file or from the command
   * line should be ignored
   */
  template &lt;typename T&gt;
  void ignoreParameter(const std::string &amp; name);

  /**
   * Whether to ignore the value of an input parameter set in the input file or from the command
   * line.
   */
  bool shouldIgnore(const std::string &amp; name);

  /**
   * @returns True if the parameter with name \p name is of type T.
   */
  template &lt;typename T&gt;
  bool isType(const std::string &amp; name) const;

  /**
   * Determine the actual variable name from the given variable \emph parameter name
   * @param var_param_name the name of the variable parameter, e.g. &#x27;variable&#x27;
   * @param moose_object_with_var_param_name the name of the moose object holding the variable
   * parameter. Used for potential error messaging
   */
  std::string varName(const std::string &amp; var_param_name,
                      const std::string &amp; moose_object_with_var_param_name) const;

  /**
   * Rename a parameter and provide a new documentation string
   * @param old_name The old name of the parameter
   * @param new_name The new name of the parameter
   * @param new_docstring The new documentation string for the parameter
   *                      If left empty, uses the old docstring for the renamed parameter
   */
  void renameParam(const std::string &amp; old_name,
                   const std::string &amp; new_name,
                   const std::string &amp; new_docstring);

  /**
   * Rename a coupled variable and provide a new documentation string
   * @param old_name The old name of the coupled variable
   * @param new_name The new name of the coupled variable
   * @param new_docstring The new documentation string for the coupled variable
   */
  void renameCoupledVar(const std::string &amp; old_name,
                        const std::string &amp; new_name,
                        const std::string &amp; new_docstring);

  void deprecateParam(const std::string &amp; old_name,
                      const std::string &amp; new_name,
                      const std::string &amp; removal_date);

  void deprecateCoupledVar(const std::string &amp; old_name,
                           const std::string &amp; new_name,
                           const std::string &amp; removal_date);

  /**
   * Checks whether the provided name is a renamed parameter name. If so we return the &#x27;new&#x27; name.
   * If not we return the incoming name
   * @param name The name to check for whether it is a renamed name
   * @return The new name if the incoming \p name is a renamed name, else \p name
   */
  std::string checkForRename(const std::string &amp; name) const;

  /**
   * A wrapper around the \p Parameters base class method. Checks for parameter rename before
   * calling the base class method
   * @param name The name to query the parameter values map with
   * @return The parameter value corresponding to the (possibly renamed) name
   */
  template &lt;typename T&gt;
  const T &amp; get(std::string_view name) const;

  /**
   * A wrapper around the \p Parameters base class method. Checks for parameter rename before
   * calling the base class method. This method tells whether a parameter with a known type is
   * defined. If the type is unknown, use isParamDefined().
   * @param name The name to query the parameter values map with
   * @return Whether there is a key in the parameter values map corresponding to the (possibly
   * renamed) name
   */
  template &lt;typename T&gt;
  bool have_parameter(std::string_view name) const;

  /**
   * A routine to transfer a parameter from one class&#x27; validParams to another
   * @param source_param The parameters list holding the param we would like to transfer
   * @param name The name of the parameter to transfer
   * @param new_description A new description of the parameter. If unspecified, uses the
   * source_params&#x27;
   */
  template &lt;typename T&gt;
  void transferParam(const InputParameters &amp; source_param,
                     const std::string &amp; name,
                     const std::string &amp; new_name = &quot;&quot;,
                     const std::string &amp; new_description = &quot;&quot;);

  /**
   * Return all the aliased names associated with \p param_name. The returned container will always
   * contain \p param_name itself. Other aliases in addition to \p param_name will include the base
   * class parameter name if \p param_name is the derived class parameter name, or deprecated names
   * that \p param_name is meant to replace.
   * @param param_name The name of the parameter that we want to lookup aliases for. This parameter
   * name must exist in our metadata and parameter names to values map, e.g. this parameter must
   * represent the derived class parameter name if a base class parameter has been renamed or the
   * blessed parameter name in situations where associated parameter names have been deprecated
   * @return All aliases which logically resolve-to/are-associated-with \p param_name, including \p
   * param_name itself
   */
  std::vector&lt;std::string&gt; paramAliases(const std::string &amp; param_name) const;

  /**
   * @return The hit node that represents the syntax responsible for creating
   * these parameters, if any
   */
  const hit::Node * getHitNode() const { return _hit_node; }
  /**
   * Sets the hit node that represents the syntax responsible for creating
   * these parameters
   *
   * Is protected to be called by only the ActionFactory, Builder, and Factory
   * via the SetHitNodeKey.
   */
  void setHitNode(const hit::Node &amp; node, const SetHitNodeKey) { _hit_node = &amp;node; }

  /**
   * @return Whether or not finalize() has been called
   */
  bool isFinalized() const { return _finalized; }

  /**
   * @return The DataFileName path for the parameter \p name (if any).
   */
  std::optional&lt;Moose::DataFileUtils::Path&gt; queryDataFileNamePath(const std::string &amp; name) const;

  /**
   * Entrypoint for the Builder to setup a std::vector&lt;VariableName&gt; parameter,
   * which will setup the default variable names if appropriate
   *
   * @param names The variable names
   * @param node The hit node that produced this parameter
   * @return An error message, if any
   */
  std::optional&lt;std::string&gt; setupVariableNames(std::vector&lt;VariableName&gt; &amp; names,
                                                const hit::Node &amp; node,
                                                const Moose::PassKey&lt;Moose::Builder&gt;);

private:
  // Private constructor so that InputParameters can only be created in certain places.
  InputParameters();

  /**
   * Method to terminate the recursive setParameters definition
   */
  void setParameters() {}

  template &lt;typename T&gt;
  static constexpr bool isFunctorNameType();

  /**
   * Appends description of what a functor is to a doc string.
   */
  template &lt;typename T&gt;
  std::string appendFunctorDescription(const std::string &amp; doc_string) const;

  /**
   * Private method for setting deprecated coupled variable documentation strings
   */
  void setDeprecatedVarDocString(const std::string &amp; new_name, const std::string &amp; doc_string);

  void renameParamInternal(const std::string &amp; old_name,
                           const std::string &amp; new_name,
                           const std::string &amp; docstring,
                           const std::string &amp; removal_date);

  void renameCoupledVarInternal(const std::string &amp; old_name,
                                const std::string &amp; new_name,
                                const std::string &amp; docstring,
                                const std::string &amp; removal_date);

  /**
   * Get the context associated with a parameter for a message.
   * @param param The parameter name
   * @return Pair that is the string prefix for the parameter (fullpath) and a pointer to the best
   * hit node that can be associated with the parameter (if any)
   */
  std::pair&lt;std::string, const hit::Node *&gt; paramMessageContext(const std::string &amp; param) const;
  /**
   * Get a prefix for messages associated with a parameter.
   *
   * Will include the best file path possible for the parameter and the parameter&#x27;s fullpath.
   */
  std::string paramMessagePrefix(const std::string &amp; param) const;

  struct Metadata
  {
    std::string _doc_string;
    /// The developer-designated unit of the parameter for use in documentation
    std::string _doc_unit;
    /// The custom type that will be printed in the YAML dump for a parameter if supplied
    std::string _custom_type;
    /// The data pertaining to a command line parameter (empty if not a command line param)
    std::optional&lt;CommandLineMetadata&gt; _cl_data;
    /// The searched path information pertaining to a DataFileName parameter
    std::optional&lt;Moose::DataFileUtils::Path&gt; _data_file_name_path;
    /// The names of the parameters organized into groups
    std::string _group;
    /// The map of functions used for range checked parameters
    std::string _range_function;
    /// directions for auto build vectors (base_, 5) -&gt; &quot;base_0 base_1 base_2 base_3 base_4&quot;)
    std::pair&lt;std::string, std::string&gt; _autobuild_vecs;
    /// True for parameters that are required (i.e. will cause an abort if not supplied)
    bool _required = false;
    /**
     * Whether the parameter is either explicitly set or provided a default value when added
     * Note: We do not store MooseEnum names in valid params, instead we ask MooseEnums whether
     *       they are valid or not.
     */
    bool _valid = false;
    /// The set of parameters that will NOT appear in the the dump of the parser tree
    bool _is_private = false;
    bool _have_coupled_default = false;
    /// The default value for optionally coupled variables
    std::vector&lt;Real&gt; _coupled_default = {0};
    /// True if a parameters value was set by addParam, and not set again.
    bool _set_by_add_param = false;
    /// The reserved option names for a parameter
    std::set&lt;std::string&gt; _reserved_values;
    /// If non-empty, this parameter is deprecated.
    std::string _deprecation_message;
    /// Original location of parameter node; used for error messages
    const hit::Node * _hit_node;
    /// True if the parameters is controllable
    bool _controllable = false;
    /// Controllable execute flag restriction
    std::set&lt;ExecFlagType&gt; _controllable_flags;
    /// whether user setting of this parameter should be ignored
    bool _ignore = false;
  };

  Metadata &amp; at(const std::string &amp; param_name)
  {
    const auto param = checkForRename(param_name);
    if (_params.count(param) == 0)
      mooseError(&quot;param &#x27;&quot;, param, &quot;&#x27; not present in InputParams&quot;);
    return _params[param];
  }
  const Metadata &amp; at(const std::string &amp; param_name) const
  {
    const auto param = checkForRename(param_name);
    if (_params.count(param) == 0)
      mooseError(&quot;param &#x27;&quot;, param, &quot;&#x27; not present in InputParams&quot;);
    return _params.at(param);
  }

  /**
   * Toggle the availability of the copy constructor
   *
   * When MooseObject is created via the Factory this flag is set to false, so when a MooseObject is
   * created if
   * the constructor is not a const reference an error is produced. This method allows the
   * InputParameterWarehouse
   * to disable copying.
   */
  void allowCopy(bool status) { _allow_copy = status; }

  /**
   * Make sure the parameter name doesn&#x27;t have any invalid characters.
   */
  void checkParamName(const std::string &amp; name) const;

  /**
   * This method is called when adding a Parameter with a default value, can be specialized for
   * non-matching types.
   */
  template &lt;typename T, typename S&gt;
  void setParamHelper(const std::string &amp; name, T &amp; l_value, const S &amp; r_value);

  /**
   * Helper for all of the addCommandLineParam() calls, which sets up _cl_data in the metadata
   *
   * @param name The parameter name
   * @param syntax The parameter syntax
   * @param required Whether or not the parameter is required
   * @param value_required Whethre or not the parameter requires a value
   */
  template &lt;typename T&gt;
  void addCommandLineParamHelper(const std::string &amp; name,
                                 const std::string &amp; syntax,
                                 const bool required,
                                 const bool value_required);

  /**
   * Internal helper for calling back to mooseError(), ideally from the underlying
   * MooseBase object if it is available (for more context)
   */
  [[noreturn]] void callMooseError(std::string msg,
                                   const bool with_prefix = true,
                                   const hit::Node * node = nullptr) const;

  /// The actual parameter data. Each Metadata object contains attributes for the corresponding
  /// parameter.
  std::map&lt;std::string, Metadata&gt; _params;

  /// The coupled variables set
  std::set&lt;std::string&gt; _coupled_vars;

  /// The class description for the owning object. This string is used in many places including
  /// mouse-over events, and external documentation produced from the source code.
  std::string _class_description;

  /// The parameter is used to restrict types that can be built.  Typically this is used for
  /// MooseObjectAction derived Actions.
  std::vector&lt;std::string&gt; _buildable_types;

  /// The RelationshipManagers that this object may either build or require.
  /// The optional second argument may be supplied to &quot;downgrade&quot; the functionality of the corresponding
  /// relationship manager (e.g. An AlgebraicRelationshipManager could be only used as a
  /// GeometricRelationshipManager for a given simulation).
  std::vector&lt;std::tuple&lt;std::string,
                         Moose::RelationshipManagerType,
                         Moose::RelationshipManagerInputParameterCallback&gt;&gt;
      _buildable_rm_types;

  /// This parameter collapses one level of nesting in the syntax blocks.  It is used
  /// in conjunction with MooseObjectAction derived Actions.
  bool _collapse_nesting;

  /// This parameter hides derived MOOSE object types from appearing in syntax dumps
  bool _moose_object_syntax_visibility;

  /// Flag for disabling deprecated parameters message, this is used by applyParameters to avoid
  /// dumping messages.
  bool _show_deprecated_message;

  /// A flag for toggling the error message in the copy constructor.
  bool _allow_copy;

  /// A map from deprecated coupled variable names to the new blessed name
  std::unordered_map&lt;std::string, std::string&gt; _new_to_deprecated_coupled_vars;

  /// A map from base-class/deprecated parameter names to derived-class/blessed parameter names and
  /// the deprecation messages in the case that the &quot;old&quot; parameter name is a deprecated parameter
  /// name. The deprecation message will be empty if the &quot;old&quot; parameter name represents a base
  /// class parameter name
  std::map&lt;std::string, std::pair&lt;std::string, std::string&gt;&gt; _old_to_new_name_and_dep;

  /// A map from derived-class/blessed parameter names to associated base-class/deprecated parameter
  /// names
  std::multimap&lt;std::string, std::string&gt; _new_to_old_names;

  /// The hit node representing the syntax that created these parameters, if any
  const hit::Node * _hit_node;

  /// Whether or not we&#x27;ve called finalize() on these parameters yet
  bool _finalized;

  // These are the only objects allowed to _create_ InputParameters
  friend InputParameters emptyInputParameters();
  friend class InputParameterWarehouse;
  friend class Parser;
  // for the printInputFile function in the action warehouse
  friend class ActionWarehouse;
};

template &lt;typename T&gt;
void
InputParameters::setHelper(const std::string &amp; /*name*/)
{
}

// Template and inline function implementations
template &lt;typename T&gt;
T &amp;
InputParameters::set(const std::string &amp; name_in, bool quiet_mode)
{
  const auto name = checkForRename(name_in);

  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  T &amp; result = this-&gt;Parameters::set&lt;T&gt;(name);

  if (quiet_mode)
    _params[name]._set_by_add_param = true;

  setHelper&lt;T&gt;(name);

  return result;
}

template &lt;typename T, typename... Ts&gt;
void
InputParameters::setParameters(const std::string &amp; name,
                               const T &amp; value,
                               Ts... extra_input_parameters)
{
  this-&gt;set&lt;T&gt;(name) = value;
  this-&gt;setParameters(extra_input_parameters...);
}

template &lt;typename T, typename UP_T&gt;
std::optional&lt;std::pair&lt;bool, std::string&gt;&gt;
InputParameters::rangeCheck(const std::string &amp; full_name,
                            const std::string &amp; short_name,
                            const InputParameters::Parameter&lt;std::vector&lt;T&gt;&gt; &amp; param,
                            const bool include_param_path)
{
  if (!isParamValid(short_name))
    return {};

  const auto &amp; range_function = _params[short_name]._range_function;
  if (range_function.empty())
    return {};

  /**
   * Automatically detect the variables used in the range checking expression.
   * We allow the following variables (where snam is the short_name of the parameter)
   *
   * snam       : tests every component in the vector
   *              &#x27;snam &gt; 0&#x27;
   * snam_size  : the size of the vector
   *              &#x27;snam_size = 5&#x27;
   * snam_i     : where i is a number from 0 to sname_size-1 tests a specific component
   *              &#x27;snam_0 &gt; snam_1&#x27;
   */
  FunctionParserBase&lt;UP_T&gt; fp;
  std::vector&lt;std::string&gt; vars;
  if (fp.ParseAndDeduceVariables(range_function, vars) != -1) // -1 for success
    return {{false,
             &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27; for parameter &quot; + short_name + &quot;&quot;}};

  // Fparser parameter buffer
  std::vector&lt;UP_T&gt; parbuf(vars.size());

  // parameter vector
  const std::vector&lt;T&gt; &amp; value = param.get();

  // iterate over all vector values (maybe ;)
  bool need_to_iterate = false;
  unsigned int i = 0;
  do
  {
    // set parameters
    for (unsigned int j = 0; j &lt; vars.size(); j++)
    {
      if (vars[j] == short_name)
      {
        if (value.size() == 0)
        {
          std::ostringstream oss;
          oss &lt;&lt; &quot;Range checking empty vector&quot;;
          if (include_param_path)
            oss &lt;&lt; &quot; parameter &quot; &lt;&lt; full_name;
          oss &lt;&lt; &quot;; expression = &#x27;&quot; &lt;&lt; range_function &lt;&lt; &quot;&#x27;&quot;;
          return {{true, oss.str()}};
        }

        parbuf[j] = value[i];
        need_to_iterate = true;
      }
      else if (vars[j] == short_name + &quot;_size&quot;)
        parbuf[j] = value.size();
      else
      {
        if (vars[j].substr(0, short_name.size() + 1) != short_name + &quot;_&quot;)
          return {{false, &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27;&quot;}};
        std::istringstream iss(vars[j]);
        iss.seekg(short_name.size() + 1);

        size_t index;
        if (iss &gt;&gt; index &amp;&amp; iss.eof())
        {
          if (index &gt;= value.size())
          {
            std::ostringstream oss;
            oss &lt;&lt; &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27;&quot;;
            if (include_param_path)
              oss &lt;&lt; &quot; for parameter &quot; &lt;&lt; full_name;
            oss &lt;&lt; &quot;; out of range variable &#x27;&quot; + vars[j] &lt;&lt; &quot;&#x27;&quot;;
            return {{true, oss.str()}};
          }
          parbuf[j] = value[index];
        }
        else
          return {{false,
                   &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27;; invalid variable &#x27;&quot; +
                       vars[j] + &quot;&#x27;&quot;}};
      }
    }

    // ensure range-checked input file parameter comparison functions
    // do absolute floating point comparisons instead of using a default epsilon.
    auto tmp_eps = fp.epsilon();
    fp.setEpsilon(0);
    UP_T result = fp.Eval(&amp;parbuf[0]);
    fp.setEpsilon(tmp_eps);

    // test function using the parameters determined above
    if (fp.EvalError())
      return {{false, &quot;Error evaluating expression &#x27;&quot; + range_function + &quot;&#x27;&quot;}};

    if (!result)
    {
      std::ostringstream oss;
      oss &lt;&lt; &quot;Range check failed&quot;;
      if (include_param_path)
        oss &lt;&lt; &quot; for parameter &quot; &lt;&lt; full_name;
      oss &lt;&lt; &quot;; expression = &#x27;&quot; &lt;&lt; range_function &lt;&lt; &quot;&#x27;&quot;;
      if (need_to_iterate)
        oss &lt;&lt; &quot;, component &quot; &lt;&lt; i;
      return {{true, oss.str()}};
    }

  } while (need_to_iterate &amp;&amp; ++i &lt; value.size());

  return {};
}

template &lt;typename T, typename UP_T&gt;
std::optional&lt;std::pair&lt;bool, std::string&gt;&gt;
InputParameters::rangeCheck(const std::string &amp; full_name,
                            const std::string &amp; short_name,
                            const InputParameters::Parameter&lt;T&gt; &amp; param,
                            const bool include_param_path)
{
  if (!isParamValid(short_name))
    return {};

  const auto &amp; range_function = _params[short_name]._range_function;
  if (range_function.empty())
    return {};

  // Parse the expression
  FunctionParserBase&lt;UP_T&gt; fp;
  if (fp.Parse(range_function, short_name) != -1) // -1 for success
    return {{false,
             &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27;&quot; + &quot; for parameter &quot; + short_name}};

  // ensure range-checked input file parameter comparison functions
  // do absolute floating point comparisons instead of using a default epsilon.
  auto tmp_eps = fp.epsilon();
  fp.setEpsilon(0);
  // We require a non-const value for the implicit upscaling of the parameter type
  std::vector&lt;UP_T&gt; value(1, param.get());
  UP_T result = fp.Eval(&amp;value[0]);
  fp.setEpsilon(tmp_eps);

  if (fp.EvalError())
    return {{true,
             &quot;Error evaluating expression &#x27;&quot; + range_function + &quot;&#x27; for parameter &quot; + short_name +
                 &quot;; perhaps you used the wrong variable name?&quot;}};

  if (!result)
  {
    std::ostringstream oss;
    oss &lt;&lt; &quot;Range check failed&quot;;
    if (include_param_path)
      oss &lt;&lt; &quot; for parameter &quot; &lt;&lt; full_name;
    oss &lt;&lt; &quot;; expression = &#x27;&quot; &lt;&lt; range_function &lt;&lt; &quot;&#x27;, value = &quot; &lt;&lt; value[0];
    return {{true, oss.str()}};
  }

  return {};
}

template &lt;typename T&gt;
T
InputParameters::getCheckedPointerParam(const std::string &amp; name_in,
                                        const std::string &amp; error_string) const
{
  const auto name = checkForRename(name_in);

  T param = this-&gt;get&lt;T&gt;(name);

  // Note: You will receive a compile error on this line if you attempt to pass a non-pointer
  // template type to this method
  if (!param)
    mooseError(&quot;Parameter &quot;, name, &quot; is NULL.\n&quot;, error_string);
  return this-&gt;get&lt;T&gt;(name);
}

template &lt;typename T&gt;
void
InputParameters::addRequiredParam(const std::string &amp; name, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  auto &amp; metadata = _params[name];
  metadata._required = true;
  if constexpr (isFunctorNameType&lt;T&gt;())
    metadata._doc_string = appendFunctorDescription&lt;T&gt;(doc_string);
  else
    metadata._doc_string = doc_string;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredParam(const std::string &amp; /*name*/,
                                  const T &amp; /*value*/,
                                  const std::string &amp; /*doc_string*/)
{
  mooseError(&quot;You cannot call addRequiredParam and supply a default value for this type, please &quot;
             &quot;use addParam instead&quot;);
}

template &lt;typename T, typename S&gt;
void
InputParameters::addParam(const std::string &amp; name, const S &amp; value, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  T &amp; l_value = InputParameters::set&lt;T&gt;(name);
  auto &amp; metadata = _params[name];
  if constexpr (isFunctorNameType&lt;T&gt;())
    metadata._doc_string = appendFunctorDescription&lt;T&gt;(doc_string);
  else
    metadata._doc_string = doc_string;

  // Set the parameter now
  setParamHelper(name, l_value, value);

  /* Indicate the default value, as set via addParam, is being used. The parameter is removed from
     the list whenever
     it changes, see set_attributes */
  metadata._set_by_add_param = true;
}

template &lt;typename T&gt;
void
InputParameters::addParam(const std::string &amp; name, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  if constexpr (isFunctorNameType&lt;T&gt;())
    _params[name]._doc_string = appendFunctorDescription&lt;T&gt;(doc_string);
  else
    _params[name]._doc_string = doc_string;
}

template &lt;typename T, typename S&gt;
void
InputParameters::setParamHelper(const std::string &amp; /*name*/, T &amp; l_value, const S &amp; r_value)
{
  l_value = r_value;
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParamHelper(const std::string &amp; name,
                                           const std::string &amp; syntax,
                                           const bool required,
                                           const bool value_required)
{
  static_assert(isValidCommandLineType&lt;T&gt;::value,
                &quot;This type is not a supported command line parameter type. See &quot;
                &quot;CommandLine::populateCommandLineParams to add it as a supported type.&quot;);

  auto &amp; cl_data = at(name)._cl_data;
  cl_data = CommandLineMetadata();

  // Split up the syntax by whitespace
  std::vector&lt;std::string&gt; syntax_split;
  MooseUtils::tokenize(syntax, syntax_split, 1, &quot; \t\n\v\f\r&quot;);

  // Set the single syntax string as the combined syntax with removed whitespace
  cl_data-&gt;syntax = MooseUtils::stringJoin(syntax_split);
  mooseAssert(cl_data-&gt;syntax.size(), &quot;Empty token&quot;);

  // Set the switches; only parse those that begin with &quot;-&quot; as we also
  // provide examples within the syntax
  for (const auto &amp; val : syntax_split)
    if (val.rfind(&quot;-&quot;, 0) == 0)
    {
      if (!std::regex_search(val, std::regex(&quot;^\\-+[a-zA-Z]&quot;)))
        mooseError(&quot;The switch &#x27;&quot;,
                   val,
                   &quot;&#x27; for the command line parameter &#x27;&quot;,
                   name,
                   &quot;&#x27; is invalid. It must begin with an alphabetical character.&quot;);

      cl_data-&gt;switches.push_back(val);
      libMesh::add_command_line_name(val);
    }

  cl_data-&gt;required = required;
  cl_data-&gt;global = false;

  // No arguments needed for a boolean parameter
  if constexpr (std::is_same_v&lt;T, bool&gt;)
  {
    (void)value_required; // purposely unused; doesn&#x27;t take a value
    cl_data-&gt;argument_type = CommandLineMetadata::ArgumentType::NONE;
  }
  // MooseEnums require a value
  else if constexpr (std::is_same_v&lt;T, MooseEnum&gt;)
  {
    (void)value_required; // purposely unused; always required
    cl_data-&gt;argument_type = CommandLineMetadata::ArgumentType::REQUIRED;
  }
  // The user didn&#x27;t specify a default, so a value is required
  else if (value_required)
    cl_data-&gt;argument_type = CommandLineMetadata::ArgumentType::REQUIRED;
  // Otherwise, it&#x27;s optional (user specified a default)
  else
    cl_data-&gt;argument_type = CommandLineMetadata::ArgumentType::OPTIONAL;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredRangeCheckedParam(const std::string &amp; name,
                                              const std::string &amp; parsed_function,
                                              const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRangeCheckedParam(const std::string &amp; name,
                                      const T &amp; value,
                                      const std::string &amp; parsed_function,
                                      const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRangeCheckedParam(const std::string &amp; name,
                                      const std::string &amp; parsed_function,
                                      const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredCustomTypeParam(const std::string &amp; name,
                                            const std::string &amp; custom_type,
                                            const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addCustomTypeParam(const std::string &amp; name,
                                    const T &amp; value,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addCustomTypeParam(const std::string &amp; name,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedCustomTypeParam(const std::string &amp; name,
                                              const std::string &amp; custom_type,
                                              const std::string &amp; doc_string,
                                              const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  addParam&lt;T&gt;(name, doc_string);
  auto &amp; metadata = _params[name];
  metadata._custom_type = custom_type;

  metadata._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

template &lt;typename T&gt;
void
InputParameters::addPrivateParam(const std::string &amp; name)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  _params[name]._is_private = true;
}

template &lt;typename T&gt;
void
InputParameters::addPrivateParam(const std::string &amp; name, const T &amp; value)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::set&lt;T&gt;(name) = value;
  auto &amp; metadata = _params[name];
  metadata._is_private = true;
  metadata._set_by_add_param = true;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredCommandLineParam(const std::string &amp; name,
                                             const std::string &amp; syntax,
                                             const std::string &amp; doc_string)
{
  static_assert(!std::is_same_v&lt;T, bool&gt;, &quot;Cannot be used for a bool&quot;);

  addRequiredParam&lt;T&gt;(name, doc_string);
  addCommandLineParamHelper&lt;T&gt;(name, syntax, /* required = */ true, /* value_required = */ true);
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParam(const std::string &amp; name,
                                     const std::string &amp; syntax,
                                     const std::string &amp; doc_string)
{
  static_assert(!std::is_same_v&lt;T, MooseEnum&gt;,
                &quot;addCommandLineParam() without a value cannot be used with a MooseEnum because a &quot;
                &quot;MooseEnum requires initialization&quot;);

  auto constexpr is_bool = std::is_same_v&lt;T, bool&gt;;
  if constexpr (is_bool)
    addParam&lt;T&gt;(name, false, doc_string);
  else
    addParam&lt;T&gt;(name, doc_string);

  addCommandLineParamHelper&lt;T&gt;(
      name, syntax, /* required = */ false, /* value_required = */ !is_bool);
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParam(const std::string &amp; name,
                                     const std::string &amp; syntax,
                                     const T &amp; value,
                                     const std::string &amp; doc_string)
{
  if constexpr (std::is_same_v&lt;T, bool&gt;)
    mooseAssert(!value, &quot;Default for bool must be false&quot;);

  addParam&lt;T&gt;(name, value, doc_string);
  addCommandLineParamHelper&lt;T&gt;(name, syntax, /* required = */ false, /* value_required = */ true);
}

template &lt;typename T&gt;
void
InputParameters::addOptionalValuedCommandLineParam(const std::string &amp; name,
                                                   const std::string &amp; syntax,
                                                   const T &amp; value,
                                                   const std::string &amp; doc_string)
{
  mooseAssert(name == &quot;csg_only&quot; || name == &quot;mesh_only&quot; || name == &quot;recover&quot; || name == &quot;run&quot;,
              &quot;Not supported for new parameters&quot;);
  static_assert(!std::is_same_v&lt;T, bool&gt;, &quot;Cannot be used for a bool (does not take a value)&quot;);
  addParam&lt;T&gt;(name, value, doc_string);
  addCommandLineParamHelper&lt;T&gt;(name, syntax, /* required = */ false, /* value_required = */ false);
}

template &lt;typename T&gt;
void
InputParameters::checkConsistentType(const std::string &amp; name_in) const
{
  const auto name = checkForRename(name_in);

  // If we don&#x27;t currently have the Parameter, can&#x27;t be any inconsistency
  InputParameters::const_iterator it = _values.find(name);
  if (it == _values.end())
    return;

  // Now, if we already have the Parameter, but it doesn&#x27;t have the
  // right type, throw an error.
  if (!this-&gt;Parameters::have_parameter&lt;T&gt;(name))
    mooseError(&quot;Attempting to set parameter \&quot;&quot;,
               name,
               &quot;\&quot; with type (&quot;,
               libMesh::demangle(typeid(T).name()),
               &quot;)\nbut the parameter already exists as type (&quot;,
               it-&gt;second-&gt;type(),
               &quot;)&quot;);
}

template &lt;typename T&gt;
void
InputParameters::suppressParameter(const std::string &amp; name_in)
{
  const auto name = checkForRename(name_in);
  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to suppress nonexistent parameter: &quot;, name);

  auto &amp; metadata = _params[name];
  metadata._required = false;
  metadata._is_private = true;
  metadata._controllable = false;
}

template &lt;typename T&gt;
void
InputParameters::ignoreParameter(const std::string &amp; name_in)
{
  const auto name = checkForRename(name_in);
  suppressParameter&lt;T&gt;(name);
  _params[name]._ignore = true;
}

template &lt;typename T&gt;
void
InputParameters::makeParamRequired(const std::string &amp; name_in)
{
  const auto name = checkForRename(name_in);

  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to require nonexistent parameter: &quot;, name);

  _params[name]._required = true;
}

template &lt;typename T&gt;
void
InputParameters::makeParamNotRequired(const std::string &amp; name_in)
{
  const auto name = checkForRename(name_in);

  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to un-require nonexistent parameter: &quot;, name);

  _params[name]._required = false;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedParam(const std::string &amp; name,
                                    const T &amp; value,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  mooseAssert(!_old_to_new_name_and_dep.count(name),
              &quot;Attempting to deprecate via addDeprecatedParam the parameter, &#x27;&quot;
                  &lt;&lt; name &lt;&lt; &quot;&#x27;, already deprecated via deprecateParam or renamed via renameParam&quot;);
  addParam&lt;T&gt;(name, value, doc_string);

  _params[name]._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedParam(const std::string &amp; name,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  mooseAssert(!_old_to_new_name_and_dep.count(name),
              &quot;Attempting to deprecate via addDeprecatedParam the parameter, &#x27;&quot;
                  &lt;&lt; name &lt;&lt; &quot;&#x27;, already deprecated via deprecateParam or renamed via renameParam&quot;);
  addParam&lt;T&gt;(name, doc_string);

  _params[name]._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

// Forward declare MooseEnum specializations for add*Param
template &lt;&gt;
void InputParameters::addRequiredParam&lt;MooseEnum&gt;(const std::string &amp; name,
                                                  const MooseEnum &amp; moose_enum,
                                                  const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                       const MultiMooseEnum &amp; moose_enum,
                                                       const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;std::vector&lt;MooseEnum&gt;&gt;(
    const std::string &amp; name,
    const std::vector&lt;MooseEnum&gt; &amp; moose_enums,
    const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;std::vector&lt;MultiMooseEnum&gt;&gt;(
    const std::string &amp; name,
    const std::vector&lt;MultiMooseEnum&gt; &amp; moose_enums,
    const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/,
                                          const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/,
                                               const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;std::vector&lt;MooseEnum&gt;&gt;(const std::string &amp; /*name*/,
                                                       const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;std::vector&lt;MultiMooseEnum&gt;&gt;(const std::string &amp; /*name*/,
                                                            const std::string &amp; /*doc_string*/);

template &lt;&gt;
void
InputParameters::addRequiredParam&lt;std::vector&lt;MultiMooseEnum&gt;&gt;(const std::string &amp; /*name*/,
                                                               const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addPrivateParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/);

template &lt;&gt;
void InputParameters::addPrivateParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/,
                                                    const std::string &amp; /*doc_string*/,
                                                    const std::string &amp; /*deprecation_message*/);

template &lt;&gt;
void
InputParameters::addDeprecatedParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/,
                                                    const std::string &amp; /*doc_string*/,
                                                    const std::string &amp; /*deprecation_message*/);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;std::vector&lt;MooseEnum&gt;&gt;(
    const std::string &amp; /*name*/,
    const std::string &amp; /*doc_string*/,
    const std::string &amp; /*deprecation_message*/);

// Forward declare specializations for setParamHelper
template &lt;&gt;
void InputParameters::setParamHelper&lt;PostprocessorName, Real&gt;(const std::string &amp; name,
                                                              PostprocessorName &amp; l_value,
                                                              const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;PostprocessorName, int&gt;(const std::string &amp; name,
                                                             PostprocessorName &amp; l_value,
                                                             const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;FunctionName, Real&gt;(const std::string &amp; /*name*/,
                                                         FunctionName &amp; l_value,
                                                         const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;FunctionName, int&gt;(const std::string &amp; /*name*/,
                                                        FunctionName &amp; l_value,
                                                        const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MaterialPropertyName, Real&gt;(const std::string &amp; /*name*/,
                                                                 MaterialPropertyName &amp; l_value,
                                                                 const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MaterialPropertyName, int&gt;(const std::string &amp; /*name*/,
                                                                MaterialPropertyName &amp; l_value,
                                                                const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MooseFunctorName, Real&gt;(const std::string &amp; /*name*/,
                                                             MooseFunctorName &amp; l_value,
                                                             const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MooseFunctorName, int&gt;(const std::string &amp; /*name*/,
                                                            MooseFunctorName &amp; l_value,
                                                            const int &amp; r_value);

template &lt;typename T&gt;
const T &amp;
InputParameters::getParamHelper(const std::string &amp; name_in, const InputParameters &amp; pars)
{
  const auto name = pars.checkForRename(name_in);

  if (!pars.isParamValid(name))
    pars.mooseError(&quot;The parameter \&quot;&quot;, name, &quot;\&quot; is being retrieved before being set.&quot;);

  return pars.get&lt;T&gt;(name);
}

// Declare specializations so we don&#x27;t fall back on the generic
// implementation, but the definition will be in InputParameters.C so
// we won&#x27;t need to bring in *MooseEnum header files here.
template &lt;&gt;
const MooseEnum &amp; InputParameters::getParamHelper&lt;MooseEnum&gt;(const std::string &amp; name,
                                                             const InputParameters &amp; pars);

template &lt;&gt;
const MultiMooseEnum &amp;
InputParameters::getParamHelper&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                const InputParameters &amp; pars);

template &lt;typename R1, typename R2, typename V1, typename V2&gt;
std::vector&lt;std::pair&lt;R1, R2&gt;&gt;
InputParameters::get(const std::string &amp; param1_in, const std::string &amp; param2_in) const
{
  const auto param1 = checkForRename(param1_in);
  const auto param2 = checkForRename(param2_in);

  const auto &amp; v1 = get&lt;V1&gt;(param1);
  const auto &amp; v2 = get&lt;V2&gt;(param2);

  auto controllable = getControllableParameters();
  if (controllable.count(param1) || controllable.count(param2))
    mooseError(&quot;Parameters &quot;,
               param1,
               &quot; and/or &quot;,
               param2 + &quot; are controllable parameters and cannot be retireved using &quot;
                        &quot;the MooseObject::getParam/InputParameters::get methods for pairs&quot;);

  if (v1.size() != v2.size())
    paramError(param1,
               &quot;Vector parameters &quot;,
               param1,
               &quot;(size: &quot;,
               v1.size(),
               &quot;) and &quot; + param2,
               &quot;(size: &quot;,
               v2.size(),
               &quot;) are of different lengths \n&quot;);

  std::vector&lt;std::pair&lt;R1, R2&gt;&gt; parameter_pairs;
  auto i1 = v1.begin();
  auto i2 = v2.begin();
  for (; i1 != v1.end() &amp;&amp; i2 != v2.end(); ++i1, ++i2)
    parameter_pairs.emplace_back(std::make_pair(*i1, *i2));
  return parameter_pairs;
}

InputParameters emptyInputParameters();

template &lt;typename T&gt;
bool
InputParameters::isType(const std::string &amp; name_in) const
{
  const auto name = checkForRename(name_in);

  if (!_params.count(name))
    mooseError(&quot;Parameter \&quot;&quot;, name, &quot;\&quot; is not valid.&quot;);
  return have_parameter&lt;T&gt;(name);
}

template &lt;typename T&gt;
const T &amp;
InputParameters::get(std::string_view name_in) const
{
  const auto name = checkForRename(std::string(name_in));

  return Parameters::get&lt;T&gt;(name);
}

template &lt;typename T&gt;
bool
InputParameters::have_parameter(std::string_view name_in) const
{
  const auto name = checkForRename(std::string(name_in));

  return Parameters::have_parameter&lt;T&gt;(name);
}

template &lt;typename T&gt;
void
InputParameters::transferParam(const InputParameters &amp; source_params,
                               const std::string &amp; name_in,
                               const std::string &amp; new_name,
                               const std::string &amp; new_description)
{
  const auto name = source_params.checkForRename(std::string(name_in));
  const auto p_name = new_name.empty() ? name_in : new_name;
  if (!source_params.have_parameter&lt;T&gt;(name) &amp;&amp; !source_params.hasCoupledValue(name))
    mooseError(&quot;The &#x27;&quot;,
               name_in,
               &quot;&#x27; parameter could not be transferred because it does not exist with type &#x27;&quot;,
               MooseUtils::prettyCppType&lt;T&gt;(),
               &quot;&#x27; in the source parameters&quot;);
  if (name != name_in)
    mooseWarning(&quot;The transferred parameter &quot; + name_in + &quot; is deprecated in favor of &quot; + name +
                 &quot; in the source parameters. The new name should likely be used for the parameter &quot;
                 &quot;transfer instead.&quot;);
  const std::string description =
      new_description.empty() ? source_params.getDescription(name) : new_description;

  if (source_params.isParamRequired(name))
  {
    // Check for a variable parameter
    if (source_params.hasCoupledValue(name))
      addRequiredCoupledVar(p_name, description);
    // Enums parameters have a default list of options
    else if constexpr (std::is_same_v&lt;MooseEnum, T&gt; || std::is_same_v&lt;MultiMooseEnum, T&gt;)
      addRequiredParam&lt;T&gt;(p_name, source_params.get&lt;T&gt;(name), description);
    else if (source_params.isRangeChecked(name))
      addRequiredRangeCheckedParam&lt;T&gt;(
          p_name, source_params.rangeCheckedFunction(name), description);
    else
      addRequiredParam&lt;T&gt;(p_name, description);
  }
  else
  {
    // Check for a variable parameter
    if (source_params.hasCoupledValue(name))
    {
      if (!source_params.hasDefaultCoupledValue(name))
        addCoupledVar(p_name, description);
      else if (source_params.numberDefaultCoupledValues(name) == 1)
        addCoupledVar(p_name, source_params.defaultCoupledValue(name), description);
      else
      {
        std::vector&lt;Real&gt; coupled_values;
        for (const auto i : libMesh::make_range(source_params.numberDefaultCoupledValues(name)))
          coupled_values.push_back(source_params.defaultCoupledValue(name, i));
        addCoupledVar(p_name, coupled_values, description);
      }
    }
    else if (source_params.isRangeChecked(name))
    {
      if (source_params.hasDefault(name))
        addRangeCheckedParam&lt;T&gt;(p_name,
                                source_params.get&lt;T&gt;(name),
                                source_params.rangeCheckedFunction(name),
                                description);
      else
        addRangeCheckedParam&lt;T&gt;(p_name, source_params.rangeCheckedFunction(name), description);
    }
    else if constexpr (std::is_same_v&lt;MooseEnum, T&gt; || std::is_same_v&lt;MultiMooseEnum, T&gt;)
      addParam&lt;T&gt;(p_name, source_params.get&lt;T&gt;(name), description);
    else
    {
      if (source_params.hasDefault(name))
        addParam&lt;T&gt;(p_name, source_params.get&lt;T&gt;(name), description);
      else
        addParam&lt;T&gt;(p_name, description);
    }
  }

  // Copy other attributes
  if (source_params.isPrivate(name))
    _params[p_name]._is_private = true;
  if (source_params.isControllable(name))
    _params[p_name]._controllable = true;
}

template &lt;typename... Args&gt;
[[noreturn]] void
InputParameters::mooseError(Args &amp;&amp;... args) const
{
  std::ostringstream oss;
  moose::internal::mooseStreamAll(oss, std::forward&lt;Args&gt;(args)...);
  callMooseError(oss.str());
}

template &lt;typename... Args&gt;
std::string
InputParameters::paramMessage(const std::string &amp; param, Args... args) const
{
  std::ostringstream oss;
  moose::internal::mooseStreamAll(oss, std::forward&lt;Args&gt;(args)...);
  return paramMessagePrefix(param) + oss.str();
}

template &lt;typename... Args&gt;
[[noreturn]] void
InputParameters::paramError(const std::string &amp; param, Args... args) const
{
  std::ostringstream oss;
  moose::internal::mooseStreamAll(oss, std::forward&lt;Args&gt;(args)...);
  const auto [prefix, node] = paramMessageContext(param);

  Moose::show_trace = false;
  callMooseError(prefix + oss.str(), false, node);
  Moose::show_trace = true;
}

namespace Moose
{
namespace internal
{
template &lt;typename T&gt;
constexpr T *
getNullptrExample()
{
  return nullptr;
}

#ifdef MOOSE_MFEM_ENABLED

template &lt;typename T&gt;
constexpr bool
isMFEMFunctorNameTypeHelper(T *)
{
  return std::is_same_v&lt;T, MFEMScalarCoefficientName&gt; ||
         std::is_same_v&lt;T, MFEMVectorCoefficientName&gt;;
}

template &lt;typename T, typename A&gt;
constexpr bool
isMFEMFunctorNameTypeHelper(std::vector&lt;T, A&gt; *)
{
  return isMFEMFunctorNameTypeHelper(getNullptrExample&lt;T&gt;());
}

#endif

template &lt;typename T&gt;
constexpr bool
isScalarFunctorNameTypeHelper(T *)
{
  return std::is_same_v&lt;T, MooseFunctorName&gt;
#ifdef MOOSE_MFEM_ENABLED
         || std::is_same_v&lt;T, MFEMScalarCoefficientName&gt;
#endif
      ;
}

template &lt;typename T, typename A&gt;
constexpr bool
isScalarFunctorNameTypeHelper(std::vector&lt;T, A&gt; *)
{
  return isScalarFunctorNameTypeHelper(getNullptrExample&lt;T&gt;());
}

template &lt;typename T&gt;
constexpr bool
isVectorFunctorNameTypeHelper(T *)
{
#ifdef MOOSE_MFEM_ENABLED
  return std::is_same_v&lt;T, MFEMVectorCoefficientName&gt;;
#else
  return false;
#endif
}

template &lt;typename T, typename A&gt;
constexpr bool
isVectorFunctorNameTypeHelper(std::vector&lt;T, A&gt; *)
{
  return isVectorFunctorNameTypeHelper(getNullptrExample&lt;T&gt;());
}

template &lt;typename T&gt;
constexpr bool
isFunctorNameTypeHelper(T * ex)
{
  return isScalarFunctorNameTypeHelper(ex) || isVectorFunctorNameTypeHelper(ex);
}
}
}

template &lt;typename T&gt;
constexpr bool
InputParameters::isFunctorNameType()
{
  return Moose::internal::isFunctorNameTypeHelper(Moose::internal::getNullptrExample&lt;T&gt;());
}

template &lt;typename T&gt;
std::string
InputParameters::appendFunctorDescription(const std::string &amp; doc_string) const
{
  auto numeric_value_type = []()
  {
    if constexpr (Moose::internal::isScalarFunctorNameTypeHelper(
                      Moose::internal::getNullptrExample&lt;T&gt;()))
      return &quot;number&quot;;
    else if constexpr (Moose::internal::isVectorFunctorNameTypeHelper(
                           Moose::internal::getNullptrExample&lt;T&gt;()))
      return &quot;numeric vector value (enclosed in curly braces)&quot;;
    else
    {
      mooseAssert(false, &quot;We control instantiations of this method&quot;);
      return &quot;&quot;;
    }
  };

  return MooseUtils::trim(doc_string, &quot;. &quot;) + &quot;. A functor is any of the following: a variable, &quot; +
         (
#ifdef MOOSE_MFEM_ENABLED
             Moose::internal::isMFEMFunctorNameTypeHelper(Moose::internal::getNullptrExample&lt;T&gt;())
                 ? &quot;an MFEM&quot;
                 :
#endif
                 &quot;a functor&quot;) +
         &quot; material property, a function, a postprocessor or a &quot; + numeric_value_type() + &quot;.&quot;;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="a276b890-7b18-4a0b-b644-1f1be27dee36"><div class="modal-content"><h4>(moose/framework/include/utils/InputParameters.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

// MOOSE includes
#include &quot;MooseUtils.h&quot;
#include &quot;MooseError.h&quot;
#include &quot;MooseTypes.h&quot;
#include &quot;MultiMooseEnum.h&quot;
#include &quot;ExecFlagEnum.h&quot;
#include &quot;Conversion.h&quot;
#include &quot;DataFileUtils.h&quot;
#include &quot;MoosePassKey.h&quot;

#include &quot;libmesh/parameters.h&quot;

#ifdef LIBMESH_HAVE_FPARSER
#include &quot;libmesh/fparser.hh&quot;
#else
template &lt;typename T&gt;
class FunctionParserBase
{
}
#endif

#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;mutex&gt;
#include &lt;optional&gt;
#include &lt;filesystem&gt;
#include &lt;regex&gt;

#include &lt;gtest/gtest.h&gt;

// Forward declarations
class Action;
class ActionFactory;
class Factory;
class FEProblemBase;
class InputParameters;
class MooseEnum;
class MooseObject;
class MultiMooseEnum;
class Problem;
namespace hit
{
class Node;
}
namespace Moose
{
class Builder;
}
class CommandLine;

/**
 * The main MOOSE class responsible for handling user-defined
 * parameters in almost every MOOSE system.
 */
class InputParameters : public libMesh::Parameters
{
public:
  InputParameters(const InputParameters &amp; rhs);
  InputParameters(const Parameters &amp; rhs);

  virtual ~InputParameters() = default;

  virtual void clear() override;

  /**
   * Structure for storing information about a command line parameter
   */
  struct CommandLineMetadata
  {
    enum ArgumentType
    {
      NONE,
      OPTIONAL,
      REQUIRED
    };

    /// The syntax for the parameter
    std::string syntax;
    /// The switches for the parameter (i.e., [-t, --timing])
    std::vector&lt;std::string&gt; switches;
    /// The type of argument
    ArgumentType argument_type;
    /// Whether or not the argument is required
    bool required;
    /// Whether or not the parameter was set by the CommandLine
    bool set_by_command_line = false;
    /// Whether or not the parameter is global (passed to MultiApps)
    bool global = false;
  };

  /**
   * Class that is used as a parameter to setHitNode() that allows only
   * relevant classes to set the hit node
   */
  class SetHitNodeKey
  {
    friend class Action;
    friend class ActionFactory;
    friend class Moose::Builder;
    friend class Factory;
    friend class FEProblemBase;
    friend class InputParameters;
    FRIEND_TEST(InputParametersTest, fileNames);
    SetHitNodeKey() {}
    SetHitNodeKey(const SetHitNodeKey &amp;) {}
  };

  /**
   * Class that is used as a parameter to setHitNode(param) that allows only
   * relevant classes to set the hit node
   */
  class SetParamHitNodeKey
  {
    friend class Moose::Builder;
    FRIEND_TEST(InputParametersTest, fileNames);
    SetParamHitNodeKey() {}
    SetParamHitNodeKey(const SetParamHitNodeKey &amp;) {}
  };

  /**
   * Determines whether or not the given type is a type that is supported for
   * a command line parameter.
   *
   * In particular, whether or not CommandLine::populateCommandLineParams
   * supports extracting these types.
   */
  template &lt;typename T&gt;
  struct isValidCommandLineType
  {
    static constexpr bool value =
        std::is_same_v&lt;T, std::string&gt; || std::is_same_v&lt;T, std::vector&lt;std::string&gt;&gt; ||
        std::is_same_v&lt;T, Real&gt; || std::is_same_v&lt;T, unsigned int&gt; || std::is_same_v&lt;T, int&gt; ||
        std::is_same_v&lt;T, bool&gt; || std::is_same_v&lt;T, MooseEnum&gt;;
  };

  /**
   * This method adds a description of the class that will be displayed
   * in the input file syntax dump
   */
  void addClassDescription(const std::string &amp; doc_string);

  /**
   * Returns the class description
   */
  std::string getClassDescription() const;

  /**
   * Override from libMesh to set user-defined attributes on our parameter
   */
  virtual void set_attributes(const std::string &amp; name, bool inserted_only) override;

  /**
   * @return The deprecated parameter message for the given parameter, if any
   */
  std::optional&lt;std::string&gt; queryDeprecatedParamMessage(const std::string &amp; name) const;

  /// This functions is called in set as a &#x27;callback&#x27; to avoid code duplication
  template &lt;typename T&gt;
  void setHelper(const std::string &amp; name);

  /**
   * Returns a writable reference to the named parameters.  Note: This is not a virtual
   * function! Use caution when comparing to the parent class implementation
   * @param name The name of the parameter to set
   * @param quiet_mode When true the parameter is kept with set_by_add_param=true,
   * this is generally not needed.
   *
   * &quot;quite_mode&quot; returns a writable reference to the named parameter, without setting
   * set_by_add_param to false. Using this method of set will make the parameter to continue to
   * behave if its value where set ONLY by addParam and not by any other method.
   *
   * This was added for handling parameters in the Output objects that have behavior dependent
   * on whether the user modified the parameters.
   *
   */
  template &lt;typename T&gt;
  T &amp; set(const std::string &amp; name, bool quiet_mode = false);

  /**
   * Given a series of parameters names and values, sets each name to
   * the corresponding value.  Any number of name, value pairs can be
   * supplied.
   *
   * Note that each \p value must be of the correct type for the
   * parameter of that name, not merely of a type convertible to the
   * correct type.
   *
   * @param name The name of the first parameter to set
   */
  template &lt;typename T, typename... Ts&gt;
  void setParameters(const std::string &amp; name, const T &amp; value, Ts... extra_input_parameters);

  /**
   * Runs a range on the supplied parameter if it exists and throws an error if that check fails.
   * @returns Optional of whether or not the error is a user error (false = developer error) and
   * the associated error
   *
   * If \p include_param_path = true, include the parameter path in the error message
   */
  ///@{
  template &lt;typename T, typename UP_T&gt;
  std::optional&lt;std::pair&lt;bool, std::string&gt;&gt;
  rangeCheck(const std::string &amp; full_name,
             const std::string &amp; short_name,
             const InputParameters::Parameter&lt;T&gt; &amp; param,
             const bool include_param_path = true);
  template &lt;typename T, typename UP_T&gt;
  std::optional&lt;std::pair&lt;bool, std::string&gt;&gt;
  rangeCheck(const std::string &amp; full_name,
             const std::string &amp; short_name,
             const InputParameters::Parameter&lt;std::vector&lt;T&gt;&gt; &amp; param,
             const bool include_param_path = true);
  ///@}
  /**
   * Verifies that the requested parameter exists and is not NULL and returns it to the caller.
   * The template parameter must be a pointer or an error will be thrown.
   */
  template &lt;typename T&gt;
  T getCheckedPointerParam(const std::string &amp; name, const std::string &amp; error_string = &quot;&quot;) const;

  /**
   * This method adds a parameter and documentation string to the InputParameters
   * object that will be extracted from the input file.  If the parameter is
   * missing in the input file, an error will be thrown
   */
  template &lt;typename T&gt;
  void addRequiredParam(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * This version of addRequiredParam is here for a consistent use with MooseEnums.  Use of
   * this function for any other type will throw an error.
   */
  template &lt;typename T&gt;
  void
  addRequiredParam(const std::string &amp; name, const T &amp; moose_enum, const std::string &amp; doc_string);

  ///@{
  /**
   * These methods add an optional parameter and a documentation string to the InputParameters
   * object. The first version of this function takes a default value which is used if the parameter
   * is not found in the input file. The second method will leave the parameter uninitialized but
   * can be checked with &quot;isParamValid&quot; before use.
   */
  template &lt;typename T, typename S&gt;
  void addParam(const std::string &amp; name, const S &amp; value, const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addParam(const std::string &amp; name, const std::string &amp; doc_string);
  ///@}

  /**
   * Enable support for initializer lists as default arguments for container type.
   */
  template &lt;typename T&gt;
  void addParam(const std::string &amp; name,
                const std::initializer_list&lt;typename T::value_type&gt; &amp; value,
                const std::string &amp; doc_string)
  {
    addParam&lt;T&gt;(name, T{value}, doc_string);
  }

  ///@{
  // BEGIN RANGE CHECKED PARAMETER METHODS
  /**
   * These methods add an range checked parameters. A lower and upper bound can be supplied and the
   * supplied parameter will be checked to fall within that range.
   */
  template &lt;typename T&gt;
  void addRequiredRangeCheckedParam(const std::string &amp; name,
                                    const std::string &amp; parsed_function,
                                    const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const T &amp; value,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  // END RANGE CHECKED PARAMETER METHODS
  ///@}

  /**
   * These methods add an option parameter and with a customer type to the InputParameters object.
   * The custom type will be output in YAML dumps and can be used within the GUI application.
   */
  template &lt;typename T&gt;
  void addRequiredCustomTypeParam(const std::string &amp; name,
                                  const std::string &amp; custom_type,
                                  const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCustomTypeParam(const std::string &amp; name,
                          const T &amp; value,
                          const std::string &amp; custom_type,
                          const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCustomTypeParam(const std::string &amp; name,
                          const std::string &amp; custom_type,
                          const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addDeprecatedCustomTypeParam(const std::string &amp; name,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_msg);

  /**
   * These method add a parameter to the InputParameters object which can be retrieved like any
   * other parameter. This parameter however is not printed in the Input file syntax dump or web
   * page dump so does not take a documentation string.  The first version of this function takes an
   * optional default value.
   */
  template &lt;typename T&gt;
  void addPrivateParam(const std::string &amp; name, const T &amp; value);
  template &lt;typename T&gt;
  void addPrivateParam(const std::string &amp; name);

  /**
   * Add parameters for retrieval from the command line.
   *
   * NOTE: This ONLY works for App objects!  This is not valid for normal MOOSE objects!
   *
   * @param name The name of the parameter
   * @param syntax Space separated list of command-line switch syntax that can set this option
   * @param doc_string Documentation.  This will be shown for --help
   */
  template &lt;typename T&gt;
  void addRequiredCommandLineParam(const std::string &amp; name,
                                   const std::string &amp; syntax,
                                   const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const T &amp; value,
                           const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const std::initializer_list&lt;typename T::value_type&gt; &amp; value,
                           const std::string &amp; doc_string)
  {
    addCommandLineParam&lt;T&gt;(name, syntax, T{value}, doc_string);
  }

  /**
   * Add a command line parameter with an optional value.
   *
   * This is a deprecated option and only remains for two parameters:
   * &quot;mesh_only&quot; and &quot;recover&quot;. There are issues with command line
   * parameters with optional values because if a value following
   * one of these is a hit cli parameter, we don&#x27;t know if we should
   * apply it to the optional option or as a hit parameter.
   *
   * It is also allowed for &quot;run&quot; as we take all arguments past
   * --run and pass to python.
   *
   * @param name The name of the parameer
   * @param syntax Space separated list of command-line switch syntax that can set this option
   * @param value The default value to assign
   * @param doc_string Documentation.  This will be shown for --help
   */
  template &lt;typename T&gt;
  void addOptionalValuedCommandLineParam(const std::string &amp; name,
                                         const std::string &amp; syntax,
                                         const T &amp; value,
                                         const std::string &amp; doc_string);

  /**
   * Sets the command line parameter with \p name as global.
   *
   * Global here means that it will be passed to all child MultiApps.
   */
  void setGlobalCommandLineParam(const std::string &amp; name);

  /**
   * @param name The name of the parameter
   * @param value The default value of this parameter if it requires one
   * @param doc_string Documentation.  This will be shown for --help
   * @param deprecation_message The message that will will print about why this param was
   * deprecated.  It might mention the &quot;new way&quot;.
   */
  template &lt;typename T&gt;
  void addDeprecatedParam(const std::string &amp; name,
                          const T &amp; value,
                          const std::string &amp; doc_string,
                          const std::string &amp; deprecation_message);

  template &lt;typename T&gt;
  void addDeprecatedParam(const std::string &amp; name,
                          const std::string &amp; doc_string,
                          const std::string &amp; deprecation_message);

  /**
   * This method checks to make sure that we aren&#x27;t adding a parameter with the same name but a
   * different type.  It
   * throws a MooseError if an inconsistent type is detected. While this state is supported by
   * libMesh it brings
   * nothing but blood and tears for those who try ;)
   *
   * @param name the name of the parameter
   */
  template &lt;typename T&gt;
  void checkConsistentType(const std::string &amp; name) const;

  /**
   * @return Whether or not the parameter \p name is a command line parameter
   */
  bool isCommandLineParameter(const std::string &amp; name) const;

  /**
   * @return Queries for the command line metadata for the parameter \p name
   *
   * Will return an empty optional if the parameter is not a command line param.
   */
  std::optional&lt;InputParameters::CommandLineMetadata&gt;
  queryCommandLineMetadata(const std::string &amp; name) const;

  /**
   * @return The command line metadata for the parameter \p name.
   */
  const InputParameters::CommandLineMetadata &amp;
  getCommandLineMetadata(const std::string &amp; name) const;

  /**
   * Class that is used as a parameter to commandLineParamSet() that allows only
   * the CommandLine to set that a parmeter is set by the command line
   */
  class CommandLineParamSetKey
  {
    friend class CommandLine;
    FRIEND_TEST(InputParametersTest, commandLineParamSetNotCLParam);
    CommandLineParamSetKey() {}
    CommandLineParamSetKey(const CommandLineParamSetKey &amp;) {}
  };
  /**
   * Marks the command line parameter \p name as set by the CommandLine.
   *
   * Protected by the CommandLineParamSetKey so that only the CommandLine can call this.
   */
  void commandLineParamSet(const std::string &amp; name, const CommandLineParamSetKey);

  /**
   * Get the documentation string for a parameter
   */
  const std::string &amp; getDescription(const std::string &amp; name) const;

  /**
   * This method takes a space delimited list of parameter names and adds them to the specified
   * group name.
   * This information is used in the GUI to group parameters into logical sections.
   */
  void addParamNamesToGroup(const std::string &amp; space_delim_names, const std::string group_name);

  /**
   * This method renames a parameter group
   * @param old_name previous name of the parameter group
   * @param new_name new name of the parameter group
   */
  void renameParameterGroup(const std::string &amp; old_name, const std::string &amp; new_name);

  /**
   * This method retrieves the group name for the passed parameter name if one exists.  Otherwise an
   * empty string is returned.
   */
  std::string getGroupName(const std::string &amp; param_name) const;

  /**
   * This method suppresses an inherited parameter so that it isn&#x27;t required or valid
   * in the derived class. The parameter is added to the private parameter list.
   * Suppressing a parameter can have dire consequences.
   * Use at your own risk!
   */
  template &lt;typename T&gt;
  void suppressParameter(const std::string &amp; name);

  /**
   * Changes the parameter to be required.
   * @param name The parameter name
   */
  template &lt;typename T&gt;
  void makeParamRequired(const std::string &amp; name);

  /**
   * Changes the parameter to not be required.
   * @param name The parameter name
   */
  template &lt;typename T&gt;
  void makeParamNotRequired(const std::string &amp; name);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   */
  void addCoupledVar(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * This method adds a deprecated coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found. The doc string for the deprecated variable will be
   * constructed from the doc string for the new variable. A deprecation message will also be
   * automatically generated
   */
  void addDeprecatedCoupledVar(const std::string &amp; old_name,
                               const std::string &amp; new_name,
                               const std::string &amp; removal_date = &quot;&quot;);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   *
   * Also - you can provide a default value for this variable in the case that an actual variable is
   * not provided.
   */
  void addCoupledVar(const std::string &amp; name, const Real value, const std::string &amp; doc_string);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   *
   * Also - you can provide a vector of values for this variable in the case that an actual variable
   * is not provided.
   */
  void addCoupledVar(const std::string &amp; name,
                     const std::vector&lt;Real&gt; &amp; value,
                     const std::string &amp; doc_string);

  ///@{
  /**
   * These methods add a coupled variable name pair. The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found.
   *
   * This version of the method will build a vector if the given the base_name and num_name
   * parameters exist
   * in the input file:
   *   e.g.
   *   [./foo]
   *     ...
   *     some_base = base_
   *     some_num  = 5
   *   [../]
   *
   *   # The coupling parameter will be passed this vector: &quot;base_0 base_1 base_2 base_3 base_4&quot;
   */
  void addCoupledVarWithAutoBuild(const std::string &amp; name,
                                  const std::string &amp; base_name,
                                  const std::string &amp; num_name,
                                  const std::string &amp; doc_string);
  void addRequiredCoupledVarWithAutoBuild(const std::string &amp; name,
                                          const std::string &amp; base_name,
                                          const std::string &amp; num_name,
                                          const std::string &amp; doc_string);
  ///@}

  /**
   * Utility functions for retrieving one of the MooseTypes variables into the common &quot;string&quot; base
   * class.
   * Scalar and Vector versions are supplied
   */
  std::string getMooseType(const std::string &amp; name) const;
  std::vector&lt;std::string&gt; getVecMooseType(const std::string &amp; name) const;

  /**
   * @returns Whether or not these parameters are for a MooseBase object, that is,
   * one with a name and type.
   *
   * Needed so that we can produce richer errors from within InputParameters
   * that have the context of the underlying object, if possible.
   */
  bool isMooseBaseObject() const;

  /**
   * @return The object type represented by these parameters, if any
   */
  const std::string * queryObjectType() const;

  /**
   * @returns The underlying owning object type, for MooseBase objects with parameters
   *
   * Will error if a type does not exist
   */
  const std::string &amp; getObjectType() const;
  /**
   * @returns The underlying owning object name, for MooseBase objects with parameters
   */
  const std::string &amp; getObjectName() const;

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable.  If the coupled variable is not supplied in the input
   * file, and error is thrown.
   *
   * Version 2: An auto built vector will be built from the base_name and num_name param. See
   * addCoupledVar for an example
   */
  void addRequiredCoupledVar(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * Returns the documentation string for the specified parameter name
   */
  std::string getDocString(const std::string &amp; name) const;

  /**
   * Set the doc string of a parameter.
   *
   * This method is generally used from within the validParams function to modify the documentation
   * for an
   * existing parameter, such as a parameter that is supplied from an interface class.
   */
  void setDocString(const std::string &amp; name, const std::string &amp; doc);

  /**
   * Returns the documentation unit string for the specified parameter name
   */
  std::string getDocUnit(const std::string &amp; name) const;

  /**
   * Set the unit string of a parameter.
   *
   * This method is only used within MooseDocs and the input syntax dump in order to provide a
   * developer-expected unit for software quality assurance purposes.
   */
  void setDocUnit(const std::string &amp; name, const std::string &amp; doc_unit);

  /**
   * Returns a boolean indicating whether the specified parameter is required or not
   */
  bool isParamRequired(const std::string &amp; name) const;

  /**
   * Forces parameter of given name to be not required regardless of type
   */
  void makeParamNotRequired(const std::string &amp; name);

  /**
   * This method returns parameters that have been initialized in one fashion or another,
   * i.e. The value was supplied as a default argument or read and properly converted from
   * the input file
   */
  bool isParamValid(const std::string &amp; name) const;

  /**
   * Returns whether or not the parameter was set due to addParam. If not then it was either set
   * programmatically
   * or was read through the input file.
   */
  bool isParamSetByAddParam(const std::string &amp; name) const;

  /**
   * Returns True if the parameters is deprecated.
   */
  bool isParamDeprecated(const std::string &amp; name) const;

  /**
   * This method returns true if all of the parameters in this object are valid
   * (i.e. isParamValid(name) == true - for all parameters)
   */
  bool areAllRequiredParamsValid() const;

  /**
   * Prints the type of the requested parameter by name
   */
  std::string type(const std::string &amp; name) const;

  /**
   * Returns a Boolean indicating whether the specified parameter is private or not
   */
  bool isPrivate(const std::string &amp; name) const;

  /**
   * Declare the given parameters as controllable
   */
  void declareControllable(const std::string &amp; name, std::set&lt;ExecFlagType&gt; execute_flags = {});

  /**
   * Marker a parameter that has been changed by the Control system (this is for output purposes)
   */
  void markControlled(const std::string &amp; name);

  /**
   * Returns a Boolean indicating whether the specified parameter is controllable
   */
  bool isControllable(const std::string &amp; name) const;

  /**
   * Return the allowed execute flags for a controllable parameter
   */
  const std::set&lt;ExecFlagType&gt; &amp; getControllableExecuteOnTypes(const std::string &amp; name) const;

  /**
   * This method must be called from every base &quot;Moose System&quot; to create linkage with the Action
   * System.
   * See &quot;Moose.C&quot; for the registerMooseObjectTask() calls.
   */
  void registerBase(const std::string &amp; value);

  /**
   * @return Whether or not the object has a registered base
   *
   * The base is registered with registerBase()
   */
  bool hasBase() const;

  /**
   * @return The base system of the object these parameters are for, if any
   *
   * Set via registerBase().
   */
  const std::string &amp; getBase() const;

  /**
   * This method is used to define the MOOSE system name that is used by the TheWarehouse object
   * for storing objects to be retrieved for execution. The base class of every object class
   * that will be called for execution (e.g., UserObject objects) should call this method.
   *
   * This is different from registerBase because the name supplied to registerBase is used to
   * associate syntax, but the objects created often go to the same objects for execution, as is
   * the case for Postprocessor object which are executed with UserObjects.
   *
   * See the AttribSystem object for use Attribute.h/C.
   */
  void registerSystemAttributeName(const std::string &amp; value);

  /**
   * Get the system attribute name if it was registered. Otherwise throw an error.
   * See the AttribSystem object for use Attribute.h/C.
   */
  const std::string &amp; getSystemAttributeName() const;

  /**
   * This method is here to indicate which Moose types a particular Action may build. It takes a
   * space delimited list of registered MooseObjects.  TODO: For now we aren&#x27;t actually checking
   * this list when we build objects. Since individual actions can do whatever they want it&#x27;s not
   * exactly trivial to check this without changing the user API.  This function properly restricts
   * the syntax and YAML dumps.
   */
  void registerBuildableTypes(const std::string &amp; names);

  /**
   * Tells MOOSE about a RelationshipManager that this object needs.  RelationshipManagers
   * handle element &quot;ghosting&quot;, &quot;non-local DOF access&quot; and &quot;sparsity pattern&quot; relationships.
   *
   * Basically: if this object needs non-local (ie non-current-element) data access then you
   * probably need a relationship manager
   *
   * @param name The name of the RelationshipManager type
   * @param rm_type The type (GEOMETRIC/ALGEBRAIC) of the RelationshipManger.  Note: You can use
   * boolean logic to to &quot;or&quot; RelationshipManagerTypes together to make a RelationshipManager that
   * is multi-typed.
   * @param input_parameter_callback This is a function pointer that will get called to fill in the
   * RelationShipManager&#x27;s InputParameters.  See MooseTypes.h for the signature of this function.
   */
  void addRelationshipManager(
      const std::string &amp; name,
      Moose::RelationshipManagerType rm_type,
      Moose::RelationshipManagerInputParameterCallback input_parameter_callback = nullptr);

  /**
   * Clears all currently registered RelationshipManagers
   */
  void clearRelationshipManagers() { _buildable_rm_types.clear(); }

  /**
   * Returns the list of buildable types as a std::vector&lt;std::string&gt;
   */
  const std::vector&lt;std::string&gt; &amp; getBuildableTypes() const;

  /**
   * Returns the list of buildable (or required) RelationshipManager object types for this object.
   */
  const std::vector&lt;std::tuple&lt;std::string,
                               Moose::RelationshipManagerType,
                               Moose::RelationshipManagerInputParameterCallback&gt;&gt; &amp;
  getBuildableRelationshipManagerTypes() const;

  ///@{
  /**
   * Mutators for controlling whether or not the outermost level of syntax will be collapsed when
   * printed.
   */
  void collapseSyntaxNesting(bool collapse);
  bool collapseSyntaxNesting() const;
  ///@}

  ///@{
  /**
   * Mutators for controlling whether or not the outermost level of syntax will be collapsed when
   * printed.
   */
  void mooseObjectSyntaxVisibility(bool visibility);
  bool mooseObjectSyntaxVisibility() const;
  ///@}

  ///@{
  /**
   * Copy and Copy/Add operators for the InputParameters object
   */
  using Parameters::operator=;
  using Parameters::operator+=;
  InputParameters &amp; operator=(const InputParameters &amp; rhs);
  InputParameters &amp; operator+=(const InputParameters &amp; rhs);
  ///@}

  /**
   * This function checks parameters stored in the object to make sure they are in the correct
   * state as the user expects:
   *   Required parameters are verified as valid meaning that they were either initialized when
   *   they were created, or were read from an input file or some other valid source
   */
  void checkParams(const std::string &amp; parsing_syntax);

  /**
   * Performs a range check on the parameter (which must have a range check)
   *
   * @param value The parameter value
   * @param long_name The full path to the parameter
   * @param short_name The name of the parameter
   * @param include_param_path Whether or not to include the parameter path in errors
   * @return An error, if any; first is whether or not it is a user error and second is the message
   */
  std::optional&lt;std::pair&lt;bool, std::string&gt;&gt; parameterRangeCheck(const Parameters::Value &amp; value,
                                                                  const std::string &amp; long_name,
                                                                  const std::string &amp; short_name,
                                                                  const bool include_param_path);

  /**
   * Finalizes the parameters, which must be done before constructing any objects
   * with these parameters (to be called in the corresponding factories).
   * typed parameters.
   *
   * This calls checkParams() and sets up the absolute paths for all file name.
   */
  void finalize(const std::string &amp; parsing_syntax);

  /**
   * @return A file base to associate with these parameters.
   *
   * Optionally, an input parameter can be provided via \p param_name.
   *
   * If the parameter is provided, we have the following options:
   * - The parameter itself has a hit node set (context for that parameter)
   * - The InputParameters object has a hit node set (context for all parameters)
   * - Neither of the above and we die
   *
   * In the event that a the parameter is set via command line, this will
   * attempt to look at the parameter&#x27;s parents to find a suitable context.
   */
  std::filesystem::path
  getFileBase(const std::optional&lt;std::string&gt; &amp; param_name = std::optional&lt;std::string&gt;()) const;

  /**
   * Methods returning iterators to the coupled variables names stored in this
   * InputParameters object
   */
  inline std::set&lt;std::string&gt;::const_iterator coupledVarsBegin() const
  {
    return _coupled_vars.begin();
  }
  inline std::set&lt;std::string&gt;::const_iterator coupledVarsEnd() const
  {
    return _coupled_vars.end();
  }

  /**
   * Return the coupled variable parameter names.
   */
  const std::set&lt;std::string&gt; &amp; getCoupledVariableParamNames() const { return _coupled_vars; }

  /**
   * Return the new to deprecated variable name map
   */
  const std::unordered_map&lt;std::string, std::string&gt; &amp; getNewToDeprecatedVarMap() const
  {
    return _new_to_deprecated_coupled_vars;
  }

  /// Return whether a parameter has a range check
  bool isRangeChecked(const std::string &amp; param_name) const;

  /// Return the range check function for any parameter (empty string if it is not range checked)
  std::string rangeCheckedFunction(const std::string &amp; name) const;

  /// Return whether a parameter has a default
  bool hasDefault(const std::string &amp; param_name) const;

  /**
   * Return whether or not the coupled variable exists
   * @param coupling_name The name of the coupled variable to test for
   * @return True if the variable exists in the coupled variables for this InputParameters object
   */
  bool hasCoupledValue(const std::string &amp; coupling_name) const;

  /**
   * Return whether or not the requested parameter has a default coupled value.
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   */
  bool hasDefaultCoupledValue(const std::string &amp; coupling_name) const;

  /**
   * Get the default value for an optionally coupled variable.
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   * @param i By default 0, in general the index of the requested coupled default value.
   */
  Real defaultCoupledValue(const std::string &amp; coupling_name, unsigned int i = 0) const;

  /**
   * Get the number of defaulted coupled value entries
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   */
  unsigned int numberDefaultCoupledValues(const std::string &amp; coupling_name) const;

  /**
   * Set the default value for an optionally coupled variable (called by the Parser).
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   * @param value Default value to set.
   * @param i By default 0, in general the index of the requested coupled default value.
   */
  void defaultCoupledValue(const std::string &amp; coupling_name, Real value, unsigned int i = 0);

  /**
   * Returns the auto build vectors for all parameters.
   */
  std::map&lt;std::string, std::pair&lt;std::string, std::string&gt;&gt; getAutoBuildVectors() const;

  // BEGIN APPLY PARAMETER METHODS
  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param exclude A vector of parameters to exclude
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must be valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private (unless \p allow_private = true)
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applyParameters(const InputParameters &amp; common,
                       const std::vector&lt;std::string&gt; &amp; exclude = {},
                       const bool allow_private = false);

  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param include A vector of parameters to apply
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applySpecificParameters(const InputParameters &amp; common,
                               const std::vector&lt;std::string&gt; &amp; include,
                               bool allow_private = false);

  /**
   * Apply values from a single parameter in common, to a single parameter stored in this object
   * @param common The set of InputParameters from which to extract parameters from
   * @param common_name The name within common from which to get the parameter values
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (except if override_default is set)
   *   (4) Both cannot be private
   */
  void applyParameter(const InputParameters &amp; common,
                      const std::string &amp; common_name,
                      bool allow_private = false,
                      bool override_default = false);
  // END APPLY PARAMETER METHODS

  /**
   * Apply properties of a single coupled variable in common, to a single coupled variable stored in
   * this object
   * @param common The set of InputParameters from which to extract the coupled variable&#x27;s
   * properties
   * @param var_name The name of the coupled variable whose properties are to be applied
   *
   * In order to apply the properties, both the local parameters and the common parameters must
   * have a coupled variable with name var_name
   */
  void applyCoupledVar(const InputParameters &amp; common, const std::string &amp; var_name);

  /**
   * Deprecated method.  Use isParamSetByUser() instead.
   */
  bool paramSetByUser(const std::string &amp; name) const;

  /**
   * Method returns true if the parameter was set by the user
   * @param name The parameter name
   */
  bool isParamSetByUser(const std::string &amp; name) const;

  /**
   * Method returns true if the parameter is defined for any type. If the
   * type is known, use have_parameter&lt;T&gt;() instead.
   * @param name The parameter name
   */
  bool isParamDefined(const std::string &amp; name) const;

  ///@{
  /*
   * These methods are here to retrieve parameters for scalar and vector types respectively. We will
   * throw errors
   * when returning most scalar and vector types.
   */
  template &lt;typename T&gt;
  static const T &amp; getParamHelper(const std::string &amp; name, const InputParameters &amp; pars);
  ///@}

  using Parameters::get;

  /// Combine two vector parameters into a single vector of pairs
  template &lt;typename R1,
            typename R2,
            typename V1 = typename std::conditional&lt;std::is_same&lt;R1, MooseEnumItem&gt;::value,
                                                    MultiMooseEnum,
                                                    std::vector&lt;R1&gt;&gt;::type,
            typename V2 = typename std::conditional&lt;std::is_same&lt;R2, MooseEnumItem&gt;::value,
                                                    MultiMooseEnum,
                                                    std::vector&lt;R2&gt;&gt;::type&gt;
  std::vector&lt;std::pair&lt;R1, R2&gt;&gt; get(const std::string &amp; param1, const std::string &amp; param2) const;

  /**
   * @returns list of all parameters
   */
  std::set&lt;std::string&gt; getParametersList() const;

  /**
   * Return list of controllable parameters
   */
  std::set&lt;std::string&gt; getControllableParameters() const;

  /**
   * Return names of parameters within a group.
   */
  std::set&lt;std::string&gt; getGroupParameters(const std::string &amp; group) const;

  /**
   * Provide a set of reserved values for a parameter. These are values that are in addition
   * to the normal set of values the parameter can take.
   */
  void setReservedValues(const std::string &amp; name, const std::set&lt;std::string&gt; &amp; reserved);

  /**
   * Get a set of reserved parameter values.
   * Returns a set by value since we can return an empty set.
   */
  std::set&lt;std::string&gt; reservedValues(const std::string &amp; name) const;

  /**
   * @return A string representing the location (i.e. filename,linenum) in the input text for the
   * block containing parameters for this object.
   */
  std::string blockLocation() const;

  /**
   * @return A string representing the full HIT parameter path from the input file (e.g.
   * &quot;Mesh/foo&quot;) for the block containing parameters for this object.
   */
  std::string blockFullpath() const;

  /**
   * @return The hit node associated with setting the parameter \p param, if any
   */
  const hit::Node * getHitNode(const std::string &amp; param) const;
  /**
   * Sets the hit node associated with the parameter \p param to \p node
   *
   * Is protected to be called by only the Builder via the SetParamHitNodeKey.
   */
  void setHitNode(const std::string &amp; param, const hit::Node &amp; node, const SetParamHitNodeKey);

  /**
   * @return A string representing the location in the input text the parameter originated from
   * (i.e. filename,linenum) for the given param
   */
  std::string inputLocation(const std::string &amp; param) const;

  /**
   * @return A string representing the full HIT parameter path from the input file (e.g.
   * &quot;Mesh/foo/bar&quot; for param &quot;bar&quot;) for the given param.
   */
  std::string paramFullpath(const std::string &amp; param) const;

  /**
   * Returns a prefix containing the parameter name and location (if available)
   */
  std::string paramLocationPrefix(const std::string &amp; param) const;

  /**
   * @return A message used as a prefix for output relating to a parameter.
   *
   * Will first prefix with a path to the parameter, or the parameter that
   * resulted in the creation of these parameters, if available. The message
   * will then be prefixed with the block path to the parameter, if available.
   */
  template &lt;typename... Args&gt;
  std::string paramMessage(const std::string &amp; param, Args... args) const;

  /**
   * Emits an error prefixed with the object information, if available.
   */
  template &lt;typename... Args&gt;
  [[noreturn]] void mooseError(Args &amp;&amp;... args) const;

  /**
   * Emits a parameter error prefixed with the parameter location and
   * object information if available.
   */
  template &lt;typename... Args&gt;
  [[noreturn]] void paramError(const std::string &amp; param, Args... args) const;

  /**
   * @return A string representing the raw, unmodified token text for the given param.
   * This is only set if this parameter is parsed from hit
   */
  std::string rawParamVal(const std::string &amp; param) const;

  /**
   * Informs this object that values for this parameter set from the input file or from the command
   * line should be ignored
   */
  template &lt;typename T&gt;
  void ignoreParameter(const std::string &amp; name);

  /**
   * Whether to ignore the value of an input parameter set in the input file or from the command
   * line.
   */
  bool shouldIgnore(const std::string &amp; name);

  /**
   * @returns True if the parameter with name \p name is of type T.
   */
  template &lt;typename T&gt;
  bool isType(const std::string &amp; name) const;

  /**
   * Determine the actual variable name from the given variable \emph parameter name
   * @param var_param_name the name of the variable parameter, e.g. &#x27;variable&#x27;
   * @param moose_object_with_var_param_name the name of the moose object holding the variable
   * parameter. Used for potential error messaging
   */
  std::string varName(const std::string &amp; var_param_name,
                      const std::string &amp; moose_object_with_var_param_name) const;

  /**
   * Rename a parameter and provide a new documentation string
   * @param old_name The old name of the parameter
   * @param new_name The new name of the parameter
   * @param new_docstring The new documentation string for the parameter
   *                      If left empty, uses the old docstring for the renamed parameter
   */
  void renameParam(const std::string &amp; old_name,
                   const std::string &amp; new_name,
                   const std::string &amp; new_docstring);

  /**
   * Rename a coupled variable and provide a new documentation string
   * @param old_name The old name of the coupled variable
   * @param new_name The new name of the coupled variable
   * @param new_docstring The new documentation string for the coupled variable
   */
  void renameCoupledVar(const std::string &amp; old_name,
                        const std::string &amp; new_name,
                        const std::string &amp; new_docstring);

  void deprecateParam(const std::string &amp; old_name,
                      const std::string &amp; new_name,
                      const std::string &amp; removal_date);

  void deprecateCoupledVar(const std::string &amp; old_name,
                           const std::string &amp; new_name,
                           const std::string &amp; removal_date);

  /**
   * Checks whether the provided name is a renamed parameter name. If so we return the &#x27;new&#x27; name.
   * If not we return the incoming name
   * @param name The name to check for whether it is a renamed name
   * @return The new name if the incoming \p name is a renamed name, else \p name
   */
  std::string checkForRename(const std::string &amp; name) const;

  /**
   * A wrapper around the \p Parameters base class method. Checks for parameter rename before
   * calling the base class method
   * @param name The name to query the parameter values map with
   * @return The parameter value corresponding to the (possibly renamed) name
   */
  template &lt;typename T&gt;
  const T &amp; get(std::string_view name) const;

  /**
   * A wrapper around the \p Parameters base class method. Checks for parameter rename before
   * calling the base class method. This method tells whether a parameter with a known type is
   * defined. If the type is unknown, use isParamDefined().
   * @param name The name to query the parameter values map with
   * @return Whether there is a key in the parameter values map corresponding to the (possibly
   * renamed) name
   */
  template &lt;typename T&gt;
  bool have_parameter(std::string_view name) const;

  /**
   * A routine to transfer a parameter from one class&#x27; validParams to another
   * @param source_param The parameters list holding the param we would like to transfer
   * @param name The name of the parameter to transfer
   * @param new_description A new description of the parameter. If unspecified, uses the
   * source_params&#x27;
   */
  template &lt;typename T&gt;
  void transferParam(const InputParameters &amp; source_param,
                     const std::string &amp; name,
                     const std::string &amp; new_name = &quot;&quot;,
                     const std::string &amp; new_description = &quot;&quot;);

  /**
   * Return all the aliased names associated with \p param_name. The returned container will always
   * contain \p param_name itself. Other aliases in addition to \p param_name will include the base
   * class parameter name if \p param_name is the derived class parameter name, or deprecated names
   * that \p param_name is meant to replace.
   * @param param_name The name of the parameter that we want to lookup aliases for. This parameter
   * name must exist in our metadata and parameter names to values map, e.g. this parameter must
   * represent the derived class parameter name if a base class parameter has been renamed or the
   * blessed parameter name in situations where associated parameter names have been deprecated
   * @return All aliases which logically resolve-to/are-associated-with \p param_name, including \p
   * param_name itself
   */
  std::vector&lt;std::string&gt; paramAliases(const std::string &amp; param_name) const;

  /**
   * @return The hit node that represents the syntax responsible for creating
   * these parameters, if any
   */
  const hit::Node * getHitNode() const { return _hit_node; }
  /**
   * Sets the hit node that represents the syntax responsible for creating
   * these parameters
   *
   * Is protected to be called by only the ActionFactory, Builder, and Factory
   * via the SetHitNodeKey.
   */
  void setHitNode(const hit::Node &amp; node, const SetHitNodeKey) { _hit_node = &amp;node; }

  /**
   * @return Whether or not finalize() has been called
   */
  bool isFinalized() const { return _finalized; }

  /**
   * @return The DataFileName path for the parameter \p name (if any).
   */
  std::optional&lt;Moose::DataFileUtils::Path&gt; queryDataFileNamePath(const std::string &amp; name) const;

  /**
   * Entrypoint for the Builder to setup a std::vector&lt;VariableName&gt; parameter,
   * which will setup the default variable names if appropriate
   *
   * @param names The variable names
   * @param node The hit node that produced this parameter
   * @return An error message, if any
   */
  std::optional&lt;std::string&gt; setupVariableNames(std::vector&lt;VariableName&gt; &amp; names,
                                                const hit::Node &amp; node,
                                                const Moose::PassKey&lt;Moose::Builder&gt;);

private:
  // Private constructor so that InputParameters can only be created in certain places.
  InputParameters();

  /**
   * Method to terminate the recursive setParameters definition
   */
  void setParameters() {}

  template &lt;typename T&gt;
  static constexpr bool isFunctorNameType();

  /**
   * Appends description of what a functor is to a doc string.
   */
  template &lt;typename T&gt;
  std::string appendFunctorDescription(const std::string &amp; doc_string) const;

  /**
   * Private method for setting deprecated coupled variable documentation strings
   */
  void setDeprecatedVarDocString(const std::string &amp; new_name, const std::string &amp; doc_string);

  void renameParamInternal(const std::string &amp; old_name,
                           const std::string &amp; new_name,
                           const std::string &amp; docstring,
                           const std::string &amp; removal_date);

  void renameCoupledVarInternal(const std::string &amp; old_name,
                                const std::string &amp; new_name,
                                const std::string &amp; docstring,
                                const std::string &amp; removal_date);

  /**
   * Get the context associated with a parameter for a message.
   * @param param The parameter name
   * @return Pair that is the string prefix for the parameter (fullpath) and a pointer to the best
   * hit node that can be associated with the parameter (if any)
   */
  std::pair&lt;std::string, const hit::Node *&gt; paramMessageContext(const std::string &amp; param) const;
  /**
   * Get a prefix for messages associated with a parameter.
   *
   * Will include the best file path possible for the parameter and the parameter&#x27;s fullpath.
   */
  std::string paramMessagePrefix(const std::string &amp; param) const;

  struct Metadata
  {
    std::string _doc_string;
    /// The developer-designated unit of the parameter for use in documentation
    std::string _doc_unit;
    /// The custom type that will be printed in the YAML dump for a parameter if supplied
    std::string _custom_type;
    /// The data pertaining to a command line parameter (empty if not a command line param)
    std::optional&lt;CommandLineMetadata&gt; _cl_data;
    /// The searched path information pertaining to a DataFileName parameter
    std::optional&lt;Moose::DataFileUtils::Path&gt; _data_file_name_path;
    /// The names of the parameters organized into groups
    std::string _group;
    /// The map of functions used for range checked parameters
    std::string _range_function;
    /// directions for auto build vectors (base_, 5) -&gt; &quot;base_0 base_1 base_2 base_3 base_4&quot;)
    std::pair&lt;std::string, std::string&gt; _autobuild_vecs;
    /// True for parameters that are required (i.e. will cause an abort if not supplied)
    bool _required = false;
    /**
     * Whether the parameter is either explicitly set or provided a default value when added
     * Note: We do not store MooseEnum names in valid params, instead we ask MooseEnums whether
     *       they are valid or not.
     */
    bool _valid = false;
    /// The set of parameters that will NOT appear in the the dump of the parser tree
    bool _is_private = false;
    bool _have_coupled_default = false;
    /// The default value for optionally coupled variables
    std::vector&lt;Real&gt; _coupled_default = {0};
    /// True if a parameters value was set by addParam, and not set again.
    bool _set_by_add_param = false;
    /// The reserved option names for a parameter
    std::set&lt;std::string&gt; _reserved_values;
    /// If non-empty, this parameter is deprecated.
    std::string _deprecation_message;
    /// Original location of parameter node; used for error messages
    const hit::Node * _hit_node;
    /// True if the parameters is controllable
    bool _controllable = false;
    /// Controllable execute flag restriction
    std::set&lt;ExecFlagType&gt; _controllable_flags;
    /// whether user setting of this parameter should be ignored
    bool _ignore = false;
  };

  Metadata &amp; at(const std::string &amp; param_name)
  {
    const auto param = checkForRename(param_name);
    if (_params.count(param) == 0)
      mooseError(&quot;param &#x27;&quot;, param, &quot;&#x27; not present in InputParams&quot;);
    return _params[param];
  }
  const Metadata &amp; at(const std::string &amp; param_name) const
  {
    const auto param = checkForRename(param_name);
    if (_params.count(param) == 0)
      mooseError(&quot;param &#x27;&quot;, param, &quot;&#x27; not present in InputParams&quot;);
    return _params.at(param);
  }

  /**
   * Toggle the availability of the copy constructor
   *
   * When MooseObject is created via the Factory this flag is set to false, so when a MooseObject is
   * created if
   * the constructor is not a const reference an error is produced. This method allows the
   * InputParameterWarehouse
   * to disable copying.
   */
  void allowCopy(bool status) { _allow_copy = status; }

  /**
   * Make sure the parameter name doesn&#x27;t have any invalid characters.
   */
  void checkParamName(const std::string &amp; name) const;

  /**
   * This method is called when adding a Parameter with a default value, can be specialized for
   * non-matching types.
   */
  template &lt;typename T, typename S&gt;
  void setParamHelper(const std::string &amp; name, T &amp; l_value, const S &amp; r_value);

  /**
   * Helper for all of the addCommandLineParam() calls, which sets up _cl_data in the metadata
   *
   * @param name The parameter name
   * @param syntax The parameter syntax
   * @param required Whether or not the parameter is required
   * @param value_required Whethre or not the parameter requires a value
   */
  template &lt;typename T&gt;
  void addCommandLineParamHelper(const std::string &amp; name,
                                 const std::string &amp; syntax,
                                 const bool required,
                                 const bool value_required);

  /**
   * Internal helper for calling back to mooseError(), ideally from the underlying
   * MooseBase object if it is available (for more context)
   */
  [[noreturn]] void callMooseError(std::string msg,
                                   const bool with_prefix = true,
                                   const hit::Node * node = nullptr) const;

  /// The actual parameter data. Each Metadata object contains attributes for the corresponding
  /// parameter.
  std::map&lt;std::string, Metadata&gt; _params;

  /// The coupled variables set
  std::set&lt;std::string&gt; _coupled_vars;

  /// The class description for the owning object. This string is used in many places including
  /// mouse-over events, and external documentation produced from the source code.
  std::string _class_description;

  /// The parameter is used to restrict types that can be built.  Typically this is used for
  /// MooseObjectAction derived Actions.
  std::vector&lt;std::string&gt; _buildable_types;

  /// The RelationshipManagers that this object may either build or require.
  /// The optional second argument may be supplied to &quot;downgrade&quot; the functionality of the corresponding
  /// relationship manager (e.g. An AlgebraicRelationshipManager could be only used as a
  /// GeometricRelationshipManager for a given simulation).
  std::vector&lt;std::tuple&lt;std::string,
                         Moose::RelationshipManagerType,
                         Moose::RelationshipManagerInputParameterCallback&gt;&gt;
      _buildable_rm_types;

  /// This parameter collapses one level of nesting in the syntax blocks.  It is used
  /// in conjunction with MooseObjectAction derived Actions.
  bool _collapse_nesting;

  /// This parameter hides derived MOOSE object types from appearing in syntax dumps
  bool _moose_object_syntax_visibility;

  /// Flag for disabling deprecated parameters message, this is used by applyParameters to avoid
  /// dumping messages.
  bool _show_deprecated_message;

  /// A flag for toggling the error message in the copy constructor.
  bool _allow_copy;

  /// A map from deprecated coupled variable names to the new blessed name
  std::unordered_map&lt;std::string, std::string&gt; _new_to_deprecated_coupled_vars;

  /// A map from base-class/deprecated parameter names to derived-class/blessed parameter names and
  /// the deprecation messages in the case that the &quot;old&quot; parameter name is a deprecated parameter
  /// name. The deprecation message will be empty if the &quot;old&quot; parameter name represents a base
  /// class parameter name
  std::map&lt;std::string, std::pair&lt;std::string, std::string&gt;&gt; _old_to_new_name_and_dep;

  /// A map from derived-class/blessed parameter names to associated base-class/deprecated parameter
  /// names
  std::multimap&lt;std::string, std::string&gt; _new_to_old_names;

  /// The hit node representing the syntax that created these parameters, if any
  const hit::Node * _hit_node;

  /// Whether or not we&#x27;ve called finalize() on these parameters yet
  bool _finalized;

  // These are the only objects allowed to _create_ InputParameters
  friend InputParameters emptyInputParameters();
  friend class InputParameterWarehouse;
  friend class Parser;
  // for the printInputFile function in the action warehouse
  friend class ActionWarehouse;
};

template &lt;typename T&gt;
void
InputParameters::setHelper(const std::string &amp; /*name*/)
{
}

// Template and inline function implementations
template &lt;typename T&gt;
T &amp;
InputParameters::set(const std::string &amp; name_in, bool quiet_mode)
{
  const auto name = checkForRename(name_in);

  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  T &amp; result = this-&gt;Parameters::set&lt;T&gt;(name);

  if (quiet_mode)
    _params[name]._set_by_add_param = true;

  setHelper&lt;T&gt;(name);

  return result;
}

template &lt;typename T, typename... Ts&gt;
void
InputParameters::setParameters(const std::string &amp; name,
                               const T &amp; value,
                               Ts... extra_input_parameters)
{
  this-&gt;set&lt;T&gt;(name) = value;
  this-&gt;setParameters(extra_input_parameters...);
}

template &lt;typename T, typename UP_T&gt;
std::optional&lt;std::pair&lt;bool, std::string&gt;&gt;
InputParameters::rangeCheck(const std::string &amp; full_name,
                            const std::string &amp; short_name,
                            const InputParameters::Parameter&lt;std::vector&lt;T&gt;&gt; &amp; param,
                            const bool include_param_path)
{
  if (!isParamValid(short_name))
    return {};

  const auto &amp; range_function = _params[short_name]._range_function;
  if (range_function.empty())
    return {};

  /**
   * Automatically detect the variables used in the range checking expression.
   * We allow the following variables (where snam is the short_name of the parameter)
   *
   * snam       : tests every component in the vector
   *              &#x27;snam &gt; 0&#x27;
   * snam_size  : the size of the vector
   *              &#x27;snam_size = 5&#x27;
   * snam_i     : where i is a number from 0 to sname_size-1 tests a specific component
   *              &#x27;snam_0 &gt; snam_1&#x27;
   */
  FunctionParserBase&lt;UP_T&gt; fp;
  std::vector&lt;std::string&gt; vars;
  if (fp.ParseAndDeduceVariables(range_function, vars) != -1) // -1 for success
    return {{false,
             &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27; for parameter &quot; + short_name + &quot;&quot;}};

  // Fparser parameter buffer
  std::vector&lt;UP_T&gt; parbuf(vars.size());

  // parameter vector
  const std::vector&lt;T&gt; &amp; value = param.get();

  // iterate over all vector values (maybe ;)
  bool need_to_iterate = false;
  unsigned int i = 0;
  do
  {
    // set parameters
    for (unsigned int j = 0; j &lt; vars.size(); j++)
    {
      if (vars[j] == short_name)
      {
        if (value.size() == 0)
        {
          std::ostringstream oss;
          oss &lt;&lt; &quot;Range checking empty vector&quot;;
          if (include_param_path)
            oss &lt;&lt; &quot; parameter &quot; &lt;&lt; full_name;
          oss &lt;&lt; &quot;; expression = &#x27;&quot; &lt;&lt; range_function &lt;&lt; &quot;&#x27;&quot;;
          return {{true, oss.str()}};
        }

        parbuf[j] = value[i];
        need_to_iterate = true;
      }
      else if (vars[j] == short_name + &quot;_size&quot;)
        parbuf[j] = value.size();
      else
      {
        if (vars[j].substr(0, short_name.size() + 1) != short_name + &quot;_&quot;)
          return {{false, &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27;&quot;}};
        std::istringstream iss(vars[j]);
        iss.seekg(short_name.size() + 1);

        size_t index;
        if (iss &gt;&gt; index &amp;&amp; iss.eof())
        {
          if (index &gt;= value.size())
          {
            std::ostringstream oss;
            oss &lt;&lt; &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27;&quot;;
            if (include_param_path)
              oss &lt;&lt; &quot; for parameter &quot; &lt;&lt; full_name;
            oss &lt;&lt; &quot;; out of range variable &#x27;&quot; + vars[j] &lt;&lt; &quot;&#x27;&quot;;
            return {{true, oss.str()}};
          }
          parbuf[j] = value[index];
        }
        else
          return {{false,
                   &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27;; invalid variable &#x27;&quot; +
                       vars[j] + &quot;&#x27;&quot;}};
      }
    }

    // ensure range-checked input file parameter comparison functions
    // do absolute floating point comparisons instead of using a default epsilon.
    auto tmp_eps = fp.epsilon();
    fp.setEpsilon(0);
    UP_T result = fp.Eval(&amp;parbuf[0]);
    fp.setEpsilon(tmp_eps);

    // test function using the parameters determined above
    if (fp.EvalError())
      return {{false, &quot;Error evaluating expression &#x27;&quot; + range_function + &quot;&#x27;&quot;}};

    if (!result)
    {
      std::ostringstream oss;
      oss &lt;&lt; &quot;Range check failed&quot;;
      if (include_param_path)
        oss &lt;&lt; &quot; for parameter &quot; &lt;&lt; full_name;
      oss &lt;&lt; &quot;; expression = &#x27;&quot; &lt;&lt; range_function &lt;&lt; &quot;&#x27;&quot;;
      if (need_to_iterate)
        oss &lt;&lt; &quot;, component &quot; &lt;&lt; i;
      return {{true, oss.str()}};
    }

  } while (need_to_iterate &amp;&amp; ++i &lt; value.size());

  return {};
}

template &lt;typename T, typename UP_T&gt;
std::optional&lt;std::pair&lt;bool, std::string&gt;&gt;
InputParameters::rangeCheck(const std::string &amp; full_name,
                            const std::string &amp; short_name,
                            const InputParameters::Parameter&lt;T&gt; &amp; param,
                            const bool include_param_path)
{
  if (!isParamValid(short_name))
    return {};

  const auto &amp; range_function = _params[short_name]._range_function;
  if (range_function.empty())
    return {};

  // Parse the expression
  FunctionParserBase&lt;UP_T&gt; fp;
  if (fp.Parse(range_function, short_name) != -1) // -1 for success
    return {{false,
             &quot;Error parsing expression &#x27;&quot; + range_function + &quot;&#x27;&quot; + &quot; for parameter &quot; + short_name}};

  // ensure range-checked input file parameter comparison functions
  // do absolute floating point comparisons instead of using a default epsilon.
  auto tmp_eps = fp.epsilon();
  fp.setEpsilon(0);
  // We require a non-const value for the implicit upscaling of the parameter type
  std::vector&lt;UP_T&gt; value(1, param.get());
  UP_T result = fp.Eval(&amp;value[0]);
  fp.setEpsilon(tmp_eps);

  if (fp.EvalError())
    return {{true,
             &quot;Error evaluating expression &#x27;&quot; + range_function + &quot;&#x27; for parameter &quot; + short_name +
                 &quot;; perhaps you used the wrong variable name?&quot;}};

  if (!result)
  {
    std::ostringstream oss;
    oss &lt;&lt; &quot;Range check failed&quot;;
    if (include_param_path)
      oss &lt;&lt; &quot; for parameter &quot; &lt;&lt; full_name;
    oss &lt;&lt; &quot;; expression = &#x27;&quot; &lt;&lt; range_function &lt;&lt; &quot;&#x27;, value = &quot; &lt;&lt; value[0];
    return {{true, oss.str()}};
  }

  return {};
}

template &lt;typename T&gt;
T
InputParameters::getCheckedPointerParam(const std::string &amp; name_in,
                                        const std::string &amp; error_string) const
{
  const auto name = checkForRename(name_in);

  T param = this-&gt;get&lt;T&gt;(name);

  // Note: You will receive a compile error on this line if you attempt to pass a non-pointer
  // template type to this method
  if (!param)
    mooseError(&quot;Parameter &quot;, name, &quot; is NULL.\n&quot;, error_string);
  return this-&gt;get&lt;T&gt;(name);
}

template &lt;typename T&gt;
void
InputParameters::addRequiredParam(const std::string &amp; name, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  auto &amp; metadata = _params[name];
  metadata._required = true;
  if constexpr (isFunctorNameType&lt;T&gt;())
    metadata._doc_string = appendFunctorDescription&lt;T&gt;(doc_string);
  else
    metadata._doc_string = doc_string;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredParam(const std::string &amp; /*name*/,
                                  const T &amp; /*value*/,
                                  const std::string &amp; /*doc_string*/)
{
  mooseError(&quot;You cannot call addRequiredParam and supply a default value for this type, please &quot;
             &quot;use addParam instead&quot;);
}

template &lt;typename T, typename S&gt;
void
InputParameters::addParam(const std::string &amp; name, const S &amp; value, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  T &amp; l_value = InputParameters::set&lt;T&gt;(name);
  auto &amp; metadata = _params[name];
  if constexpr (isFunctorNameType&lt;T&gt;())
    metadata._doc_string = appendFunctorDescription&lt;T&gt;(doc_string);
  else
    metadata._doc_string = doc_string;

  // Set the parameter now
  setParamHelper(name, l_value, value);

  /* Indicate the default value, as set via addParam, is being used. The parameter is removed from
     the list whenever
     it changes, see set_attributes */
  metadata._set_by_add_param = true;
}

template &lt;typename T&gt;
void
InputParameters::addParam(const std::string &amp; name, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  if constexpr (isFunctorNameType&lt;T&gt;())
    _params[name]._doc_string = appendFunctorDescription&lt;T&gt;(doc_string);
  else
    _params[name]._doc_string = doc_string;
}

template &lt;typename T, typename S&gt;
void
InputParameters::setParamHelper(const std::string &amp; /*name*/, T &amp; l_value, const S &amp; r_value)
{
  l_value = r_value;
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParamHelper(const std::string &amp; name,
                                           const std::string &amp; syntax,
                                           const bool required,
                                           const bool value_required)
{
  static_assert(isValidCommandLineType&lt;T&gt;::value,
                &quot;This type is not a supported command line parameter type. See &quot;
                &quot;CommandLine::populateCommandLineParams to add it as a supported type.&quot;);

  auto &amp; cl_data = at(name)._cl_data;
  cl_data = CommandLineMetadata();

  // Split up the syntax by whitespace
  std::vector&lt;std::string&gt; syntax_split;
  MooseUtils::tokenize(syntax, syntax_split, 1, &quot; \t\n\v\f\r&quot;);

  // Set the single syntax string as the combined syntax with removed whitespace
  cl_data-&gt;syntax = MooseUtils::stringJoin(syntax_split);
  mooseAssert(cl_data-&gt;syntax.size(), &quot;Empty token&quot;);

  // Set the switches; only parse those that begin with &quot;-&quot; as we also
  // provide examples within the syntax
  for (const auto &amp; val : syntax_split)
    if (val.rfind(&quot;-&quot;, 0) == 0)
    {
      if (!std::regex_search(val, std::regex(&quot;^\\-+[a-zA-Z]&quot;)))
        mooseError(&quot;The switch &#x27;&quot;,
                   val,
                   &quot;&#x27; for the command line parameter &#x27;&quot;,
                   name,
                   &quot;&#x27; is invalid. It must begin with an alphabetical character.&quot;);

      cl_data-&gt;switches.push_back(val);
      libMesh::add_command_line_name(val);
    }

  cl_data-&gt;required = required;
  cl_data-&gt;global = false;

  // No arguments needed for a boolean parameter
  if constexpr (std::is_same_v&lt;T, bool&gt;)
  {
    (void)value_required; // purposely unused; doesn&#x27;t take a value
    cl_data-&gt;argument_type = CommandLineMetadata::ArgumentType::NONE;
  }
  // MooseEnums require a value
  else if constexpr (std::is_same_v&lt;T, MooseEnum&gt;)
  {
    (void)value_required; // purposely unused; always required
    cl_data-&gt;argument_type = CommandLineMetadata::ArgumentType::REQUIRED;
  }
  // The user didn&#x27;t specify a default, so a value is required
  else if (value_required)
    cl_data-&gt;argument_type = CommandLineMetadata::ArgumentType::REQUIRED;
  // Otherwise, it&#x27;s optional (user specified a default)
  else
    cl_data-&gt;argument_type = CommandLineMetadata::ArgumentType::OPTIONAL;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredRangeCheckedParam(const std::string &amp; name,
                                              const std::string &amp; parsed_function,
                                              const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRangeCheckedParam(const std::string &amp; name,
                                      const T &amp; value,
                                      const std::string &amp; parsed_function,
                                      const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRangeCheckedParam(const std::string &amp; name,
                                      const std::string &amp; parsed_function,
                                      const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredCustomTypeParam(const std::string &amp; name,
                                            const std::string &amp; custom_type,
                                            const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addCustomTypeParam(const std::string &amp; name,
                                    const T &amp; value,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addCustomTypeParam(const std::string &amp; name,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedCustomTypeParam(const std::string &amp; name,
                                              const std::string &amp; custom_type,
                                              const std::string &amp; doc_string,
                                              const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  addParam&lt;T&gt;(name, doc_string);
  auto &amp; metadata = _params[name];
  metadata._custom_type = custom_type;

  metadata._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

template &lt;typename T&gt;
void
InputParameters::addPrivateParam(const std::string &amp; name)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  _params[name]._is_private = true;
}

template &lt;typename T&gt;
void
InputParameters::addPrivateParam(const std::string &amp; name, const T &amp; value)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::set&lt;T&gt;(name) = value;
  auto &amp; metadata = _params[name];
  metadata._is_private = true;
  metadata._set_by_add_param = true;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredCommandLineParam(const std::string &amp; name,
                                             const std::string &amp; syntax,
                                             const std::string &amp; doc_string)
{
  static_assert(!std::is_same_v&lt;T, bool&gt;, &quot;Cannot be used for a bool&quot;);

  addRequiredParam&lt;T&gt;(name, doc_string);
  addCommandLineParamHelper&lt;T&gt;(name, syntax, /* required = */ true, /* value_required = */ true);
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParam(const std::string &amp; name,
                                     const std::string &amp; syntax,
                                     const std::string &amp; doc_string)
{
  static_assert(!std::is_same_v&lt;T, MooseEnum&gt;,
                &quot;addCommandLineParam() without a value cannot be used with a MooseEnum because a &quot;
                &quot;MooseEnum requires initialization&quot;);

  auto constexpr is_bool = std::is_same_v&lt;T, bool&gt;;
  if constexpr (is_bool)
    addParam&lt;T&gt;(name, false, doc_string);
  else
    addParam&lt;T&gt;(name, doc_string);

  addCommandLineParamHelper&lt;T&gt;(
      name, syntax, /* required = */ false, /* value_required = */ !is_bool);
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParam(const std::string &amp; name,
                                     const std::string &amp; syntax,
                                     const T &amp; value,
                                     const std::string &amp; doc_string)
{
  if constexpr (std::is_same_v&lt;T, bool&gt;)
    mooseAssert(!value, &quot;Default for bool must be false&quot;);

  addParam&lt;T&gt;(name, value, doc_string);
  addCommandLineParamHelper&lt;T&gt;(name, syntax, /* required = */ false, /* value_required = */ true);
}

template &lt;typename T&gt;
void
InputParameters::addOptionalValuedCommandLineParam(const std::string &amp; name,
                                                   const std::string &amp; syntax,
                                                   const T &amp; value,
                                                   const std::string &amp; doc_string)
{
  mooseAssert(name == &quot;csg_only&quot; || name == &quot;mesh_only&quot; || name == &quot;recover&quot; || name == &quot;run&quot;,
              &quot;Not supported for new parameters&quot;);
  static_assert(!std::is_same_v&lt;T, bool&gt;, &quot;Cannot be used for a bool (does not take a value)&quot;);
  addParam&lt;T&gt;(name, value, doc_string);
  addCommandLineParamHelper&lt;T&gt;(name, syntax, /* required = */ false, /* value_required = */ false);
}

template &lt;typename T&gt;
void
InputParameters::checkConsistentType(const std::string &amp; name_in) const
{
  const auto name = checkForRename(name_in);

  // If we don&#x27;t currently have the Parameter, can&#x27;t be any inconsistency
  InputParameters::const_iterator it = _values.find(name);
  if (it == _values.end())
    return;

  // Now, if we already have the Parameter, but it doesn&#x27;t have the
  // right type, throw an error.
  if (!this-&gt;Parameters::have_parameter&lt;T&gt;(name))
    mooseError(&quot;Attempting to set parameter \&quot;&quot;,
               name,
               &quot;\&quot; with type (&quot;,
               libMesh::demangle(typeid(T).name()),
               &quot;)\nbut the parameter already exists as type (&quot;,
               it-&gt;second-&gt;type(),
               &quot;)&quot;);
}

template &lt;typename T&gt;
void
InputParameters::suppressParameter(const std::string &amp; name_in)
{
  const auto name = checkForRename(name_in);
  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to suppress nonexistent parameter: &quot;, name);

  auto &amp; metadata = _params[name];
  metadata._required = false;
  metadata._is_private = true;
  metadata._controllable = false;
}

template &lt;typename T&gt;
void
InputParameters::ignoreParameter(const std::string &amp; name_in)
{
  const auto name = checkForRename(name_in);
  suppressParameter&lt;T&gt;(name);
  _params[name]._ignore = true;
}

template &lt;typename T&gt;
void
InputParameters::makeParamRequired(const std::string &amp; name_in)
{
  const auto name = checkForRename(name_in);

  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to require nonexistent parameter: &quot;, name);

  _params[name]._required = true;
}

template &lt;typename T&gt;
void
InputParameters::makeParamNotRequired(const std::string &amp; name_in)
{
  const auto name = checkForRename(name_in);

  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to un-require nonexistent parameter: &quot;, name);

  _params[name]._required = false;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedParam(const std::string &amp; name,
                                    const T &amp; value,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  mooseAssert(!_old_to_new_name_and_dep.count(name),
              &quot;Attempting to deprecate via addDeprecatedParam the parameter, &#x27;&quot;
                  &lt;&lt; name &lt;&lt; &quot;&#x27;, already deprecated via deprecateParam or renamed via renameParam&quot;);
  addParam&lt;T&gt;(name, value, doc_string);

  _params[name]._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedParam(const std::string &amp; name,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  mooseAssert(!_old_to_new_name_and_dep.count(name),
              &quot;Attempting to deprecate via addDeprecatedParam the parameter, &#x27;&quot;
                  &lt;&lt; name &lt;&lt; &quot;&#x27;, already deprecated via deprecateParam or renamed via renameParam&quot;);
  addParam&lt;T&gt;(name, doc_string);

  _params[name]._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

// Forward declare MooseEnum specializations for add*Param
template &lt;&gt;
void InputParameters::addRequiredParam&lt;MooseEnum&gt;(const std::string &amp; name,
                                                  const MooseEnum &amp; moose_enum,
                                                  const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                       const MultiMooseEnum &amp; moose_enum,
                                                       const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;std::vector&lt;MooseEnum&gt;&gt;(
    const std::string &amp; name,
    const std::vector&lt;MooseEnum&gt; &amp; moose_enums,
    const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;std::vector&lt;MultiMooseEnum&gt;&gt;(
    const std::string &amp; name,
    const std::vector&lt;MultiMooseEnum&gt; &amp; moose_enums,
    const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/,
                                          const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/,
                                               const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;std::vector&lt;MooseEnum&gt;&gt;(const std::string &amp; /*name*/,
                                                       const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;std::vector&lt;MultiMooseEnum&gt;&gt;(const std::string &amp; /*name*/,
                                                            const std::string &amp; /*doc_string*/);

template &lt;&gt;
void
InputParameters::addRequiredParam&lt;std::vector&lt;MultiMooseEnum&gt;&gt;(const std::string &amp; /*name*/,
                                                               const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addPrivateParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/);

template &lt;&gt;
void InputParameters::addPrivateParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/,
                                                    const std::string &amp; /*doc_string*/,
                                                    const std::string &amp; /*deprecation_message*/);

template &lt;&gt;
void
InputParameters::addDeprecatedParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/,
                                                    const std::string &amp; /*doc_string*/,
                                                    const std::string &amp; /*deprecation_message*/);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;std::vector&lt;MooseEnum&gt;&gt;(
    const std::string &amp; /*name*/,
    const std::string &amp; /*doc_string*/,
    const std::string &amp; /*deprecation_message*/);

// Forward declare specializations for setParamHelper
template &lt;&gt;
void InputParameters::setParamHelper&lt;PostprocessorName, Real&gt;(const std::string &amp; name,
                                                              PostprocessorName &amp; l_value,
                                                              const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;PostprocessorName, int&gt;(const std::string &amp; name,
                                                             PostprocessorName &amp; l_value,
                                                             const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;FunctionName, Real&gt;(const std::string &amp; /*name*/,
                                                         FunctionName &amp; l_value,
                                                         const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;FunctionName, int&gt;(const std::string &amp; /*name*/,
                                                        FunctionName &amp; l_value,
                                                        const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MaterialPropertyName, Real&gt;(const std::string &amp; /*name*/,
                                                                 MaterialPropertyName &amp; l_value,
                                                                 const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MaterialPropertyName, int&gt;(const std::string &amp; /*name*/,
                                                                MaterialPropertyName &amp; l_value,
                                                                const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MooseFunctorName, Real&gt;(const std::string &amp; /*name*/,
                                                             MooseFunctorName &amp; l_value,
                                                             const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MooseFunctorName, int&gt;(const std::string &amp; /*name*/,
                                                            MooseFunctorName &amp; l_value,
                                                            const int &amp; r_value);

template &lt;typename T&gt;
const T &amp;
InputParameters::getParamHelper(const std::string &amp; name_in, const InputParameters &amp; pars)
{
  const auto name = pars.checkForRename(name_in);

  if (!pars.isParamValid(name))
    pars.mooseError(&quot;The parameter \&quot;&quot;, name, &quot;\&quot; is being retrieved before being set.&quot;);

  return pars.get&lt;T&gt;(name);
}

// Declare specializations so we don&#x27;t fall back on the generic
// implementation, but the definition will be in InputParameters.C so
// we won&#x27;t need to bring in *MooseEnum header files here.
template &lt;&gt;
const MooseEnum &amp; InputParameters::getParamHelper&lt;MooseEnum&gt;(const std::string &amp; name,
                                                             const InputParameters &amp; pars);

template &lt;&gt;
const MultiMooseEnum &amp;
InputParameters::getParamHelper&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                const InputParameters &amp; pars);

template &lt;typename R1, typename R2, typename V1, typename V2&gt;
std::vector&lt;std::pair&lt;R1, R2&gt;&gt;
InputParameters::get(const std::string &amp; param1_in, const std::string &amp; param2_in) const
{
  const auto param1 = checkForRename(param1_in);
  const auto param2 = checkForRename(param2_in);

  const auto &amp; v1 = get&lt;V1&gt;(param1);
  const auto &amp; v2 = get&lt;V2&gt;(param2);

  auto controllable = getControllableParameters();
  if (controllable.count(param1) || controllable.count(param2))
    mooseError(&quot;Parameters &quot;,
               param1,
               &quot; and/or &quot;,
               param2 + &quot; are controllable parameters and cannot be retireved using &quot;
                        &quot;the MooseObject::getParam/InputParameters::get methods for pairs&quot;);

  if (v1.size() != v2.size())
    paramError(param1,
               &quot;Vector parameters &quot;,
               param1,
               &quot;(size: &quot;,
               v1.size(),
               &quot;) and &quot; + param2,
               &quot;(size: &quot;,
               v2.size(),
               &quot;) are of different lengths \n&quot;);

  std::vector&lt;std::pair&lt;R1, R2&gt;&gt; parameter_pairs;
  auto i1 = v1.begin();
  auto i2 = v2.begin();
  for (; i1 != v1.end() &amp;&amp; i2 != v2.end(); ++i1, ++i2)
    parameter_pairs.emplace_back(std::make_pair(*i1, *i2));
  return parameter_pairs;
}

InputParameters emptyInputParameters();

template &lt;typename T&gt;
bool
InputParameters::isType(const std::string &amp; name_in) const
{
  const auto name = checkForRename(name_in);

  if (!_params.count(name))
    mooseError(&quot;Parameter \&quot;&quot;, name, &quot;\&quot; is not valid.&quot;);
  return have_parameter&lt;T&gt;(name);
}

template &lt;typename T&gt;
const T &amp;
InputParameters::get(std::string_view name_in) const
{
  const auto name = checkForRename(std::string(name_in));

  return Parameters::get&lt;T&gt;(name);
}

template &lt;typename T&gt;
bool
InputParameters::have_parameter(std::string_view name_in) const
{
  const auto name = checkForRename(std::string(name_in));

  return Parameters::have_parameter&lt;T&gt;(name);
}

template &lt;typename T&gt;
void
InputParameters::transferParam(const InputParameters &amp; source_params,
                               const std::string &amp; name_in,
                               const std::string &amp; new_name,
                               const std::string &amp; new_description)
{
  const auto name = source_params.checkForRename(std::string(name_in));
  const auto p_name = new_name.empty() ? name_in : new_name;
  if (!source_params.have_parameter&lt;T&gt;(name) &amp;&amp; !source_params.hasCoupledValue(name))
    mooseError(&quot;The &#x27;&quot;,
               name_in,
               &quot;&#x27; parameter could not be transferred because it does not exist with type &#x27;&quot;,
               MooseUtils::prettyCppType&lt;T&gt;(),
               &quot;&#x27; in the source parameters&quot;);
  if (name != name_in)
    mooseWarning(&quot;The transferred parameter &quot; + name_in + &quot; is deprecated in favor of &quot; + name +
                 &quot; in the source parameters. The new name should likely be used for the parameter &quot;
                 &quot;transfer instead.&quot;);
  const std::string description =
      new_description.empty() ? source_params.getDescription(name) : new_description;

  if (source_params.isParamRequired(name))
  {
    // Check for a variable parameter
    if (source_params.hasCoupledValue(name))
      addRequiredCoupledVar(p_name, description);
    // Enums parameters have a default list of options
    else if constexpr (std::is_same_v&lt;MooseEnum, T&gt; || std::is_same_v&lt;MultiMooseEnum, T&gt;)
      addRequiredParam&lt;T&gt;(p_name, source_params.get&lt;T&gt;(name), description);
    else if (source_params.isRangeChecked(name))
      addRequiredRangeCheckedParam&lt;T&gt;(
          p_name, source_params.rangeCheckedFunction(name), description);
    else
      addRequiredParam&lt;T&gt;(p_name, description);
  }
  else
  {
    // Check for a variable parameter
    if (source_params.hasCoupledValue(name))
    {
      if (!source_params.hasDefaultCoupledValue(name))
        addCoupledVar(p_name, description);
      else if (source_params.numberDefaultCoupledValues(name) == 1)
        addCoupledVar(p_name, source_params.defaultCoupledValue(name), description);
      else
      {
        std::vector&lt;Real&gt; coupled_values;
        for (const auto i : libMesh::make_range(source_params.numberDefaultCoupledValues(name)))
          coupled_values.push_back(source_params.defaultCoupledValue(name, i));
        addCoupledVar(p_name, coupled_values, description);
      }
    }
    else if (source_params.isRangeChecked(name))
    {
      if (source_params.hasDefault(name))
        addRangeCheckedParam&lt;T&gt;(p_name,
                                source_params.get&lt;T&gt;(name),
                                source_params.rangeCheckedFunction(name),
                                description);
      else
        addRangeCheckedParam&lt;T&gt;(p_name, source_params.rangeCheckedFunction(name), description);
    }
    else if constexpr (std::is_same_v&lt;MooseEnum, T&gt; || std::is_same_v&lt;MultiMooseEnum, T&gt;)
      addParam&lt;T&gt;(p_name, source_params.get&lt;T&gt;(name), description);
    else
    {
      if (source_params.hasDefault(name))
        addParam&lt;T&gt;(p_name, source_params.get&lt;T&gt;(name), description);
      else
        addParam&lt;T&gt;(p_name, description);
    }
  }

  // Copy other attributes
  if (source_params.isPrivate(name))
    _params[p_name]._is_private = true;
  if (source_params.isControllable(name))
    _params[p_name]._controllable = true;
}

template &lt;typename... Args&gt;
[[noreturn]] void
InputParameters::mooseError(Args &amp;&amp;... args) const
{
  std::ostringstream oss;
  moose::internal::mooseStreamAll(oss, std::forward&lt;Args&gt;(args)...);
  callMooseError(oss.str());
}

template &lt;typename... Args&gt;
std::string
InputParameters::paramMessage(const std::string &amp; param, Args... args) const
{
  std::ostringstream oss;
  moose::internal::mooseStreamAll(oss, std::forward&lt;Args&gt;(args)...);
  return paramMessagePrefix(param) + oss.str();
}

template &lt;typename... Args&gt;
[[noreturn]] void
InputParameters::paramError(const std::string &amp; param, Args... args) const
{
  std::ostringstream oss;
  moose::internal::mooseStreamAll(oss, std::forward&lt;Args&gt;(args)...);
  const auto [prefix, node] = paramMessageContext(param);

  Moose::show_trace = false;
  callMooseError(prefix + oss.str(), false, node);
  Moose::show_trace = true;
}

namespace Moose
{
namespace internal
{
template &lt;typename T&gt;
constexpr T *
getNullptrExample()
{
  return nullptr;
}

#ifdef MOOSE_MFEM_ENABLED

template &lt;typename T&gt;
constexpr bool
isMFEMFunctorNameTypeHelper(T *)
{
  return std::is_same_v&lt;T, MFEMScalarCoefficientName&gt; ||
         std::is_same_v&lt;T, MFEMVectorCoefficientName&gt;;
}

template &lt;typename T, typename A&gt;
constexpr bool
isMFEMFunctorNameTypeHelper(std::vector&lt;T, A&gt; *)
{
  return isMFEMFunctorNameTypeHelper(getNullptrExample&lt;T&gt;());
}

#endif

template &lt;typename T&gt;
constexpr bool
isScalarFunctorNameTypeHelper(T *)
{
  return std::is_same_v&lt;T, MooseFunctorName&gt;
#ifdef MOOSE_MFEM_ENABLED
         || std::is_same_v&lt;T, MFEMScalarCoefficientName&gt;
#endif
      ;
}

template &lt;typename T, typename A&gt;
constexpr bool
isScalarFunctorNameTypeHelper(std::vector&lt;T, A&gt; *)
{
  return isScalarFunctorNameTypeHelper(getNullptrExample&lt;T&gt;());
}

template &lt;typename T&gt;
constexpr bool
isVectorFunctorNameTypeHelper(T *)
{
#ifdef MOOSE_MFEM_ENABLED
  return std::is_same_v&lt;T, MFEMVectorCoefficientName&gt;;
#else
  return false;
#endif
}

template &lt;typename T, typename A&gt;
constexpr bool
isVectorFunctorNameTypeHelper(std::vector&lt;T, A&gt; *)
{
  return isVectorFunctorNameTypeHelper(getNullptrExample&lt;T&gt;());
}

template &lt;typename T&gt;
constexpr bool
isFunctorNameTypeHelper(T * ex)
{
  return isScalarFunctorNameTypeHelper(ex) || isVectorFunctorNameTypeHelper(ex);
}
}
}

template &lt;typename T&gt;
constexpr bool
InputParameters::isFunctorNameType()
{
  return Moose::internal::isFunctorNameTypeHelper(Moose::internal::getNullptrExample&lt;T&gt;());
}

template &lt;typename T&gt;
std::string
InputParameters::appendFunctorDescription(const std::string &amp; doc_string) const
{
  auto numeric_value_type = []()
  {
    if constexpr (Moose::internal::isScalarFunctorNameTypeHelper(
                      Moose::internal::getNullptrExample&lt;T&gt;()))
      return &quot;number&quot;;
    else if constexpr (Moose::internal::isVectorFunctorNameTypeHelper(
                           Moose::internal::getNullptrExample&lt;T&gt;()))
      return &quot;numeric vector value (enclosed in curly braces)&quot;;
    else
    {
      mooseAssert(false, &quot;We control instantiations of this method&quot;);
      return &quot;&quot;;
    }
  };

  return MooseUtils::trim(doc_string, &quot;. &quot;) + &quot;. A functor is any of the following: a variable, &quot; +
         (
#ifdef MOOSE_MFEM_ENABLED
             Moose::internal::isMFEMFunctorNameTypeHelper(Moose::internal::getNullptrExample&lt;T&gt;())
                 ? &quot;an MFEM&quot;
                 :
#endif
                 &quot;a functor&quot;) +
         &quot; material property, a function, a postprocessor or a &quot; + numeric_value_type() + &quot;.&quot;;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
<!DOCTYPE html><head><meta charset="UTF-8"><title>Compile time Derivatives | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="40063018-b1db-489a-9c99-c96935614d72" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ae6aa765-6b6b-4922-9bd7-4123bef081c5" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="bdd56191-d079-4e42-8070-f09bab4ffd25" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f7222f66-7109-4021-8f4a-8f0b3dfd384d" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="34b1ee02-5710-4289-b66d-c24a2ea1de4b"><i class="material-icons">menu</i></a><ul class="sidenav" id="34b1ee02-5710-4289-b66d-c24a2ea1de4b"><li><a href="#!" class="dropdown-trigger" data-target="febd794e-2a1f-451e-a034-41276c80f402" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="26192d46-69d6-4cec-968b-b75cd5e62645" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d9d924cf-dc2f-4f16-b1c6-82109096d437" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b1079743-2338-46ea-8154-e5a3278455c5" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="40063018-b1db-489a-9c99-c96935614d72"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="ae6aa765-6b6b-4922-9bd7-4123bef081c5"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="bdd56191-d079-4e42-8070-f09bab4ffd25"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="f7222f66-7109-4021-8f4a-8f0b3dfd384d"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="febd794e-2a1f-451e-a034-41276c80f402"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="26192d46-69d6-4cec-968b-b75cd5e62645"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="d9d924cf-dc2f-4f16-b1c6-82109096d437"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="b1079743-2338-46ea-8154-e5a3278455c5"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="597a3105-7aab-4614-87fe-fac6c2e61083" data-section-level="1" data-section-text="Compile - time Derivatives"><h1 id="compile-time-derivatives">Compile-time Derivatives</h1><p><code>CompileTimeDerivatives</code> (CTD) is a C++ namespace containing classes, functions, and operators to implement mathematical expressions with the ability to perform symbolic automatic differentiation at compile time. It is a replacement for the runtime automatic differentiation in <a href="../../modules/phase_field/FunctionMaterials/ExpressionBuilder.html"><code>ExpressionBuilder</code></a> which uses a convoluted process to arrive at compiled mathematical expressions and their derivatives.</p><section id="c9b55c8f-08f9-4ac8-a556-80d0a453f56f" data-section-level="2" data-section-text="Uses"><h2 id="uses">Uses</h2><p>The intended uses for the CTD framework are the implementation of empirical or analytical models with closed form expressions that compute quantities of which derivatives are required. Examples are</p><ol class="browser-default" start="1"><li><p>Thermodynamic free energies, the derivatives of which are chemical potentials, which are required to solve the phase field equations. </p></li><li><p>A thermal conductivity as a function of temperature, where the derivative w.r.t. temperature is required in the heat transfer equations.</p></li></ol><p>CTD is not meant to replace runtime AD using dual numbers (which computes derivatives w.r.t. degrees of freedom). Any application that requires the construction of symbolic derivatives of equations w.r.t. known coupled variables, can be simplified with CTD.</p></section><section id="82e0c280-c98c-4695-80e1-a99f82a31465" data-section-level="2" data-section-text="Examples"><h2 id="examples">Examples</h2><p>Constructing an expression and taking its derivative.</p><p>Create a _tag_ that will identify the variable</p><pre style="max-height:350px;"><code class="language-cpp">
  enum
  {
    dX
  };
</code></pre><p>Connect a C++ variable and a _tag_ to obtain a compile time derivative reference object that will evaluate as the C++ variable value:</p><pre style="max-height:350px;"><code class="language-cpp">
  Real x;
  const auto X = makeRef&lt;dX&gt;(x);
</code></pre><p>Build an expression for <code>x^2+100</code>:</p><pre style="max-height:350px;"><code class="language-cpp">
  const auto result = X * X + 100.0;
</code></pre><p>Evaluate the expression for x=5:</p><pre style="max-height:350px;"><code class="language-text">
  x = 5;
  Moose::out &lt;&lt; result() &lt;&lt; &#x27;\n&#x27;; // 125.0
</code></pre><p>And evaluate the derivative w.r.t. <code>x</code> at x=5:</p><pre style="max-height:350px;"><code class="language-text">
  Moose::out &lt;&lt; result.D&lt;dX&gt;()() &lt;&lt; &#x27;\n&#x27;; // 10.0
</code></pre><p>Note that there is no runtime cost to calling <code>.D&lt;dX&gt;()</code>. The derivatives are taken at compile time.</p><p>The unit tests contain more examples on how to use the system.</p><pre style="max-height:350px;"><code class="language-cpp">
#include &quot;gtest/gtest.h&quot;

// Moose includes
#include &quot;MooseTypes.h&quot;
#include &quot;CompileTimeDerivatives.h&quot;

using namespace CompileTimeDerivatives;

TEST(CompileTimeDerivativesTest, simple)
{
  // this test serves as a simple example for the compile time derivative system

  // a variable to be used in the expression evaluation
  Real my_x = 1.0;

  // use an enum to use symbols for tags
  enum
  {
    dx
  };

  // we wrap this variable in a reference node that we tag with the `dx` enum
  const auto x = makeRef&lt;dx&gt;(my_x);

  // now we build an expression that uses our variable x
  // the expression is not yet evaluated
  const auto result = (x + 2) * (x + 3);

  // when evaluated this expression should always return (1+2)*(1*3) = 12
  // we evaluate the result using the () operator
  EXPECT_NEAR(result(), 12, 1e-10);

  // we can build the derivative using the D&lt;&gt;() function. The template parameter
  // is the tag we want to take the derivative w.r.t.
  const auto dx_result = result.D&lt;dx&gt;();

  // the derivative of the above expression is 1*(x+3)+(x+2)*1 = 2x+5
  // let&#x27;s set our original variable to 2
  my_x = 2.0;

  // if we re-evaluate the original expression we should get an updated result
  // of (2+2)*(2*3) = 20
  EXPECT_NEAR(result(), 20, 1e-10);

  // and for the derivative we expect 2*2+5 = 9
  EXPECT_NEAR(dx_result(), 9, 1e-10);
}

#define CTD_EVALTEST(expression, v0, v1, dv)                                                       \
  for (Real v = v0; v &lt;= v1; v += dv)                                                              \
  {                                                                                                \
    Real r1, r2;                                                                                   \
    {                                                                                              \
      const auto x = makeRef&lt;1&gt;(v);                                                                \
      const auto result = expression;                                                              \
      r1 = result();                                                                               \
    }                                                                                              \
    {                                                                                              \
      const auto &amp; x = v;                                                                          \
      r2 = expression;                                                                             \
    }                                                                                              \
    EXPECT_NEAR(r1, r2, 1e-13);                                                                    \
  }

TEST(CompileTimeDerivativesTest, evaluate)
{
  CTD_EVALTEST(x, -10, 10, 0.72)
  CTD_EVALTEST(2 * x, -10, 10, 0.72)
  CTD_EVALTEST(2.0 * x, -10, 10, 0.72)
  CTD_EVALTEST(x * 3, -10, 10, 0.72)
  CTD_EVALTEST(x * -3.0, -10, 10, 0.72)
  CTD_EVALTEST(x + 1, -10, 10, 0.72)
  CTD_EVALTEST(x - 1.0, -10, 10, 0.72)
  CTD_EVALTEST(0.5 + x, -10, 10, 0.72)
  CTD_EVALTEST(0.75 - x, -10, 10, 0.72)
  CTD_EVALTEST(1.0 / x, -10, 10, 0.72)
  CTD_EVALTEST(x / 2.0, -10, 10, 0.72)
  CTD_EVALTEST(x + (2.0 / x), -10, 10, 0.72)
  CTD_EVALTEST(x * (1.0 + x), -10, 10, 0.72)

  CTD_EVALTEST(x * (1.0 + x * (3.0 - x * (2.0 + x * (5.0 - x)))), -10, 10, 0.63)

  CTD_EVALTEST(x * -1.0 &gt; x * -2.0, -10, 10, 0.63)
  CTD_EVALTEST(x * -1.0 &lt; x * -2.0, -10, 10, 0.63)
  CTD_EVALTEST(x * -1.0 &gt;= x * -2.0, -10, 10, 1)
  CTD_EVALTEST(x * -1.0 &lt;= x * -2.0, -10, 10, 1)
  CTD_EVALTEST(0.0 &lt; x, -1, 1, 1)
  CTD_EVALTEST(0.0 &gt; x, -1, 1, 1)
  CTD_EVALTEST(0.0 &lt;= x, -1, 1, 1)
  CTD_EVALTEST(0.0 &gt;= x, -1, 1, 1)
  CTD_EVALTEST(0.0 == x, -1, 1, 1)
  CTD_EVALTEST(0.0 != x, -1, 1, 1)

  using namespace std;
  CTD_EVALTEST(sin(x), -10, 10, 0.72)
  CTD_EVALTEST(cos(x), -10, 10, 0.72)
  CTD_EVALTEST(tan(x), -10, 10, 0.72)
  CTD_EVALTEST(exp(x), -2, 2, 0.1)
  CTD_EVALTEST(erf(x), -2, 2, 0.1)
  CTD_EVALTEST(log(x), 0.1, 10, 0.1)
  CTD_EVALTEST(tanh(x), -10, 10, 0.1)
  CTD_EVALTEST(sinh(x), -4, 4, 0.1)
  CTD_EVALTEST(cosh(x), -4, 4, 0.1)
  CTD_EVALTEST(atan(x), -4, 4, 0.1)

  CTD_EVALTEST(min(x, x * x), -2, 2, 0.271)
  CTD_EVALTEST(max(x, x * x), -2, 2, 0.271)

  const auto v = makeValue(0.5);
  const auto r1 = CompileTimeDerivatives::atan2(1.0, 2.0);
  const auto r2 = CompileTimeDerivatives::atan2(v, 2.0);
  const auto r3 = CompileTimeDerivatives::atan2(1.0, v);
  const auto r4 = CompileTimeDerivatives::atan2(v, v);
  EXPECT_NEAR(r1(), 0.46364760900080609, 1e-12);
  EXPECT_NEAR(r2(), 0.24497866312686414, 1e-12);
  EXPECT_NEAR(r3(), 1.1071487177940904, 1e-12);
  EXPECT_NEAR(r4(), 0.7853981633974482, 1e-12);
}

TEST(CompileTimeDerivativesTest, finitedifference)
{
  Real v = 0;
  const auto x = makeRef&lt;1&gt;(v);

  const auto test = [&amp;v](auto expr, Real v0, Real v1, Real dv, Real eps = 1e-6, Real err = 1e-6)
  {
    for (Real vv = v0; vv &lt;= v1; vv += dv)
    {
      v = vv;
      const auto df = expr.template D&lt;1&gt;()();
      v = vv - eps;
      const auto f0 = expr();
      v = vv + eps;
      const auto f1 = expr();
      const auto fd = (f1 - f0) / (2.0 * eps);
      EXPECT_NEAR(df, fd, err);
    }
  };

  test(x, -3, 3, 0.21);
  test(-x, -3, 3, 0.21);
  test(x * x, -3, 3, 0.21);
  test(pow(x, 3), -3, 3, 0.21);
  test(pow(5, x), -3, 3, 0.21);
  test(pow(x, 3.0), -3, 3, 0.21);
  test(pow(5.0, x), -3, 3, 0.21);
  test(pow(x, x), 0.1, 3, 0.21);
  test(pow&lt;4&gt;(x), -3, 3, 0.21);
  test(pow&lt;4&gt;(2), -1, 1, 0.4);
  test(sin(x), -3, 3, 0.21);
  test(-sin(x), -3, 3, 0.21);
  test(cos(x), -3, 3, 0.21);
  test(tan(x), -10, 10, 0.2, 1e-7);
  test(exp(x), -2, 2, 0.2);
  test(erf(x), -2, 2, 0.2);
  test(log(x), 0.1, 3, 0.1);
  test(tanh(x), -10, 10, 0.2, 1e-7);
  test(sinh(x), -4, 4, 0.2);
  test(cosh(x), -4, 4, 0.2);
  test(atan(x), -4, 4, 0.2);
  test(atan2(x, 1), -3, 3, 0.21);
  test(atan2(1, x), -3, 3, 0.21);
  test(atan2(sin(x), cos(x)), -3, 3, 0.2);
}

TEST(CompileTimeDerivativesTest, derivative)
{
  enum
  {
    dX
  };

  Real v = 0.0;
  const auto x = makeRef&lt;dX&gt;(v);
  const auto result = x * (1.0 - x) - (x * log(x) + (1.0 - x) * log(1.0 - x));

  Real r0 = 0, r1 = 0, r2 = 0;
  for (v = 0.01; v &lt;= 0.99; v += 0.01)
  {
    r0 += std::abs(result() - (v * (1.0 - v) - (v * std::log(v) + (1.0 - v) * std::log(1.0 - v))));
    r1 += std::abs(result.D&lt;dX&gt;()() -
                   (-2.0 * v - std::log(v) + std::log(1.0 - v) - (v - 1.0) / (1.0 - v)));
    r2 += std::abs(result.D&lt;dX&gt;().D&lt;dX&gt;()() - (-2.0 + 1.0 / (v - 1.0) - 1.0 / v));
  }
  EXPECT_NEAR(r0, 0, 1e-12);
  EXPECT_NEAR(r1, 0, 1e-12);
  EXPECT_NEAR(r2, 0, 1e-12);
}

TEST(CompileTimeDerivativesTest, variable_reference)
{
  enum
  {
    dX
  };

  Real x = 0.0;
  const auto X = makeRef&lt;dX&gt;(x);
  const auto result = X * X + 100.0;

  x = 5;
  EXPECT_EQ(result(), 125.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 10.0);

  x = 3;
  EXPECT_EQ(result(), 109.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 6.0);
}

TEST(CompileTimeDerivativesTest, vector_reference)
{
  enum
  {
    dX
  };

  std::vector&lt;double&gt; _prop{1, 2, 3, 4};
  std::size_t _qp = 0;

  const auto prop = makeRef&lt;dX&gt;(_prop, _qp);
  const auto result = 3.0 * prop * prop;

  _qp = 1;
  EXPECT_EQ(result(), 12.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 12.0);
  EXPECT_EQ(result.D&lt;dX&gt;().D&lt;dX&gt;()(), 6.0);

  _qp = 3;
  EXPECT_EQ(result(), 48.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 24.0);
  EXPECT_EQ(result.D&lt;dX&gt;().D&lt;dX&gt;()(), 6.0);
}

TEST(CompileTimeDerivativesTest, print)
{
  std::vector&lt;double&gt; _prop{1, 2, 3, 4};
  std::size_t _qp = 2;
  const auto prop = makeRef(_prop, _qp);
  const auto result1 = 3.0 * prop * prop;
  EXPECT_EQ(result1.print(), &quot;3*[a[2]]*[a[2]]&quot;);

  Real v = 0.0;
  const auto x = makeRef(v);
  const auto result2 = x * (1.0 - x) - (x * log(x) + (1.0 - x) * log(1.0 - x));
  EXPECT_EQ(result2.print(), &quot;[v]*(1-[v])-([v]*log([v])+(1-[v])*log(1-[v]))&quot;);
}

TEST(CompileTimeDerivativesTest, makeRefs)
{
  const Real va = 1, vb = 2, vc = 1.5;
  const auto [a, b, c] = makeRefs&lt;30&gt;(va, vb, vc);

  // matching order
  EXPECT_EQ(&amp;va, &amp;a());
  EXPECT_EQ(&amp;vb, &amp;b());
  EXPECT_EQ(&amp;vc, &amp;c());

  // correct tags
  EXPECT_EQ(a.D&lt;30&gt;()(), 1);
  EXPECT_EQ(a.D&lt;31&gt;()(), 0);
  EXPECT_EQ(a.D&lt;32&gt;()(), 0);

  EXPECT_EQ(b.D&lt;30&gt;()(), 0);
  EXPECT_EQ(b.D&lt;31&gt;()(), 1);
  EXPECT_EQ(b.D&lt;32&gt;()(), 0);

  EXPECT_EQ(c.D&lt;30&gt;()(), 0);
  EXPECT_EQ(c.D&lt;31&gt;()(), 0);
  EXPECT_EQ(c.D&lt;32&gt;()(), 1);
}

TEST(CompileTimeDerivativesTest, makeStandardDeviation)
{
  // start tag for the fitting parameters
  const int params = 30;

  // fitting parameter data and corresponding CTD objects
  const Real va = 1, vb = 2, vc = 1.5;
  const auto [a, b, c] = makeRefs&lt;params&gt;(va, vb, vc);

  // function variable (omit tag, since we dont need to derive w.r.t. x)
  const Real vx = 0.5;
  const auto x = makeRef(vx);

  // function expression
  const auto f = a + b * x + c * x * x;

  // covariance matrix for the a,b,c parameters
  // clang-format off
  CTMatrix&lt;Real, 3, 3&gt; covariance(
    0.2,  0.01, 0.07,
    0.01, 0.4,  0.05,
    0.07, 0.05, 0.3);
  // clang-format on

  // Object that calculates the standard deviation of f
  const auto std_dev = makeStandardDeviation&lt;params&gt;(f, covariance);

  EXPECT_NEAR(std_dev(), 0.6133922073192649, 1e-15);
}

TEST(CompileTimeDerivativesTest, conditional)
{
  Real vx = 0.0;
  const auto x = makeRef(vx);

  const auto result = conditional(x &lt; 3, 2 * x, 5 * x);

  for (vx = 0.0; vx &lt; 6.0; vx += 0.31)
  {
    if (vx &lt; 3)
      EXPECT_EQ(result(), 2 * vx);
    else
      EXPECT_EQ(result(), 5 * vx);
  }
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#6f5b1ad4-2751-481e-b7d6-02acd2bc3cdf">(moose/unit/src/CompileTimeDerivativesTest.C)</a></section></section><div class="moose-modal modal" id="6f5b1ad4-2751-481e-b7d6-02acd2bc3cdf"><div class="modal-content"><h4>(moose/unit/src/CompileTimeDerivativesTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

// Moose includes
#include &quot;MooseTypes.h&quot;
#include &quot;CompileTimeDerivatives.h&quot;

using namespace CompileTimeDerivatives;

TEST(CompileTimeDerivativesTest, simple)
{
  // this test serves as a simple example for the compile time derivative system

  // a variable to be used in the expression evaluation
  Real my_x = 1.0;

  // use an enum to use symbols for tags
  enum
  {
    dx
  };

  // we wrap this variable in a reference node that we tag with the `dx` enum
  const auto x = makeRef&lt;dx&gt;(my_x);

  // now we build an expression that uses our variable x
  // the expression is not yet evaluated
  const auto result = (x + 2) * (x + 3);

  // when evaluated this expression should always return (1+2)*(1*3) = 12
  // we evaluate the result using the () operator
  EXPECT_NEAR(result(), 12, 1e-10);

  // we can build the derivative using the D&lt;&gt;() function. The template parameter
  // is the tag we want to take the derivative w.r.t.
  const auto dx_result = result.D&lt;dx&gt;();

  // the derivative of the above expression is 1*(x+3)+(x+2)*1 = 2x+5
  // let&#x27;s set our original variable to 2
  my_x = 2.0;

  // if we re-evaluate the original expression we should get an updated result
  // of (2+2)*(2*3) = 20
  EXPECT_NEAR(result(), 20, 1e-10);

  // and for the derivative we expect 2*2+5 = 9
  EXPECT_NEAR(dx_result(), 9, 1e-10);
}

#define CTD_EVALTEST(expression, v0, v1, dv)                                                       \
  for (Real v = v0; v &lt;= v1; v += dv)                                                              \
  {                                                                                                \
    Real r1, r2;                                                                                   \
    {                                                                                              \
      const auto x = makeRef&lt;1&gt;(v);                                                                \
      const auto result = expression;                                                              \
      r1 = result();                                                                               \
    }                                                                                              \
    {                                                                                              \
      const auto &amp; x = v;                                                                          \
      r2 = expression;                                                                             \
    }                                                                                              \
    EXPECT_NEAR(r1, r2, 1e-13);                                                                    \
  }

TEST(CompileTimeDerivativesTest, evaluate)
{
  CTD_EVALTEST(x, -10, 10, 0.72)
  CTD_EVALTEST(2 * x, -10, 10, 0.72)
  CTD_EVALTEST(2.0 * x, -10, 10, 0.72)
  CTD_EVALTEST(x * 3, -10, 10, 0.72)
  CTD_EVALTEST(x * -3.0, -10, 10, 0.72)
  CTD_EVALTEST(x + 1, -10, 10, 0.72)
  CTD_EVALTEST(x - 1.0, -10, 10, 0.72)
  CTD_EVALTEST(0.5 + x, -10, 10, 0.72)
  CTD_EVALTEST(0.75 - x, -10, 10, 0.72)
  CTD_EVALTEST(1.0 / x, -10, 10, 0.72)
  CTD_EVALTEST(x / 2.0, -10, 10, 0.72)
  CTD_EVALTEST(x + (2.0 / x), -10, 10, 0.72)
  CTD_EVALTEST(x * (1.0 + x), -10, 10, 0.72)

  CTD_EVALTEST(x * (1.0 + x * (3.0 - x * (2.0 + x * (5.0 - x)))), -10, 10, 0.63)

  CTD_EVALTEST(x * -1.0 &gt; x * -2.0, -10, 10, 0.63)
  CTD_EVALTEST(x * -1.0 &lt; x * -2.0, -10, 10, 0.63)
  CTD_EVALTEST(x * -1.0 &gt;= x * -2.0, -10, 10, 1)
  CTD_EVALTEST(x * -1.0 &lt;= x * -2.0, -10, 10, 1)
  CTD_EVALTEST(0.0 &lt; x, -1, 1, 1)
  CTD_EVALTEST(0.0 &gt; x, -1, 1, 1)
  CTD_EVALTEST(0.0 &lt;= x, -1, 1, 1)
  CTD_EVALTEST(0.0 &gt;= x, -1, 1, 1)
  CTD_EVALTEST(0.0 == x, -1, 1, 1)
  CTD_EVALTEST(0.0 != x, -1, 1, 1)

  using namespace std;
  CTD_EVALTEST(sin(x), -10, 10, 0.72)
  CTD_EVALTEST(cos(x), -10, 10, 0.72)
  CTD_EVALTEST(tan(x), -10, 10, 0.72)
  CTD_EVALTEST(exp(x), -2, 2, 0.1)
  CTD_EVALTEST(erf(x), -2, 2, 0.1)
  CTD_EVALTEST(log(x), 0.1, 10, 0.1)
  CTD_EVALTEST(tanh(x), -10, 10, 0.1)
  CTD_EVALTEST(sinh(x), -4, 4, 0.1)
  CTD_EVALTEST(cosh(x), -4, 4, 0.1)
  CTD_EVALTEST(atan(x), -4, 4, 0.1)

  CTD_EVALTEST(min(x, x * x), -2, 2, 0.271)
  CTD_EVALTEST(max(x, x * x), -2, 2, 0.271)

  const auto v = makeValue(0.5);
  const auto r1 = CompileTimeDerivatives::atan2(1.0, 2.0);
  const auto r2 = CompileTimeDerivatives::atan2(v, 2.0);
  const auto r3 = CompileTimeDerivatives::atan2(1.0, v);
  const auto r4 = CompileTimeDerivatives::atan2(v, v);
  EXPECT_NEAR(r1(), 0.46364760900080609, 1e-12);
  EXPECT_NEAR(r2(), 0.24497866312686414, 1e-12);
  EXPECT_NEAR(r3(), 1.1071487177940904, 1e-12);
  EXPECT_NEAR(r4(), 0.7853981633974482, 1e-12);
}

TEST(CompileTimeDerivativesTest, finitedifference)
{
  Real v = 0;
  const auto x = makeRef&lt;1&gt;(v);

  const auto test = [&amp;v](auto expr, Real v0, Real v1, Real dv, Real eps = 1e-6, Real err = 1e-6)
  {
    for (Real vv = v0; vv &lt;= v1; vv += dv)
    {
      v = vv;
      const auto df = expr.template D&lt;1&gt;()();
      v = vv - eps;
      const auto f0 = expr();
      v = vv + eps;
      const auto f1 = expr();
      const auto fd = (f1 - f0) / (2.0 * eps);
      EXPECT_NEAR(df, fd, err);
    }
  };

  test(x, -3, 3, 0.21);
  test(-x, -3, 3, 0.21);
  test(x * x, -3, 3, 0.21);
  test(pow(x, 3), -3, 3, 0.21);
  test(pow(5, x), -3, 3, 0.21);
  test(pow(x, 3.0), -3, 3, 0.21);
  test(pow(5.0, x), -3, 3, 0.21);
  test(pow(x, x), 0.1, 3, 0.21);
  test(pow&lt;4&gt;(x), -3, 3, 0.21);
  test(pow&lt;4&gt;(2), -1, 1, 0.4);
  test(sin(x), -3, 3, 0.21);
  test(-sin(x), -3, 3, 0.21);
  test(cos(x), -3, 3, 0.21);
  test(tan(x), -10, 10, 0.2, 1e-7);
  test(exp(x), -2, 2, 0.2);
  test(erf(x), -2, 2, 0.2);
  test(log(x), 0.1, 3, 0.1);
  test(tanh(x), -10, 10, 0.2, 1e-7);
  test(sinh(x), -4, 4, 0.2);
  test(cosh(x), -4, 4, 0.2);
  test(atan(x), -4, 4, 0.2);
  test(atan2(x, 1), -3, 3, 0.21);
  test(atan2(1, x), -3, 3, 0.21);
  test(atan2(sin(x), cos(x)), -3, 3, 0.2);
}

TEST(CompileTimeDerivativesTest, derivative)
{
  enum
  {
    dX
  };

  Real v = 0.0;
  const auto x = makeRef&lt;dX&gt;(v);
  const auto result = x * (1.0 - x) - (x * log(x) + (1.0 - x) * log(1.0 - x));

  Real r0 = 0, r1 = 0, r2 = 0;
  for (v = 0.01; v &lt;= 0.99; v += 0.01)
  {
    r0 += std::abs(result() - (v * (1.0 - v) - (v * std::log(v) + (1.0 - v) * std::log(1.0 - v))));
    r1 += std::abs(result.D&lt;dX&gt;()() -
                   (-2.0 * v - std::log(v) + std::log(1.0 - v) - (v - 1.0) / (1.0 - v)));
    r2 += std::abs(result.D&lt;dX&gt;().D&lt;dX&gt;()() - (-2.0 + 1.0 / (v - 1.0) - 1.0 / v));
  }
  EXPECT_NEAR(r0, 0, 1e-12);
  EXPECT_NEAR(r1, 0, 1e-12);
  EXPECT_NEAR(r2, 0, 1e-12);
}

TEST(CompileTimeDerivativesTest, variable_reference)
{
  enum
  {
    dX
  };

  Real x = 0.0;
  const auto X = makeRef&lt;dX&gt;(x);
  const auto result = X * X + 100.0;

  x = 5;
  EXPECT_EQ(result(), 125.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 10.0);

  x = 3;
  EXPECT_EQ(result(), 109.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 6.0);
}

TEST(CompileTimeDerivativesTest, vector_reference)
{
  enum
  {
    dX
  };

  std::vector&lt;double&gt; _prop{1, 2, 3, 4};
  std::size_t _qp = 0;

  const auto prop = makeRef&lt;dX&gt;(_prop, _qp);
  const auto result = 3.0 * prop * prop;

  _qp = 1;
  EXPECT_EQ(result(), 12.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 12.0);
  EXPECT_EQ(result.D&lt;dX&gt;().D&lt;dX&gt;()(), 6.0);

  _qp = 3;
  EXPECT_EQ(result(), 48.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 24.0);
  EXPECT_EQ(result.D&lt;dX&gt;().D&lt;dX&gt;()(), 6.0);
}

TEST(CompileTimeDerivativesTest, print)
{
  std::vector&lt;double&gt; _prop{1, 2, 3, 4};
  std::size_t _qp = 2;
  const auto prop = makeRef(_prop, _qp);
  const auto result1 = 3.0 * prop * prop;
  EXPECT_EQ(result1.print(), &quot;3*[a[2]]*[a[2]]&quot;);

  Real v = 0.0;
  const auto x = makeRef(v);
  const auto result2 = x * (1.0 - x) - (x * log(x) + (1.0 - x) * log(1.0 - x));
  EXPECT_EQ(result2.print(), &quot;[v]*(1-[v])-([v]*log([v])+(1-[v])*log(1-[v]))&quot;);
}

TEST(CompileTimeDerivativesTest, makeRefs)
{
  const Real va = 1, vb = 2, vc = 1.5;
  const auto [a, b, c] = makeRefs&lt;30&gt;(va, vb, vc);

  // matching order
  EXPECT_EQ(&amp;va, &amp;a());
  EXPECT_EQ(&amp;vb, &amp;b());
  EXPECT_EQ(&amp;vc, &amp;c());

  // correct tags
  EXPECT_EQ(a.D&lt;30&gt;()(), 1);
  EXPECT_EQ(a.D&lt;31&gt;()(), 0);
  EXPECT_EQ(a.D&lt;32&gt;()(), 0);

  EXPECT_EQ(b.D&lt;30&gt;()(), 0);
  EXPECT_EQ(b.D&lt;31&gt;()(), 1);
  EXPECT_EQ(b.D&lt;32&gt;()(), 0);

  EXPECT_EQ(c.D&lt;30&gt;()(), 0);
  EXPECT_EQ(c.D&lt;31&gt;()(), 0);
  EXPECT_EQ(c.D&lt;32&gt;()(), 1);
}

TEST(CompileTimeDerivativesTest, makeStandardDeviation)
{
  // start tag for the fitting parameters
  const int params = 30;

  // fitting parameter data and corresponding CTD objects
  const Real va = 1, vb = 2, vc = 1.5;
  const auto [a, b, c] = makeRefs&lt;params&gt;(va, vb, vc);

  // function variable (omit tag, since we dont need to derive w.r.t. x)
  const Real vx = 0.5;
  const auto x = makeRef(vx);

  // function expression
  const auto f = a + b * x + c * x * x;

  // covariance matrix for the a,b,c parameters
  // clang-format off
  CTMatrix&lt;Real, 3, 3&gt; covariance(
    0.2,  0.01, 0.07,
    0.01, 0.4,  0.05,
    0.07, 0.05, 0.3);
  // clang-format on

  // Object that calculates the standard deviation of f
  const auto std_dev = makeStandardDeviation&lt;params&gt;(f, covariance);

  EXPECT_NEAR(std_dev(), 0.6133922073192649, 1e-15);
}

TEST(CompileTimeDerivativesTest, conditional)
{
  Real vx = 0.0;
  const auto x = makeRef(vx);

  const auto result = conditional(x &lt; 3, 2 * x, 5 * x);

  for (vx = 0.0; vx &lt; 6.0; vx += 0.31)
  {
    if (vx &lt; 3)
      EXPECT_EQ(result(), 2 * vx);
    else
      EXPECT_EQ(result(), 5 * vx);
  }
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
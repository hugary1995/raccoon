<!DOCTYPE html><head><meta charset="UTF-8"><title>RayTracingStudy | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="7d41cc69-4387-47f7-8f63-67701119a422" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d42859ea-15b9-4109-8d08-1f5e892008f3" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="fb5e5b2b-9efa-4918-9e37-ac1f7475b790" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="69e16c84-04de-485d-a124-559bc49ed4d1" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="09d9876b-f44f-4778-9d73-e116d391ac38"><i class="material-icons">menu</i></a><ul class="sidenav" id="09d9876b-f44f-4778-9d73-e116d391ac38"><li><a href="#!" class="dropdown-trigger" data-target="fa1540d5-47b4-4c24-91a7-635f98d04783" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="a41aa9d3-c099-4c76-9732-facfbc0530a8" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="e556773c-a21c-4ac5-8672-ed27d9ca0076" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="200b5393-579d-4843-93c9-3ee23246443e" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="7d41cc69-4387-47f7-8f63-67701119a422"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="d42859ea-15b9-4109-8d08-1f5e892008f3"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="fb5e5b2b-9efa-4918-9e37-ac1f7475b790"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="69e16c84-04de-485d-a124-559bc49ed4d1"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="fa1540d5-47b4-4c24-91a7-635f98d04783"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="a41aa9d3-c099-4c76-9732-facfbc0530a8"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="e556773c-a21c-4ac5-8672-ed27d9ca0076"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="200b5393-579d-4843-93c9-3ee23246443e"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="b7fc996e-9616-4c71-84cc-2e4e6adfa637" data-section-level="1" data-section-text="RayTracingStudy"><h1 id="raytracingstudy">RayTracingStudy</h1><p>The <code>RayTracingStudy</code> is the base object for generating and tracing of <a href="../raytracing/Ray.html">Rays</a> with the <a href="../../modules/ray_tracing/index.html">Ray Tracing Module</a>. For information about the manipulation of <a href="../raytracing/Ray.html">Rays</a> once they have began tracing, see <a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html">RayBCs</a>.</p><div class="card moose-alert moose-alert-tip"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">school</i><span class="moose-alert-title-brand">tip</span></div><div class="card-content"><div class="moose-alert-content"><p>The majority of the information presented here is for <strong>advanced</strong> users only. The use of this module for simple cases like line sources (see <a href="../../modules/ray_tracing/examples/line_sources.html">Using Line Sources</a>) and line integrals (see <a href="../../modules/ray_tracing/examples/line_integrals.html">Computing Line Integrals</a>) utilize the <a href="RepeatableRayStudy.html">RepeatableRayStudy</a>. Please see <a href="RepeatableRayStudy.html">RepeatableRayStudy</a> first for a more general understanding. If the <a href="RepeatableRayStudy.html">RepeatableRayStudy</a> is not sufficient for your use case, please then reference the <a href="RepeatableRayStudyBase.html">RepeatableRayStudyBase</a> instead.</p></div></div></div><section id="eeee3fe9-8078-4edc-87d6-a14a169fc016" data-section-level="2" data-section-text="Execution Phases"><h2 id="execution-phases">Execution Phases</h2><p>The execution of the  <code>RayTracingStudy</code> is split up into two phases:</p><ul class="browser-default"><li><p><a href="RayTracingStudy.html#generation">Generation</a> - The <a href="../raytracing/Ray.html">Rays</a> to be traced are defined and moved into the buffer to be traced </p></li><li><p><a href="RayTracingStudy.html#propagation">Propagation</a> - The <a href="../raytracing/Ray.html">Rays</a> are traced until completion</p></li></ul><section id="37092a4f-decf-4188-9dfe-b88f8cb1bd35" data-section-level="3" data-section-text="Generation"><h3 id="generation">Generation</h3><p>To use the <code>RayTracingStudy</code>, you are to derive from it and override the <code>generateRays()</code> method. Within <code>generateRays()</code>, you are to create <a href="../raytracing/Ray.html">Rays</a> (using the <a href="RayTracingStudy.html#ray-pool">Ray Pool</a>), set their trajectories (for more information, see <a href="../raytracing/Ray.html#defining-a-ray-trajectory">Defining a Ray Trajectory</a>), set their data (if any, see <a href="../raytracing/Ray.html#using-ray-data">Using Ray Data</a> for more information), and move them into the buffer to be traced with <code>moveRayToBuffer()</code> or <code>moveRaysToBuffer()</code>.</p><p>If you know in advance the number of <a href="../raytracing/Ray.html">Rays</a> that you are adding to the buffer to be traced during generation, it is advised call <code>reserveRayBuffer()</code> with the number of <a href="../raytracing/Ray.html">Rays</a> to be moved to the buffer <strong>before</strong> moving them into the buffer.</p></section><section id="a28f5a7d-45a3-4b7b-b0e0-f04f97eaf588" data-section-level="3" data-section-text="Propagation"><h3 id="propagation">Propagation</h3><p>The Ray propagation phase traces the <a href="../raytracing/Ray.html">Rays</a> that were added to the buffer to be traced. This is done internally by the <code>propagateRays()</code> method.</p><p>Note that additional <a href="../raytracing/Ray.html">Ray</a> objects may be added to be traced during the propagation phase via <a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html">RayBCs</a>. For more information, see <a href="../../syntax/RayKernels/index.html#creating-additional-rays">Creating Additional Rays</a> for creating a <a href="../raytracing/Ray.html">Ray</a> within <a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html#creating-a-new-ray">Creating a New Ray</a> for creating a <a href="../raytracing/Ray.html">Ray</a> within <a href="../../syntax/RayBCs/index.html">RayBCs</a>.</p></section></section><section id="7e26b3d1-b4ac-4659-8804-ad36f5d7d99f" data-section-level="2" data-section-text="Specialization"><h2 id="specialization">Specialization</h2><p>There are many methods that can be overridden in your derived class. A summary of such methods follows:</p><ul class="browser-default"><li><p><code>generateRays()</code> - <strong>MUST</strong> override to define and move the <a href="../raytracing/Ray.html">Rays</a> into the buffer to be traced (see <a href="RayTracingStudy.html#generation">Generation</a>) </p></li><li><p><code>preExecuteStudy()</code> - Called before <a href="RayTracingStudy.html#generation">Generation</a> </p></li><li><p><code>postExecuteStudy()</code> - Called after <a href="RayTracingStudy.html#propagation">Propagation</a> </p></li><li><p><code>postOnSegment()</code> - Called after each segment of a <a href="../raytracing/Ray.html">Ray</a> </p></li><li><p><code>onCompleteRay()</code> - Called when the trace of a <a href="../raytracing/Ray.html">Ray</a> has ended </p></li><li><p><code>buildSegmentQuadrature()</code> Called to generate the 1D quadrature across a <a href="../raytracing/Ray.html">Ray</a> segment</p></li></ul></section><section id="4c9c17f8-c965-4973-ab2c-a5653b58a1d7" data-section-level="2" data-section-text="Helper Systems"><h2 id="helper-systems">Helper Systems</h2><p>The <code>RayTracingStudy</code> contains many systems that aid in the generation and manipulation of <a href="../raytracing/Ray.html">Rays</a>:</p><ul class="browser-default"><li><p><a href="RayTracingStudy.html#ray-data-registration">Ray Data Registration</a>: Registers indices into data and auxiliary data to be stored on each <a href="../raytracing/Ray.html">Ray</a> </p></li><li><p><a href="RayTracingStudy.html#ray-registration">Ray Registration</a>: Registers names to be associated with each <a href="../raytracing/Ray.html">Ray</a> and requires <a href="../../syntax/RayBCs/index.html">RayBCs</a> and <a href="../../syntax/RayKernels/index.html">RayKernels</a> to provide which <a href="../raytracing/Ray.html">Rays</a> they are applied to </p></li><li><p><a href="RayTracingStudy.html#ray-banking">Ray Banking</a>: Banks <a href="../raytracing/Ray.html">Rays</a> once they end to be accessed after tracing </p></li><li><p><a href="RayTracingStudy.html#ray-pool">Ray Pool</a>: A shared pool of <a href="../raytracing/Ray.html">Rays</a> that allows for their reuse after they are called to be destructed </p></li><li><p><a href="RayTracingStudy.html#side-normal-caching">Side Normal Caching</a>: Generates and caches (for future use) outward normals for an element</p></li></ul><section id="1476235a-9c9e-4543-a349-770ce44c2da8" data-section-level="3" data-section-text="Ray Data Registration"><h3 id="ray-data-registration">Ray Data Registration</h3><p>The data and auxiliary data associated with a <a href="../raytracing/Ray.html">Ray</a> is stored on the <a href="../raytracing/Ray.html">Ray</a> itself in the form of two <code>std::vector&lt;RayData&gt;</code> (<code>RayData</code> is typically a <code>Real</code>), which are accessed via <code>Ray::data()</code> and <code>Ray::auxData()</code>. A data registration system exists that allows for the study, <a href="../../syntax/RayKernels/index.html">RayKernels</a>, and <a href="../../syntax/RayBCs/index.html">RayBCs</a> to request the data and auxiliary data that they need upon construction.</p><p>To register value(s), use the methods <code>registerRayData()</code> and <code>registerRayAuxData()</code>, which return either a single index or a vector of indices into the <code>Ray::data()</code> and <code>Ray::auxData()</code> vectors that you should utilize. If the same value is registered (uses the same name) within multiple objects, the same index will be returned.</p><p>For example, the <a href="../raykernels/IntegralRayKernel.html">IntegralRayKernel</a> is the base object for <a href="../../syntax/RayKernels/index.html">RayKernels</a> that integrate a field across a line (variables, materials, etc). In order to accumulate the integrated value, these kernels need a data value on the <a href="../raytracing/Ray.html">Ray</a>. As such, they register the need for <a href="../raytracing/Ray.html">Ray</a> data in the constructor and store the index for access:</p><pre style="max-height:350px;"><code class="language-cpp">IntegralRayKernel::IntegralRayKernel(const InputParameters &amp; params)
  : IntegralRayKernelBase(params),
    _integral_data_index(_study.registerRayData(integralRayDataName())),
    _average(getParam&lt;bool&gt;(&quot;average&quot;))
{
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#2a2b0ae7-0b17-4a58-bfa8-26941168df78">(moose/modules/ray_tracing/src/raykernels/IntegralRayKernel.C)</a><pre style="max-height:350px;"><code class="language-cpp">class IntegralRayKernel : public IntegralRayKernelBase
{
public:
  IntegralRayKernel(const InputParameters &amp; params);

  static InputParameters validParams();

  /**
   * Gets the name of the Ray data associated with the integral accumulated by this RayKernel
   */
  std::string integralRayDataName() const { return _name + &quot;_value&quot;; }

  void onSegment() override final;

protected:
  virtual Real computeQpIntegral() = 0;

  /// The index into the data on the Ray that this integral accumulates into
  const RayDataIndex _integral_data_index;

  /// Whether or not to compute the average (divide by the length)
  const bool _average;
};
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#1fb76783-ae0a-4786-b9b7-759d659523c7">(moose/modules/ray_tracing/include/raykernels/IntegralRayKernel.h)</a><p>While you can acquire <a href="../raytracing/Ray.html">Rays</a> that do not necessarily have the data size set according to the registration using the <a href="RayTracingStudy.html#ray-pool">Ray Pool</a>, any time the data is accessed on a <a href="../raytracing/Ray.html">Ray</a> (via <code>Ray::data()</code> and <code>Ray::auxData()</code>), if it is not sized properly as required by the registration, it will be resized to the registered size with zeros.</p></section><section id="292c86a4-a22b-4120-a7b5-064f55c32108" data-section-level="3" data-section-text="Ray Registration"><h3 id="ray-registration">Ray Registration</h3><p>For cases in which only a few <a href="../raytracing/Ray.html">Rays</a> are generated, it is beneficial to have a registration system that allows for the user to access a specific <a href="../raytracing/Ray.html">Ray</a> by name instead of an ID. Specific examples are line sources (see <a href="../../modules/ray_tracing/examples/line_sources.html">Using Line Sources</a>) and line integrals (see <a href="../../modules/ray_tracing/examples/line_integrals.html">Computing Line Integrals</a>), which utilize the <a href="RepeatableRayStudy.html">RepeatableRayStudy</a>.</p><p>The enabling and disabling of ray registration is handled by the <code>_use_ray_registration</code> private parameter, for which the default is true. When ray registration is enabled, all <a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html">RayBCs</a> <strong>must</strong> have the parameter <a href="#ddf43b0f-543f-4728-9dc3-e63b11957456" class="moose-modal-link modal-trigger">&quot;rays&quot;</a> set, which identifies the <a href="../raytracing/Ray.html">Rays</a> by name that said objects are executed on. When ray registration is disabled, the <a href="#6e633780-82da-4f2b-815b-7ff881946bd3" class="moose-modal-link modal-trigger">&quot;rays&quot;</a> parameter cannot be used and <a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html">RayBCs</a> will be executed for <strong>all</strong> <a href="../raytracing/Ray.html">Rays</a>.</p><p>When using <a href="../raytracing/Ray.html">Ray</a> registration, each <a href="../raytracing/Ray.html">Ray</a> must be constructed within the study using the <code>acquireRegisteredRay()</code> method, which takes as an argument the name for the <a href="../raytracing/Ray.html">Ray</a>. For more information, see <a href="RayTracingStudy.html#ray-pool">Ray Pool</a>.</p><p>The public methods <code>registeredRayID()</code> and <code>registeredRayName()</code> can be utilized to map a registered <a href="../raytracing/Ray.html">Ray</a> name to its ID and an ID to its registered name, respectively.</p></section><section id="2b018030-bd39-44b5-9349-4ae6df853f4e" data-section-level="3" data-section-text="Ray Banking"><h3 id="ray-banking">Ray Banking</h3><p>It is often useful to examine a <a href="../raytracing/Ray.html">Ray</a> after it has completed tracing. An example use case is for obtaining the accumulated integral for a <a href="../raytracing/Ray.html">Ray</a> that is integrating a field along a line (see <a href="../../modules/ray_tracing/examples/line_integrals.html">Computing Line Integrals</a> and <a href="../raykernels/IntegralRayKernel.html">IntegralRayKernel</a>). Within line integrals, the <a href="../raytracing/Ray.html">Ray</a> banks will be accessed to obtain the final accumulated value in a <a href="../raytracing/Ray.html">Ray</a>.</p><p>With the <code>_bank_rays_on_completion</code> private parameter set to true, all <a href="../raytracing/Ray.html">Rays</a> that complete on a given processor are stored in the private member variable <code>_ray_bank</code>. This bank can be accessed through the <code>rayBank()</code> method or via <code>getBankedRay()</code>, which will return the <a href="../raytracing/Ray.html">Ray</a> with the requested ID on the processor that ended the <a href="../raytracing/Ray.html">Ray</a>.</p><p>In addition, the methods <code>getBankedRayData()</code> and <code>getBankedRayAuxData()</code> are available to get a single data value from a <a href="../raytracing/Ray.html">Ray</a> from the banks after it has completed. For these methods, the resulting value is replicated across all processors.</p></section><section id="d882d9b4-8d8b-49b6-88c2-815c82625259" data-section-level="3" data-section-text="Ray Pool"><h3 id="ray-pool">Ray Pool</h3><p>For simulations with the <a href="../../modules/ray_tracing/index.html">Ray Tracing Module</a> that generate a significant number of <a href="../raytracing/Ray.html">Ray</a> objects, it becomes advantageous to minimize the construction of new <a href="../raytracing/Ray.html">Ray</a> objects. This is more important whenever the size of the data on the <a href="../raytracing/Ray.html">Ray</a> is significant.</p><p>Because of this, construction <a href="../raytracing/Ray.html">Ray</a> objects is handled via a shared pool. The pool ensures that, internally, any <a href="../raytracing/Ray.html">Rays</a> that are no-longer used can be reset and used again without extraneous allocation. The construction of new <a href="../raytracing/Ray.html">Rays</a> can only occur in three places:</p><ul class="browser-default"><li><p>Within <code>generateRays()</code> in a study, to create <a href="../raytracing/Ray.html">Rays</a> to be inserted into the buffer for tracing, via the <code>acquireRay{}()</code> methods (more discussion follows). </p></li><li><p>Within <code>onSegment()</code> in <a href="../../syntax/RayKernels/index.html">RayKernels</a>, via the <code>acquireRay()</code> method. </p></li><li><p>Within <code>onBoundary()</code> in <a href="../../syntax/RayBCs/index.html">RayBCs</a>, via the <code>acquireRay()</code> method.</p></li></ul><p>Multiple methods exist for acquiring rays within the study, which are:</p><ul class="browser-default"><li><p><code>acquireRay()</code> - Acquires a <a href="../raytracing/Ray.html">Ray</a> with a generated unique ID and with data sized according to the <a href="RayTracingStudy.html#ray-registration">Ray Registration</a>. </p></li><li><p><code>acquireUnsizedRay()</code> - Acquires a <a href="../raytracing/Ray.html">Ray</a> with a generated unique ID and data sized to zero. Note, whenever the unsized data is accessed within the <a href="../raytracing/Ray.html">Ray</a>, it will be automatically resized to ensure data consistency. </p></li><li><p><code>acquireReplicatedRay()</code> - Acquires a <a href="../raytracing/Ray.html">Ray</a> with an ID that is replicated across all processors and with data sized according to the <a href="RayTracingStudy.html#ray-registration">Ray Registration</a>. This must be called on all processors at the same time. </p></li><li><p><code>acquireRegisteredRay()</code> - Acquires a <a href="../raytracing/Ray.html">Ray</a> that is replicated across all processors with a given name and utilizes the <a href="RayTracingStudy.html#ray-registration">Ray Registration</a>. For example use, see <a href="RepeatableRayStudy.html">RepeatableRayStudy</a>. </p></li><li><p><code>acquireCopiedRay()</code> - Acquires a <a href="../raytracing/Ray.html">Ray</a> that is initialized from another <a href="../raytracing/Ray.html">Ray</a>. This is the only acquire method that does not generate a new ID. For example use, see <a href="RepeatableRayStudyBase.html">RepeatableRayStudyBase</a>.</p></li></ul><p><a href="../raytracing/Ray.html">Ray</a> storage is wrapped as a <code>std::shared_ptr&lt;Ray&gt;</code>. The significance of using a <code>shared_ptr</code> is that the destructor is called when the use count reaches zero, that is, when nobody is holding onto the <a href="../raytracing/Ray.html">Ray</a>. The internal tracing algorithm will decrease the use count for a traced <a href="../raytracing/Ray.html">Ray</a> after it has completed tracing. That is, if no other shared ownership of the <a href="../raytracing/Ray.html">Ray</a> exists, the use count will reach zero. This is why <a href="RayTracingStudy.html#ray-banking">Ray Banking</a> exists&mdash;the <a href="../raytracing/Ray.html">Ray</a> bank will increase the use count of the <a href="../raytracing/Ray.html">Ray</a> so that it is available for use after tracing and is not destructed.</p><p>As all <a href="../raytracing/Ray.html">Rays</a> must be constructed using the shared pool, whenever the use count for a <a href="../raytracing/Ray.html">Ray</a> goes to zero, the <a href="../raytracing/Ray.html">Ray</a> will be returned to the pool for future use.</p></section><section id="8612cfea-66d7-429b-84bb-8f91fb8eb8a5" data-section-level="3" data-section-text="Side Normal Caching"><h3 id="side-normal-caching">Side Normal Caching</h3><p>There is often a need to obtain the outward normal for an element&#x27;s side for many use cases of the <a href="../../modules/ray_tracing/index.html">Ray Tracing Module</a>.</p><p>The <code>RayTracingStudy</code> can provide outward side normals for an element on the fly. It also caches the generated normal for future requests for the same side normal. This is accessed through the <code>getSideNormal()</code> method.</p><p>Note that the side normals obtained through this caching are evaluated at the side centroid. Therefore, if the element side is non-planar, the returned normal will be an approximation. </p></section></section></section><div class="moose-modal modal" id="2a2b0ae7-0b17-4a58-bfa8-26941168df78"><div class="modal-content"><h4>(moose/modules/ray_tracing/src/raykernels/IntegralRayKernel.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;IntegralRayKernel.h&quot;

// Local includes
#include &quot;RayTracingStudy.h&quot;

InputParameters
IntegralRayKernel::validParams()
{
  auto params = IntegralRayKernelBase::validParams();
  params.addParam&lt;bool&gt;(
      &quot;average&quot;,
      false,
      &quot;Whether or not to compute the average value (divides by the segment length)&quot;);
  return params;
}

IntegralRayKernel::IntegralRayKernel(const InputParameters &amp; params)
  : IntegralRayKernelBase(params),
    _integral_data_index(_study.registerRayData(integralRayDataName())),
    _average(getParam&lt;bool&gt;(&quot;average&quot;))
{
}

void
IntegralRayKernel::onSegment()
{
  // Note that here we do not multiply by _coord[_qp]!
  //
  // The integral done here is the integral of a field variable/material/etc, and not
  // an integration that contributes to the residual/Jacobian. Hence: it is something like
  // a line integral. In RZ and RSPHERICAL, we want line integrals to still be line integrals.
  // Therefore, it does not make sense to multiply by the coordinate transformation.
  Real integral = 0;
  for (_qp = 0; _qp &lt; _q_point.size(); ++_qp)
    integral += _JxW[_qp] * computeQpIntegral();

  // If we&#x27;re computing the average, divide by the length
  if (_average)
    integral /= _current_segment_length;

  // Accumulate the integral into the Ray
  currentRay()-&gt;data(_integral_data_index) += integral;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="1fb76783-ae0a-4786-b9b7-759d659523c7"><div class="modal-content"><h4>(moose/modules/ray_tracing/include/raykernels/IntegralRayKernel.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;IntegralRayKernelBase.h&quot;

/**
 * Base class for a RayKernel that integrates along a Ray segment and stores the result in a scalar
 * value on the Ray
 */
class IntegralRayKernel : public IntegralRayKernelBase
{
public:
  IntegralRayKernel(const InputParameters &amp; params);

  static InputParameters validParams();

  /**
   * Gets the name of the Ray data associated with the integral accumulated by this RayKernel
   */
  std::string integralRayDataName() const { return _name + &quot;_value&quot;; }

  void onSegment() override final;

protected:
  virtual Real computeQpIntegral() = 0;

  /// The index into the data on the Ray that this integral accumulates into
  const RayDataIndex _integral_data_index;

  /// Whether or not to compute the average (divide by the length)
  const bool _average;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ddf43b0f-543f-4728-9dc3-e63b11957456"><div class="modal-content"><h4>rays</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the Rays associated with this object; only used if Ray registration is enabled within the study. If no Rays are supplied, this object will be applied to all Rays.</p></div></div><div class="moose-modal modal" id="6e633780-82da-4f2b-815b-7ff881946bd3"><div class="modal-content"><h4>rays</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the Rays associated with this object; only used if Ray registration is enabled within the study. If no Rays are supplied, this object will be applied to all Rays.</p></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
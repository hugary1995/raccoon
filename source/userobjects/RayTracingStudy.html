<!DOCTYPE html><head><meta charset="UTF-8"><title>RayTracingStudy | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="a7e8db0f-a111-4f32-8903-52cbdd3f0f62" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8153b670-85d4-4a09-955e-d9b294b4ef23" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="2b4ac702-bb3e-4232-99a3-ea41291460d8" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f66d6f8c-1368-4622-8f5e-829c82f1b6c9" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="c90a0696-4b49-4d3e-931f-45bd36357d80"><i class="material-icons">menu</i></a><ul class="sidenav" id="c90a0696-4b49-4d3e-931f-45bd36357d80"><li><a href="#!" class="dropdown-trigger" data-target="d4dc04fa-1619-40d3-b9ef-337567d7a388" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="a3fd1f03-21e2-49bc-9430-7a6caecd3941" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="3c6ed4ef-9cf7-40cc-8637-cf301bf026d4" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f32089b5-e71f-4b68-86a3-6eaa65c964d4" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="a7e8db0f-a111-4f32-8903-52cbdd3f0f62"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="8153b670-85d4-4a09-955e-d9b294b4ef23"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="2b4ac702-bb3e-4232-99a3-ea41291460d8"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="f66d6f8c-1368-4622-8f5e-829c82f1b6c9"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="d4dc04fa-1619-40d3-b9ef-337567d7a388"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="a3fd1f03-21e2-49bc-9430-7a6caecd3941"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="3c6ed4ef-9cf7-40cc-8637-cf301bf026d4"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="f32089b5-e71f-4b68-86a3-6eaa65c964d4"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="4e26303b-325e-40c9-9372-91814554c017" data-section-level="1" data-section-text="RayTracingStudy"><h1 id="raytracingstudy">RayTracingStudy</h1><p>The <code>RayTracingStudy</code> is the base object for generating and tracing of <a href="../raytracing/Ray.html">Rays</a> with the <a href="../../modules/ray_tracing/index.html">Ray Tracing Module</a>. For information about the manipulation of <a href="../raytracing/Ray.html">Rays</a> once they have began tracing, see <a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html">RayBCs</a>.</p><div class="card moose-alert moose-alert-tip"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">school</i><span class="moose-alert-title-brand">tip</span></div><div class="card-content"><div class="moose-alert-content"><p>The majority of the information presented here is for <strong>advanced</strong> users only. The use of this module for simple cases like line sources (see <a href="../../modules/ray_tracing/examples/line_sources.html">Using Line Sources</a>) and line integrals (see <a href="../../modules/ray_tracing/examples/line_integrals.html">Computing Line Integrals</a>) utilize the <a href="RepeatableRayStudy.html">RepeatableRayStudy</a>. Please see <a href="RepeatableRayStudy.html">RepeatableRayStudy</a> first for a more general understanding. If the <a href="RepeatableRayStudy.html">RepeatableRayStudy</a> is not sufficient for your use case, please then reference the <a href="RepeatableRayStudyBase.html">RepeatableRayStudyBase</a> instead.</p></div></div></div><section id="2591d60b-5e33-4ce3-ad2e-cc1b3a1144dc" data-section-level="2" data-section-text="Execution Phases"><h2 id="execution-phases">Execution Phases</h2><p>The execution of the  <code>RayTracingStudy</code> is split up into two phases:</p><ul class="browser-default"><li><p><a href="RayTracingStudy.html#generation">Generation</a> - The <a href="../raytracing/Ray.html">Rays</a> to be traced are defined and moved into the buffer to be traced </p></li><li><p><a href="RayTracingStudy.html#propagation">Propagation</a> - The <a href="../raytracing/Ray.html">Rays</a> are traced until completion</p></li></ul><section id="139c09f7-fe1f-477d-9c4f-e8879a95d0af" data-section-level="3" data-section-text="Generation"><h3 id="generation">Generation</h3><p>To use the <code>RayTracingStudy</code>, you are to derive from it and override the <code>generateRays()</code> method. Within <code>generateRays()</code>, you are to create <a href="../raytracing/Ray.html">Rays</a> (using the <a href="RayTracingStudy.html#ray-pool">Ray Pool</a>), set their trajectories (for more information, see <a href="../raytracing/Ray.html#defining-a-ray-trajectory">Defining a Ray Trajectory</a>), set their data (if any, see <a href="../raytracing/Ray.html#using-ray-data">Using Ray Data</a> for more information), and move them into the buffer to be traced with <code>moveRayToBuffer()</code> or <code>moveRaysToBuffer()</code>.</p><p>If you know in advance the number of <a href="../raytracing/Ray.html">Rays</a> that you are adding to the buffer to be traced during generation, it is advised call <code>reserveRayBuffer()</code> with the number of <a href="../raytracing/Ray.html">Rays</a> to be moved to the buffer <strong>before</strong> moving them into the buffer.</p></section><section id="15fd08c2-e1e5-44c5-957c-7877f51129f4" data-section-level="3" data-section-text="Propagation"><h3 id="propagation">Propagation</h3><p>The Ray propagation phase traces the <a href="../raytracing/Ray.html">Rays</a> that were added to the buffer to be traced. This is done internally by the <code>propagateRays()</code> method.</p><p>Note that additional <a href="../raytracing/Ray.html">Ray</a> objects may be added to be traced during the propagation phase via <a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html">RayBCs</a>. For more information, see <a href="../../syntax/RayKernels/index.html#creating-additional-rays">Creating Additional Rays</a> for creating a <a href="../raytracing/Ray.html">Ray</a> within <a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html#creating-a-new-ray">Creating a New Ray</a> for creating a <a href="../raytracing/Ray.html">Ray</a> within <a href="../../syntax/RayBCs/index.html">RayBCs</a>.</p></section></section><section id="6839d693-f5c8-4544-b0bb-0b39bac2543c" data-section-level="2" data-section-text="Specialization"><h2 id="specialization">Specialization</h2><p>There are many methods that can be overridden in your derived class. A summary of such methods follows:</p><ul class="browser-default"><li><p><code>generateRays()</code> - <strong>MUST</strong> override to define and move the <a href="../raytracing/Ray.html">Rays</a> into the buffer to be traced (see <a href="RayTracingStudy.html#generation">Generation</a>) </p></li><li><p><code>preExecuteStudy()</code> - Called before <a href="RayTracingStudy.html#generation">Generation</a> </p></li><li><p><code>postExecuteStudy()</code> - Called after <a href="RayTracingStudy.html#propagation">Propagation</a> </p></li><li><p><code>postOnSegment()</code> - Called after each segment of a <a href="../raytracing/Ray.html">Ray</a> </p></li><li><p><code>onCompleteRay()</code> - Called when the trace of a <a href="../raytracing/Ray.html">Ray</a> has ended </p></li><li><p><code>buildSegmentQuadrature()</code> Called to generate the 1D quadrature across a <a href="../raytracing/Ray.html">Ray</a> segment</p></li></ul></section><section id="60ac86eb-c4e6-4118-b362-d56448828826" data-section-level="2" data-section-text="Helper Systems"><h2 id="helper-systems">Helper Systems</h2><p>The <code>RayTracingStudy</code> contains many systems that aid in the generation and manipulation of <a href="../raytracing/Ray.html">Rays</a>:</p><ul class="browser-default"><li><p><a href="RayTracingStudy.html#ray-data-registration">Ray Data Registration</a>: Registers indices into data and auxiliary data to be stored on each <a href="../raytracing/Ray.html">Ray</a> </p></li><li><p><a href="RayTracingStudy.html#ray-registration">Ray Registration</a>: Registers names to be associated with each <a href="../raytracing/Ray.html">Ray</a> and requires <a href="../../syntax/RayBCs/index.html">RayBCs</a> and <a href="../../syntax/RayKernels/index.html">RayKernels</a> to provide which <a href="../raytracing/Ray.html">Rays</a> they are applied to </p></li><li><p><a href="RayTracingStudy.html#ray-banking">Ray Banking</a>: Banks <a href="../raytracing/Ray.html">Rays</a> once they end to be accessed after tracing </p></li><li><p><a href="RayTracingStudy.html#ray-pool">Ray Pool</a>: A shared pool of <a href="../raytracing/Ray.html">Rays</a> that allows for their reuse after they are called to be destructed </p></li><li><p><a href="RayTracingStudy.html#side-normal-caching">Side Normal Caching</a>: Generates and caches (for future use) outward normals for an element</p></li></ul><section id="e1761d2e-78c5-4bc9-827e-08605213e6c2" data-section-level="3" data-section-text="Ray Data Registration"><h3 id="ray-data-registration">Ray Data Registration</h3><p>The data and auxiliary data associated with a <a href="../raytracing/Ray.html">Ray</a> is stored on the <a href="../raytracing/Ray.html">Ray</a> itself in the form of two <code>std::vector&lt;RayData&gt;</code> (<code>RayData</code> is typically a <code>Real</code>), which are accessed via <code>Ray::data()</code> and <code>Ray::auxData()</code>. A data registration system exists that allows for the study, <a href="../../syntax/RayKernels/index.html">RayKernels</a>, and <a href="../../syntax/RayBCs/index.html">RayBCs</a> to request the data and auxiliary data that they need upon construction.</p><p>To register value(s), use the methods <code>registerRayData()</code> and <code>registerRayAuxData()</code>, which return either a single index or a vector of indices into the <code>Ray::data()</code> and <code>Ray::auxData()</code> vectors that you should utilize. If the same value is registered (uses the same name) within multiple objects, the same index will be returned.</p><p>For example, the <a href="../raykernels/IntegralRayKernel.html">IntegralRayKernel</a> is the base object for <a href="../../syntax/RayKernels/index.html">RayKernels</a> that integrate a field across a line (variables, materials, etc). In order to accumulate the integrated value, these kernels need a data value on the <a href="../raytracing/Ray.html">Ray</a>. As such, they register the need for <a href="../raytracing/Ray.html">Ray</a> data in the constructor and store the index for access:</p><pre style="max-height:350px;"><code class="language-cpp">IntegralRayKernel::IntegralRayKernel(const InputParameters &amp; params)
  : IntegralRayKernelBase(params),
    _integral_data_index(_study.registerRayData(integralRayDataName())),
    _average(getParam&lt;bool&gt;(&quot;average&quot;))
{
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#cd1d303e-365f-4150-aedc-9b5fb2fed0fb">(moose/modules/ray_tracing/src/raykernels/IntegralRayKernel.C)</a><pre style="max-height:350px;"><code class="language-cpp">class IntegralRayKernel : public IntegralRayKernelBase
{
public:
  IntegralRayKernel(const InputParameters &amp; params);

  static InputParameters validParams();

  /**
   * Gets the name of the Ray data associated with the integral accumulated by this RayKernel
   */
  std::string integralRayDataName() const { return _name + &quot;_value&quot;; }

  void onSegment() override final;

protected:
  virtual Real computeQpIntegral() = 0;

  /// The index into the data on the Ray that this integral accumulates into
  const RayDataIndex _integral_data_index;

  /// Whether or not to compute the average (divide by the length)
  const bool _average;
};
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#a5f194fe-88b2-4e7f-9629-311edf4b534b">(moose/modules/ray_tracing/include/raykernels/IntegralRayKernel.h)</a><p>While you can acquire <a href="../raytracing/Ray.html">Rays</a> that do not necessarily have the data size set according to the registration using the <a href="RayTracingStudy.html#ray-pool">Ray Pool</a>, any time the data is accessed on a <a href="../raytracing/Ray.html">Ray</a> (via <code>Ray::data()</code> and <code>Ray::auxData()</code>), if it is not sized properly as required by the registration, it will be resized to the registered size with zeros.</p></section><section id="608c7b47-6692-4028-91ea-ea5b5c2aa757" data-section-level="3" data-section-text="Ray Registration"><h3 id="ray-registration">Ray Registration</h3><p>For cases in which only a few <a href="../raytracing/Ray.html">Rays</a> are generated, it is beneficial to have a registration system that allows for the user to access a specific <a href="../raytracing/Ray.html">Ray</a> by name instead of an ID. Specific examples are line sources (see <a href="../../modules/ray_tracing/examples/line_sources.html">Using Line Sources</a>) and line integrals (see <a href="../../modules/ray_tracing/examples/line_integrals.html">Computing Line Integrals</a>), which utilize the <a href="RepeatableRayStudy.html">RepeatableRayStudy</a>.</p><p>The enabling and disabling of ray registration is handled by the <code>_use_ray_registration</code> private parameter, for which the default is true. When ray registration is enabled, all <a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html">RayBCs</a> <strong>must</strong> have the parameter <a href="#8f710409-f77d-4b21-bd79-e2e516b737fd" class="moose-modal-link modal-trigger">&quot;rays&quot;</a> set, which identifies the <a href="../raytracing/Ray.html">Rays</a> by name that said objects are executed on. When ray registration is disabled, the <a href="#f5a1deac-846d-446d-9e20-4b3af8643caf" class="moose-modal-link modal-trigger">&quot;rays&quot;</a> parameter cannot be used and <a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html">RayBCs</a> will be executed for <strong>all</strong> <a href="../raytracing/Ray.html">Rays</a>.</p><p>When using <a href="../raytracing/Ray.html">Ray</a> registration, each <a href="../raytracing/Ray.html">Ray</a> must be constructed within the study using the <code>acquireRegisteredRay()</code> method, which takes as an argument the name for the <a href="../raytracing/Ray.html">Ray</a>. For more information, see <a href="RayTracingStudy.html#ray-pool">Ray Pool</a>.</p><p>The public methods <code>registeredRayID()</code> and <code>registeredRayName()</code> can be utilized to map a registered <a href="../raytracing/Ray.html">Ray</a> name to its ID and an ID to its registered name, respectively.</p></section><section id="f6adf92d-027c-4334-9790-7cff84c7f6e7" data-section-level="3" data-section-text="Ray Banking"><h3 id="ray-banking">Ray Banking</h3><p>It is often useful to examine a <a href="../raytracing/Ray.html">Ray</a> after it has completed tracing. An example use case is for obtaining the accumulated integral for a <a href="../raytracing/Ray.html">Ray</a> that is integrating a field along a line (see <a href="../../modules/ray_tracing/examples/line_integrals.html">Computing Line Integrals</a> and <a href="../raykernels/IntegralRayKernel.html">IntegralRayKernel</a>). Within line integrals, the <a href="../raytracing/Ray.html">Ray</a> banks will be accessed to obtain the final accumulated value in a <a href="../raytracing/Ray.html">Ray</a>.</p><p>With the <code>_bank_rays_on_completion</code> private parameter set to true, all <a href="../raytracing/Ray.html">Rays</a> that complete on a given processor are stored in the private member variable <code>_ray_bank</code>. This bank can be accessed through the <code>rayBank()</code> method or via <code>getBankedRay()</code>, which will return the <a href="../raytracing/Ray.html">Ray</a> with the requested ID on the processor that ended the <a href="../raytracing/Ray.html">Ray</a>.</p><p>In addition, the methods <code>getBankedRayData()</code> and <code>getBankedRayAuxData()</code> are available to get a single data value from a <a href="../raytracing/Ray.html">Ray</a> from the banks after it has completed. For these methods, the resulting value is replicated across all processors.</p></section><section id="70c6c237-af88-44b4-9335-73c412d3e9c1" data-section-level="3" data-section-text="Ray Pool"><h3 id="ray-pool">Ray Pool</h3><p>For simulations with the <a href="../../modules/ray_tracing/index.html">Ray Tracing Module</a> that generate a significant number of <a href="../raytracing/Ray.html">Ray</a> objects, it becomes advantageous to minimize the construction of new <a href="../raytracing/Ray.html">Ray</a> objects. This is more important whenever the size of the data on the <a href="../raytracing/Ray.html">Ray</a> is significant.</p><p>Because of this, construction <a href="../raytracing/Ray.html">Ray</a> objects is handled via a shared pool. The pool ensures that, internally, any <a href="../raytracing/Ray.html">Rays</a> that are no-longer used can be reset and used again without extraneous allocation. The construction of new <a href="../raytracing/Ray.html">Rays</a> can only occur in three places:</p><ul class="browser-default"><li><p>Within <code>generateRays()</code> in a study, to create <a href="../raytracing/Ray.html">Rays</a> to be inserted into the buffer for tracing, via the <code>acquireRay{}()</code> methods (more discussion follows). </p></li><li><p>Within <code>onSegment()</code> in <a href="../../syntax/RayKernels/index.html">RayKernels</a>, via the <code>acquireRay()</code> method. </p></li><li><p>Within <code>onBoundary()</code> in <a href="../../syntax/RayBCs/index.html">RayBCs</a>, via the <code>acquireRay()</code> method.</p></li></ul><p>Multiple methods exist for acquiring rays within the study, which are:</p><ul class="browser-default"><li><p><code>acquireRay()</code> - Acquires a <a href="../raytracing/Ray.html">Ray</a> with a generated unique ID and with data sized according to the <a href="RayTracingStudy.html#ray-registration">Ray Registration</a>. </p></li><li><p><code>acquireUnsizedRay()</code> - Acquires a <a href="../raytracing/Ray.html">Ray</a> with a generated unique ID and data sized to zero. Note, whenever the unsized data is accessed within the <a href="../raytracing/Ray.html">Ray</a>, it will be automatically resized to ensure data consistency. </p></li><li><p><code>acquireReplicatedRay()</code> - Acquires a <a href="../raytracing/Ray.html">Ray</a> with an ID that is replicated across all processors and with data sized according to the <a href="RayTracingStudy.html#ray-registration">Ray Registration</a>. This must be called on all processors at the same time. </p></li><li><p><code>acquireRegisteredRay()</code> - Acquires a <a href="../raytracing/Ray.html">Ray</a> that is replicated across all processors with a given name and utilizes the <a href="RayTracingStudy.html#ray-registration">Ray Registration</a>. For example use, see <a href="RepeatableRayStudy.html">RepeatableRayStudy</a>. </p></li><li><p><code>acquireCopiedRay()</code> - Acquires a <a href="../raytracing/Ray.html">Ray</a> that is initialized from another <a href="../raytracing/Ray.html">Ray</a>. This is the only acquire method that does not generate a new ID. For example use, see <a href="RepeatableRayStudyBase.html">RepeatableRayStudyBase</a>.</p></li></ul><p><a href="../raytracing/Ray.html">Ray</a> storage is wrapped as a <code>std::shared_ptr&lt;Ray&gt;</code>. The significance of using a <code>shared_ptr</code> is that the destructor is called when the use count reaches zero, that is, when nobody is holding onto the <a href="../raytracing/Ray.html">Ray</a>. The internal tracing algorithm will decrease the use count for a traced <a href="../raytracing/Ray.html">Ray</a> after it has completed tracing. That is, if no other shared ownership of the <a href="../raytracing/Ray.html">Ray</a> exists, the use count will reach zero. This is why <a href="RayTracingStudy.html#ray-banking">Ray Banking</a> exists&mdash;the <a href="../raytracing/Ray.html">Ray</a> bank will increase the use count of the <a href="../raytracing/Ray.html">Ray</a> so that it is available for use after tracing and is not destructed.</p><p>As all <a href="../raytracing/Ray.html">Rays</a> must be constructed using the shared pool, whenever the use count for a <a href="../raytracing/Ray.html">Ray</a> goes to zero, the <a href="../raytracing/Ray.html">Ray</a> will be returned to the pool for future use.</p></section><section id="cd6aca8b-e878-4059-b55a-22e1d42a3ae9" data-section-level="3" data-section-text="Side Normal Caching"><h3 id="side-normal-caching">Side Normal Caching</h3><p>There is often a need to obtain the outward normal for an element&#x27;s side for many use cases of the <a href="../../modules/ray_tracing/index.html">Ray Tracing Module</a>.</p><p>The <code>RayTracingStudy</code> can provide outward side normals for an element on the fly. It also caches the generated normal for future requests for the same side normal. This is accessed through the <code>getSideNormal()</code> method.</p><p>Note that the side normals obtained through this caching are evaluated at the side centroid. Therefore, if the element side is non-planar, the returned normal will be an approximation. </p></section></section></section><div class="moose-modal modal" id="cd1d303e-365f-4150-aedc-9b5fb2fed0fb"><div class="modal-content"><h4>(moose/modules/ray_tracing/src/raykernels/IntegralRayKernel.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;IntegralRayKernel.h&quot;

// Local includes
#include &quot;RayTracingStudy.h&quot;

InputParameters
IntegralRayKernel::validParams()
{
  auto params = IntegralRayKernelBase::validParams();
  params.addParam&lt;bool&gt;(
      &quot;average&quot;,
      false,
      &quot;Whether or not to compute the average value (divides by the segment length)&quot;);
  return params;
}

IntegralRayKernel::IntegralRayKernel(const InputParameters &amp; params)
  : IntegralRayKernelBase(params),
    _integral_data_index(_study.registerRayData(integralRayDataName())),
    _average(getParam&lt;bool&gt;(&quot;average&quot;))
{
}

void
IntegralRayKernel::onSegment()
{
  // Note that here we do not multiply by _coord[_qp]!
  //
  // The integral done here is the integral of a field variable/material/etc, and not
  // an integration that contributes to the residual/Jacobian. Hence: it is something like
  // a line integral. In RZ and RSPHERICAL, we want line integrals to still be line integrals.
  // Therefore, it does not make sense to multiply by the coordinate transformation.
  Real integral = 0;
  for (_qp = 0; _qp &lt; _q_point.size(); ++_qp)
    integral += _JxW[_qp] * computeQpIntegral();

  // If we&#x27;re computing the average, divide by the length
  if (_average)
    integral /= _current_segment_length;

  // Accumulate the integral into the Ray
  currentRay()-&gt;data(_integral_data_index) += integral;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="a5f194fe-88b2-4e7f-9629-311edf4b534b"><div class="modal-content"><h4>(moose/modules/ray_tracing/include/raykernels/IntegralRayKernel.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;IntegralRayKernelBase.h&quot;

/**
 * Base class for a RayKernel that integrates along a Ray segment and stores the result in a scalar
 * value on the Ray
 */
class IntegralRayKernel : public IntegralRayKernelBase
{
public:
  IntegralRayKernel(const InputParameters &amp; params);

  static InputParameters validParams();

  /**
   * Gets the name of the Ray data associated with the integral accumulated by this RayKernel
   */
  std::string integralRayDataName() const { return _name + &quot;_value&quot;; }

  void onSegment() override final;

protected:
  virtual Real computeQpIntegral() = 0;

  /// The index into the data on the Ray that this integral accumulates into
  const RayDataIndex _integral_data_index;

  /// Whether or not to compute the average (divide by the length)
  const bool _average;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="8f710409-f77d-4b21-bd79-e2e516b737fd"><div class="modal-content"><h4>rays</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the Rays associated with this object; only used if Ray registration is enabled within the study. If no Rays are supplied, this object will be applied to all Rays.</p></div></div><div class="moose-modal modal" id="f5a1deac-846d-446d-9e20-4b3af8643caf"><div class="modal-content"><h4>rays</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the Rays associated with this object; only used if Ray registration is enabled within the study. If no Rays are supplied, this object will be applied to all Rays.</p></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
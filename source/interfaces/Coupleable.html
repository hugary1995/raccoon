<!DOCTYPE html><head><meta charset="UTF-8"><title>Coupleable | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="7eabca6c-83bb-4b41-b0d8-3fe5e8575895" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f14cc754-8958-4575-b0a5-95e3a6e4cef4" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b35535b2-0619-4e5e-9c38-6623adea3e96" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="db01ea78-b87c-4505-bdcd-8c0bc8143b2d" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="55c37e9f-7f05-4a2e-959b-0ba8c64624f0"><i class="material-icons">menu</i></a><ul class="sidenav" id="55c37e9f-7f05-4a2e-959b-0ba8c64624f0"><li><a href="#!" class="dropdown-trigger" data-target="69f53e4d-14ac-4847-b7c0-fb031efe2290" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9d662a9c-29a3-4b01-8751-401b8204cc3f" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="71d48a79-b024-4cb2-9670-315861fc8340" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="7e5ed7ee-bc5f-4060-90cd-ddcda5decacf" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="7eabca6c-83bb-4b41-b0d8-3fe5e8575895"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="f14cc754-8958-4575-b0a5-95e3a6e4cef4"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="b35535b2-0619-4e5e-9c38-6623adea3e96"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="db01ea78-b87c-4505-bdcd-8c0bc8143b2d"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="69f53e4d-14ac-4847-b7c0-fb031efe2290"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="9d662a9c-29a3-4b01-8751-401b8204cc3f"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="71d48a79-b024-4cb2-9670-315861fc8340"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="7e5ed7ee-bc5f-4060-90cd-ddcda5decacf"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="4796fc8f-8079-4b16-b84e-14b27f759e87" data-section-level="1" data-section-text="Coupleable"><h1 id="coupleable">Coupleable</h1><p>This class provides an API for coupling different kinds of variables values into MOOSE systems. The following tables summarize the methods it provides.</p><div recursive form="['left', 'left']" class="moose-table-div"><table><thead><tr><th style=";text-align:left">Methods for scalar field variables</th><th style=";text-align:left">Description</th></tr></thead><tbody><tr><td style=";text-align:left"><code>coupledValue</code>*‡§</td><td style=";text-align:left">Value of a coupled variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledGradient</code>*‡§</td><td style=";text-align:left">Gradient of a coupled variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledSecond</code>*‡§</td><td style=";text-align:left">Second spatial derivatives of a coupled variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledDot</code>†§</td><td style=";text-align:left">Time derivative of a coupled variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledDotDot</code>†§</td><td style=";text-align:left">Second time derivative of a coupled variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledDotDu</code></td><td style=";text-align:left">Derivative with regards to the variable of the time derivative of a coupled variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledDotDotDu</code></td><td style=";text-align:left">Derivative with regards to the variable of the second time derivative of a coupled variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledGradientDot</code>§</td><td style=";text-align:left">Time derivative of the gradient of a coupled variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledGradientDotDot</code></td><td style=";text-align:left">Second time derivative of the gradient of a coupled variable at q-points</td></tr></tbody></table></div><p>&mdash;</p><div recursive form="['left', 'left']" class="moose-table-div"><table><thead><tr><th style=";text-align:left">Methods for nodal scalar field variables</th><th style=";text-align:left">Description</th></tr></thead><tbody><tr><td style=";text-align:left"><code>coupledNodalValue</code>*‡§</td><td style=";text-align:left">Value of a coupled variable at nodes</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledNodalDot</code>†</td><td style=";text-align:left">Time derivative of a coupled variable at nodes</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledNodalDotDot</code>†</td><td style=";text-align:left">Second time derivative of a coupled variable at nodes</td></tr></tbody></table></div><p>&mdash;</p><div recursive form="['left', 'left']" class="moose-table-div"><table><thead><tr><th style=";text-align:left">Methods for array field variables</th><th style=";text-align:left">Description</th></tr></thead><tbody><tr><td style=";text-align:left"><code>coupledArrayValue</code>‡</td><td style=";text-align:left">Value of a coupled array variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledArrayGradient</code>‡</td><td style=";text-align:left">Gradient of a coupled array variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledArrayDot</code>†</td><td style=";text-align:left">Time derivative of a coupled array variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledArrayDotDot</code>†</td><td style=";text-align:left">Second time derivative of a coupled array variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledArrayDotDu</code></td><td style=";text-align:left">Derivative with regards to the variable of the time derivative of a coupled array variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledArrayGradientDot</code></td><td style=";text-align:left">Time derivative of the gradient of a coupled array variable at q-points</td></tr></tbody></table></div><p>&mdash;</p><div recursive form="['left', 'left']" class="moose-table-div"><table><thead><tr><th style=";text-align:left">Methods for vector field variables</th><th style=";text-align:left">Description</th></tr></thead><tbody><tr><td style=";text-align:left"><code>coupledVectorValue</code>‡§</td><td style=";text-align:left">Value of a coupled vector variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledVectorGradient</code>‡§</td><td style=";text-align:left">Gradient of a coupled vector variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledCurl</code>‡</td><td style=";text-align:left">Curl of a coupled vector variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledDiv</code>‡</td><td style=";text-align:left">Divergence of a coupled vector variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledVectorDot</code>†§</td><td style=";text-align:left">Time derivative of a coupled vector variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledVectorDotDot</code>†</td><td style=";text-align:left">Second time derivative of a coupled vector variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledVectorDotDu</code></td><td style=";text-align:left">Derivative with regards to the variable of the time derivative of a coupled vector variable at q-points</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledVectorDotDotDu</code></td><td style=";text-align:left">Derivative with regards to the variable of the second time derivative of a coupled vector variable at q-points</td></tr></tbody></table></div><p>&mdash;</p><div recursive form="['left', 'left']" class="moose-table-div"><table><thead><tr><th style=";text-align:left">Methods for nodal vector field variables</th><th style=";text-align:left">Description</th></tr></thead><tbody><tr><td style=";text-align:left"><code>coupledNodalValue</code>*‡§</td><td style=";text-align:left">Value of a coupled vector variable at nodes</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>coupledNodalDot</code></td><td style=";text-align:left">Time derivative of a coupled vector variable at nodes</td></tr></tbody></table></div><p>&mdash;</p><p>*: These methods are also provided with values from the previous Newton iteration by suffixing their name with <code>PreviousNL</code>, e.g. <code>coupledSecondPreviousNL</code>.</p><p>†: These methods are also provided with values from the previous time step of a transient simulation by suffixing their name with <code>Old</code>, e.g. <code>coupledDotOld</code>.</p><p>‡: These methods are also provided with values from the previous or second previous time steps of a transient simulation by suffixing their name with <code>Old</code> or <code>Older</code>, respectively, e.g. <code>coupledDivOld</code> or <code>coupledDivOlder</code>.</p><p>§: These methods are also provided with automatic differentiation info by prefixing their name with <code>ad</code> and preserving <code>camelCase</code>, e.g. <code>adCoupledValue</code> or <code>adCoupledVectorDot</code>.</p><p>Note that all of these prefixes and suffixes are mutually exclusive, i.e. none can be mixed and matched in any way.</p><p>Lastly, some methods are only available with automatic differentiation info, e.g. <code>adCoupledLowerValue</code> returns the value of a coupled lower-dimensional variable and <code>adCoupledVectorSecond</code> returns the second spatial derivatives of a coupled vector variable.</p><section id="19802497-9f67-414b-9540-ced01951aa7f" data-section-level="2" data-section-text="Optional Coupling"><h2 id="optional-coupling">Optional Coupling</h2><p>To determine if a variable was coupled, users can use <code>isCoupled</code> method. The typical use case looks like this:</p><pre style="max-height:350px;"><code class="language-text">
_value(isCoupled(&quot;v&quot;) ? coupledValue(&quot;v&quot;) : _zero)
</code></pre><p>However, this use case became obsolete and now it is recommended to use default values for optionally coupled variables, see the following example:</p><pre style="max-height:350px;"><code class="language-text">
InputParameters
Class::validParams()
{
  InputParameters params = BaseClass::validParams();
  params.addCoupledVar(&quot;v&quot;, 2., &quot;Coupled value&quot;);
  ...
  return params;
}

Class::Class(...) : BaseClass(...),
  _v(coupledValue(&#x27;v&#x27;))
</code></pre><p>The advantage here is that users can provide arbitrary default values to their variables.</p></section><section id="725bf1fd-dca9-44ea-b8a0-41f48009970f" data-section-level="2" data-section-text="Coupling of Vectors of Variables"><h2 id="coupling-of-vectors-of-variables">Coupling of Vectors of Variables</h2><p>Users can couple a vector of variables using the following syntax:</p><pre style="max-height:350px;"><code class="language-text">
v = &#x27;a b c&#x27;
</code></pre><p>This syntax provides 3 variables coupled as a variable <code>v</code> in a MOOSE object using the <code>Coupleable</code> interface. The number of components coupled into can be obtained by <code>coupledComponents</code> method. Then, individual components can be obtained by calling <code>coupledValue</code> (or any other method mentioned above) passing in the variable name (as usual) and the component index. See the following example:</p><p>Declarations:</p><pre style="max-height:350px;"><code class="language-text">
class B : public A
{
  ...
protected:
  unsigned int _n_vars;
  std::vector&lt;MooseVariable *&gt; _vars;
};
</code></pre><p>Implementation:</p><pre style="max-height:350px;"><code class="language-text">
InputParameters
B::validParams()
{
  InputParameters params = A::validParams();
  params.addRequiredCoupledVar(&quot;v&quot;, &quot;Coupled value&quot;);
  ...
  return params;
}

B::B(...) : A(...),
  _n_vars(coupledComponents(&quot;v&quot;))
{
  for (unsigned int i = 0; i &lt; _n_vars; i++)
    _vars.push_back(dynamic_cast&lt;MooseVariable *&gt;(getVar(&quot;v&quot;, i)));
}
</code></pre></section><section id="fbabfbdd-2630-4749-9b97-8211d146d7ec" data-section-level="2" data-section-text="Defaults for Coupling of Vectors of Variables"><h2 id="defaults-for-coupling-of-vectors-of-variables">Defaults for Coupling of Vectors of Variables</h2><p>Vectors of variables can be added using <code>params.addCoupledVar</code> as described above. The parameter class allows providing defaults for vector variables as follows:</p><pre style="max-height:350px;"><code class="language-text">
InputParameters
B::validParams()
{
  InputParameters params = A::validParams();
  params.addCoupledVar(&quot;v&quot;, {1, 2, 3}, &quot;Coupled value&quot;);
  ...
  return params;
}
</code></pre><p>Coupled variable parameters can be set to constant real numbers in the input file using the syntax</p><pre style="max-height:350px;"><code class="language-text">
v = &#x27;1&#x27;
</code></pre><p>for a single coupled variable or using</p><pre style="max-height:350px;"><code class="language-text">
v = &#x27;1 2 3&#x27;
</code></pre><p>for a vector of coupled variables. Currently mixing actual variable assignments and defaults like this:</p><pre style="max-height:350px;"><code class="language-text">
v = &#x27;1 actual_var 3&#x27;
</code></pre><p>is not supported.</p></section><section id="a844b8d6-ca8d-4f91-9769-ee7089818794" data-section-level="2" data-section-text="Coupled Solution DOFs"><h2 id="coupled-solution-dofs">Coupled Solution DOFs</h2><p>It is possible to retrieve the solution DOFs of an element in an elemental loop. This is different than the &quot;value&quot; type coupling which holds the interpolated values of the shape functions themselves. Obtaining the raw DOFs all the user to perform their own integration or other evaluation without going through the interpolation process. These functions can be found here:</p><pre style="max-height:350px;"><code class="language-cpp">  /**
   * Returns DoFs in the current solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValues(const std::string &amp; var_name,
                                                 unsigned int comp = 0) const;

  /**
   * Returns DoFs in the current solution vector of all of a coupled variable&#x27;s components for the
   * local element
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of the coupled variable
   */
  std::vector&lt;const VariableValue *&gt; coupledAllDofValues(const std::string &amp; var_name) const;

  /**
   * Returns DoFs in the old solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the old DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValuesOld(const std::string &amp; var_name,
                                                    unsigned int comp = 0) const;

  /**
   * Returns DoFs in the old solution vector of all of a coupled variable&#x27;s components for the local
   * element
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each compontnet of the coupled variable
   */
  std::vector&lt;const VariableValue *&gt; coupledAllDofValuesOld(const std::string &amp; var_name) const;

  /**
   * Returns DoFs in the older solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the older DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValuesOlder(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Returns DoFs in the older solution vector of all of a coupled variable&#x27;s components for the
   * local element
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of the coupled variable
   */
  std::vector&lt;const VariableValue *&gt; coupledAllDofValuesOlder(const std::string &amp; var_name) const;

  /**
   * Returns DoFs in the current solution vector of a coupled array variable for the local element
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a VariableValue for the DoFs of the coupled variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDofValues(const std::string &amp; var_name,
                                                           unsigned int comp = 0) const;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#488a78d6-51e0-48c9-8ad1-baba76f5dbf5">(moose/framework/include/interfaces/Coupleable.h)</a></section><section id="470173e7-d555-461e-b090-7c71121aa597" data-section-level="2" data-section-text="Coupling of variables through their names"><h2 id="coupling-of-variables-through-their-names">Coupling of variables through their names</h2><p>Typically variables are coupled in through calling <code>params.addCoupledVar</code> or <code>params.addRequiredCoupledVar</code> of the valid parameters of an object. There are cases where the variable names are provided through parameters in other types with <code>params.addParam</code> or <code>params.addRequiredParam</code>. For these cases, this interface provides two functions <code>coupledValueByName</code> and <code>coupledArrayValueByName</code> that take a variable name directly. This suffix <code>ByName</code> is only available for the two functions currently because they are the only onces needed by MOOSE and MOOSE applications. More can be added as desired in the future.</p></section><section id="590a4624-4d22-4539-a38d-6f60fca43554" data-section-level="2" data-section-text="Writing directly to coupled variables"><h2 id="writing-directly-to-coupled-variables">Writing directly to coupled variables</h2><p>Element- and nodal user objects as well AuxKernels may obtain a writable reference to a MOOSE field variable through the <code>Coupleable::writableVariable</code> function. The returned variable reference provides a <code>setDofValue</code> (for FE and FV variables) and <code>setNodalvalue</code> (only for FE variables) methods that can be used to set the nodal or elemental DOF value(s) of the variable.</p><p><code>Coupleable::writableVariable</code> enforces compatibility between the calling object type and the family of the requested variable. I.e. nodal user objects and AuxKernels may only obtain references to nodal variables, and element user objects and elemental AuxKernels may only obtain references to elemental variables.</p><p>The block restrictions of the variables are also checked not to exceed the block restrictions of the calling object. MOOSE keeps track of all variables to which a reference was obtained through <code>Coupleable::writableVariable</code>. Each variable in the system may at most be written to by a single object on any given subdomain.</p><p>The user object and aux kernel thread loops check if an executed object has any writable variable references, and if so, will insert those variables into the aux solution vector. This obviates the need for using the <a href="../auxkernels/ProjectionAux.html"><code>ProjectionAux</code></a> kernel.</p><div class="card moose-alert moose-alert-warning"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">warning</i><span class="moose-alert-title-brand">warning</span></div><div class="card-content"><div class="moose-alert-content"><p><code>Coupleable::writableVariable</code> can let users write to both FE / FV from AuxKernels and UserObjects but one must exercise caution about whether Nodal or Elemental type AuxKernels / UOs are used as the quadrature would depend on this choice and might lead to segfault if a FV variable values are set using <code>setDofValue</code> function for non-zero values of <code>_qp</code> .</p></div></div></div></section></section><div class="moose-modal modal" id="488a78d6-51e0-48c9-8ad1-baba76f5dbf5"><div class="modal-content"><h4>(moose/framework/include/interfaces/Coupleable.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#ifdef MOOSE_KOKKOS_SCOPE
#include &quot;KokkosVariableValue.h&quot;
#endif

#include &lt;unordered_map&gt;
#include &quot;MooseTypes.h&quot;
#include &quot;MooseArray.h&quot;
#include &quot;MooseVariableFE.h&quot;
#include &quot;MooseVariableFV.h&quot;
#include &quot;MooseLinearVariableFV.h&quot;
#include &quot;InputParameters.h&quot;
#include &quot;HasMembers.h&quot;

#define usingCoupleableMembers                                                                     \
  using Coupleable::_zero;                                                                         \
  using Coupleable::_grad_zero;                                                                    \
  using Coupleable::_ad_zero;                                                                      \
  using Coupleable::_ad_grad_zero;                                                                 \
  using Coupleable::coupled;                                                                       \
  using Coupleable::isCoupled;                                                                     \
  using Coupleable::coupledComponents

// Forward declarations
class MooseVariableScalar;
class MooseObject;

namespace libMesh
{
template &lt;typename T&gt;
class DenseVector;
}

template &lt;typename&gt;
class MooseVariableField;
typedef MooseVariableField&lt;Real&gt; MooseWritableVariable;

/**
 * Interface for objects that needs coupling capabilities
 *
 */
class Coupleable
{
public:
  /**
   * Constructing the object
   * @param parameters Parameters that come from constructing the object
   * @param nodal true if we need to couple with nodal values, otherwise false
   * @param is_fv Whether the \p MooseObject is a finite volume object
   */
  Coupleable(const MooseObject * moose_object, bool nodal, bool is_fv = false);

#ifdef MOOSE_KOKKOS_ENABLED
  /**
   * Special constructor used for Kokkos functor copy during parallel dispatch
   */
  Coupleable(const Coupleable &amp; object, const Moose::Kokkos::FunctorCopy &amp; key);
#endif

  /**
   * Get the list of coupled variables
   * @return The list of coupled variables
   */
  const std::unordered_map&lt;std::string, std::vector&lt;MooseVariableFieldBase *&gt;&gt; &amp;
  getCoupledVars() const
  {
    return _coupled_vars;
  }

  /**
   * Get the list of all coupled variables
   * @return The list of all coupled variables
   */
  const std::vector&lt;MooseVariableFieldBase *&gt; &amp; getCoupledMooseVars() const
  {
    return _coupled_moose_vars;
  }

  /**
   * Get the list of standard coupled variables
   * @return The list of standard coupled variables
   */
  const std::vector&lt;MooseVariable *&gt; &amp; getCoupledStandardMooseVars() const
  {
    return _coupled_standard_moose_vars;
  }

  /**
   * Get the list of vector coupled variables
   * @return The list of vector coupled variables
   */
  const std::vector&lt;VectorMooseVariable *&gt; &amp; getCoupledVectorMooseVars() const
  {
    return _coupled_vector_moose_vars;
  }

  /**
   * Get the list of array coupled variables
   * @return The list of array coupled variables
   */
  const std::vector&lt;ArrayMooseVariable *&gt; &amp; getCoupledArrayMooseVars() const
  {
    return _coupled_array_moose_vars;
  }

  void addFEVariableCoupleableVectorTag(TagID tag) { _fe_coupleable_vector_tags.insert(tag); }

  void addFEVariableCoupleableMatrixTag(TagID tag) { _fe_coupleable_matrix_tags.insert(tag); }

  std::set&lt;TagID&gt; &amp; getFEVariableCoupleableVectorTags() { return _fe_coupleable_vector_tags; }

  std::set&lt;TagID&gt; &amp; getFEVariableCoupleableMatrixTags() { return _fe_coupleable_matrix_tags; }

  const std::set&lt;TagID&gt; &amp; getFEVariableCoupleableVectorTags() const
  {
    return _fe_coupleable_vector_tags;
  }

  const std::set&lt;TagID&gt; &amp; getFEVariableCoupleableMatrixTags() const
  {
    return _fe_coupleable_matrix_tags;
  }

  /**
   * returns a reference to the set of writable coupled variables
   */
  auto &amp; getWritableCoupledVariables() const { return _writable_coupled_variables[_c_tid]; }

  /**
   * Checks whether the object has any writable coupled variables
   */
  bool hasWritableCoupledVariables() const { return !getWritableCoupledVariables().empty(); }

protected:
  /**
   * A call-back function provided by the derived object for actions before coupling a variable
   * with functions such as coupledValue.
   */
  virtual void coupledCallback(const std::string &amp; /*var_name*/, bool /*is_old*/) const {}

  /**
   * Returns true if a variables has been coupled as name.
   * @param var_name The name the kernel wants to refer to the variable as.
   * @param i By default 0, in general the index to test in a vector of MooseVariable pointers.
   * @return True if a coupled variable has the supplied name
   */
  virtual bool isCoupled(const std::string &amp; var_name, unsigned int i = 0) const;

  /**
   * Returns true if a variable passed as a coupled value is really a constant
   * @param var_name The name the kernel wants to refer to the variable as.
   * @return True if the variable is actually a constant
   */
  virtual bool isCoupledConstant(const std::string &amp; var_name) const;

  /**
   * Number of coupled components
   * @param var_name Name of the variable
   * @return number of components this variable has (usually 1)
   */
  unsigned int coupledComponents(const std::string &amp; var_name) const;

  /**
   * Names of the variable in the Coupleable interface
   * @param var_name Name of the variable
   * @param comp the component of the variable
   * @return name the variable has been coupled as. For constants, returns the constant
   */
  VariableName coupledName(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Names of the variables in the Coupleable interface
   * @param var_name Names of the variables
   * @return names the variables have been coupled as
   */
  std::vector&lt;VariableName&gt; coupledNames(const std::string &amp; var_name) const;

  /**
   * Returns the index for a coupled variable by name
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Index of coupled variable, if this is an optionally coupled variable that wasn&#x27;t
   * provided this will return a unique &quot;invalid&quot; index.
   */
  virtual unsigned int coupled(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Returns the indices for a coupled variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of the indices for all components of the coupled variable \p var_name.
   */
  std::vector&lt;unsigned int&gt; coupledIndices(const std::string &amp; var_name) const;

  /**
   * Returns value of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::_u
   */
  virtual const VariableValue &amp; coupledValue(const std::string &amp; var_name,
                                             unsigned int comp = 0) const;

  /**
   * Returns the values for all of a coupled variable components
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const VariableValue *&gt; coupledValues(const std::string &amp; var_name) const;

  /**
   * Returns the values for all of a coupled vector variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of VectorVariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const VectorVariableValue *&gt; coupledVectorValues(const std::string &amp; var_name) const;

  /**
   * Returns value of a coupled variable for use in templated automatic differentiation classes
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a GenericVariableValue for the coupled variable
   */
  template &lt;bool is_ad&gt;
  const GenericVariableValue&lt;is_ad&gt; &amp; coupledGenericValue(const std::string &amp; var_name,
                                                          unsigned int comp = 0) const;

  /**
   * Returns value of a coupled vector variable for use in templated automatic differentiation
   * classes
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a GenericVariableVectorValue for the coupled variable
   */
  template &lt;bool is_ad&gt;
  const GenericVectorVariableValue&lt;is_ad&gt; &amp; coupledGenericVectorValue(const std::string &amp; var_name,
                                                                      unsigned int comp = 0) const;

  /**
   * Returns the values for all of a coupled variable&#x27;s components for use in templated automatic
   * differentiation classes
   * @param var_name Name of coupled variable
   * @return Vector of GenericVariableValue pointers for each component of \p var_name
   */
  template &lt;bool is_ad&gt;
  std::vector&lt;const GenericVariableValue&lt;is_ad&gt; *&gt;
  coupledGenericValues(const std::string &amp; var_name) const;

  /**
   * Returns DOF value of a coupled variable for use in templated automatic differentiation classes
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a GenericVariableValue for the coupled variable
   */
  template &lt;bool is_ad&gt;
  const GenericVariableValue&lt;is_ad&gt; &amp; coupledGenericDofValue(const std::string &amp; var_name,
                                                             unsigned int comp = 0) const;

  /**
   * Returns time derivative of a coupled variable for use in templated automatic differentiation
   * classes
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a GenericVariableValue for the coupled variable time derivative
   */
  template &lt;bool is_ad&gt;
  const GenericVariableValue&lt;is_ad&gt; &amp; coupledGenericDot(const std::string &amp; var_name,
                                                        unsigned int comp = 0) const;

  /**
   * Returns the second time derivative of a coupled variable for use in templated automatic
   * differentiation classes
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a GenericVariableValue for the coupled variable second time derivative
   */
  template &lt;bool is_ad&gt;
  const GenericVariableValue&lt;is_ad&gt; &amp; coupledGenericDotDot(const std::string &amp; var_name,
                                                           unsigned int comp = 0) const;

  /**
   * Returns value of a coupled lower-dimensional variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   */
  virtual const VariableValue &amp; coupledValueLower(const std::string &amp; var_name,
                                                  unsigned int comp = 0) const;

  /**
   * Returns value of a coupled variable for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a ADVariableValue for the coupled variable
   */
  const ADVariableValue &amp; adCoupledValue(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Returns the values for all of a coupled variable&#x27;s components for use in Automatic
   * Differentiation
   * @param var_name Name of coupled variable
   * @return Vector of ADVariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const ADVariableValue *&gt; adCoupledValues(const std::string &amp; var_name) const;

  /**
   * Returns value of a coupled lower-dimensional variable for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a ADVariableValue for the coupled variable
   */
  const ADVariableValue &amp; adCoupledLowerValue(const std::string &amp; var_name,
                                              unsigned int comp = 0) const;

  /**
   * Returns value of a coupled vector variable for use in Automatic Differentiation
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::value
   */
  const ADVectorVariableValue &amp; adCoupledVectorValue(const std::string &amp; var_name,
                                                     unsigned int comp = 0) const;

  /**
   * Returns the values for all of a coupled vector variable&#x27;s components for use in
   * Automatic Differentiation
   * @param var_name Name of coupled variable
   * @return Vector of ADVariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const ADVectorVariableValue *&gt;
  adCoupledVectorValues(const std::string &amp; var_name) const;

  /**
   * Returns value of a coupled variable for a given tag
   * @param var_names Name(s) of coupled variable(s)
   * @param tag vector tag ID
   * @param index Index of the desired variable in the vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::_u
   */
  virtual const VariableValue &amp;
  coupledVectorTagValue(const std::string &amp; var_names, TagID tag, unsigned int index = 0) const;

  virtual const VariableValue &amp; coupledVectorTagValue(const std::string &amp; var_names,
                                                      const std::string &amp; tag_name,
                                                      unsigned int index = 0) const;

  /**
   * Returns the values for all the coupled variables desired for a given tag
   * @param var_names Name(s) of coupled variable(s)
   * @param tag vector tag ID
   * @return Vector of VariableValue pointers for each variable in \p var_names
   */
  std::vector&lt;const VariableValue *&gt; coupledVectorTagValues(const std::string &amp; var_names,
                                                            TagID tag) const;

  std::vector&lt;const VariableValue *&gt; coupledVectorTagValues(const std::string &amp; var_names,
                                                            const std::string &amp; tag_name) const;

  /**
   * Returns value of a coupled array variable for a given tag
   * @param var_names Name(s) of coupled array variable(s)
   * @param tag vector tag ID
   * @param index Index of the desired variable in the vector of coupled variables
   * @return Reference to a VariableValue for the coupled array variable
   * @see Kernel::_u
   */
  virtual const ArrayVariableValue &amp; coupledVectorTagArrayValue(const std::string &amp; var_names,
                                                                TagID tag,
                                                                unsigned int index = 0) const;

  virtual const ArrayVariableValue &amp; coupledVectorTagArrayValue(const std::string &amp; var_names,
                                                                const std::string &amp; tag_name,
                                                                unsigned int index = 0) const;

  /**
   * Returns the values for all the coupled variables desired for a given tag
   * @param var_name Name of array coupled variable
   * @param tag vector tag ID
   * @return Vector of ArrayVariableValue pointers for each variable in \p var_names
   */
  std::vector&lt;const ArrayVariableValue *&gt; coupledVectorTagArrayValues(const std::string &amp; var_names,
                                                                      TagID tag) const;

  std::vector&lt;const ArrayVariableValue *&gt;
  coupledVectorTagArrayValues(const std::string &amp; var_names, const std::string &amp; tag_name) const;

  /**
   * Returns gradient of a coupled variable for a given tag
   * @param var_names Name(s) of coupled variable(s)
   * @param tag vector tag ID
   * @param index Index of the desired variable in the vector of coupled variables
   * @return Reference to a VariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  virtual const VariableGradient &amp;
  coupledVectorTagGradient(const std::string &amp; var_names, TagID tag, unsigned int index = 0) const;

  virtual const VariableGradient &amp; coupledVectorTagGradient(const std::string &amp; var_names,
                                                            const std::string &amp; tag_name,
                                                            unsigned int index = 0) const;

  /**
   * Returns gradients for all the coupled variables desired for a given tag
   * @param var_names Name(s) of coupled array variable(s)
   * @param tag vector tag ID
   * @return Vector of VariableGradient pointers for each variables in \p var_name
   */
  std::vector&lt;const VariableGradient *&gt; coupledVectorTagGradients(const std::string &amp; var_names,
                                                                  TagID tag) const;

  std::vector&lt;const VariableGradient *&gt;
  coupledVectorTagGradients(const std::string &amp; var_names, const std::string &amp; tag_name) const;

  /**
   * Returns gradient of a coupled array variable for a given tag
   * @param var_names Name(s) of coupled array variable(s)
   * @param tag vector tag ID
   * @param index Index of the desired variable in the vector of coupled variables
   * @return Reference to a ArrayVariableGradient containing the gradient of the coupled array
   * variable
   * @see Kernel::gradient
   */
  virtual const ArrayVariableGradient &amp; coupledVectorTagArrayGradient(const std::string &amp; var_names,
                                                                      TagID tag,
                                                                      unsigned int index = 0) const;

  virtual const ArrayVariableGradient &amp; coupledVectorTagArrayGradient(const std::string &amp; var_names,
                                                                      const std::string &amp; tag_name,
                                                                      unsigned int index = 0) const;

  /**
   * Returns gradients for all the coupled variables desired for a given tag
   * @param var_names Name(s) of coupled array variable(s)
   * @param tag vector tag ID
   * @return Vector of ArrayVariableGradient pointers for each variable in \p var_name
   */
  std::vector&lt;const ArrayVariableGradient *&gt;
  coupledVectorTagArrayGradients(const std::string &amp; var_names, TagID tag) const;

  std::vector&lt;const ArrayVariableGradient *&gt;
  coupledVectorTagArrayGradients(const std::string &amp; var_names, const std::string &amp; tag_name) const;

  /**
   * Returns dof value of a coupled variable for a given tag
   * @param var_names Name(s) of coupled variable(s)
   * @param tag vector tag ID
   * @param index Index of the desired variable in the vector of coupled variables
   * @return Reference to a DofValue for the coupled variable
   */
  virtual const VariableValue &amp;
  coupledVectorTagDofValue(const std::string &amp; var_name, TagID tag, unsigned int index = 0) const;

  virtual const VariableValue &amp; coupledVectorTagDofValue(const std::string &amp; var_names,
                                                         const std::string &amp; tag_name,
                                                         unsigned int index = 0) const;

  /**
   * Returns evaluations of a tagged vector at the requested variable&#x27;s degree of freedom indices
   * @param var_name Name of coupled variable
   * @param tag_name vector tag name
   * @return Reference to a ArrayVariableValue for the coupled variable
   */
  const ArrayVariableValue &amp; coupledVectorTagArrayDofValue(const std::string &amp; var_name,
                                                           const std::string &amp; tag_name,
                                                           unsigned int comp = 0) const;

  /**
   * Returns the dof values for all the coupled variables desired for a given tag
   * @param var_names Name(s) of coupled variable(s)
   * @param tag vector tag ID
   * @return Vector of VariableValue pointers for each variable in \p var_name
   */
  std::vector&lt;const VariableValue *&gt; coupledVectorTagDofValues(const std::string &amp; var_names,
                                                               TagID tag) const;

  std::vector&lt;const VariableValue *&gt; coupledVectorTagDofValues(const std::string &amp; var_names,
                                                               const std::string &amp; tag_name) const;

  /**
   * Returns value of a coupled variable for a given tag. This couples the diag vector of matrix
   * @param var_names Name(s) of coupled variable(s)
   * @param tag matrix tag ID
   * @param index Index of the desired variable in the vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::_u
   */
  virtual const VariableValue &amp;
  coupledMatrixTagValue(const std::string &amp; var_names, TagID tag, unsigned int index = 0) const;

  virtual const VariableValue &amp; coupledMatrixTagValue(const std::string &amp; var_names,
                                                      const std::string &amp; tag_name,
                                                      unsigned int index = 0) const;

  /**
   * Returns the diagonal matrix values for all the coupled variables desired for a given tag
   * @param var_names Name(s) of coupled variable(s)
   * @param tag matrix tag ID
   * @return Vector of VariableValue pointers for each variable in \p var_name
   */
  std::vector&lt;const VariableValue *&gt; coupledMatrixTagValues(const std::string &amp; var_names,
                                                            TagID tag) const;

  std::vector&lt;const VariableValue *&gt; coupledMatrixTagValues(const std::string &amp; var_names,
                                                            const std::string &amp; tag_name) const;

  /**
   * Returns value of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue for the coupled vector variable
   * @see VectorKernel::_u
   */
  virtual const VectorVariableValue &amp; coupledVectorValue(const std::string &amp; var_name,
                                                         unsigned int comp = 0) const;

  /**
   * Returns value of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue for the coupled vector variable
   * @see ArrayKernel::_u
   */
  virtual const ArrayVariableValue &amp; coupledArrayValue(const std::string &amp; var_name,
                                                       unsigned int comp = 0) const;

  /**
   * Returns the values for all of a coupled array variable&#x27;s components
   * @param var_name Name of coupled array variable
   * @return Vector of ArrayVariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const ArrayVariableValue *&gt; coupledArrayValues(const std::string &amp; var_name) const;

  /**
   * Returns a *writable* MooseVariable object for a nodal or elemental variable. Use
   * var.setNodalValue(val[, idx]) in both cases (!) to set the solution DOF values. Only one
   * object can obtain a writable reference in a simulation. Note that the written values will
   * not ba available in the same system loop! E.g. values written using this API by a nodal
   * AuxKernel will not be updated for other nodal AuxKernels during the same iteration over all
   * nodes.
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a MooseWritableVariable for the coupled variable
   * @see Kernel::value
   */
  MooseWritableVariable &amp; writableVariable(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Returns a *writable* reference to a coupled variable for writing to multiple
   * AuxVariables from a single AuxKernel or a UserObject. Only one object can obtain
   * a writable reference in a simulation.
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::value
   */
  virtual VariableValue &amp; writableCoupledValue(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Checks that the passed in variable is only accessed writable by one object in a given subdomain
   */
  void checkWritableVar(MooseWritableVariable * var);

  /**
   * Returns an old value from previous time step  of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the old value of the coupled variable
   * @see Kernel::valueOld
   */
  virtual const VariableValue &amp; coupledValueOld(const std::string &amp; var_name,
                                                unsigned int comp = 0) const;

  /**
   * Returns the old values for all of a coupled variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const VariableValue *&gt; coupledValuesOld(const std::string &amp; var_name) const;

  /**
   * Returns the old values for all of a coupled vector variable&#x27;s components
   * @param var_name Name of coupled vector variable
   * @return Vector of VectorVariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const VectorVariableValue *&gt;
  coupledVectorValuesOld(const std::string &amp; var_name) const;

  /**
   * Returns an old value from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the older value of the coupled variable
   * @see Kernel::valueOlder
   */
  virtual const VariableValue &amp; coupledValueOlder(const std::string &amp; var_name,
                                                  unsigned int comp = 0) const;

  /**
   * Returns the older values for all of a coupled variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const VariableValue *&gt; coupledValuesOlder(const std::string &amp; var_name) const;

  /**
   * Returns value of previous Newton iterate of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the older value of the coupled variable
   */
  virtual const VariableValue &amp; coupledValuePreviousNL(const std::string &amp; var_name,
                                                       unsigned int comp = 0) const;

  /**
   * Returns an old value from previous time step  of a coupled vector variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableValue containing the old value of the coupled variable
   * @see VectorKernel::_u_old
   */
  virtual const VectorVariableValue &amp; coupledVectorValueOld(const std::string &amp; var_name,
                                                            unsigned int comp = 0) const;

  /**
   * Returns an old value from two time steps previous of a coupled vector variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableValue containing the older value of the coupled variable
   * @see VectorKernel::_u_older
   */
  virtual const VectorVariableValue &amp; coupledVectorValueOlder(const std::string &amp; var_name,
                                                              unsigned int comp = 0) const;

  /**
   * Returns an old value from previous time step of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the old value of the coupled variable
   * @see ArrayKernel::_u_old
   */
  virtual const ArrayVariableValue &amp; coupledArrayValueOld(const std::string &amp; var_name,
                                                          unsigned int comp = 0) const;

  /**
   * Returns an old value from two time steps previous of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the older value of the coupled variable
   * @see ArrayKernel::_u_older
   */
  virtual const ArrayVariableValue &amp; coupledArrayValueOlder(const std::string &amp; var_name,
                                                            unsigned int comp = 0) const;

  /**
   * Returns gradient of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  virtual const VariableGradient &amp; coupledGradient(const std::string &amp; var_name,
                                                   unsigned int comp = 0) const;

  /**
   * Returns the gradients for all of a coupled variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of VariableGradient pointers for each component of \p var_name
   */
  std::vector&lt;const VariableGradient *&gt; coupledGradients(const std::string &amp; var_name) const;

  /**
   * Returns gradient of a coupled variable for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to an ADVariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  const ADVariableGradient &amp; adCoupledGradient(const std::string &amp; var_name,
                                               unsigned int comp = 0) const;

  /**
   * Returns gradient of a coupled variable&#x27;s time derivative for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to an ADVariableGradient containing the gradient of the coupled variable&#x27;s
   * time derivative
   */
  const ADVariableGradient &amp; adCoupledGradientDot(const std::string &amp; var_name,
                                                  unsigned int comp = 0) const;

  /**
   * Returns the gradients for all of a coupled variable&#x27;s components for use in Automatic
   * Differentiation
   * @param var_name Name of coupled variable
   * @return Vector of ADVariableGradient pointers for each component of \p var_name
   */
  std::vector&lt;const ADVariableGradient *&gt; adCoupledGradients(const std::string &amp; var_name) const;

  /**
   * Returns gradient of a coupled variable for use in templated automatic differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  template &lt;bool is_ad&gt;
  const GenericVariableGradient&lt;is_ad&gt; &amp; coupledGenericGradient(const std::string &amp; var_name,
                                                                unsigned int comp = 0) const;

  /**
   * Returns the gradients for all of a coupled variable&#x27;s components for use in templated automatic
   * differentiation
   * @param var_name Name of coupled variable
   * @return Vector of VariableGradient pointers for each component of \p var_name
   */
  template &lt;bool is_ad&gt;
  std::vector&lt;const GenericVariableGradient&lt;is_ad&gt; *&gt;
  coupledGenericGradients(const std::string &amp; var_name) const;

  /**
   * Returns gradient of a coupled vector variable for use in Automatic Differentiation
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  const ADVectorVariableGradient &amp; adCoupledVectorGradient(const std::string &amp; var_name,
                                                           unsigned int comp = 0) const;

  /**
   * Returns second derivatives of a coupled variable for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the second derivatives of the coupled variable
   */
  const ADVariableSecond &amp; adCoupledSecond(const std::string &amp; var_name,
                                           unsigned int comp = 0) const;

  /**
   * Returns second derivatives of a coupled vector variable for use in Automatic Differentiation
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableSecond containing the second derivatives of the coupled
   * variable
   */
  const ADVectorVariableSecond &amp; adCoupledVectorSecond(const std::string &amp; var_name,
                                                       unsigned int comp = 0) const;

  /**
   * Returns an old gradient from previous time step of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the old gradient of the coupled variable
   * @see Kernel::gradientOld
   */
  virtual const VariableGradient &amp; coupledGradientOld(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Returns the old gradients for all of a coupled variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of VariableGradient pointers for each component of \p var_name
   */
  std::vector&lt;const VariableGradient *&gt; coupledGradientsOld(const std::string &amp; var_name) const;

  /**
   * Returns an old gradient from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the older gradient of the coupled variable
   * @see Kernel::gradientOlder
   */
  virtual const VariableGradient &amp; coupledGradientOlder(const std::string &amp; var_name,
                                                        unsigned int comp = 0) const;

  /**
   * Returns gradient of a coupled variable for previous Newton iterate
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the gradient of the coupled variable
   */
  virtual const VariableGradient &amp; coupledGradientPreviousNL(const std::string &amp; var_name,
                                                             unsigned int comp = 0) const;

  /**
   * Time derivative of the gradient of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the time derivative of the gradient of a
   * coupled variable
   */
  virtual const VariableGradient &amp; coupledGradientDot(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Second time derivative of the gradient of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the time derivative of the gradient of a
   * coupled variable
   */
  virtual const VariableGradient &amp; coupledGradientDotDot(const std::string &amp; var_name,
                                                         unsigned int comp = 0) const;

  /**
   * Returns gradient of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableGradient containing the gradient of the coupled vector
   * variable
   */
  virtual const VectorVariableGradient &amp; coupledVectorGradient(const std::string &amp; var_name,
                                                               unsigned int comp = 0) const;

  /**
   * Returns an old gradient from previous time step of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableGradient containing the old gradient of the coupled vector
   * variable
   */
  virtual const VectorVariableGradient &amp; coupledVectorGradientOld(const std::string &amp; var_name,
                                                                  unsigned int comp = 0) const;

  /**
   * Returns an old gradient from two time steps previous of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableGradient containing the older gradient of the coupled
   * vector variable
   */
  virtual const VectorVariableGradient &amp; coupledVectorGradientOlder(const std::string &amp; var_name,
                                                                    unsigned int comp = 0) const;

  /**
   * Returns gradient of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a VectorVariableGradient containing the gradient of the coupled array
   * variable
   */
  virtual const ArrayVariableGradient &amp; coupledArrayGradient(const std::string &amp; var_name,
                                                             unsigned int comp = 0) const;

  /**
   * Returns an old gradient from previous time step of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a VectorVariableGradient containing the old gradient of the coupled array
   * variable
   */
  virtual const ArrayVariableGradient &amp; coupledArrayGradientOld(const std::string &amp; var_name,
                                                                unsigned int comp = 0) const;

  /**
   * Returns an old gradient from two time steps previous of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableGradient containing the older gradient of the coupled
   * array variable
   */
  virtual const ArrayVariableGradient &amp; coupledArrayGradientOlder(const std::string &amp; var_name,
                                                                  unsigned int comp = 0) const;

  /**
   * Retun a gradient of a coupled array variable&#x27;s time derivative
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableGradient containing the gradient of the time derivative
   * the coupled array variable
   */
  virtual const ArrayVariableGradient &amp; coupledArrayGradientDot(const std::string &amp; var_name,
                                                                unsigned int comp = 0) const;

  /**
   * Returns curl of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableCurl containing the curl of the coupled variable
   * @see Kernel::_curl_u
   */
  virtual const VectorVariableCurl &amp; coupledCurl(const std::string &amp; var_name,
                                                 unsigned int comp = 0) const;

  /**
   * Returns an old curl from previous time step of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableCurl containing the old curl of the coupled variable
   * @see Kernel::_curl_u_old
   */
  virtual const VectorVariableCurl &amp; coupledCurlOld(const std::string &amp; var_name,
                                                    unsigned int comp = 0) const;

  /**
   * Returns an old curl from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableCurl containing the older curl of the coupled variable
   * @see Kernel::_curl_u_older
   */
  virtual const VectorVariableCurl &amp; coupledCurlOlder(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Returns curl of a coupled variable for use in objects utilizing Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to an ADVectorVariableCurl containing the curl of the coupled variable
   * @see Kernel::_curl_u
   */
  const ADVectorVariableCurl &amp; adCoupledCurl(const std::string &amp; var_name,
                                             unsigned int comp = 0) const;

  /**
   * Returns divergence of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableDivergence containing the divergence of the coupled
   * variable
   * @see Kernel::_div_u
   */
  virtual const VectorVariableDivergence &amp; coupledDiv(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Returns an old divergence from previous time step of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableDivergence containing the old divergence of the coupled
   * variable
   * @see Kernel::_div_u_old
   */
  virtual const VectorVariableDivergence &amp; coupledDivOld(const std::string &amp; var_name,
                                                         unsigned int comp = 0) const;

  /**
   * Returns an old divergence from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableDivergence containing the older divergence of the coupled
   * variable
   * @see Kernel::_div_u_older
   */
  virtual const VectorVariableDivergence &amp; coupledDivOlder(const std::string &amp; var_name,
                                                           unsigned int comp = 0) const;

  /**
   * Returns second spatial derivatives of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the second derivative of the coupled variable
   * @see Kernel::second
   */
  virtual const VariableSecond &amp; coupledSecond(const std::string &amp; var_name,
                                               unsigned int comp = 0) const;

  /**
   * Returns an old second spatial derivatives from previous time step of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the old second derivative of the coupled
   * variable
   * @see Kernel::secondOld
   */
  virtual const VariableSecond &amp; coupledSecondOld(const std::string &amp; var_name,
                                                  unsigned int comp = 0) const;

  /**
   * Returns an old second derivative from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the older second derivative of the coupled
   * variable
   * @see Kernel::secondOlder
   */
  virtual const VariableSecond &amp; coupledSecondOlder(const std::string &amp; var_name,
                                                    unsigned int comp = 0) const;

  /**
   * Returns second derivative of a coupled variable for the previous Newton iterate
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the second derivative of the coupled variable
   */
  virtual const VariableSecond &amp; coupledSecondPreviousNL(const std::string &amp; var_name,
                                                         unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   */
  virtual const VariableValue &amp; coupledDot(const std::string &amp; var_name,
                                           unsigned int comp = 0) const;

  /**
   * Returns the time derivatives for all of a coupled variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const VariableValue *&gt; coupledDots(const std::string &amp; var_name) const;

  /**
   * Second time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the second time derivative of the coupled
   * variable
   */
  virtual const VariableValue &amp; coupledDotDot(const std::string &amp; var_name,
                                              unsigned int comp = 0) const;

  /**
   * Old time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the old time derivative of the coupled variable
   */
  virtual const VariableValue &amp; coupledDotOld(const std::string &amp; var_name,
                                              unsigned int comp = 0) const;

  /**
   * Old second time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the old second time derivative of the coupled
   * variable
   */
  virtual const VariableValue &amp; coupledDotDotOld(const std::string &amp; var_name,
                                                 unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled variable for ad simulations
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   * @see Kernel::dot
   */
  const ADVariableValue &amp; adCoupledDot(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Returns the time derivatives for all of a coupled variable&#x27;s components for ad simulations
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const ADVariableValue *&gt; adCoupledDots(const std::string &amp; var_name) const;

  /**
   * Second time derivative of a coupled variable for ad simulations
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to an ADVariableValue containing the second time derivative of the coupled
   * variable
   */
  const ADVariableValue &amp; adCoupledDotDot(const std::string &amp; var_name,
                                          unsigned int comp = 0) const;

  /**
   * Time derivative of a vector coupled variable for ad simulations
   * @param var_name Name of vector coupled variable
   * @param comp Component number
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   * @see Kernel::dot
   */
  const ADVectorVariableValue &amp; adCoupledVectorDot(const std::string &amp; var_name,
                                                   unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const VectorVariableValue &amp; coupledVectorDot(const std::string &amp; var_name,
                                                       unsigned int comp = 0) const;

  /**
   * Second time derivative of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const VectorVariableValue &amp; coupledVectorDotDot(const std::string &amp; var_name,
                                                          unsigned int comp = 0) const;

  /**
   * Old time derivative of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const VectorVariableValue &amp; coupledVectorDotOld(const std::string &amp; var_name,
                                                          unsigned int comp = 0) const;

  /**
   * Old second time derivative of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const VectorVariableValue &amp; coupledVectorDotDotOld(const std::string &amp; var_name,
                                                             unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled vector variable with respect to the coefficients
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VariableValue containing the time derivative of the coupled
   * vector variable with respect to the coefficients
   */
  virtual const VariableValue &amp; coupledVectorDotDu(const std::string &amp; var_name,
                                                   unsigned int comp = 0) const;

  /**
   * Second time derivative of a coupled vector variable with respect to the coefficients
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VariableValue containing the time derivative of the coupled vector
   * variable with respect to the coefficients
   */
  virtual const VariableValue &amp; coupledVectorDotDotDu(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDot(const std::string &amp; var_name,
                                                     unsigned int comp = 0) const;

  /**
   * Second time derivative of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDotDot(const std::string &amp; var_name,
                                                        unsigned int comp = 0) const;

  /**
   * Old time derivative of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDotOld(const std::string &amp; var_name,
                                                        unsigned int comp = 0) const;

  /**
   * Old second time derivative of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDotDotOld(const std::string &amp; var_name,
                                                           unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled variable with respect to the coefficients
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   * with respect to the coefficients
   */
  virtual const VariableValue &amp; coupledDotDu(const std::string &amp; var_name,
                                             unsigned int comp = 0) const;

  /**
   * Second time derivative of a coupled variable with respect to the coefficients
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   * with respect to the coefficients
   */
  virtual const VariableValue &amp; coupledDotDotDu(const std::string &amp; var_name,
                                                unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled array variable with respect to the coefficients
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  const VariableValue &amp; coupledArrayDotDu(const std::string &amp; var_name,
                                          unsigned int comp = 0) const;

  /**
   * Returns nodal values of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalValue(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Returns AD nodal values of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   */
  template &lt;typename T&gt;
  const typename Moose::ADType&lt;T&gt;::type &amp; adCoupledNodalValue(const std::string &amp; var_name,
                                                              unsigned int comp = 0) const;

  /**
   * Returns an old nodal value from previous time step  of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the old value of the coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalValueOld(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Returns an old nodal value from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the older value of the coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalValueOlder(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Returns nodal values of a coupled variable for previous Newton iterate
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalValuePreviousNL(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Nodal values of time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the nodal values of time derivative of the
   * coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalDot(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Nodal values of second time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the nodal values of second time derivative of
   * the coupled variable
   */
  virtual const VariableValue &amp; coupledNodalDotDot(const std::string &amp; var_name,
                                                   unsigned int comp = 0) const;

  /**
   * Nodal values of old time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the nodal values of time derivative of the
   * coupled variable
   */
  virtual const VariableValue &amp; coupledNodalDotOld(const std::string &amp; var_name,
                                                   unsigned int comp = 0) const;

  /**
   * Nodal values of old second time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the nodal values of second time derivative of
   * the coupled variable
   */
  virtual const VariableValue &amp; coupledNodalDotDotOld(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;
  // coupled-dof-values-begin
  /**
   * Returns DoFs in the current solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValues(const std::string &amp; var_name,
                                                 unsigned int comp = 0) const;

  /**
   * Returns DoFs in the current solution vector of all of a coupled variable&#x27;s components for the
   * local element
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of the coupled variable
   */
  std::vector&lt;const VariableValue *&gt; coupledAllDofValues(const std::string &amp; var_name) const;

  /**
   * Returns DoFs in the old solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the old DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValuesOld(const std::string &amp; var_name,
                                                    unsigned int comp = 0) const;

  /**
   * Returns DoFs in the old solution vector of all of a coupled variable&#x27;s components for the local
   * element
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each compontnet of the coupled variable
   */
  std::vector&lt;const VariableValue *&gt; coupledAllDofValuesOld(const std::string &amp; var_name) const;

  /**
   * Returns DoFs in the older solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the older DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValuesOlder(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Returns DoFs in the older solution vector of all of a coupled variable&#x27;s components for the
   * local element
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of the coupled variable
   */
  std::vector&lt;const VariableValue *&gt; coupledAllDofValuesOlder(const std::string &amp; var_name) const;

  /**
   * Returns DoFs in the current solution vector of a coupled array variable for the local element
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a VariableValue for the DoFs of the coupled variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDofValues(const std::string &amp; var_name,
                                                           unsigned int comp = 0) const;
  // coupled-dof-values-end

  /**
   * Returns DOF value of a coupled variable for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to an ADVariableValue for the DoFs of the coupled variable
   */
  virtual const ADVariableValue &amp; adCoupledDofValues(const std::string &amp; var_name,
                                                     unsigned int comp = 0) const;

  /**
   * method that returns _zero to RESIDUAL computing objects and _ad_zero to JACOBIAN
   * computing objects
   */
  const ADVariableValue &amp; adZeroValue() const;

  /**
   *  method that returns _grad_zero to RESIDUAL computing objects and _ad_grad_zero to
   * JACOBIAN computing objects
   */
  const ADVariableGradient &amp; adZeroGradient() const;

  /**
   * Retrieve a zero second for automatic differentiation
   */
  const ADVariableSecond &amp; adZeroSecond() const;

  /**
   * Returns zero value templated with automatic differentiation boolean
   * @return Reference to a const GenericVariableValue
   */
  template &lt;bool is_ad&gt;
  const GenericVariableValue&lt;is_ad&gt; &amp; genericZeroValue();

  /**
   * Returns zero gradient templated with automatic differentiation boolean
   * @return Reference to a const GenericVariableValue
   */
  template &lt;bool is_ad&gt;
  const GenericVariableGradient&lt;is_ad&gt; &amp; genericZeroGradient();

  /**
   * Returns zero second derivative templated with automatic differentiation boolean
   * @return Reference to a const GenericVariableValue
   */
  template &lt;bool is_ad&gt;
  const GenericVariableSecond&lt;is_ad&gt; &amp; genericZeroSecond();

protected:
  // Reference to the interface&#x27;s input parameters
  const InputParameters &amp; _c_parameters;

  /// The name of the object this interface is part of
  const std::string &amp; _c_name;
  /// The type of the object this interface is part of
  const std::string &amp; _c_type;

  // Reference to FEProblemBase
  FEProblemBase &amp; _c_fe_problem;

  /// Pointer to the system object if the moose object this is an interface for has one
  const SystemBase * const _c_sys;

  /// Coupled vars whose values we provide
  std::unordered_map&lt;std::string, std::vector&lt;MooseVariableFieldBase *&gt;&gt; _coupled_vars;

  /// Vector of all coupled variables
  std::vector&lt;MooseVariableFieldBase *&gt; _coupled_moose_vars;

  /// Vector of standard coupled variables
  std::vector&lt;MooseVariable *&gt; _coupled_standard_moose_vars;

  /// Vector of vector coupled variables
  std::vector&lt;VectorMooseVariable *&gt; _coupled_vector_moose_vars;

  /// Vector of array coupled variables
  std::vector&lt;ArrayMooseVariable *&gt; _coupled_array_moose_vars;

  /// Vector of all finite volume coupled variables
  std::vector&lt;MooseVariableField&lt;Real&gt; *&gt; _coupled_fv_moose_vars;

  /// map from new to deprecated variable names
  const std::unordered_map&lt;std::string, std::string&gt; &amp; _new_to_deprecated_coupled_vars;

  /// True if we provide coupling to nodal values
  bool _c_nodal;

  /// True if implicit value is required
  bool _c_is_implicit;

  // Argument to allow element-to-nodal coupling
  const bool _c_allow_element_to_nodal_coupling;

  /// Thread ID of the thread using this object
  THREAD_ID _c_tid;

  /// Will hold the default value for optional coupled variables.
  mutable std::unordered_map&lt;std::string, std::vector&lt;std::unique_ptr&lt;VariableValue&gt;&gt;&gt;
      _default_value;

  /// Will hold the default value for optional coupled variables for automatic differentiation.
  mutable std::unordered_map&lt;std::string, std::unique_ptr&lt;MooseArray&lt;ADReal&gt;&gt;&gt; _ad_default_value;

  /// Will hold the default value for optional vector coupled variables.
  mutable std::unordered_map&lt;std::string, std::unique_ptr&lt;VectorVariableValue&gt;&gt;
      _default_vector_value;

  /// Will hold the default value for optional array coupled variables.
  mutable std::unordered_map&lt;std::string, std::unique_ptr&lt;ArrayVariableValue&gt;&gt; _default_array_value;

  /// Will hold the default value for optional vector coupled variables for automatic differentiation.
  mutable std::unordered_map&lt;std::string, std::unique_ptr&lt;MooseArray&lt;ADRealVectorValue&gt;&gt;&gt;
      _ad_default_vector_value;

  /**
   * This will always be zero because the default values for optionally coupled variables is always
   * constant and this is used for time derivative info
   */
  mutable VariableValue _default_value_zero;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable VariableGradient _default_gradient;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable MooseArray&lt;ADRealVectorValue&gt; _ad_default_gradient;

  /// This will always be zero because the default values for optionally coupled vector variables is always constant
  mutable MooseArray&lt;ADRealTensorValue&gt; _ad_default_vector_gradient;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable VariableSecond _default_second;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable MooseArray&lt;ADRealTensorValue&gt; _ad_default_second;

  /// This will always be zero because the default values for optionally coupled vector variables is always constant
  mutable MooseArray&lt;ADRealVectorValue&gt; _ad_default_curl;

  /// Zero value of a variable
  const VariableValue &amp; _zero;
  const VariablePhiValue &amp; _phi_zero;
  const MooseArray&lt;ADReal&gt; &amp; _ad_zero;

  /// Zero gradient of a variable
  const VariableGradient &amp; _grad_zero;
  const MooseArray&lt;ADRealVectorValue&gt; &amp; _ad_grad_zero;

  /// Zero gradient of trial function
  const VariablePhiGradient &amp; _grad_phi_zero;

  /// Zero second derivative of a variable
  const VariableSecond &amp; _second_zero;
  const MooseArray&lt;ADRealTensorValue&gt; &amp; _ad_second_zero;
  /// Zero second derivative of a test function
  const VariablePhiSecond &amp; _second_phi_zero;
  /// Zero value of a vector variable
  const VectorVariableValue &amp; _vector_zero;
  /// Zero value of the curl of a vector variable
  const VectorVariableCurl &amp; _vector_curl_zero;

  /**
   * This will always be zero because the default values for optionally coupled variables is always
   * constant and this is used for time derivative info
   */
  mutable VectorVariableValue _default_vector_value_zero;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable VectorVariableGradient _default_vector_gradient;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable VectorVariableCurl _default_vector_curl;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable VectorVariableDivergence _default_div;

  /**
   * This will always be zero because the default values for optionally coupled variables is always
   * constant and this is used for time derivative info
   */
  ArrayVariableValue _default_array_value_zero;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  ArrayVariableGradient _default_array_gradient;

  /**
   * Check that the right kind of variable is being coupled in
   *
   * @param var_name The name of the coupled variable
   */
  bool
  checkVar(const std::string &amp; var_name, unsigned int comp = 0, unsigned int comp_bound = 0) const;

private:
  /**
   * Generic helper method to get vector tag values based on tag ID
   */
  template &lt;typename T&gt;
  const typename OutputTools&lt;T&gt;::VariableValue &amp;
  vectorTagValueHelper(const std::string &amp; var_names, TagID tag, unsigned int index = 0) const;

  /**
   * Generic helper method to get vector tag values based on tag name
   */
  template &lt;typename T&gt;
  const typename OutputTools&lt;T&gt;::VariableValue &amp; vectorTagValueHelper(const std::string &amp; var_names,
                                                                      const std::string &amp; tag_name,
                                                                      unsigned int index = 0) const;

  /**
   * Generic helper method to get vector tag degree of freedom values based on tag ID
   */
  template &lt;typename T&gt;
  const typename OutputTools&lt;T&gt;::VariableValue &amp;
  vectorTagDofValueHelper(const std::string &amp; var_name, TagID tag, unsigned int comp = 0) const;

  /**
   * Generic helper method to get vector tag degree of freedom values based on tag name
   */
  template &lt;typename T&gt;
  const typename OutputTools&lt;T&gt;::VariableValue &amp; vectorTagDofValueHelper(
      const std::string &amp; var_name, const std::string &amp; tag_name, unsigned int comp = 0) const;

  /**
   * Method that may request additional solution states from the variable&#x27;s system depending on the
   * value of \p tag_name. E.g. if the tag name corresponds to old or older variable solution
   * values, then we must request more states
   */
  template &lt;typename T&gt;
  void
  requestStates(const std::string &amp; var_name, const TagName &amp; tag_name, const unsigned int comp);

  enum class FuncAge
  {
    Curr,
    Old,
    Older,
  };

  enum class VarType
  {
    Ignore,
    Gradient,
    Second,
    GradientDot,
    Dot,
  };

  void checkFuncType(const std::string var_name, VarType t, FuncAge age) const;

protected:
  /**
   * Deprecated method. Use \p getFieldVar instead
   * Extract pointer to a base coupled field variable. Could be either a finite volume or finite
   * element variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  const MooseVariableFieldBase * getFEVar(const std::string &amp; var_name, unsigned int comp) const;

  /*
   * Extract pointer to a base coupled field variable. Could be either a finite volume or finite
   * element variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  const MooseVariableFieldBase * getFieldVar(const std::string &amp; var_name, unsigned int comp) const;

  /*
   * Extract pointer to a base coupled field variable. Could be either a finite volume or finite
   * element variable
   * @param var_name Name of variable desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  MooseVariableFieldBase * getFieldVar(const std::string &amp; var_name, unsigned int comp);

  /**
   * Helper that that be used to retrieve a variable of arbitrary type \p T
   */
  template &lt;typename T&gt;
  const T * getVarHelper(const std::string &amp; var_name, unsigned int comp) const;

  /**
   * Helper that can be used to retrieve a variable of arbitrary type \p T
   */
  template &lt;typename T&gt;
  T * getVarHelper(const std::string &amp; var_name, unsigned int comp);

  /**
   * Extract pointer to a coupled variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  MooseVariable * getVar(const std::string &amp; var_name, unsigned int comp);

  /**
   * Extract pointer to a coupled vector variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  VectorMooseVariable * getVectorVar(const std::string &amp; var_name, unsigned int comp);

  /**
   * Extract pointer to a coupled array variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  ArrayMooseVariable * getArrayVar(const std::string &amp; var_name, unsigned int comp);

  /**
   * Extract pointer to a coupled variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  const MooseVariable * getVar(const std::string &amp; var_name, unsigned int comp) const;

  /**
   * Extract pointer to a coupled vector variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  const VectorMooseVariable * getVectorVar(const std::string &amp; var_name, unsigned int comp) const;

  /**
   * Extract pointer to a coupled array variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  const ArrayMooseVariable * getArrayVar(const std::string &amp; var_name, unsigned int comp) const;

  /**
   * Checks to make sure that the current Executioner has set &quot;_is_transient&quot; when old/older values
   * are coupled in.
   * @param name the name of the variable
   * @param fn_name The name of the function that called this method - used in the error message
   */
  void validateExecutionerType(const std::string &amp; name, const std::string &amp; fn_name) const;

  template &lt;typename T, typename Func&gt;
  std::vector&lt;T&gt; coupledVectorHelper(const std::string &amp; var_name, const Func &amp; func) const
  {
    const auto components = coupledComponents(var_name);
    std::vector&lt;T&gt; vals(components);
    for (MooseIndex(components) comp = 0; comp &lt; components; ++comp)
      vals[comp] = func(comp);
    return vals;
  }

  /// Whether or not this object is a &quot;neighbor&quot; object: ie all of it&#x27;s coupled values should be neighbor values
  bool _coupleable_neighbor;

public:
  /**
   * Helper method to return (and insert if necessary) the default value for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the variable for which to retrieve a default value
   * @return VariableValue * a pointer to the associated VariableValue.
   */
  const ADVariableValue * getADDefaultValue(const std::string &amp; var_name) const;

  /**
   * Helper method to return (and insert if necessary) the default vector value for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the vector variable for which to retrieve a default value
   * @return VectorVariableValue * a pointer to the associated VectorVariableValue.
   */
  const ADVectorVariableValue * getADDefaultVectorValue(const std::string &amp; var_name) const;

  /**
   * Helper method to return (and insert if necessary) the default gradient for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the variable for which to retrieve a default gradient
   * @return Reference to a ADVariableGradient containing zero entries for the default values
   */
  const ADVariableGradient &amp; getADDefaultGradient() const;

  /**
   * Helper method to return (and insert if necessary) the default gradient for Automatic
   * Differentiation for an uncoupled vector variable.
   * @param var_name the name of the vector variable for which to retrieve a default gradient
   * @return Reference to a ADVectorVariableGradient containing zero entries for the default values
   */
  const ADVectorVariableGradient &amp; getADDefaultVectorGradient() const;

  /**
   * Helper method to return (and insert if necessary) the default second derivatives for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the variable for which to retrieve a default second derivative
   * @return Reference to a ADVariableSecond containing zero entries for the default values
   */
  const ADVariableSecond &amp; getADDefaultSecond() const;

  /**
   * Helper method to return (and insert if necessary) the default curl value for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the vector variable for which to retrieve a default value
   * @return Reference to a ADVectorVariableCurl containing zero entries for the default values
   */
  const ADVectorVariableCurl &amp; getADDefaultCurl() const;

private:
  /**
   * Helper method to return (and insert if necessary) the default value
   * for an uncoupled variable.
   * @param var_name the name of the variable for which to retrieve a default value
   * @return a pointer to the associated VariableValue.
   */
  const VariableValue * getDefaultValue(const std::string &amp; var_name, unsigned int comp) const;

  /**
   * Helper method to return (and insert if necessary) the default value
   * for an uncoupled vector variable.
   * @param var_name the name of the vector variable for which to retrieve a default value
   * @return a pointer to the associated VectorVariableValue.
   */
  const VectorVariableValue * getDefaultVectorValue(const std::string &amp; var_name) const;

  /**
   * Helper method to return (and insert if necessary) the default value
   * for an uncoupled array variable.
   * @param var_name the name of the vector variable for which to retrieve a default value
   * @return a pointer to the associated VectorVariableValue.
   */
  const ArrayVariableValue * getDefaultArrayValue(const std::string &amp; var_name) const;

  /**
   * Get nodal default value
   */
  template &lt;typename T&gt;
  const T &amp; getDefaultNodalValue(const std::string &amp; var_name, unsigned int comp = 0) const;

  template &lt;typename T&gt;
  const Moose::Functor&lt;T&gt; &amp; getDefaultFunctor(const std::string &amp; var_name) const;

  /// Maximum qps for any element in this system
  unsigned int _coupleable_max_qps;

  /// Unique indices for optionally coupled vars that weren&#x27;t provided
  std::unordered_map&lt;std::string, std::vector&lt;unsigned int&gt;&gt; _optional_var_index;

  /// Scalar variables coupled into this object (for error checking)
  std::unordered_map&lt;std::string, std::vector&lt;MooseVariableScalar *&gt;&gt; _c_coupled_scalar_vars;

  std::set&lt;TagID&gt; _fe_coupleable_vector_tags;

  std::set&lt;TagID&gt; _fe_coupleable_matrix_tags;

  /// Whether the MooseObject is a finite volume object
  const bool _is_fv;

  const MooseObject * const _obj;

  /// vector tag names for which we need to request older solution states from the system
  const std::set&lt;std::string&gt; _older_state_tags = {Moose::OLD_SOLUTION_TAG,
                                                   Moose::OLDER_SOLUTION_TAG};

  /// keep a set of allocated writable variable references to make sure only one object can obtain them per thread
  std::vector&lt;std::set&lt;MooseWritableVariable *&gt;&gt; _writable_coupled_variables;

  /**
   * kokkos-related variables and methods
   */
private:
  const Real _kokkos_default_value_zero = 0;

#ifdef MOOSE_KOKKOS_SCOPE
  Moose::Kokkos::Variable kokkosCoupledVectorTagVariable(const std::string &amp; var_name,
                                                         const std::string &amp; tag_name,
                                                         unsigned int comp) const;
  Moose::Kokkos::Variable kokkosCoupledVectorTagVariables(const std::string &amp; var_name,
                                                          const std::string &amp; tag_name) const;
  Moose::Kokkos::Variable kokkosZeroVariable() const;

public:
  Moose::Kokkos::VariableValue kokkosCoupledVectorTagValueByName(const std::string &amp; var_name,
                                                                 const std::string &amp; tag_name,
                                                                 unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue
  kokkosCoupledVectorTagValuesByName(const std::string &amp; var_name,
                                     const std::string &amp; tag_name) const;
  Moose::Kokkos::VariableGradient kokkosCoupledVectorTagGradientByName(const std::string &amp; var_name,
                                                                       const std::string &amp; tag_name,
                                                                       unsigned int comp = 0) const;
  Moose::Kokkos::VariableGradient
  kokkosCoupledVectorTagGradientsByName(const std::string &amp; var_name,
                                        const std::string &amp; tag_name) const;
  Moose::Kokkos::VariableValue kokkosCoupledVectorTagNodalValueByName(const std::string &amp; var_name,
                                                                      const std::string &amp; tag_name,
                                                                      unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue
  kokkosCoupledVectorTagNodalValuesByName(const std::string &amp; var_name,
                                          const std::string &amp; tag_name) const;
  Moose::Kokkos::VariableValue kokkosCoupledVectorTagDofValueByName(const std::string &amp; var_name,
                                                                    const std::string &amp; tag_name,
                                                                    unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue
  kokkosCoupledVectorTagDofValuesByName(const std::string &amp; var_name,
                                        const std::string &amp; tag_name) const;

  Moose::Kokkos::VariableValue kokkosCoupledVectorTagValue(const std::string &amp; var_name,
                                                           const std::string &amp; tag_param_name,
                                                           unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue
  kokkosCoupledVectorTagValues(const std::string &amp; var_name,
                               const std::string &amp; tag_param_name) const;
  Moose::Kokkos::VariableGradient kokkosCoupledVectorTagGradient(const std::string &amp; var_name,
                                                                 const std::string &amp; tag_param_name,
                                                                 unsigned int comp = 0) const;
  Moose::Kokkos::VariableGradient
  kokkosCoupledVectorTagGradients(const std::string &amp; var_name,
                                  const std::string &amp; tag_param_name) const;
  Moose::Kokkos::VariableValue kokkosCoupledVectorTagNodalValue(const std::string &amp; var_name,
                                                                const std::string &amp; tag_param_name,
                                                                unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue
  kokkosCoupledVectorTagNodalValues(const std::string &amp; var_name,
                                    const std::string &amp; tag_param_name) const;
  Moose::Kokkos::VariableValue kokkosCoupledVectorTagDofValue(const std::string &amp; var_name,
                                                              const std::string &amp; tag_param_name,
                                                              unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue
  kokkosCoupledVectorTagDofValues(const std::string &amp; var_name,
                                  const std::string &amp; tag_param_name) const;

  Moose::Kokkos::VariableValue kokkosCoupledValue(const std::string &amp; var_name,
                                                  unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue kokkosCoupledValues(const std::string &amp; var_name) const;
  Moose::Kokkos::VariableGradient kokkosCoupledGradient(const std::string &amp; var_name,
                                                        unsigned int comp = 0) const;
  Moose::Kokkos::VariableGradient kokkosCoupledGradients(const std::string &amp; var_name) const;
  Moose::Kokkos::VariableValue kokkosCoupledNodalValue(const std::string &amp; var_name,
                                                       unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue kokkosCoupledNodalValues(const std::string &amp; var_name) const;
  Moose::Kokkos::VariableValue kokkosCoupledDofValue(const std::string &amp; var_name,
                                                     unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue kokkosCoupledDofValues(const std::string &amp; var_name) const;

  Moose::Kokkos::VariableValue kokkosCoupledValueOld(const std::string &amp; var_name,
                                                     unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue kokkosCoupledValuesOld(const std::string &amp; var_name) const;
  Moose::Kokkos::VariableGradient kokkosCoupledGradientOld(const std::string &amp; var_name,
                                                           unsigned int comp = 0) const;
  Moose::Kokkos::VariableGradient kokkosCoupledGradientsOld(const std::string &amp; var_name) const;
  Moose::Kokkos::VariableValue kokkosCoupledNodalValueOld(const std::string &amp; var_name,
                                                          unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue kokkosCoupledNodalValuesOld(const std::string &amp; var_name) const;
  Moose::Kokkos::VariableValue kokkosCoupledDofValueOld(const std::string &amp; var_name,
                                                        unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue kokkosCoupledDofValuesOld(const std::string &amp; var_name) const;

  Moose::Kokkos::VariableValue kokkosCoupledValueOlder(const std::string &amp; var_name,
                                                       unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue kokkosCoupledValuesOlder(const std::string &amp; var_name) const;
  Moose::Kokkos::VariableGradient kokkosCoupledGradientOlder(const std::string &amp; var_name,
                                                             unsigned int comp = 0) const;
  Moose::Kokkos::VariableGradient kokkosCoupledGradientsOlder(const std::string &amp; var_name) const;
  Moose::Kokkos::VariableValue kokkosCoupledNodalValueOlder(const std::string &amp; var_name,
                                                            unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue kokkosCoupledNodalValuesOlder(const std::string &amp; var_name) const;
  Moose::Kokkos::VariableValue kokkosCoupledDofValueOlder(const std::string &amp; var_name,
                                                          unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue kokkosCoupledDofValuesOlder(const std::string &amp; var_name) const;

  Moose::Kokkos::VariableValue kokkosCoupledDot(const std::string &amp; var_name,
                                                unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue kokkosCoupledDots(const std::string &amp; var_name) const;
  Moose::Kokkos::VariableValue kokkosCoupledNodalDot(const std::string &amp; var_name,
                                                     unsigned int comp = 0) const;
  Moose::Kokkos::VariableValue kokkosCoupledNodalDots(const std::string &amp; var_name) const;

  Moose::Kokkos::Scalar&lt;const Real&gt; kokkosCoupledDotDu(const std::string &amp; var_name,
                                                       unsigned int comp = 0) const;

  Moose::Kokkos::VariableValue kokkosZeroValue() const;
  Moose::Kokkos::VariableGradient kokkosZeroGradient() const;
  Moose::Kokkos::VariableValue kokkosZeroNodalValue() const;
#endif
};

template &lt;typename T&gt;
T *
Coupleable::getVarHelper(const std::string &amp; var_name_in, unsigned int comp)
{
  const auto var_name = _c_parameters.checkForRename(var_name_in);
  auto name_to_use = var_name;

  // First check for supplied name
  if (!checkVar(var_name, comp, 0))
  {
    // See if there is an associated deprecated name that the user may have used instead
    auto it = _new_to_deprecated_coupled_vars.find(var_name);
    if (it == _new_to_deprecated_coupled_vars.end())
      return nullptr;
    else
    {
      auto deprecated_name = it-&gt;second;
      if (checkVar(deprecated_name, comp, 0))
        name_to_use = deprecated_name;
      else
        return nullptr;
    }
  }

  auto coupled_vars_it = _coupled_vars.find(name_to_use);

  mooseAssert(coupled_vars_it != _coupled_vars.end(),
              &quot;Trying to get a coupled var &quot; &lt;&lt; name_to_use &lt;&lt; &quot; that doesn&#x27;t exist&quot;);

  if (auto coupled_var = dynamic_cast&lt;T *&gt;(coupled_vars_it-&gt;second[comp]))
    return coupled_var;
  else
  {
    for (auto &amp; var : _coupled_standard_moose_vars)
      if (var-&gt;name() == name_to_use)
        mooseError(&quot;The named variable is a standard variable, try a &quot;
                   &quot;&#x27;coupled[Value/Gradient/Dot/etc]...&#x27; function instead&quot;);
    for (auto &amp; var : _coupled_vector_moose_vars)
      if (var-&gt;name() == name_to_use)
        mooseError(&quot;The named variable is a vector variable, try a &quot;
                   &quot;&#x27;coupledVector[Value/Gradient/Dot/etc]...&#x27; function instead&quot;);
    for (auto &amp; var : _coupled_array_moose_vars)
      if (var-&gt;name() == name_to_use)
        mooseError(&quot;The named variable is an array variable, try a &quot;
                   &quot;&#x27;coupledArray[Value/Gradient/Dot/etc]...&#x27; function instead&quot;);
    for (auto &amp; var : _coupled_fv_moose_vars)
      if (var-&gt;name() == name_to_use)
        mooseError(&quot;The named variable is a finite volume variable, which the coupled[...] routine &quot;
                   &quot;used does not support. Try using the functor system routines instead.&quot;);
    mooseError(
        &quot;Variable &#x27;&quot;, name_to_use, &quot;&#x27; is of a different C++ type than you tried to fetch it as.&quot;);
  }
}

template &lt;typename T&gt;
const T *
Coupleable::getVarHelper(const std::string &amp; var_name, unsigned int comp) const
{
  return const_cast&lt;Coupleable *&gt;(this)-&gt;getVarHelper&lt;T&gt;(var_name, comp);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
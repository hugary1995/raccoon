<!DOCTYPE html><head><meta charset="UTF-8"><title>SetupInterface | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="43ab5dc6-225f-4811-a698-0f7a6652c364" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b84a2e58-b7d2-4392-85a5-2d9c0d3b18fd" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="913337e9-d449-49b1-b20a-2bd3b43b0d6c" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8e09f347-7d60-4236-ae7b-a82b0297cc8e" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="910e4b50-7d41-4dc4-85d3-752100ce4a2b"><i class="material-icons">menu</i></a><ul class="sidenav" id="910e4b50-7d41-4dc4-85d3-752100ce4a2b"><li><a href="#!" class="dropdown-trigger" data-target="92404a36-283a-46a5-991c-2a0eac20fa91" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="cb941fb1-c152-40bd-a533-c99afb167bc1" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="138746bf-e655-4b3b-9d36-e71e85059998" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d0a752ce-c133-4b6f-bfb8-77dca36a3c05" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="43ab5dc6-225f-4811-a698-0f7a6652c364"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="b84a2e58-b7d2-4392-85a5-2d9c0d3b18fd"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="913337e9-d449-49b1-b20a-2bd3b43b0d6c"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="8e09f347-7d60-4236-ae7b-a82b0297cc8e"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="92404a36-283a-46a5-991c-2a0eac20fa91"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="cb941fb1-c152-40bd-a533-c99afb167bc1"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="138746bf-e655-4b3b-9d36-e71e85059998"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="d0a752ce-c133-4b6f-bfb8-77dca36a3c05"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="11ba5264-4193-402e-bdae-c55300dd0026" data-section-level="1" data-section-text="SetupInterface"><h1 id="setupinterface">SetupInterface</h1><p>Most user-facing objects in MOOSE inherit from the <code>SetupInterface</code> class. This class provides two features to objects:</p><ul class="browser-default"><li><p>The <code>execute_on</code> parameter, which, as the name suggests, dictates when the object is to be executed. </p></li><li><p>Virtual setup methods that allow derived classes to perform setup applications prior to execution.</p></li></ul><section id="4f3af5f6-4c3c-443a-bd50-19403c3ebfe0" data-section-level="2" data-section-text="Execute On"><h2 id="execute-on">Execute On</h2><p>Any object inheriting from the SetupInterface, that adds the <code>SetupInterface::validParams()</code> within its own parameters, will have an <code>execute_on</code> parameter that can be set to various flags. The default (and thus most common) flags are listed below:</p><div recursive form="['left', 'left']" class="moose-table-div"><table><thead><tr><th style=";text-align:left">Execute Flag</th><th style=";text-align:left">Description</th></tr></thead><tbody><tr><td style=";text-align:left"><code>NONE</code></td><td style=";text-align:left">Never executed.</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>INITIAL</code></td><td style=";text-align:left">Prior to the first time step.</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>LINEAR</code></td><td style=";text-align:left">Prior to each residual evaluation.</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>NONLINEAR</code></td><td style=";text-align:left">Prior to each Jacobian evaluation.</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>NONLINEAR_CONVERGENCE</code></td><td style=";text-align:left">Prior to each nonlinear convergence check. Note that <code>NONLINEAR</code> is not appropriate for this purpose since that only executes if it has already been determined that another nonlinear step is to be taken.</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>TIMESTEP_END</code></td><td style=";text-align:left">After the solve for each time step.</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>TIMESTEP_BEGIN</code></td><td style=";text-align:left">Prior to the solve for each time step.</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>MULTIAPP_FIXED_POINT_BEGIN</code></td><td style=";text-align:left">At the beginning of each fixed point solve loop, after transfers to the multiapps have been executed on <code>TIMESTEP_BEGIN</code> but before the multiapps (followed by the parent problem) have been executed on <code>TIMESTEP_BEGIN</code>.</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>MULTIAPP_FIXED_POINT_END</code></td><td style=";text-align:left">At the end of each fixed point solve loop (only if the fixed point solve converged).</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>MULTIAPP_FIXED_POINT_CONVERGENCE</code></td><td style=";text-align:left">In each iteration of the MultiApp fixed point loop, immediately prior to the MultiApp fixed point convergence check, after <code>TIMESTEP_END</code> and MultiApps/transfers executing on <code>TIMESTEP_END</code>.</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>POST_ADAPTIVITY</code></td><td style=";text-align:left">Once all adaptivity steps have been performed on a timestep (after <code>TIMESTEP_END</code> and before progressing to the next step). Note that <code>POST_ADAPTIVITY</code> is not executed on initial adaptivity, the final timestep, or during multi-app Picard iterations. <code>POST_ADAPTIVITY</code> will be executed even if the mesh is not changed by adaptivity, as long as adaptivity is executed.</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>FINAL</code></td><td style=";text-align:left">At the end of the entire simulation.</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>CUSTOM</code></td><td style=";text-align:left">At user specified instants.</td></tr></tbody><tbody><tr><td style=";text-align:left"><code>ALWAYS</code></td><td style=";text-align:left">Union of all the above flags.</td></tr></tbody></table></div><p>Note that other flags exist, since it is possible for applications to add additional flags to those added by the core MOOSE framework (see <a href="SetupInterface.html#creating-custom-execute-flags">Creating Custom Execute Flags</a> below). Documentation on these custom flags should appear within the associated application documentation; please contact the application&#x27;s developers if not found.</p><p>The <code>execute_on</code> parameter can be set to a single flag or multiple flags. For example, it may be desirable to only execute an object initially because the state of the auxiliary computation does not vary. In the input file snippet below, the <a href="../auxkernels/ElementLengthAux.html">ElementLengthAux</a> computation only needs to be computed initially, and thus the <code>execute_on</code> parameter is set as such.</p><pre style="max-height:350px;"><code class="language-moose">[AuxKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxKernels/index.html&quot;}&gt;&gt;&gt;]
  [./min]
    type = ElementLengthAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the element size using Elem::hmin() or Elem::hmax() from libMesh.&quot;, &quot;href&quot;: &quot;../auxkernels/ElementLengthAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = min
    method&lt;&lt;&lt;{&quot;description&quot;: &quot;The size calculation to perform (&#x27;min&#x27; or &#x27;max&#x27;).&quot;}&gt;&gt;&gt; = min
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = initial
  [../]
  [./max]
    type = ElementLengthAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the element size using Elem::hmin() or Elem::hmax() from libMesh.&quot;, &quot;href&quot;: &quot;../auxkernels/ElementLengthAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = max
    method&lt;&lt;&lt;{&quot;description&quot;: &quot;The size calculation to perform (&#x27;min&#x27; or &#x27;max&#x27;).&quot;}&gt;&gt;&gt; = max
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = initial
  [../]
[../]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#afb0f18e-c93e-4522-bd5a-ac67be975ad7">(moose/test/tests/auxkernels/element_length/element_length.i)</a><p>Alternatively, it is often desirable to run a computation with multiple execute flags. For example, in the input file snippet below a <a href="../controls/TimePeriod.html">TimePeriod</a> control object that is responsible for enabling a <a href="../../syntax/Dampers/index.html">Damper</a> object needs to be run initially and prior to each timestep to guarantee that the damper is enabled when desired.</p><pre style="max-height:350px;"><code class="language-moose">[Controls&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Controls/index.html&quot;}&gt;&gt;&gt;]
  [./damping_control]
    type = TimePeriod&lt;&lt;&lt;{&quot;description&quot;: &quot;Control the enabled/disabled state of objects with time.&quot;, &quot;href&quot;: &quot;../controls/TimePeriod.html&quot;}&gt;&gt;&gt;
    disable_objects&lt;&lt;&lt;{&quot;description&quot;: &quot;A list of object tags to disable.&quot;}&gt;&gt;&gt; = &#x27;*::const_damp&#x27;
    start_time&lt;&lt;&lt;{&quot;description&quot;: &quot;The time at which the objects are to be enabled/disabled.&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_begin&#x27;
  [../]
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#c42ef43a-5725-43e2-af70-4130bb009aed">(moose/test/tests/controls/time_periods/dampers/control.i)</a><p>Depending on the system these options or others will be available, since, as discussed in <a href="SetupInterface.html#creating-custom-execute-flags">Creating Custom Execute Flags</a>, custom flags may be added. The list of execution flags registered by MOOSE are listed in the <code>registerExecFlags</code> function:</p><pre style="max-height:350px;"><code class="language-cpp">
#ifdef HAVE_GPERFTOOLS
#include &quot;gperftools/profiler.h&quot;
#include &quot;gperftools/heap-profiler.h&quot;
#endif

// MOOSE includes
#include &quot;MooseRevision.h&quot;
#include &quot;AppFactory.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;NonlinearSystemBase.h&quot;
#include &quot;AuxiliarySystem.h&quot;
#include &quot;MooseSyntax.h&quot;
#include &quot;MooseInit.h&quot;
#include &quot;Executioner.h&quot;
#include &quot;Executor.h&quot;
#include &quot;PetscSupport.h&quot;
#include &quot;Conversion.h&quot;
#include &quot;CommandLine.h&quot;
#include &quot;InfixIterator.h&quot;
#include &quot;MultiApp.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseObjectAction.h&quot;
#include &quot;InputParameterWarehouse.h&quot;
#include &quot;SystemInfo.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;FileOutput.h&quot;
#include &quot;ConsoleUtils.h&quot;
#include &quot;JsonSyntaxTree.h&quot;
#include &quot;JsonInputFileFormatter.h&quot;
#include &quot;SONDefinitionFormatter.h&quot;
#include &quot;RelationshipManager.h&quot;
#include &quot;ProxyRelationshipManager.h&quot;
#include &quot;Registry.h&quot;
#include &quot;SerializerGuard.h&quot;
#include &quot;PerfGraphInterface.h&quot; // For TIME_SECTION
#include &quot;SolutionInvalidInterface.h&quot;
#include &quot;Attributes.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;CommonOutputAction.h&quot;
#include &quot;CastUniquePointer.h&quot;
#include &quot;NullExecutor.h&quot;
#include &quot;ExecFlagRegistry.h&quot;
#include &quot;SolutionInvalidity.h&quot;
#include &quot;MooseServer.h&quot;
#include &quot;RestartableDataWriter.h&quot;
#include &quot;StringInputStream.h&quot;
#include &quot;MooseMain.h&quot;
#include &quot;FEProblemBase.h&quot;
#include &quot;Parser.h&quot;
#include &quot;CSGBase.h&quot;

// Regular expression includes
#include &quot;pcrecpp.h&quot;

#include &quot;libmesh/exodusII_io.h&quot;
#include &quot;libmesh/mesh_refinement.h&quot;
#include &quot;libmesh/string_to_enum.h&quot;
#include &quot;libmesh/checkpoint_io.h&quot;
#include &quot;libmesh/mesh_base.h&quot;
#include &quot;libmesh/petsc_solver_exception.h&quot;

// System include for dynamic library methods
#ifdef LIBMESH_HAVE_DLOPEN
#include &lt;dlfcn.h&gt;
#include &lt;sys/utsname.h&gt; // utsname
#endif

#ifdef MOOSE_LIBTORCH_ENABLED
#include &lt;torch/version.h&gt;
#endif

// C++ includes
#include &lt;numeric&gt; // std::accumulate
#include &lt;fstream&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstdlib&gt; // for system()
#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;filesystem&gt;

using namespace libMesh;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#4e19dd33-8bdc-4dc6-8423-0de3a776a68e">(moose/framework/src/base/MooseApp.C)</a><p>Each type of MOOSE object can choose its own default value for <code>execute_on</code>, which can be found in their <code>validParams()</code> method. Some examples are as follows:</p><div recursive form="['left', 'left']" class="moose-table-div"><table><thead><tr><th style=";text-align:left">Object Base Class</th><th style=";text-align:left">Default <code>execute_on</code> Values</th></tr></thead><tbody><tr><td style=";text-align:left"><code>AuxKernel</code></td><td style=";text-align:left"><code>LINEAR</code>, <code>TIMESTEP_END</code></td></tr></tbody><tbody><tr><td style=";text-align:left"><code>Postprocessor</code></td><td style=";text-align:left"><code>TIMESTEP_END</code></td></tr></tbody><tbody><tr><td style=";text-align:left"><code>UserObject</code></td><td style=";text-align:left"><code>TIMESTEP_END</code></td></tr></tbody><tbody><tr><td style=";text-align:left"><code>Output</code></td><td style=";text-align:left"><code>INITIAL</code>, <code>TIMESTEP_END</code></td></tr></tbody><tbody><tr><td style=";text-align:left"><code>Control</code></td><td style=";text-align:left"><code>INITIAL</code>, <code>TIMESTEP_BEGIN</code></td></tr></tbody><tbody><tr><td style=";text-align:left"><code>MultiApp</code></td><td style=";text-align:left"><code>TIMESTEP_BEGIN</code></td></tr></tbody><tbody><tr><td style=";text-align:left"><code>Transfer</code></td><td style=";text-align:left">(same as corresponding <code>MultiApp</code>)</td></tr></tbody></table></div></section><section id="6774aadd-82bb-401b-ad43-d6ae94fc1e22" data-section-level="2" data-section-text="Modifying Execute On"><h2 id="modifying-execute-on">Modifying Execute On</h2><p>When creating objects that inherit from <code>SetupInterface</code> it is possible to set, add, or remove available execute flags by retrieving and then modifying the <code>ExecFlagEnum</code> parameter. For example, consider the snippet below (see <a class="moose-source-filename tooltipped modal-trigger" href="#2fe3a905-e57f-4bab-9b8e-3390acfb1f5a">Output.C</a>).</p><pre style="max-height:350px;"><code class="language-cpp">  ExecFlagEnum &amp; exec_enum = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true);
  exec_enum = Output::getDefaultExecFlagEnum();
  exec_enum = {EXEC_INITIAL, EXEC_TIMESTEP_END};
  params.setDocString(&quot;execute_on&quot;, exec_enum.getDocString());
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#88f8da31-a8e2-4a06-8ceb-d67705d8c354">(moose/framework/src/outputs/Output.C)</a><p>First, the <code>execute_on</code> parameter is retrieved for modification by using the &quot;set&quot; method. Notice, that a second boolean argument is passed to &quot;set&quot;: this second flag enables &quot;quiet mode&quot;. Quiet mode allows this default modification to not count as a user modification for the purposes of <code>InputParameters::isParamSetByUser</code>.</p><p>Second, the two new execution flags are added (<code>EXEC_FINAL</code> and <code>EXEC_FAILED</code>); therefore these additional options are available to all classes (all <code>Output</code> objects in this case) that inherit from this object.</p><p>Third, the default active flags are set to <code>EXEC_INITIAL</code> and <code>EXEC_TIMESTEP_END</code>, which are the defaults for all <code>Output</code> objects.</p><p>Finally, the documentation string for the <code>execute_on</code> parameter for the <code>Output</code> objects is updated to reflect the changes made to the parameter. The <code>ExecFlagEnum</code> has a convenience function that generates a documentation string that includes the URL to this page.</p></section><section id="a8c4bd44-ac02-43f3-837c-287889bf0449" data-section-level="2" data-section-text="Virtual Setup Methods"><h2 id="virtual-setup-methods">Virtual Setup Methods</h2><p>The SetupInterface includes virtual methods that correspond to the primary execute flags with MOOSE, these methods are listed in the header as shown here.</p><pre style="max-height:350px;"><code class="language-cpp">/**
* Gets called at the beginning of the simulation before this object is asked to do its job
*/
virtual void initialSetup();
/**
* Gets called at the beginning of the timestep before this object is asked to do its job
*/
virtual void timestepSetup();
/**
* Gets called just before the Jacobian is computed and before this object is asked to do its job
*/
virtual void jacobianSetup();
/**
* Gets called just before the residual is computed and before this object is asked to do its job
*/
virtual void residualSetup();
/**
* Gets called when the subdomain changes (i.e. in a Jacobian or residual loop) and before this
* object is asked to do its job
*/
virtual void subdomainSetup();
/**
* Gets called in FEProblemBase::execute() for execute flags other than initial, timestep_begin,
* nonlinear, linear and subdomain
*/
virtual void customSetup(const ExecFlagType &amp; /*exec_type*/) {}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#3d524bb1-7622-451a-9fec-d0ed386e425d">(moose/framework/include/interfaces/SetupInterface.h)</a><p>In general, these methods should be utilized to perform &quot;setup&quot; procedures prior to the calls to execute for the corresponding execute flag.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>A few of the methods were created prior to the execute flags, thus the names do not correspond but they remain as is to keep the API consistent: the &quot;jacobianSetup&quot; methods is called prior to the &quot;NONLINEAR&quot; execute flag and the &quot;residualSetup&quot; is called prior to the &quot;LINEAR&quot; execute flag.</p></div></div></div><p>There is also a generic setup function &quot;customSetup&quot; that takes an execute flag as the argument. This function is called by MOOSE when performing evaluations of objects on the custom execute flags in <a href="SetupInterface.html#creating-custom-execute-flags">Creating Custom Execute Flags</a>.</p><div class="card moose-alert moose-alert-warning"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">warning</i><span class="moose-alert-title-brand">warning:</span>Note on the &quot;customSetup&quot; function</div><div class="card-content"><div class="moose-alert-content"><p>This function is not called on <em>initial</em>, <em>timestep_begin</em>, <em>subdomain</em>, <em>nonlinear</em> and <em>linear</em>. Setup operations for those execute flags should be implemented in <em>initialSetup</em>, <em>timestepSetup</em>, <em>subdomainSetup</em>, <em>jacobianSetup</em> and <em>residualSetup</em> functions respectively.</p></div></div></div></section><section id="24490e7b-b4ad-41a3-9701-e999a22c4b82" data-section-level="2" data-section-text="Creating Custom Execute Flags"><h2 id="creating-custom-execute-flags">Creating Custom Execute Flags</h2><p>It is possible to create custom execute flags for an application. To create and utilize a custom execute flag, the following steps should be followed.</p><section id="bf4778d7-e9fb-4c34-bfd3-6ed9ee6d3933" data-section-level="3" data-section-text="1 . Register an Execute Flag"><h3 id="1-register-an-execute-flag">1. Register an Execute Flag</h3><p>Within your application a new global <code>const</code> should be declared in a header file. For example, within the <code>LevelSetApp</code> within MOOSE modules, the header <code>LevelSetTypes.h</code> declares the new flags <code>EXEC_ADAPT_MESH</code> and <code>EXEC_COMPUTE_MARKERS</code>:</p><pre style="max-height:350px;"><code class="language-cpp">
#pragma once

#include &quot;Moose.h&quot;

namespace LevelSet
{
extern const ExecFlagType EXEC_ADAPT_MESH;
extern const ExecFlagType EXEC_COMPUTE_MARKERS;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#7cc75a4b-ea72-4373-8928-78616f58226e">(moose/modules/level_set/include/base/LevelSetTypes.h)</a><p>This new global must be registered, which occurs in the corresponding source file using the <code>registerExecFlag()</code> macro defined in <code>ExecFlagRegistry.h</code>:</p><pre style="max-height:350px;"><code class="language-cpp">
// Level set includes
#include &quot;LevelSetTypes.h&quot;

// MOOSE includes
#include &quot;ExecFlagRegistry.h&quot;

const ExecFlagType LevelSet::EXEC_ADAPT_MESH = registerExecFlag(&quot;ADAPT_MESH&quot;);
const ExecFlagType LevelSet::EXEC_COMPUTE_MARKERS = registerExecFlag(&quot;COMPUTE_MARKERS&quot;);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#c239a6a9-1c86-4781-8769-5a5e368e89eb">(moose/modules/level_set/src/base/LevelSetTypes.C)</a></section><section id="adfc2a80-556f-47e7-958f-92df36ff2661" data-section-level="3" data-section-text="2 . Add the Execute Flag to InputParameters"><h3 id="2-add-the-execute-flag-to-inputparameters">2. Add the Execute Flag to InputParameters</h3><p>After a flag is registered, it must be made available to the object(s) that are desired to be executed with the custom flag. This is done by adding this new flag to an existing object&#x27;s valid parameters. For example, the following adds the <code>EXEC_ADAPT_MESH</code> and <code>EXEC_COMPUTE_MARKERS</code> flags to a <code>Transfer</code> object and then sets the default to be <code>{LevelSet::EXEC_COMPUTE_MARKERS, LevelSet::EXEC_ADAPT_MESH}</code>:</p><pre style="max-height:350px;"><code class="language-cpp">ExecFlagEnum &amp; exec = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);
exec.addAvailableFlags(LevelSet::EXEC_ADAPT_MESH, LevelSet::EXEC_COMPUTE_MARKERS);
exec = {LevelSet::EXEC_COMPUTE_MARKERS, LevelSet::EXEC_ADAPT_MESH};
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#5fcbb03f-136c-4b57-806f-87f80c1938dc">(moose/modules/level_set/src/transfers/LevelSetMeshRefinementTransfer.C)</a></section><section id="cf025fd7-dc78-497f-847e-74b749b975df" data-section-level="3" data-section-text="3 . Use the Execute Flag"><h3 id="3-use-the-execute-flag">3. Use the Execute Flag</h3><p>Depending on what type of custom computation is desired, various MOOSE execution calls accept execution flags, which will spawn calculations. For example, the <code>LevelSetProblem</code> contains a custom method that uses the <code>EXEC_ADAPT_MESH</code> and <code>EXEC_COMPUTE_MARKERS</code> flags to perform an additional <a href="../../syntax/Transfers/index.html"><code>MultiAppTransfer</code></a> execution:</p><pre style="max-height:350px;"><code class="language-cpp">execMultiAppTransfers(LevelSet::EXEC_ADAPT_MESH, MultiAppTransfer::TO_MULTIAPP);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#cb27975b-70b4-45f5-86c9-0893d5174d4c">(moose/modules/level_set/src/base/LevelSetProblem.C)</a></section></section></section><div class="moose-modal modal" id="afb0f18e-c93e-4522-bd5a-ac67be975ad7"><div class="modal-content"><h4>(moose/test/tests/auxkernels/element_length/element_length.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 100
[]

[AuxVariables]
  [./min]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./max]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./min]
    type = ElementLengthAux
    variable = min
    method = min
    execute_on = initial
  [../]
  [./max]
    type = ElementLengthAux
    variable = max
    method = max
    execute_on = initial
  [../]
[../]

[Problem]
  type = FEProblem
  solve = false
[]

[Executioner]
  type = Steady
[]

[Outputs]
  execute_on = &#x27;TIMESTEP_END&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="c42ef43a-5725-43e2-af70-4130bb009aed"><div class="modal-content"><h4>(moose/test/tests/controls/time_periods/dampers/control.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = CoefDiffusion
    variable = u
    coef = 0.1
  [../]
  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  nl_rel_tol = 0.95e-8
[]

[Postprocessors]
  [./nlin]
    type = NumNonlinearIterations
  [../]
[]

[Dampers]
  [./const_damp]
    type = ConstantDamper
    damping = 0.9
  [../]
[]

[Outputs]
  csv = true
[]

[Controls]
  [./damping_control]
    type = TimePeriod
    disable_objects = &#x27;*::const_damp&#x27;
    start_time = 0.25
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="4e19dd33-8bdc-4dc6-8423-0de3a776a68e"><div class="modal-content"><h4>(moose/framework/src/base/MooseApp.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#ifdef HAVE_GPERFTOOLS
#include &quot;gperftools/profiler.h&quot;
#include &quot;gperftools/heap-profiler.h&quot;
#endif

// MOOSE includes
#include &quot;MooseRevision.h&quot;
#include &quot;AppFactory.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;NonlinearSystemBase.h&quot;
#include &quot;AuxiliarySystem.h&quot;
#include &quot;MooseSyntax.h&quot;
#include &quot;MooseInit.h&quot;
#include &quot;Executioner.h&quot;
#include &quot;Executor.h&quot;
#include &quot;PetscSupport.h&quot;
#include &quot;Conversion.h&quot;
#include &quot;CommandLine.h&quot;
#include &quot;InfixIterator.h&quot;
#include &quot;MultiApp.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseObjectAction.h&quot;
#include &quot;InputParameterWarehouse.h&quot;
#include &quot;SystemInfo.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;FileOutput.h&quot;
#include &quot;ConsoleUtils.h&quot;
#include &quot;JsonSyntaxTree.h&quot;
#include &quot;JsonInputFileFormatter.h&quot;
#include &quot;SONDefinitionFormatter.h&quot;
#include &quot;RelationshipManager.h&quot;
#include &quot;ProxyRelationshipManager.h&quot;
#include &quot;Registry.h&quot;
#include &quot;SerializerGuard.h&quot;
#include &quot;PerfGraphInterface.h&quot; // For TIME_SECTION
#include &quot;SolutionInvalidInterface.h&quot;
#include &quot;Attributes.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;CommonOutputAction.h&quot;
#include &quot;CastUniquePointer.h&quot;
#include &quot;NullExecutor.h&quot;
#include &quot;ExecFlagRegistry.h&quot;
#include &quot;SolutionInvalidity.h&quot;
#include &quot;MooseServer.h&quot;
#include &quot;RestartableDataWriter.h&quot;
#include &quot;StringInputStream.h&quot;
#include &quot;MooseMain.h&quot;
#include &quot;FEProblemBase.h&quot;
#include &quot;Parser.h&quot;
#include &quot;CSGBase.h&quot;

// Regular expression includes
#include &quot;pcrecpp.h&quot;

#include &quot;libmesh/exodusII_io.h&quot;
#include &quot;libmesh/mesh_refinement.h&quot;
#include &quot;libmesh/string_to_enum.h&quot;
#include &quot;libmesh/checkpoint_io.h&quot;
#include &quot;libmesh/mesh_base.h&quot;
#include &quot;libmesh/petsc_solver_exception.h&quot;

// System include for dynamic library methods
#ifdef LIBMESH_HAVE_DLOPEN
#include &lt;dlfcn.h&gt;
#include &lt;sys/utsname.h&gt; // utsname
#endif

#ifdef MOOSE_LIBTORCH_ENABLED
#include &lt;torch/version.h&gt;
#endif

// C++ includes
#include &lt;numeric&gt; // std::accumulate
#include &lt;fstream&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstdlib&gt; // for system()
#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;filesystem&gt;

using namespace libMesh;

void
MooseApp::addAppParam(InputParameters &amp; params)
{
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;app_to_run&quot;, &quot;--app &lt;type&gt;&quot;, &quot;Specify the application type to run (case-sensitive)&quot;);
}

void
MooseApp::addInputParam(InputParameters &amp; params)
{
  params.addCommandLineParam&lt;std::vector&lt;std::string&gt;&gt;(
      &quot;input_file&quot;, &quot;-i &lt;input file(s)&gt;&quot;, &quot;Specify input file(s); multiple files are merged&quot;);
}

InputParameters
MooseApp::validParams()
{
  InputParameters params = MooseBase::validParams();

  MooseApp::addAppParam(params);
  MooseApp::addInputParam(params);

  params.addCommandLineParam&lt;bool&gt;(&quot;display_version&quot;, &quot;-v --version&quot;, &quot;Print application version&quot;);

  params.addOptionalValuedCommandLineParam&lt;std::string&gt;(
      &quot;mesh_only&quot;,
      &quot;--mesh-only &lt;optional path&gt;&quot;,
      &quot;&quot;,
      &quot;Build and output the mesh only (Default: \&quot;&lt;input_file_name&gt;_in.e\&quot;)&quot;);
  params.addOptionalValuedCommandLineParam&lt;std::string&gt;(
      &quot;csg_only&quot;,
      &quot;--csg-only &lt;optional path&gt;&quot;,
      &quot;&quot;,
      &quot;Setup and output the input mesh in CSG format only (Default: &quot;
      &quot;\&quot;&lt;input_file_name&gt;_out_csg.json\&quot;)&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_input&quot;, &quot;--show-input&quot;, &quot;Shows the parsed input file before running the simulation&quot;);
  params.setGlobalCommandLineParam(&quot;show_input&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_outputs&quot;, &quot;--show-outputs&quot;, &quot;Shows the output execution time information&quot;);
  params.setGlobalCommandLineParam(&quot;show_outputs&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_controls&quot;, &quot;--show-controls&quot;, &quot;Shows the Control logic available and executed&quot;);
  params.setGlobalCommandLineParam(&quot;show_controls&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;no_color&quot;, &quot;--no-color&quot;, &quot;Disable coloring of all Console outputs&quot;);
  params.setGlobalCommandLineParam(&quot;no_color&quot;);

  MooseEnum colors(&quot;auto on off&quot;, &quot;on&quot;);
  params.addCommandLineParam&lt;MooseEnum&gt;(
      &quot;color&quot;, &quot;--color &lt;auto,on,off=on&gt;&quot;, colors, &quot;Whether to use color in console output&quot;);
  params.setGlobalCommandLineParam(&quot;color&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;help&quot;, &quot;-h --help&quot;, &quot;Displays CLI usage statement&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;minimal&quot;,
      &quot;--minimal&quot;,
      &quot;Ignore input file and build a minimal application with Transient executioner&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;language_server&quot;,
      &quot;--language-server&quot;,
      &quot;Starts a process to communicate with development tools using the language server protocol&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;definition&quot;, &quot;--definition&quot;, &quot;Shows a SON style input definition dump for input validation&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;dump&quot;, &quot;--dump&quot;, &quot;Shows a dump of available input file syntax&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;dump_search&quot;,
      &quot;--dump-search &lt;search&gt;&quot;,
      &quot;Shows a dump of available input syntax matching a search&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;registry&quot;, &quot;--registry&quot;, &quot;Lists all known objects and actions&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;registry_hit&quot;, &quot;--registry-hit&quot;, &quot;Lists all known objects and actions in hit format&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;use_executor&quot;, &quot;--executor&quot;, &quot;Use the new Executor system instead of Executioners&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_type&quot;, &quot;--show-type&quot;, &quot;Return the name of the application object&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;yaml&quot;, &quot;--yaml&quot;, &quot;Dumps all input file syntax in YAML format&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;yaml_search&quot;, &quot;--yaml-search&quot;, &quot;Dumps input file syntax matching a search in YAML format&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;json&quot;, &quot;--json&quot;, &quot;Dumps all input file syntax in JSON format&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;json_search&quot;, &quot;--json-search&quot;, &quot;Dumps input file syntax matching a search in JSON format&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;syntax&quot;, &quot;--syntax&quot;, &quot;Dumps the associated Action syntax paths ONLY&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_docs&quot;, &quot;--docs&quot;, &quot;Print url/path to the documentation website&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_capabilities&quot;, &quot;--show-capabilities&quot;, &quot;Dumps the capability registry in JSON format.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;required_capabilities&quot;,
      &quot;--required-capabilities&quot;,
      &quot;A list of conditions that is checked against the registered capabilities (see &quot;
      &quot;--show-capabilities). The executable will terminate early if the conditions are not met.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;check_capabilities&quot;,
      &quot;--check-capabilities&quot;,
      &quot;A list of conditions that is checked against the registered capabilities. Will exit based &quot;
      &quot;on whether or not the capaiblities are fulfilled. Does not check dynamically loaded apps.&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;check_input&quot;,
                                   &quot;--check-input&quot;,
                                   &quot;Check the input file (i.e. requires -i &lt;filename&gt;) and quit&quot;);
  params.setGlobalCommandLineParam(&quot;check_input&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_inputs&quot;,
      &quot;--show-copyable-inputs&quot;,
      &quot;Shows the directories able to be copied into a user-writable location&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;copy_inputs&quot;,
      &quot;--copy-inputs &lt;dir&gt;&quot;,
      &quot;Copies installed inputs (e.g. tests, examples, etc.) to a directory &lt;appname&gt;_&lt;dir&gt;&quot;);
  // TODO: Should this remain a bool? It can&#x27;t be a regular argument because it contains
  // values that have dashes in it, so it&#x27;ll get treated as another arg
  params.addOptionalValuedCommandLineParam&lt;std::string&gt;(
      &quot;run&quot;,
      &quot;--run &lt;test harness args&gt;&quot;,
      &quot;&quot;,
      &quot;Runs the inputs in the current directory copied to a &quot;
      &quot;user-writable location by \&quot;--copy-inputs\&quot;&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;list_constructed_objects&quot;,
      &quot;--list-constructed-objects&quot;,
      &quot;List all moose object type names constructed by the master app factory&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;n_threads&quot;, &quot;--n-threads=&lt;n&gt;&quot;, &quot;Runs the specified number of threads per process&quot;);
  // This probably shouldn&#x27;t be global, but the implications of removing this are currently
  // unknown and we need to manage it with libmesh better
  params.setGlobalCommandLineParam(&quot;n_threads&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;allow_unused&quot;,
                                   &quot;-w --allow-unused&quot;,
                                   &quot;Warn about unused input file options instead of erroring&quot;);
  params.setGlobalCommandLineParam(&quot;allow_unused&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_unused&quot;, &quot;-e --error-unused&quot;, &quot;Error when encountering unused input file options&quot;);
  params.setGlobalCommandLineParam(&quot;error_unused&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_override&quot;,
      &quot;-o --error-override&quot;,
      &quot;Error when encountering overridden or parameters supplied multiple times&quot;);
  params.setGlobalCommandLineParam(&quot;error_override&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_deprecated&quot;, &quot;--error-deprecated&quot;, &quot;Turn deprecated code messages into Errors&quot;);
  params.setGlobalCommandLineParam(&quot;error_deprecated&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;distributed_mesh&quot;,
                                   &quot;--distributed-mesh&quot;,
                                   &quot;Forces the use of a distributed finite element mesh&quot;);
  // Would prefer that this parameter isn&#x27;t global, but we rely on it too much
  // in tests to be able to go back on that decision now
  params.setGlobalCommandLineParam(&quot;distributed_mesh&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;split_mesh&quot;,
      &quot;--split-mesh &lt;splits&gt;&quot;,
      &quot;Comma-separated list of numbers of chunks to split the mesh into&quot;);

  // TODO: remove the logic now that this is global
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;split_file&quot;, &quot;--split-file &lt;filename&gt;&quot;, &quot;Name of split mesh file(s) to write/read&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;use_split&quot;, &quot;--use-split&quot;, &quot;Use split distributed mesh files&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;refinements&quot;, &quot;-r &lt;num refinements&gt;&quot;, &quot;Specify additional initial uniform mesh refinements&quot;);

  params.addOptionalValuedCommandLineParam&lt;std::string&gt;(
      &quot;recover&quot;,
      &quot;--recover &lt;optional file base&gt;&quot;,
      &quot;&quot;,
      &quot;Continue the calculation. Without &lt;file base&gt;, the most recent recovery file will be used&quot;);
  params.setGlobalCommandLineParam(&quot;recover&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;force_restart&quot;,
      &quot;--force-restart&quot;,
      &quot;Forcefully load checkpoints despite possible incompatibilities&quot;);
  params.setGlobalCommandLineParam(&quot;force_restart&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;suppress_header&quot;,
                                   &quot;--suppress-header&quot;,
                                   false,
                                   &quot;Disables the output of the application header.&quot;);
  params.setGlobalCommandLineParam(&quot;suppress_header&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;test_checkpoint_half_transient&quot;,
      &quot;--test-checkpoint-half-transient&quot;,
      &quot;Run half of a transient with checkpoints enabled; used by the TestHarness&quot;);
  params.setGlobalCommandLineParam(&quot;test_checkpoint_half_transient&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;test_restep&quot;,
                                   &quot;--test-restep&quot;,
                                   &quot;Test re-running the middle timestep; used by the TestHarness&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;trap_fpe&quot;,
      &quot;--trap-fpe&quot;,
      &quot;Enable floating point exception handling in critical sections of code&quot;
#ifdef DEBUG
      &quot; (automatic due to debug build)&quot;
#endif
  );
  params.setGlobalCommandLineParam(&quot;trap_fpe&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;no_trap_fpe&quot;,
      &quot;--no-trap-fpe&quot;,
      &quot;Disable floating point exception handling in critical sections of code&quot;
#ifndef DEBUG
      &quot; (unused due to non-debug build)&quot;
#endif
  );

  params.setGlobalCommandLineParam(&quot;no_trap_fpe&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;no_gdb_backtrace&quot;, &quot;--no-gdb-backtrace&quot;, &quot;Disables gdb backtraces.&quot;);
  params.setGlobalCommandLineParam(&quot;no_gdb_backtrace&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;error&quot;, &quot;--error&quot;, &quot;Turn all warnings into errors&quot;);
  params.setGlobalCommandLineParam(&quot;error&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;timing&quot;,
                                   &quot;-t --timing&quot;,
                                   &quot;Enable all performance logging for timing; disables screen &quot;
                                   &quot;output of performance logs for all Console objects&quot;);
  params.setGlobalCommandLineParam(&quot;timing&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;no_timing&quot;, &quot;--no-timing&quot;, &quot;Disabled performance logging; overrides -t or --timing&quot;);
  params.setGlobalCommandLineParam(&quot;no_timing&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;allow_test_objects&quot;, &quot;--allow-test-objects&quot;, &quot;Register test objects and syntax&quot;);
  params.setGlobalCommandLineParam(&quot;allow_test_objects&quot;);

  // Options ignored by MOOSE but picked up by libMesh, these are here so that they are displayed in
  // the application help
  params.addCommandLineParam&lt;bool&gt;(
      &quot;keep_cout&quot;,
      &quot;--keep-cout&quot;,
      &quot;Keep standard output from all processors when running in parallel&quot;);
  params.setGlobalCommandLineParam(&quot;keep_cout&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;redirect_stdout&quot;,
      &quot;--redirect-stdout&quot;,
      &quot;Keep standard output from all processors when running in parallel&quot;);
  params.setGlobalCommandLineParam(&quot;redirect_stdout&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;timpi_sync&quot;,
      &quot;--timpi-sync &lt;type=nbx&gt;&quot;,
      &quot;nbx&quot;,
      &quot;Changes the sync type used in spare parallel communitations within TIMPI&quot;);
  params.setGlobalCommandLineParam(&quot;timpi_sync&quot;);

  // Options for debugging
  params.addCommandLineParam&lt;std::string&gt;(&quot;start_in_debugger&quot;,
                                          &quot;--start-in-debugger &lt;debugger&gt;&quot;,
                                          &quot;Start the application and attach a debugger; this will &quot;
                                          &quot;launch xterm windows using &lt;debugger&gt;&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;stop_for_debugger&quot;,
      &quot;--stop-for-debugger &lt;seconds&gt;&quot;,
      &quot;Pauses the application during startup for &lt;seconds&gt; to allow for connection of debuggers&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;perf_graph_live_all&quot;, &quot;--perf-graph-live-all&quot;, &quot;Forces printing of ALL progress messages&quot;);
  params.setGlobalCommandLineParam(&quot;perf_graph_live_all&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;disable_perf_graph_live&quot;, &quot;--disable-perf-graph-live&quot;, &quot;Disables PerfGraph live printing&quot;);
  params.setGlobalCommandLineParam(&quot;disable_perf_graph_live&quot;);

  params.addParam&lt;bool&gt;(
      &quot;automatic_automatic_scaling&quot;, false, &quot;Whether to turn on automatic scaling by default&quot;);

  const MooseEnum compute_device_type(&quot;cpu cuda mps hip ceed-cpu ceed-cuda ceed-hip&quot;, &quot;cpu&quot;);
  params.addCommandLineParam&lt;MooseEnum&gt;(
      &quot;compute_device&quot;,
      &quot;--compute-device&quot;,
      compute_device_type,
      &quot;The device type we want to run accelerated (libtorch, MFEM) computations on.&quot;);

#ifdef HAVE_GPERFTOOLS
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;gperf_profiler_on&quot;,
      &quot;--gperf-profiler-on &lt;ranks&gt;&quot;,
      &quot;To generate profiling report only on comma-separated list of MPI ranks&quot;);
#endif

  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_data_params&quot;,
      &quot;--show-data-params&quot;,
      false,
      &quot;Show found paths for all DataFileName parameters in the header&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;show_data_paths&quot;,
                                   &quot;--show-data-paths&quot;,
                                   false,
                                   &quot;Show registered data paths for searching in the header&quot;);

  params.addPrivateParam&lt;std::shared_ptr&lt;CommandLine&gt;&gt;(&quot;_command_line&quot;);
  params.addPrivateParam&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(&quot;_comm&quot;);
  params.addPrivateParam&lt;unsigned int&gt;(&quot;_multiapp_level&quot;);
  params.addPrivateParam&lt;unsigned int&gt;(&quot;_multiapp_number&quot;);
  params.addPrivateParam&lt;bool&gt;(&quot;_use_master_mesh&quot;, false);
  params.addPrivateParam&lt;const MooseMesh *&gt;(&quot;_master_mesh&quot;);
  params.addPrivateParam&lt;const MooseMesh *&gt;(&quot;_master_displaced_mesh&quot;);
  params.addPrivateParam&lt;std::unique_ptr&lt;Backup&gt; *&gt;(&quot;_initial_backup&quot;, nullptr);
  params.addPrivateParam&lt;std::shared_ptr&lt;Parser&gt;&gt;(&quot;_parser&quot;);
#ifdef MOOSE_MFEM_ENABLED
  params.addPrivateParam&lt;std::shared_ptr&lt;mfem::Device&gt;&gt;(&quot;_mfem_device&quot;);
  params.addPrivateParam&lt;std::set&lt;std::string&gt;&gt;(&quot;_mfem_devices&quot;);
#endif

  params.addParam&lt;bool&gt;(
      &quot;use_legacy_material_output&quot;,
      true,
      &quot;Set false to allow material properties to be output on INITIAL, not just TIMESTEP_END.&quot;);
  params.addParam&lt;bool&gt;(
      &quot;use_legacy_initial_residual_evaluation_behavior&quot;,
      true,
      &quot;The legacy behavior performs an often times redundant residual evaluation before the &quot;
      &quot;solution modifying objects are executed prior to the initial (0th nonlinear iteration) &quot;
      &quot;residual evaluation. The new behavior skips that redundant residual evaluation unless the &quot;
      &quot;parameter Executioner/use_pre_SMO_residual is set to true.&quot;);

  params.addParam&lt;bool&gt;(
      MeshGeneratorSystem::allow_data_driven_param,
      false,
      &quot;Set true to enable data-driven mesh generation, which is an experimental feature&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;parse_neml2_only&quot;,
      &quot;--parse-neml2-only&quot;,
      &quot;Executes the [NEML2] block to parse the input file and terminate.&quot;);

  MooseApp::addAppParam(params);

  params.registerBase(&quot;Application&quot;);

  return params;
}

MooseApp::MooseApp(const InputParameters &amp; parameters)
  : PerfGraphInterface(*this, &quot;MooseApp&quot;),
    ParallelObject(*parameters.get&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(
        &quot;_comm&quot;)), // Can&#x27;t call getParam() before pars is set
    // The use of AppFactory::getAppParams() is atrocious. However, a long time ago
    // we decided to copy construct parameters in each derived application...
    // which means that the &quot;parameters&quot; we get if someone derives from MooseApp are
    // actually a copy of the ones built by the factory. Because we have unique
    // application names, this allows us to reference (using _pars and MooseBase)
    // the actual const parameters that the AppFactory made for this application
    MooseBase(*this, AppFactory::instance().getAppParams(parameters)),
    _comm(getParam&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(&quot;_comm&quot;)),
    _file_base_set_by_user(false),
    _output_position_set(false),
    _start_time_set(false),
    _start_time(0.0),
    _global_time_offset(0.0),
    _input_parameter_warehouse(std::make_unique&lt;InputParameterWarehouse&gt;()),
    _action_factory(*this),
    _action_warehouse(*this, _syntax, _action_factory),
    _output_warehouse(*this),
    _parser(getCheckedPointerParam&lt;std::shared_ptr&lt;Parser&gt;&gt;(&quot;_parser&quot;)),
    _command_line(getCheckedPointerParam&lt;std::shared_ptr&lt;CommandLine&gt;&gt;(&quot;_command_line&quot;)),
    _builder(*this, _action_warehouse, *_parser),
    _restartable_data(libMesh::n_threads()),
    _perf_graph(createRecoverablePerfGraph()),
    _solution_invalidity(createRecoverableSolutionInvalidity()),
    _rank_map(*_comm, _perf_graph),
    _use_executor(getParam&lt;bool&gt;(&quot;use_executor&quot;)),
    _null_executor(NULL),
    _use_nonlinear(true),
    _use_eigen_value(false),
    _enable_unused_check(ERROR_UNUSED),
    _factory(*this),
    _error_overridden(false),
    _early_exit_param(&quot;&quot;),
    _ready_to_exit(false),
    _exit_code(0),
    _initial_from_file(false),
    _distributed_mesh_on_command_line(false),
    _recover(false),
    _restart(false),
    _split_mesh(false),
    _use_split(getParam&lt;bool&gt;(&quot;use_split&quot;)),
    _force_restart(getParam&lt;bool&gt;(&quot;force_restart&quot;)),
#ifdef DEBUG
    _trap_fpe(true),
#else
    _trap_fpe(false),
#endif
    _test_checkpoint_half_transient(parameters.get&lt;bool&gt;(&quot;test_checkpoint_half_transient&quot;)),
    _test_restep(parameters.get&lt;bool&gt;(&quot;test_restep&quot;)),
    _check_input(getParam&lt;bool&gt;(&quot;check_input&quot;)),
    _multiapp_level(isParamValid(&quot;_multiapp_level&quot;) ? getParam&lt;unsigned int&gt;(&quot;_multiapp_level&quot;)
                                                    : 0),
    _multiapp_number(isParamValid(&quot;_multiapp_number&quot;) ? getParam&lt;unsigned int&gt;(&quot;_multiapp_number&quot;)
                                                      : 0),
    _use_master_mesh(getParam&lt;bool&gt;(&quot;_use_master_mesh&quot;)),
    _master_mesh(isParamValid(&quot;_master_mesh&quot;) ? getParam&lt;const MooseMesh *&gt;(&quot;_master_mesh&quot;)
                                              : nullptr),
    _master_displaced_mesh(isParamValid(&quot;_master_displaced_mesh&quot;)
                               ? getParam&lt;const MooseMesh *&gt;(&quot;_master_displaced_mesh&quot;)
                               : nullptr),
    _mesh_generator_system(*this),
    _chain_control_system(*this),
    _rd_reader(*this, _restartable_data, forceRestart()),
    _execute_flags(moose::internal::ExecFlagRegistry::getExecFlagRegistry().getFlags()),
    _output_buffer_cache(nullptr),
    _automatic_automatic_scaling(getParam&lt;bool&gt;(&quot;automatic_automatic_scaling&quot;)),
    _initial_backup(getParam&lt;std::unique_ptr&lt;Backup&gt; *&gt;(&quot;_initial_backup&quot;))
#ifdef MOOSE_LIBTORCH_ENABLED
    ,
    _libtorch_device(determineLibtorchDeviceType(getParam&lt;MooseEnum&gt;(&quot;compute_device&quot;)))
#endif
#ifdef MOOSE_MFEM_ENABLED
    ,
    _mfem_device(isParamValid(&quot;_mfem_device&quot;)
                     ? getParam&lt;std::shared_ptr&lt;mfem::Device&gt;&gt;(&quot;_mfem_device&quot;)
                     : nullptr),
    _mfem_devices(isParamValid(&quot;_mfem_devices&quot;) ? getParam&lt;std::set&lt;std::string&gt;&gt;(&quot;_mfem_devices&quot;)
                                                : std::set&lt;std::string&gt;{})
#endif
{
  if (&amp;parameters != &amp;_pars)
  {
    const auto show_trace = Moose::show_trace;
    Moose::show_trace = false;
    const std::string bad_params = &quot;(InputParameters parameters)&quot;;
    const std::string good_params = &quot;(const InputParameters &amp; parameters)&quot;;
    const std::string source_constructor = type() + &quot;::&quot; + type();
    mooseDoOnce(mooseDeprecated(type(),
                                &quot; copy-constructs its input parameters.\n\n&quot;,
                                &quot;This is deprecated and will not be allowed in the future.\n\n&quot;,
                                &quot;In &quot;,
                                type(),
                                &quot;.C, change:\n  &quot;,
                                source_constructor,
                                bad_params,
                                &quot; -&gt; &quot;,
                                source_constructor,
                                good_params,
                                &quot;\n\n&quot;,
                                &quot;In &quot;,
                                type(),
                                &quot;.h, change:\n  &quot;,
                                type(),
                                bad_params,
                                &quot;; -&gt; &quot;,
                                type(),
                                good_params,
                                &quot;;&quot;));
    Moose::show_trace = show_trace;
  }

  mooseAssert(_command_line-&gt;hasParsed(), &quot;Command line has not parsed&quot;);
  mooseAssert(_parser-&gt;queryRoot() &amp;&amp; _parser-&gt;queryCommandLineRoot(), &quot;Parser has not parsed&quot;);

  // Set the TIMPI sync type via --timpi-sync
  const auto &amp; timpi_sync = getParam&lt;std::string&gt;(&quot;timpi_sync&quot;);
  const_cast&lt;Parallel::Communicator &amp;&gt;(comm()).sync_type(timpi_sync);

#ifdef HAVE_GPERFTOOLS
  if (isUltimateMaster())
  {
    bool has_cpu_profiling = false;
    bool has_heap_profiling = false;
    static std::string cpu_profile_file;
    static std::string heap_profile_file;

    // For CPU profiling, users need to have environment &#x27;MOOSE_PROFILE_BASE&#x27;
    if (std::getenv(&quot;MOOSE_PROFILE_BASE&quot;))
    {
      has_cpu_profiling = true;
      cpu_profile_file =
          std::getenv(&quot;MOOSE_PROFILE_BASE&quot;) + std::to_string(_comm-&gt;rank()) + &quot;.prof&quot;;
      // create directory if needed
      auto name = MooseUtils::splitFileName(cpu_profile_file);
      if (!name.first.empty())
      {
        if (processor_id() == 0)
          MooseUtils::makedirs(name.first.c_str());
        _comm-&gt;barrier();
      }
    }

    // For Heap profiling, users need to have &#x27;MOOSE_HEAP_BASE&#x27;
    if (std::getenv(&quot;MOOSE_HEAP_BASE&quot;))
    {
      has_heap_profiling = true;
      heap_profile_file = std::getenv(&quot;MOOSE_HEAP_BASE&quot;) + std::to_string(_comm-&gt;rank());
      // create directory if needed
      auto name = MooseUtils::splitFileName(heap_profile_file);
      if (!name.first.empty())
      {
        if (processor_id() == 0)
          MooseUtils::makedirs(name.first.c_str());
        _comm-&gt;barrier();
      }
    }

    // turn on profiling only on selected ranks
    if (isParamSetByUser(&quot;gperf_profiler_on&quot;))
    {
      auto rankstr = getParam&lt;std::string&gt;(&quot;gperf_profiler_on&quot;);
      std::vector&lt;processor_id_type&gt; ranks;
      bool success = MooseUtils::tokenizeAndConvert(rankstr, ranks, &quot;, &quot;);
      if (!success)
        mooseError(&quot;Invalid argument for --gperf-profiler-on: &#x27;&quot;, rankstr, &quot;&#x27;&quot;);
      for (auto &amp; rank : ranks)
      {
        if (rank &gt;= _comm-&gt;size())
          mooseError(&quot;Invalid argument for --gperf-profiler-on: &quot;,
                     rank,
                     &quot; is greater than or equal to &quot;,
                     _comm-&gt;size());
        if (rank == _comm-&gt;rank())
        {
          _cpu_profiling = has_cpu_profiling;
          _heap_profiling = has_heap_profiling;
        }
      }
    }
    else
    {
      _cpu_profiling = has_cpu_profiling;
      _heap_profiling = has_heap_profiling;
    }

    if (_cpu_profiling)
      if (!ProfilerStart(cpu_profile_file.c_str()))
        mooseError(&quot;CPU profiler is not started properly&quot;);

    if (_heap_profiling)
    {
      HeapProfilerStart(heap_profile_file.c_str());
      if (!IsHeapProfilerRunning())
        mooseError(&quot;Heap profiler is not started properly&quot;);
    }
  }
#else
  if (std::getenv(&quot;MOOSE_PROFILE_BASE&quot;) || std::getenv(&quot;MOOSE_HEAP_BASE&quot;))
    mooseError(&quot;gperftool is not available for CPU or heap profiling&quot;);
#endif

  // If this will be a language server then turn off output until that starts
  if (isParamValid(&quot;language_server&quot;) &amp;&amp; getParam&lt;bool&gt;(&quot;language_server&quot;))
    _output_buffer_cache = Moose::out.rdbuf(nullptr);

  Registry::addKnownLabel(_type);
  Moose::registerAll(_factory, _action_factory, _syntax);

  _the_warehouse = std::make_unique&lt;TheWarehouse&gt;();
  _the_warehouse-&gt;registerAttribute&lt;AttribMatrixTags&gt;(&quot;matrix_tags&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribVectorTags&gt;(&quot;vector_tags&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribExecOns&gt;(&quot;exec_ons&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribSubdomains&gt;(&quot;subdomains&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribBoundaries&gt;(&quot;boundaries&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribThread&gt;(&quot;thread&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribExecutionOrderGroup&gt;(&quot;execution_order_group&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribPreIC&gt;(&quot;pre_ic&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribPreAux&gt;(&quot;pre_aux&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribPostAux&gt;(&quot;post_aux&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribName&gt;(&quot;name&quot;, &quot;dummy&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribSystem&gt;(&quot;system&quot;, &quot;dummy&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribVar&gt;(&quot;variable&quot;, -1);
  _the_warehouse-&gt;registerAttribute&lt;AttribInterfaces&gt;(&quot;interfaces&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribSysNum&gt;(&quot;sys_num&quot;, libMesh::invalid_uint);
  _the_warehouse-&gt;registerAttribute&lt;AttribResidualObject&gt;(&quot;residual_object&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribSorted&gt;(&quot;sorted&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribDisplaced&gt;(&quot;displaced&quot;, -1);

  _perf_graph.enableLivePrint();

  if (_check_input &amp;&amp; isParamSetByUser(&quot;recover&quot;))
    mooseError(&quot;Cannot run --check-input with --recover. Recover files might not exist&quot;);

  if (isParamSetByUser(&quot;start_in_debugger&quot;) &amp;&amp; isUltimateMaster())
  {
    auto command = getParam&lt;std::string&gt;(&quot;start_in_debugger&quot;);

    Moose::out &lt;&lt; &quot;Starting in debugger using: &quot; &lt;&lt; command &lt;&lt; std::endl;

    auto hostname = MooseUtils::hostname();

    std::stringstream command_stream;

    // This will start XTerm and print out some info first... then run the debugger
    command_stream &lt;&lt; &quot;xterm -e \&quot;echo &#x27;Rank: &quot; &lt;&lt; processor_id() &lt;&lt; &quot;  Hostname: &quot; &lt;&lt; hostname
                   &lt;&lt; &quot;  PID: &quot; &lt;&lt; getpid() &lt;&lt; &quot;&#x27;; echo &#x27;&#x27;; &quot;;

    // Figure out how to run the debugger
    if (command.find(&quot;lldb&quot;) != std::string::npos || command.find(&quot;gdb&quot;) != std::string::npos)
      command_stream &lt;&lt; command &lt;&lt; &quot; -p &quot; &lt;&lt; getpid();
    else
      mooseError(&quot;Unknown debugger: &quot;,
                 command,
                 &quot;\nIf this is truly what you meant then contact moose-users to have a discussion &quot;
                 &quot;about adding your debugger.&quot;);

    // Finish up the command
    command_stream &lt;&lt; &quot;\&quot;&quot;
                   &lt;&lt; &quot; &amp; &quot;;
    std::string command_string = command_stream.str();
    Moose::out &lt;&lt; &quot;Running: &quot; &lt;&lt; command_string &lt;&lt; std::endl;

    int ret = std::system(command_string.c_str());
    libmesh_ignore(ret);

    // Sleep to allow time for the debugger to attach
    std::this_thread::sleep_for(std::chrono::seconds(10));
  }

  if (isParamSetByUser(&quot;stop_for_debugger&quot;) &amp;&amp; isUltimateMaster())
  {
    Moose::out &lt;&lt; &quot;\nStopping for &quot; &lt;&lt; getParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;)
               &lt;&lt; &quot; seconds to allow attachment from a debugger.\n&quot;;

    Moose::out &lt;&lt; &quot;\nAll of the processes you can connect to:\n&quot;;
    Moose::out &lt;&lt; &quot;rank - hostname - pid\n&quot;;

    auto hostname = MooseUtils::hostname();

    {
      // The &#x27;false&#x27; turns off the serialization warning
      SerializerGuard sg(_communicator, false); // Guarantees that the processors print in order
      Moose::err &lt;&lt; processor_id() &lt;&lt; &quot; - &quot; &lt;&lt; hostname &lt;&lt; &quot; - &quot; &lt;&lt; getpid() &lt;&lt; &quot;\n&quot;;
    }

    Moose::out &lt;&lt; &quot;\nWaiting...\n&quot; &lt;&lt; std::endl;

    // Sleep to allow time for the debugger to attach
    std::this_thread::sleep_for(std::chrono::seconds(getParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;)));
  }

  if (_master_mesh &amp;&amp; isUltimateMaster())
    mooseError(&quot;Mesh can be passed in only for sub-apps&quot;);

  if (_master_displaced_mesh &amp;&amp; !_master_mesh)
    mooseError(&quot;_master_mesh should have been set when _master_displaced_mesh is set&quot;);

#ifdef MOOSE_MFEM_ENABLED
  if (_mfem_device)
  {
    mooseAssert(!isUltimateMaster(),
                &quot;The MFEM device should only be auto-set for sub-applications&quot;);
    mooseAssert(!_mfem_devices.empty(),
                &quot;If we are a sub-application and we have an MFEM device object, then we must know &quot;
                &quot;its configuration string&quot;);
  }
#endif

  // Data specifically associated with the mesh (meta-data) that will read from the restart
  // file early during the simulation setup so that they are available to Actions and other objects
  // that need them during the setup process. Most of the restartable data isn&#x27;t made available
  // until all objects have been created and all Actions have been executed (i.e. initialSetup).
  registerRestartableDataMapName(MooseApp::MESH_META_DATA, MooseApp::MESH_META_DATA_SUFFIX);

  if (_pars.have_parameter&lt;bool&gt;(&quot;use_legacy_dirichlet_bc&quot;))
    mooseDeprecated(&quot;The parameter &#x27;use_legacy_dirichlet_bc&#x27; is no longer valid.\n\n&quot;,
                    &quot;All Dirichlet boundary conditions are preset by default.\n\n&quot;,
                    &quot;Remove said parameter in &quot;,
                    name(),
                    &quot; to remove this deprecation warning.&quot;);

  if (_test_restep &amp;&amp; _test_checkpoint_half_transient)
    mooseError(&quot;Cannot use --test-restep and --test-checkpoint-half-transient together&quot;);

  registerCapabilities();

  Moose::out &lt;&lt; std::flush;

#ifdef MOOSE_KOKKOS_ENABLED
#ifdef MOOSE_ENABLE_KOKKOS_GPU
  queryKokkosGPUs();
#endif
#endif
}

std::optional&lt;MooseEnum&gt;
MooseApp::getComputeDevice() const
{
  if (isParamSetByUser(&quot;compute_device&quot;))
    return getParam&lt;MooseEnum&gt;(&quot;compute_device&quot;);
  return {};
}

void
MooseApp::registerCapabilities()
{
  // helper lambdas
  auto haveCapability = [](const std::string &amp; capability, const std::string &amp; doc)
  { addCapability(capability, true, doc + &quot; is available.&quot;); };

  auto missingCapability =
      [](const std::string &amp; capability, const std::string &amp; doc, const std::string &amp; help = &quot;&quot;)
  { addCapability(capability, false, doc + &quot; is not available. &quot; + help); };

  auto haveCapabilityVersion =
      [](const std::string &amp; capability, const std::string &amp; doc, const std::string &amp; version)
  { addCapability(capability, version, doc + &quot; version &quot; + version + &quot; is available.&quot;); };

  auto petscMissingCapability = [](const std::string &amp; capability, const std::string &amp; doc)
  {
    addCapability(
        capability, false, doc + &quot; is not available. Check your PETSc configure options.&quot;);
  };

  auto libmeshMissingCapability =
      [](const std::string &amp; capability, const std::string &amp; doc, const std::string &amp; config_option)
  {
    addCapability(capability,
                  false,
                  doc + &quot; is not available. It is controlled by the `&quot; + config_option +
                      &quot;` libMesh configure option.&quot;);
  };

  // register capabilities
  if (_trap_fpe)
    addCapability(&quot;trap_fpe&quot;,
                  true,
                  &quot;Trapping floating point exceptions is enabled (in debug mode this &quot;
                  &quot;can be disabled using the --no-trap-fpe option).&quot;);
  else
    addCapability(&quot;trap_fpe&quot;,
                  false,
                  &quot;Trapping floating point exceptions is not enabled (enable them using &quot;
                  &quot;the --trap-fpe option or by running a debug mode executable).&quot;);

  {
    const auto doc = &quot;LibTorch machine learning and parallel tensor algebra library&quot;;
#ifdef MOOSE_LIBTORCH_ENABLED
    addCapability(&quot;libtorch&quot;, TORCH_VERSION, doc);
#else
    missingCapability(&quot;libtorch&quot;,
                      doc,
                      &quot;Check &quot;
                      &quot;https://mooseframework.inl.gov/moose/getting_started/installation/&quot;
                      &quot;install_libtorch.html for &quot;
                      &quot;instructions on how to configure and build moose with libTorch.&quot;);
#endif
  }

  {
    const auto doc = &quot;MFEM finite element library&quot;;
#ifdef MOOSE_MFEM_ENABLED
    haveCapability(&quot;mfem&quot;, doc);
#else
    missingCapability(&quot;mfem&quot;,
                      doc,
                      &quot;Install mfem using the scripts/update_and_rebuild_mfem.sh script after &quot;
                      &quot;first running scripts/update_and_rebuild_conduit.sh. Finally, configure &quot;
                      &quot;moose with ./configure --with-mfem&quot;);
#endif
  }

  {
    const auto doc = &quot;New Engineering Material model Library, version 2&quot;;
#ifdef NEML2_ENABLED
    haveCapability(&quot;neml2&quot;, doc);
#else
    missingCapability(&quot;neml2&quot;,
                      doc,
                      &quot;Install neml2 using the scripts/update_and_rebuild_neml2.sh script, then &quot;
                      &quot;configure moose with ./configure --with-neml2 --with-libtorch&quot;);
#endif
  }

  {
    const auto doc = &quot;gperftools code performance analysis and profiling library&quot;;
#ifdef HAVE_GPERFTOOLS
    haveCapability(&quot;gperftools&quot;, doc);
#else
    missingCapability(&quot;gperftools&quot;,
                      doc,
                      &quot;Check https://mooseframework.inl.gov/application_development/profiling.html &quot;
                      &quot;for instructions on profiling MOOSE based applications.&quot;);
#endif
  }

  {
    const auto doc = &quot;libPNG portable network graphics format library&quot;;
#ifdef MOOSE_HAVE_LIBPNG
    haveCapability(&quot;libpng&quot;, doc);
#else
    missingCapability(&quot;libpng&quot;,
                      doc,
                      &quot;Install libpng through conda or your distribution and check that it gets &quot;
                      &quot;detected through pkg-config, then reconfigure and rebuild MOOSE.&quot;);
#endif
  }

  {
    const auto doc = &quot;NVIDIA GPU parallel computing platform&quot;;
#ifdef PETSC_HAVE_CUDA
    haveCapability(&quot;cuda&quot;, doc);
#else
    missingCapability(&quot;cuda&quot;, doc, &quot;Add the CUDA bin directory to your path and rebuild PETSc.&quot;);
#endif
  }

  {
    const auto doc = &quot;Kokkos performance portability programming ecosystem&quot;;
#ifdef MOOSE_KOKKOS_ENABLED
    haveCapability(&quot;kokkos&quot;, doc);
#else
    missingCapability(&quot;kokkos&quot;,
                      doc,
                      &quot;Rebuild PETSc with Kokkos support and libMesh. Then, reconfigure MOOSE with &quot;
                      &quot;--with-kokkos.&quot;);
#endif
  }

  {
    const auto doc = &quot;Kokkos support for PETSc&quot;;
#ifdef PETSC_HAVE_KOKKOS
    haveCapability(&quot;petsc_kokkos&quot;, doc);
#else
    missingCapability(
        &quot;kokkos&quot;, doc, &quot;Rebuild PETSc with Kokkos support, then rebuild libMesh and MOOSE.&quot;);
#endif
  }

  addCapability(
      &quot;ad_size&quot;,
      MOOSE_AD_MAX_DOFS_PER_ELEM,
      &quot;MOOSE was configured and built with a dual number backing store size of &quot; +
          Moose::stringify(MOOSE_AD_MAX_DOFS_PER_ELEM) +
          &quot;. Complex simulations with many variables or contact problems may require larger &quot;
          &quot;values. Reconfigure MOOSE with the --with-derivative-size=&lt;n&gt; option in the root of the &quot;
          &quot;repository.&quot;);
  {
    const std::string method = QUOTE(METHOD);
    addCapability(&quot;method&quot;, method, &quot;The executable was built with METHOD=\&quot;&quot; + method + &quot;\&quot;&quot;);
  }

  {
    const std::string version = QUOTE(LIBMESH_DETECTED_PETSC_VERSION_MAJOR) &quot;.&quot; QUOTE(
        LIBMESH_DETECTED_PETSC_VERSION_MINOR) &quot;.&quot; QUOTE(LIBMESH_DETECTED_PETSC_VERSION_SUBMINOR);
    addCapability(&quot;petsc&quot;, version, &quot;Using PETSc version &quot; + version + &quot;.&quot;);
  }

#ifdef LIBMESH_PETSC_USE_DEBUG
  addCapability(&quot;petsc_debug&quot;, true, &quot;PETSc was built with debugging options.&quot;);
#else
  addCapability(&quot;petsc_debug&quot;, false, &quot;PETSc was built without debugging options.&quot;);
#endif

  {
    const auto doc = &quot;SuperLU direct solver&quot;;
#ifdef LIBMESH_PETSC_HAVE_SUPERLU_DIST
    haveCapability(&quot;superlu&quot;, doc);
#else
    petscMissingCapability(&quot;superlu&quot;, doc);
#endif
  }

  {
    const auto doc = &quot;MUltifrontal Massively Parallel sparse direct Solver (MUMPS)&quot;;
#ifdef LIBMESH_PETSC_HAVE_MUMPS
    haveCapability(&quot;mumps&quot;, doc);
#else
    petscMissingCapability(&quot;mumps&quot;, doc);
#endif
  }

  {
    const auto doc = &quot;STRUMPACK - STRUctured Matrix PACKage solver library&quot;;
#ifdef LIBMESH_PETSC_HAVE_STRUMPACK
    haveCapability(&quot;strumpack&quot;, doc);
#else
    petscMissingCapability(&quot;strumpack&quot;, doc);
#endif
  }

  {
    const auto doc = &quot;Parmetis partitioning library&quot;;
#if defined(LIBMESH_PETSC_HAVE_PARMETIS) || defined(LIBMESH_HAVE_PARMETIS)
    haveCapability(&quot;parmetis&quot;, doc);
#else
    petscMissingCapability(&quot;parmetis&quot;, doc);
#endif
  }

  {
    const auto doc = &quot;Chaco graph partitioning library&quot;;
#ifdef LIBMESH_PETSC_HAVE_CHACO
    haveCapability(&quot;chaco&quot;, doc);
#else
    petscMissingCapability(&quot;chaco&quot;, doc);
#endif
  }

  {
    const auto doc = &quot;Party matrix or graph partitioning library&quot;;
#ifdef LIBMESH_PETSC_HAVE_PARTY
    haveCapability(&quot;party&quot;, doc);
#else
    petscMissingCapability(&quot;party&quot;, doc);
#endif
  }

  {
    const auto doc = &quot;PT-Scotch graph partitioning library&quot;;
#ifdef LIBMESH_PETSC_HAVE_PTSCOTCH
    haveCapability(&quot;ptscotch&quot;, doc);
#else
    petscMissingCapability(&quot;ptscotch&quot;, doc);
#endif
  }

  {
    const auto doc = &quot;Scalable Library for Eigenvalue Problem Computations (SLEPc)&quot;;
#ifdef LIBMESH_HAVE_SLEPC
    const auto version = QUOTE(LIBMESH_DETECTED_SLEPC_VERSION_MAJOR) &quot;.&quot; QUOTE(
        LIBMESH_DETECTED_SLEPC_VERSION_MINOR) &quot;.&quot; QUOTE(LIBMESH_DETECTED_SLEPC_VERSION_SUBMINOR);
    haveCapabilityVersion(&quot;slepc&quot;, doc, version);
#else
    petscMissingCapability(&quot;slepc&quot;, doc);
#endif
  }

  {
    const auto doc = &quot;Exodus mesh file format library&quot;;
#ifdef LIBMESH_HAVE_EXODUS_API
    const std::string version = QUOTE(LIBMESH_DETECTED_EXODUS_VERSION_MAJOR) &quot;.&quot; QUOTE(
        LIBMESH_DETECTED_EXODUS_VERSION_MINOR);
    haveCapabilityVersion(&quot;exodus&quot;, doc, version);
#else
    libmeshMissingCapability(&quot;exodus&quot;, doc, &quot;--enable-exodus&quot;);
#endif
  }

  {
    const auto doc = &quot;Netgen meshing library&quot;;
#ifdef LIBMESH_HAVE_NETGEN
    haveCapability(&quot;netgen&quot;, doc);
#else
    libmeshMissingCapability(&quot;netgen&quot;, doc, &quot;--enable-netgen&quot;);
#endif
  }

  {
    const auto doc = &quot;Visualization Toolkit (VTK)&quot;;
#ifdef LIBMESH_HAVE_VTK
    const std::string version = QUOTE(LIBMESH_DETECTED_VTK_VERSION_MAJOR) &quot;.&quot; QUOTE(
        LIBMESH_DETECTED_VTK_VERSION_MINOR) &quot;.&quot; QUOTE(LIBMESH_DETECTED_VTK_VERSION_SUBMINOR);
    haveCapabilityVersion(&quot;vtk&quot;, doc, version);
#else
    libmeshMissingCapability(&quot;vtk&quot;, doc, &quot;--disable-vtk and --enable-vtk-required&quot;);
#endif
  }

  {
    const auto doc = &quot;libcurl - the multiprotocol file transfer library&quot;;
#ifdef LIBMESH_HAVE_CURL
    haveCapability(&quot;curl&quot;, doc);
#else
    libmeshMissingCapability(&quot;curl&quot;, doc, &quot;--enable-curl&quot;);
#endif
  }

  {
    const auto doc = &quot;Tecplot post-processing tools API&quot;;
#ifdef LIBMESH_HAVE_TECPLOT_API
    haveCapability(&quot;tecplot&quot;, doc);
#else
    libmeshMissingCapability(&quot;tecplot&quot;, doc, &quot;--enable-tecplot&quot;);
#endif
  }

  {
    const auto doc = &quot;Boost C++ library&quot;;
#ifdef LIBMESH_HAVE_EXTERNAL_BOOST
    haveCapability(&quot;boost&quot;, doc);
#else
    libmeshMissingCapability(&quot;boost&quot;, doc, &quot;--with-boost&quot;);
#endif
  }

  // libmesh stuff
  {
    const auto doc = &quot;Adaptive mesh refinement&quot;;
#ifdef LIBMESH_ENABLE_AMR
    haveCapability(&quot;amr&quot;, doc);
#else
    libmeshMissingCapability(&quot;amr&quot;, doc, &quot;--disable-amr&quot;);
#endif
  }

  {
    const auto doc = &quot;nanoflann library for Nearest Neighbor (NN) search with KD-trees&quot;;
#ifdef LIBMESH_HAVE_NANOFLANN
    haveCapability(&quot;nanoflann&quot;, doc);
#else
    libmeshMissingCapability(&quot;nanoflann&quot;, doc, &quot;--disable-nanoflann&quot;);
#endif
  }

  {
    const auto doc = &quot;sfcurves library for space filling curves (required by geometric &quot;
                     &quot;partitioners such as SFCurves, Hilbert and Morton -  not LGPL compatible)&quot;;
#ifdef LIBMESH_HAVE_SFCURVES
    haveCapability(&quot;sfcurves&quot;, doc);
#else
    libmeshMissingCapability(&quot;sfcurves&quot;, doc, &quot;--disable-sfc&quot;);
#endif
  }

#ifdef LIBMESH_HAVE_FPARSER
#ifdef LIBMESH_HAVE_FPARSER_JIT
  addCapability(&quot;fparser&quot;, &quot;jit&quot;, &quot;FParser enabled with just in time compilation support.&quot;);
#else
  addCapability(&quot;fparser&quot;, &quot;byte_code&quot;, &quot;FParser enabled.&quot;);
#endif
#else
  addCapability(&quot;fparser&quot;,
                false,
                &quot;FParser is disabled, libMesh was likely configured with --disable-fparser.&quot;);
#endif

#ifdef LIBMESH_HAVE_DLOPEN
  addCapability(
      &quot;dlopen&quot;, true, &quot;The dlopen() system call is available to dynamically load libraries.&quot;);
#else
  addCapability(&quot;dlopen&quot;,
                false,
                &quot;The dlopen() system call is not available. Dynamic library loading is &quot;
                &quot;not supported on this system.&quot;);
#endif

  {
    const auto doc = &quot;LibMesh support for threaded execution&quot;;
#ifdef LIBMESH_USING_THREADS
    haveCapability(&quot;threads&quot;, doc);
#else
    libmeshMissingCapability(&quot;threads&quot;, doc, &quot;--with-thread-model=tbb,pthread,openmp,auto,none&quot;);
#endif
  }

  {
    const auto doc = &quot;OpenMP multi-platform shared-memory parallel programming API&quot;;
#ifdef LIBMESH_HAVE_OPENMP
    haveCapability(&quot;openmp&quot;, doc);
#else
    libmeshMissingCapability(&quot;openmp&quot;, doc, &quot;--with-thread-model=tbb,pthread,openmp,auto,none&quot;);
#endif
  }
  {
    const auto doc = &quot;oneAPI Threading Building Blocks (TBB) API&quot;;
#ifdef LIBMESH_HAVE_TBB_API
    haveCapability(&quot;tbb&quot;, doc);
#else
    libmeshMissingCapability(&quot;tbb&quot;, doc, &quot;--with-thread-model=tbb,pthread,openmp,auto,none&quot;);
#endif
  }

  {
    const auto doc = &quot;libMesh unique ID support&quot;;
#ifdef LIBMESH_ENABLE_UNIQUE_ID
    haveCapability(&quot;unique_id&quot;, doc);
#else
    libmeshMissingCapability(&quot;unique_id&quot;, doc, &quot;--enable-unique-id&quot;);
#endif
  }

  {
    const auto doc = &quot;libMesh default mesh mode&quot;;
#ifdef LIBMESH_ENABLE_PARMESH
    addCapability(&quot;mesh_mode&quot;, &quot;distributed&quot;, doc);
#else
    addCapability(&quot;mesh_mode&quot;, &quot;replicated&quot;, doc);
#endif
  }

  addCapability(&quot;dof_id_bytes&quot;,
                static_cast&lt;int&gt;(sizeof(dof_id_type)),
                &quot;Degree of freedom (DOF) identifiers use &quot; + Moose::stringify(sizeof(dof_id_type)) +
                    &quot; bytes for storage. This is controlled by the &quot;
                    &quot;--with-dof-id-bytes=&lt;1|2|4|8&gt; libMesh configure option.&quot;);

  // compiler
  {
    const auto doc = &quot;Compiler used to build the MOOSE framework.&quot;;
#if defined(__INTEL_LLVM_COMPILER)
    addCapability(&quot;compiler&quot;, &quot;intel&quot;, doc);
#elif defined(__clang__)
    addCapability(&quot;compiler&quot;, &quot;clang&quot;, doc);
#elif defined(__GNUC__) || defined(__GNUG__)
    addCapability(&quot;compiler&quot;, &quot;gcc&quot;, doc);
#elif defined(_MSC_VER)
    addCapability(&quot;compiler&quot;, &quot;msvc&quot;, doc);
#else
    addCapability(&quot;compiler&quot;, false, &quot;Unknown compiler&quot;);
#endif
  }

  // OS related
  {
    const auto doc = &quot;Operating system this executable is running on.&quot;;
#ifdef __APPLE__
    addCapability(&quot;platform&quot;, &quot;darwin&quot;, doc);
#elif __WIN32__
    addCapability(&quot;platform&quot;, &quot;win32&quot;, doc);
#elif __linux__
    addCapability(&quot;platform&quot;, &quot;linux&quot;, doc);
#elif __unix__ // all unices not caught above
    addCapability(&quot;platform&quot;, &quot;unix&quot;, doc);
#endif
  }
}

MooseApp::~MooseApp()
{
#ifdef HAVE_GPERFTOOLS
  // CPU profiling stop
  if (_cpu_profiling)
    ProfilerStop();
  // Heap profiling stop
  if (_heap_profiling)
    HeapProfilerStop();
#endif
  _action_warehouse.clear();
  _the_warehouse.reset();
  _executioner.reset();

  // Don&#x27;t wait for implicit destruction of input parameter storage
  _input_parameter_warehouse.reset();

  // This is dirty, but I don&#x27;t know what else to do. Obviously, others
  // have had similar problems if you look above. In specific, the
  // dlclose below on macs is destructing some data that does not
  // belong to it in garbage collection. So... don&#x27;t even give
  // dlclose an option
  _restartable_data.clear();

  // Remove this app&#x27;s parameters from the AppFactory. This allows
  // for creating an app with this name again in the same execution,
  // which needs to be done when resetting applications in MultiApp
  AppFactory::instance().clearAppParams(parameters(), {});

#ifdef LIBMESH_HAVE_DLOPEN
  // Close any open dynamic libraries
  for (const auto &amp; lib_pair : _lib_handles)
    dlclose(lib_pair.second.library_handle);
#endif

#ifdef MOOSE_KOKKOS_ENABLED
  deallocateKokkosMemoryPool();
#endif
}

std::string
MooseApp::getFrameworkVersion() const
{
  return MOOSE_VERSION;
}

std::string
MooseApp::getVersion() const
{
  return MOOSE_VERSION;
}

std::string
MooseApp::getPrintableVersion() const
{
  return getPrintableName() + &quot; Version: &quot; + getVersion();
}

void
MooseApp::setupOptions()
{
  TIME_SECTION(&quot;setupOptions&quot;, 5, &quot;Setting Up Options&quot;);

  // Print the header, this is as early as possible
  if (header().length() &amp;&amp; !getParam&lt;bool&gt;(&quot;suppress_header&quot;))
    _console &lt;&lt; header() &lt;&lt; std::endl;

  if (getParam&lt;bool&gt;(&quot;error_unused&quot;))
    setCheckUnusedFlag(true);
  else if (getParam&lt;bool&gt;(&quot;allow_unused&quot;))
    setCheckUnusedFlag(false);

  if (getParam&lt;bool&gt;(&quot;error_override&quot;))
    setErrorOverridden();

  _distributed_mesh_on_command_line = getParam&lt;bool&gt;(&quot;distributed_mesh&quot;);

  if (getParam&lt;bool&gt;(&quot;trap_fpe&quot;))
  {
    _trap_fpe = true;
    _perf_graph.setActive(false);
    if (getParam&lt;bool&gt;(&quot;no_trap_fpe&quot;))
      mooseError(&quot;Cannot use both \&quot;--trap-fpe\&quot; and \&quot;--no-trap-fpe\&quot; flags.&quot;);
  }
  else if (getParam&lt;bool&gt;(&quot;no_trap_fpe&quot;))
    _trap_fpe = false;

  // Turn all warnings in MOOSE to errors (almost see next logic block)
  Moose::_warnings_are_errors = getParam&lt;bool&gt;(&quot;error&quot;);

  // Deprecated messages can be toggled to errors independently from everything else.
  Moose::_deprecated_is_error = getParam&lt;bool&gt;(&quot;error_deprecated&quot;);

  if (isUltimateMaster()) // makes sure coloring isn&#x27;t reset incorrectly in multi-app settings
  {
    // Set from command line
    auto color = getParam&lt;MooseEnum&gt;(&quot;color&quot;);
    if (!isParamSetByUser(&quot;color&quot;))
    {
      // Set from deprecated --no-color
      if (getParam&lt;bool&gt;(&quot;no_color&quot;))
        color = &quot;off&quot;;
      // Set from environment
      else
      {
        char * c_color = std::getenv(&quot;MOOSE_COLOR&quot;);
        if (c_color)
          color.assign(std::string(c_color), &quot;While assigning environment variable MOOSE_COLOR&quot;);
      }
    }

    if (color == &quot;auto&quot;)
      Moose::setColorConsole(true);
    else if (color == &quot;on&quot;)
      Moose::setColorConsole(true, true);
    else if (color == &quot;off&quot;)
      Moose::setColorConsole(false);
    else
      mooseAssert(false, &quot;Should not hit&quot;);

    // After setting color so that non-yellow deprecated is honored
    if (getParam&lt;bool&gt;(&quot;no_color&quot;))
      mooseDeprecated(&quot;The --no-color flag is deprecated. Use &#x27;--color off&#x27; instead.&quot;);
  }

// If there&#x27;s no threading model active, but the user asked for
// --n-threads &gt; 1 on the command line, throw a mooseError.  This is
// intended to prevent situations where the user has potentially
// built MOOSE incorrectly (neither TBB nor pthreads found) and is
// asking for multiple threads, not knowing that there will never be
// any threads launched.
#if !LIBMESH_USING_THREADS
  if (libMesh::command_line_value(&quot;--n-threads&quot;, 1) &gt; 1)
    mooseError(&quot;You specified --n-threads &gt; 1, but there is no threading model active!&quot;);
#endif

  // Build a minimal running application, ignoring the input file.
  if (getParam&lt;bool&gt;(&quot;minimal&quot;))
    createMinimalApp();

  else if (getParam&lt;bool&gt;(&quot;display_version&quot;))
  {
    Moose::out &lt;&lt; getPrintableVersion() &lt;&lt; std::endl;
    _early_exit_param = &quot;--version&quot;;
    _ready_to_exit = true;
    return;
  }
  else if (getParam&lt;bool&gt;(&quot;help&quot;))
  {
    _command_line-&gt;printUsage();
    _early_exit_param = &quot;--help&quot;;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;dump&quot;) || isParamSetByUser(&quot;dump_search&quot;))
  {
    const std::string search =
        isParamSetByUser(&quot;dump_search&quot;) ? getParam&lt;std::string&gt;(&quot;dump_search&quot;) : &quot;&quot;;

    JsonSyntaxTree tree(search);

    {
      TIME_SECTION(&quot;dump&quot;, 1, &quot;Building Syntax Tree&quot;);
      _builder.buildJsonSyntaxTree(tree);
    }

    // Check if second arg is valid or not
    if ((tree.getRoot()).is_object())
    {
      // Turn off live printing so that it doesn&#x27;t mess with the dump
      _perf_graph.disableLivePrint();

      JsonInputFileFormatter formatter;
      Moose::out &lt;&lt; &quot;\n### START DUMP DATA ###\n&quot;
                 &lt;&lt; formatter.toString(tree.getRoot()) &lt;&lt; &quot;\n### END DUMP DATA ###&quot; &lt;&lt; std::endl;
      _early_exit_param = &quot;--dump&quot;;
      _ready_to_exit = true;
    }
    else
      mooseError(&quot;Search parameter &#x27;&quot;, search, &quot;&#x27; was not found in the registered syntax.&quot;);
  }
  else if (getParam&lt;bool&gt;(&quot;registry&quot;))
  {
    _perf_graph.disableLivePrint();

    Moose::out &lt;&lt; &quot;Label\tType\tName\tClass\tFile\n&quot;;

    auto &amp; objmap = Registry::allObjects();
    for (auto &amp; entry : objmap)
      for (auto &amp; obj : entry.second)
        Moose::out &lt;&lt; entry.first &lt;&lt; &quot;\tobject\t&quot; &lt;&lt; obj-&gt;name() &lt;&lt; &quot;\t&quot; &lt;&lt; obj-&gt;_classname &lt;&lt; &quot;\t&quot;
                   &lt;&lt; obj-&gt;_file &lt;&lt; &quot;\n&quot;;

    auto &amp; actmap = Registry::allActions();
    for (auto &amp; entry : actmap)
    {
      for (auto &amp; act : entry.second)
        Moose::out &lt;&lt; entry.first &lt;&lt; &quot;\taction\t&quot; &lt;&lt; act-&gt;_name &lt;&lt; &quot;\t&quot; &lt;&lt; act-&gt;_classname &lt;&lt; &quot;\t&quot;
                   &lt;&lt; act-&gt;_file &lt;&lt; &quot;\n&quot;;
    }
    _early_exit_param = &quot;--registry&quot;;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;registry_hit&quot;))
  {
    _perf_graph.disableLivePrint();

    Moose::out &lt;&lt; &quot;### START REGISTRY DATA ###\n&quot;;

    hit::Section root(&quot;&quot;);
    auto sec = new hit::Section(&quot;registry&quot;);
    root.addChild(sec);
    auto objsec = new hit::Section(&quot;objects&quot;);
    sec-&gt;addChild(objsec);

    auto &amp; objmap = Registry::allObjects();
    for (auto &amp; entry : objmap)
      for (auto &amp; obj : entry.second)
      {
        auto ent = new hit::Section(&quot;entry&quot;);
        objsec-&gt;addChild(ent);
        ent-&gt;addChild(new hit::Field(&quot;label&quot;, hit::Field::Kind::String, entry.first));
        ent-&gt;addChild(new hit::Field(&quot;type&quot;, hit::Field::Kind::String, &quot;object&quot;));
        ent-&gt;addChild(new hit::Field(&quot;name&quot;, hit::Field::Kind::String, obj-&gt;name()));
        ent-&gt;addChild(new hit::Field(&quot;class&quot;, hit::Field::Kind::String, obj-&gt;_classname));
        ent-&gt;addChild(new hit::Field(&quot;file&quot;, hit::Field::Kind::String, obj-&gt;_file));
      }

    auto actsec = new hit::Section(&quot;actions&quot;);
    sec-&gt;addChild(actsec);
    auto &amp; actmap = Registry::allActions();
    for (auto &amp; entry : actmap)
      for (auto &amp; act : entry.second)
      {
        auto ent = new hit::Section(&quot;entry&quot;);
        actsec-&gt;addChild(ent);
        ent-&gt;addChild(new hit::Field(&quot;label&quot;, hit::Field::Kind::String, entry.first));
        ent-&gt;addChild(new hit::Field(&quot;type&quot;, hit::Field::Kind::String, &quot;action&quot;));
        ent-&gt;addChild(new hit::Field(&quot;task&quot;, hit::Field::Kind::String, act-&gt;_name));
        ent-&gt;addChild(new hit::Field(&quot;class&quot;, hit::Field::Kind::String, act-&gt;_classname));
        ent-&gt;addChild(new hit::Field(&quot;file&quot;, hit::Field::Kind::String, act-&gt;_file));
      }

    Moose::out &lt;&lt; root.render();

    Moose::out &lt;&lt; &quot;\n### END REGISTRY DATA ###\n&quot;;
    _early_exit_param = &quot;--registry_hit&quot;;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;definition&quot;))
  {
    _perf_graph.disableLivePrint();

    JsonSyntaxTree tree(&quot;&quot;);
    _builder.buildJsonSyntaxTree(tree);
    SONDefinitionFormatter formatter;
    Moose::out &lt;&lt; &quot;%-START-SON-DEFINITION-%\n&quot;
               &lt;&lt; formatter.toString(tree.getRoot()) &lt;&lt; &quot;\n%-END-SON-DEFINITION-%\n&quot;;
    _early_exit_param = &quot;--definition&quot;;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;yaml&quot;) || isParamSetByUser(&quot;yaml_search&quot;))
  {
    const std::string search =
        isParamSetByUser(&quot;yaml_search&quot;) ? getParam&lt;std::string&gt;(&quot;yaml_search&quot;) : &quot;&quot;;
    _perf_graph.disableLivePrint();

    _builder.initSyntaxFormatter(Moose::Builder::YAML, true);
    _builder.buildFullTree(search);

    _early_exit_param = &quot;--yaml&quot;;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;json&quot;) || isParamSetByUser(&quot;json_search&quot;))
  {
    const std::string search =
        isParamSetByUser(&quot;json_search&quot;) ? getParam&lt;std::string&gt;(&quot;json_search&quot;) : &quot;&quot;;
    _perf_graph.disableLivePrint();

    JsonSyntaxTree tree(search);
    _builder.buildJsonSyntaxTree(tree);

    outputMachineReadableData(
        &quot;json&quot;, &quot;**START JSON DATA**\n&quot;, &quot;\n**END JSON DATA**&quot;, tree.getRoot().dump(2));
    _early_exit_param = &quot;--json&quot;;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;syntax&quot;))
  {
    _perf_graph.disableLivePrint();

    std::multimap&lt;std::string, Syntax::ActionInfo&gt; syntax = _syntax.getAssociatedActions();
    std::stringstream ss;
    for (const auto &amp; it : syntax)
      ss &lt;&lt; it.first &lt;&lt; &quot;\n&quot;;
    outputMachineReadableData(&quot;syntax&quot;, &quot;**START SYNTAX DATA**\n&quot;, &quot;**END SYNTAX DATA**&quot;, ss.str());
    _early_exit_param = &quot;--syntax&quot;;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;show_type&quot;))
  {
    _perf_graph.disableLivePrint();

    Moose::out &lt;&lt; &quot;MooseApp Type: &quot; &lt;&lt; type() &lt;&lt; std::endl;
    _early_exit_param = &quot;--show-type&quot;;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;show_capabilities&quot;))
  {
    _perf_graph.disableLivePrint();
    outputMachineReadableData(&quot;show_capabilities&quot;,
                              &quot;**START JSON DATA**\n&quot;,
                              &quot;\n**END JSON DATA**&quot;,
                              Moose::Capabilities::getCapabilityRegistry().dump());
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;check_capabilities&quot;))
  {
    _perf_graph.disableLivePrint();
    const auto &amp; capabilities = getParam&lt;std::string&gt;(&quot;check_capabilities&quot;);
    auto [status, reason, doc] = Moose::Capabilities::getCapabilityRegistry().check(capabilities);
    const bool pass = status == CapabilityUtils::CERTAIN_PASS;
    _console &lt;&lt; &quot;Capabilities &#x27;&quot; &lt;&lt; capabilities &lt;&lt; &quot;&#x27; are &quot; &lt;&lt; (pass ? &quot;&quot; : &quot;not &quot;) &lt;&lt; &quot;fulfilled.&quot;
             &lt;&lt; std::endl;
    _ready_to_exit = true;
    if (!pass)
      _exit_code = 77;
    return;
  }
  else if (!getInputFileNames().empty())
  {
    if (isParamSetByUser(&quot;recover&quot;))
    {
      // We need to set the flag manually here since the recover parameter is a string type (takes
      // an optional filename)
      _recover = true;
      const auto &amp; recover = getParam&lt;std::string&gt;(&quot;recover&quot;);
      if (recover.size())
        _restart_recover_base = recover;
    }

    _builder.build();

    if (isParamValid(&quot;required_capabilities&quot;))
    {
      _perf_graph.disableLivePrint();

      const auto required_capabilities = getParam&lt;std::string&gt;(&quot;required_capabilities&quot;);
      auto [status, reason, doc] =
          Moose::Capabilities::getCapabilityRegistry().check(required_capabilities);
      if (status &lt; CapabilityUtils::UNKNOWN)
      {
        mooseInfo(&quot;Required capabilities &#x27;&quot;, required_capabilities, &quot;&#x27; not fulfilled.&quot;);
        _ready_to_exit = true;
        // we use code 77 as &quot;skip&quot; in the Testharness
        _exit_code = 77;
        return;
      }
      if (status == CapabilityUtils::UNKNOWN)
        mooseError(&quot;Required capabilities &#x27;&quot;,
                   required_capabilities,
                   &quot;&#x27; are not specific enough. A comparison test is performed on an undefined &quot;
                   &quot;capability. Disambiguate this requirement by adding an existence/non-existence &quot;
                   &quot;requirement. Example: &#x27;unknown&lt;1.2.3&#x27; should become &#x27;unknown &amp; unknown&lt;1.2.3&#x27; &quot;
                   &quot;or &#x27;!unknown | unknown&lt;1.2.3&#x27;&quot;);
    }

    // Lambda to check for mutually exclusive parameters
    auto isExclusiveParamSetByUser =
        [this](const std::vector&lt;std::string&gt; &amp; group, const std::string &amp; param)
    {
      auto is_set = isParamSetByUser(param);
      if (is_set)
        for (const auto &amp; p : group)
          if (p != param &amp;&amp; isParamSetByUser(p))
            mooseError(&quot;Parameters &#x27;&quot; + p + &quot;&#x27; and &#x27;&quot; + param +
                       &quot;&#x27; are mutually exclusive. Please choose only one of them.&quot;);
      return is_set;
    };

    // The following parameters set the final task and so are mutually exclusive.
    const std::vector&lt;std::string&gt; final_task_params = {
        &quot;csg_only&quot;, &quot;mesh_only&quot;, &quot;split_mesh&quot;, &quot;parse_neml2_only&quot;};
    if (isExclusiveParamSetByUser(final_task_params, &quot;csg_only&quot;))
    {
      // Error checking on incompatible command line options
      if (_distributed_mesh_on_command_line)
        mooseError(&quot;--csg-only cannot be used in conjunction with --distributed-mesh&quot;);
      const bool has_mesh_split = isParamSetByUser(&quot;split_file&quot;) || _use_split;
      if (has_mesh_split)
        mooseError(&quot;--csg-only is not compatible with any mesh splitting options&quot;);
      if (isParamSetByUser(&quot;refinements&quot;))
        mooseError(&quot;--csg-only cannot be used in conjunction with -r refinements option&quot;);
      if (!isUltimateMaster())
        mooseError(&quot;--csg-only option cannot be used as a Subapp&quot;);
      if (_recover)
        mooseError(&quot;--csg-only option cannot be used in recovery mode&quot;);

      _syntax.registerTaskName(&quot;execute_csg_generators&quot;, true);
      _syntax.addDependency(&quot;execute_csg_generators&quot;, &quot;execute_mesh_generators&quot;);
      _syntax.addDependency(&quot;recover_meta_data&quot;, &quot;execute_csg_generators&quot;);

      _syntax.registerTaskName(&quot;csg_only&quot;, true);
      _syntax.addDependency(&quot;csg_only&quot;, &quot;recover_meta_data&quot;);
      _syntax.addDependency(&quot;set_mesh_base&quot;, &quot;csg_only&quot;);
      _action_warehouse.setFinalTask(&quot;csg_only&quot;);
    }
    else if (isExclusiveParamSetByUser(final_task_params, &quot;mesh_only&quot;))
    {
      // If we are looking to just check the input, there is no need to
      // call MeshOnlyAction and generate a mesh
      if (_check_input)
        _action_warehouse.setFinalTask(&quot;setup_mesh_complete&quot;);
      else
      {
        _syntax.registerTaskName(&quot;mesh_only&quot;, true);
        _syntax.addDependency(&quot;mesh_only&quot;, &quot;setup_mesh_complete&quot;);
        _syntax.addDependency(&quot;determine_system_type&quot;, &quot;mesh_only&quot;);
        _action_warehouse.setFinalTask(&quot;mesh_only&quot;);
      }
    }
    else if (isExclusiveParamSetByUser(final_task_params, &quot;split_mesh&quot;))
    {
      _split_mesh = true;
      _syntax.registerTaskName(&quot;split_mesh&quot;, true);
      _syntax.addDependency(&quot;split_mesh&quot;, &quot;setup_mesh_complete&quot;);
      _syntax.addDependency(&quot;determine_system_type&quot;, &quot;split_mesh&quot;);
      _action_warehouse.setFinalTask(&quot;split_mesh&quot;);
    }
    else if (isExclusiveParamSetByUser(final_task_params, &quot;parse_neml2_only&quot;))
    {
      _syntax.registerTaskName(&quot;parse_neml2&quot;);
      _syntax.addDependency(&quot;determine_system_type&quot;, &quot;parse_neml2&quot;);
      _action_warehouse.setFinalTask(&quot;parse_neml2&quot;);
    }
    _action_warehouse.build();

    // Setup the AppFileBase for use by the Outputs or other systems that need output file info
    {
      // Extract the CommonOutputAction
      const auto common_actions = _action_warehouse.getActions&lt;CommonOutputAction&gt;();
      mooseAssert(common_actions.size() &lt;= 1, &quot;Should not be more than one CommonOutputAction&quot;);
      const Action * common = common_actions.empty() ? nullptr : *common_actions.begin();

      // If file_base is set in CommonOutputAction through parsing input, obtain the file_base
      if (common &amp;&amp; common-&gt;isParamValid(&quot;file_base&quot;))
      {
        _output_file_base = common-&gt;getParam&lt;std::string&gt;(&quot;file_base&quot;);
        _file_base_set_by_user = true;
      }
      else if (isUltimateMaster())
      {
        // if this app is a master, we use the first input file name as the default file base.
        // use proximate here because the input file is an absolute path
        const auto &amp; base = getLastInputFileName();
        size_t pos = base.find_last_of(&#x27;.&#x27;);
        _output_file_base = base.substr(0, pos);
        // Note: we did not append &quot;_out&quot; in the file base here because we do not want to
        //       have it in between the input file name and the object name for Output/*
        //       syntax.
      }
      // default file base for multiapps is set by MultiApp
    }
  }
  // No input file provided but we have other arguments (so don&#x27;t just show print usage)
  else if (!isParamSetByUser(&quot;input_file&quot;) &amp;&amp; _command_line-&gt;getArguments().size() &gt; 2)
  {
    mooseAssert(getInputFileNames().empty(), &quot;Should be empty&quot;);

    if (_check_input)
      mooseError(&quot;You specified --check-input, but did not provide an input file. Add -i &quot;
                 &quot;&lt;inputfile&gt; to your command line.&quot;);

    mooseError(&quot;No input files specified. Add -i &lt;inputfile&gt; to your command line.&quot;);
  }
  else if (isParamValid(&quot;language_server&quot;) &amp;&amp; getParam&lt;bool&gt;(&quot;language_server&quot;))
  {
    _perf_graph.disableLivePrint();

    // Reset output to the buffer what was cached before it was turned it off
    if (!Moose::out.rdbuf() &amp;&amp; _output_buffer_cache)
      Moose::out.rdbuf(_output_buffer_cache);

    // Start a language server that communicates using an iostream connection
    MooseServer moose_server(*this);

    moose_server.run();

    _early_exit_param = &quot;--language-server&quot;;
    _ready_to_exit = true;
  }

  else /* The catch-all case for bad options or missing options, etc. */
  {
    _command_line-&gt;printUsage();
    _early_exit_param = &quot;bad or missing&quot;;
    _ready_to_exit = true;
    _exit_code = 1;
  }

#ifdef MOOSE_KOKKOS_ENABLED
  for (auto &amp; action : _action_warehouse.allActionBlocks())
    if (action-&gt;isParamValid(&quot;_kokkos_action&quot;))
      _has_kokkos_objects = true;
#endif

  Moose::out &lt;&lt; std::flush;
}

const std::vector&lt;std::string&gt; &amp;
MooseApp::getInputFileNames() const
{
  mooseAssert(_parser, &quot;Parser is not set&quot;);
  return _parser-&gt;getInputFileNames();
}

const std::string &amp;
MooseApp::getLastInputFileName() const
{
  mooseAssert(_parser, &quot;Parser is not set&quot;);
  return _parser-&gt;getLastInputFileName();
}

std::string
MooseApp::getOutputFileBase(bool for_non_moose_build_output) const
{
  if (_file_base_set_by_user || for_non_moose_build_output || _multiapp_level)
    return _output_file_base;
  else
    return _output_file_base + &quot;_out&quot;;
}

void
MooseApp::setOutputFileBase(const std::string &amp; output_file_base)
{
  _output_file_base = output_file_base;

  // Reset the file base in the outputs
  _output_warehouse.resetFileBase();

  // Reset the file base in multiapps (if they have been constructed yet)
  if (getExecutioner())
    for (auto &amp; multi_app : feProblem().getMultiAppWarehouse().getObjects())
      multi_app-&gt;setAppOutputFileBase();

  _file_base_set_by_user = true;
}

void
MooseApp::runInputFile()
{
  TIME_SECTION(&quot;runInputFile&quot;, 3);

  // If early exit param has been set, then just return
  if (_ready_to_exit)
    return;

  _action_warehouse.executeAllActions();

  if (isParamSetByUser(&quot;csg_only&quot;))
  {
    _early_exit_param = &quot;--csg-only&quot;;
    _ready_to_exit = true;
  }
  else if (isParamSetByUser(&quot;mesh_only&quot;))
  {
    _early_exit_param = &quot;--mesh-only&quot;;
    _ready_to_exit = true;
  }
  else if (isParamSetByUser(&quot;split_mesh&quot;))
  {
    _early_exit_param = &quot;--split-mesh&quot;;
    _ready_to_exit = true;
  }
  else if (isParamSetByUser(&quot;parse_neml2_only&quot;))
  {
    _early_exit_param = &quot;--parse-neml2-only&quot;;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;list_constructed_objects&quot;))
  {
    // TODO: ask multiapps for their constructed objects
    _early_exit_param = &quot;--list-constructed-objects&quot;;
    _ready_to_exit = true;
    std::stringstream ss;
    for (const auto &amp; obj : _factory.getConstructedObjects())
      ss &lt;&lt; obj &lt;&lt; &#x27;\n&#x27;;
    outputMachineReadableData(
        &quot;list_constructed_objects&quot;, &quot;**START OBJECT DATA**\n&quot;, &quot;\n**END OBJECT DATA**&quot;, ss.str());
  }
}

void
MooseApp::errorCheck()
{
  bool warn = _enable_unused_check == WARN_UNUSED;
  bool err = _enable_unused_check == ERROR_UNUSED;

  _builder.errorCheck(*_comm, warn, err);

  // Return early for mesh only mode, since we want error checking to run even though
  // an executor is not created for this case
  if (isParamSetByUser(&quot;mesh_only&quot;))
    return;

  if (!_executor.get() &amp;&amp; !_executioner.get())
  {
    if (!_early_exit_param.empty())
    {
      mooseAssert(_check_input,
                  &quot;Something went wrong, we should only get here if _check_input is true.&quot;);
      mooseError(
          &quot;Incompatible command line arguments provided. --check-input cannot be called with &quot;,
          _early_exit_param,
          &quot;.&quot;);
    }
    // We should never get here
    mooseError(&quot;The Executor is being called without being initialized. This is likely &quot;
               &quot;caused by &quot;
               &quot;incompatible command line arguments&quot;);
  }

  auto apps = feProblem().getMultiAppWarehouse().getObjects();
  for (auto app : apps)
    for (unsigned int i = 0; i &lt; app-&gt;numLocalApps(); i++)
      app-&gt;localApp(i)-&gt;errorCheck();
}

void
MooseApp::executeExecutioner()
{
  TIME_SECTION(&quot;executeExecutioner&quot;, 3);

  // If ready to exit has been set, then just return
  if (_ready_to_exit)
    return;

  // run the simulation
  if (_use_executor &amp;&amp; _executor)
  {
    LibmeshPetscCall(Moose::PetscSupport::petscSetupOutput(_command_line.get()));
    _executor-&gt;init();
    errorCheck();
    auto result = _executor-&gt;exec();
    if (!result.convergedAll())
      mooseError(result.str());
  }
  else if (_executioner)
  {
    LibmeshPetscCall(Moose::PetscSupport::petscSetupOutput(_command_line.get()));
    _executioner-&gt;init();
    errorCheck();
    _executioner-&gt;execute();
    if (!_executioner-&gt;lastSolveConverged())
      setExitCode(1);
  }
  else
    mooseError(&quot;No executioner was specified (go fix your input file)&quot;);
}

bool
MooseApp::isRecovering() const
{
  return _recover;
}

bool
MooseApp::isRestarting() const
{
  return _restart;
}

bool
MooseApp::isSplitMesh() const
{
  return _split_mesh;
}

bool
MooseApp::hasRestartRecoverFileBase() const
{
  return !_restart_recover_base.empty();
}

bool
MooseApp::hasRecoverFileBase() const
{
  mooseDeprecated(&quot;MooseApp::hasRecoverFileBase is deprecated, use &quot;
                  &quot;MooseApp::hasRestartRecoverFileBase() instead.&quot;);
  return !_restart_recover_base.empty();
}

void
MooseApp::registerRestartableNameWithFilter(const std::string &amp; name,
                                            Moose::RESTARTABLE_FILTER filter)
{
  using Moose::RESTARTABLE_FILTER;
  switch (filter)
  {
    case RESTARTABLE_FILTER::RECOVERABLE:
      _recoverable_data_names.insert(name);
      break;
    default:
      mooseError(&quot;Unknown filter&quot;);
  }
}

std::vector&lt;std::filesystem::path&gt;
MooseApp::backup(const std::filesystem::path &amp; folder_base)
{
  TIME_SECTION(&quot;backup&quot;, 2, &quot;Backing Up Application to File&quot;);

  preBackup();

  RestartableDataWriter writer(*this, _restartable_data);
  return writer.write(folder_base);
}

std::unique_ptr&lt;Backup&gt;
MooseApp::backup()
{
  TIME_SECTION(&quot;backup&quot;, 2, &quot;Backing Up Application&quot;);

  RestartableDataWriter writer(*this, _restartable_data);

  preBackup();

  auto backup = std::make_unique&lt;Backup&gt;();
  writer.write(*backup-&gt;header, *backup-&gt;data);

  return backup;
}

void
MooseApp::restore(const std::filesystem::path &amp; folder_base, const bool for_restart)
{
  TIME_SECTION(&quot;restore&quot;, 2, &quot;Restoring Application from File&quot;);

  const DataNames filter_names = for_restart ? getRecoverableData() : DataNames{};

  _rd_reader.setInput(folder_base);
  _rd_reader.restore(filter_names);

  postRestore(for_restart);
}

void
MooseApp::restore(std::unique_ptr&lt;Backup&gt; backup, const bool for_restart)
{
  TIME_SECTION(&quot;restore&quot;, 2, &quot;Restoring Application&quot;);

  const DataNames filter_names = for_restart ? getRecoverableData() : DataNames{};

  if (!backup)
    mooseError(&quot;MooseApp::restore(): Provided backup is not initialized&quot;);

  auto header = std::move(backup-&gt;header);
  mooseAssert(header, &quot;Header not available&quot;);

  auto data = std::move(backup-&gt;data);
  mooseAssert(data, &quot;Data not available&quot;);

  _rd_reader.setInput(std::move(header), std::move(data));
  _rd_reader.restore(filter_names);

  postRestore(for_restart);
}

void
MooseApp::restoreFromInitialBackup(const bool for_restart)
{
  mooseAssert(hasInitialBackup(), &quot;Missing initial backup&quot;);
  restore(std::move(*_initial_backup), for_restart);
}

std::unique_ptr&lt;Backup&gt;
MooseApp::finalizeRestore()
{
  if (!_rd_reader.isRestoring())
    mooseError(&quot;MooseApp::finalizeRestore(): Not currently restoring&quot;);

  // This gives us access to the underlying streams so that we can return it if needed
  auto input_streams = _rd_reader.clear();

  std::unique_ptr&lt;Backup&gt; backup;

  // Give them back a backup if this restore started from a Backup, in which case
  // the two streams in the Backup are formed into StringInputStreams
  if (auto header_string_input = dynamic_cast&lt;StringInputStream *&gt;(input_streams.header.get()))
  {
    auto data_string_input = dynamic_cast&lt;StringInputStream *&gt;(input_streams.data.get());
    mooseAssert(data_string_input, &quot;Should also be a string input&quot;);

    auto header_sstream = header_string_input-&gt;release();
    mooseAssert(header_sstream, &quot;Header not available&quot;);

    auto data_sstream = data_string_input-&gt;release();
    mooseAssert(data_sstream, &quot;Data not available&quot;);

    backup = std::make_unique&lt;Backup&gt;();
    backup-&gt;header = std::move(header_sstream);
    backup-&gt;data = std::move(data_sstream);
  }

  return backup;
}

void
MooseApp::setCheckUnusedFlag(bool warn_is_error)
{
  _enable_unused_check = warn_is_error ? ERROR_UNUSED : WARN_UNUSED;
}

void
MooseApp::disableCheckUnusedFlag()
{
  _enable_unused_check = OFF;
}

FEProblemBase &amp;
MooseApp::feProblem() const
{
  mooseAssert(_executor.get() || _executioner.get(), &quot;No executioner yet, calling too early!&quot;);
  return _executor.get() ? _executor-&gt;feProblem() : _executioner-&gt;feProblem();
}

void
MooseApp::addExecutor(const std::string &amp; type,
                      const std::string &amp; name,
                      const InputParameters &amp; params)
{
  std::shared_ptr&lt;Executor&gt; executor = _factory.create&lt;Executor&gt;(type, name, params);

  if (_executors.count(executor-&gt;name()) &gt; 0)
    mooseError(&quot;an executor with name &#x27;&quot;, executor-&gt;name(), &quot;&#x27; already exists&quot;);
  _executors[executor-&gt;name()] = executor;
}

void
MooseApp::addExecutorParams(const std::string &amp; type,
                            const std::string &amp; name,
                            const InputParameters &amp; params)
{
  _executor_params[name] = std::make_pair(type, std::make_unique&lt;InputParameters&gt;(params));
}

const Parser &amp;
MooseApp::parser() const
{
  mooseAssert(_parser, &quot;Not set&quot;);
  return *_parser;
}

Parser &amp;
MooseApp::parser()
{
  return const_cast&lt;Parser &amp;&gt;(std::as_const(*this).parser());
}

void
MooseApp::recursivelyCreateExecutors(const std::string &amp; current_executor_name,
                                     std::list&lt;std::string&gt; &amp; possible_roots,
                                     std::list&lt;std::string&gt; &amp; current_branch)
{
  // Did we already make this one?
  if (_executors.find(current_executor_name) != _executors.end())
    return;

  // Is this one already on the current branch (i.e. there is a cycle)
  if (std::find(current_branch.begin(), current_branch.end(), current_executor_name) !=
      current_branch.end())
  {
    std::stringstream exec_names_string;

    auto branch_it = current_branch.begin();

    exec_names_string &lt;&lt; *branch_it++;

    for (; branch_it != current_branch.end(); ++branch_it)
      exec_names_string &lt;&lt; &quot;, &quot; &lt;&lt; *branch_it;

    exec_names_string &lt;&lt; &quot;, &quot; &lt;&lt; current_executor_name;

    mooseError(&quot;Executor cycle detected: &quot;, exec_names_string.str());
  }

  current_branch.push_back(current_executor_name);

  // Build the dependencies first
  const auto &amp; params = *_executor_params[current_executor_name].second;

  for (const auto &amp; param : params)
  {
    if (params.have_parameter&lt;ExecutorName&gt;(param.first))
    {
      const auto &amp; dependency_name = params.get&lt;ExecutorName&gt;(param.first);

      possible_roots.remove(dependency_name);

      if (!dependency_name.empty())
        recursivelyCreateExecutors(dependency_name, possible_roots, current_branch);
    }
  }

  // Add this Executor
  const auto &amp; type = _executor_params[current_executor_name].first;
  addExecutor(type, current_executor_name, params);

  current_branch.pop_back();
}

void
MooseApp::createExecutors()
{
  // Do we have any?
  if (_executor_params.empty())
    return;

  // Holds the names of Executors that may be the root executor
  std::list&lt;std::string&gt; possibly_root;

  // What is already built
  std::map&lt;std::string, bool&gt; already_built;

  // The Executors that are currently candidates for being roots
  std::list&lt;std::string&gt; possible_roots;

  // The current line of dependencies - used for finding cycles
  std::list&lt;std::string&gt; current_branch;

  // Build the NullExecutor
  {
    auto params = _factory.getValidParams(&quot;NullExecutor&quot;);
    _null_executor = _factory.create&lt;NullExecutor&gt;(&quot;NullExecutor&quot;, &quot;_null_executor&quot;, params);
  }

  for (const auto &amp; params_entry : _executor_params)
  {
    const auto &amp; name = params_entry.first;

    // Did we already make this one?
    if (_executors.find(name) != _executors.end())
      continue;

    possible_roots.emplace_back(name);

    recursivelyCreateExecutors(name, possible_roots, current_branch);
  }

  // If there is more than one possible root - error
  if (possible_roots.size() &gt; 1)
  {
    auto root_string_it = possible_roots.begin();

    std::stringstream roots_string;

    roots_string &lt;&lt; *root_string_it++;

    for (; root_string_it != possible_roots.end(); ++root_string_it)
      roots_string &lt;&lt; &quot;, &quot; &lt;&lt; *root_string_it;

    mooseError(&quot;Multiple Executor roots found: &quot;, roots_string.str());
  }

  // Set the root executor
  _executor = _executors[possible_roots.front()];
}

Executor &amp;
MooseApp::getExecutor(const std::string &amp; name, bool fail_if_not_found)
{
  auto it = _executors.find(name);

  if (it != _executors.end())
    return *it-&gt;second;

  if (fail_if_not_found)
    mooseError(&quot;Executor not found: &quot;, name);

  return *_null_executor;
}

Executioner *
MooseApp::getExecutioner() const
{
  return _executioner.get() ? _executioner.get() : _executor.get();
}

void
MooseApp::setErrorOverridden()
{
  _error_overridden = true;
}

void
MooseApp::run()
{
  TIME_SECTION(&quot;run&quot;, 3);
  if (getParam&lt;bool&gt;(&quot;show_docs&quot;))
  {
    auto binname = appBinaryName();
    if (binname == &quot;&quot;)
      mooseError(&quot;could not locate installed tests to run (unresolved binary/app name)&quot;);
    auto docspath = MooseUtils::docsDir(binname);
    if (docspath == &quot;&quot;)
      mooseError(&quot;no installed documentation found&quot;);

    auto docmsgfile = MooseUtils::pathjoin(docspath, &quot;docmsg.txt&quot;);
    std::string docmsg = &quot;file://&quot; + MooseUtils::realpath(docspath) + &quot;/index.html&quot;;
    if (MooseUtils::pathExists(docmsgfile) &amp;&amp; MooseUtils::checkFileReadable(docmsgfile))
    {
      std::ifstream ifs(docmsgfile);
      std::string content((std::istreambuf_iterator&lt;char&gt;(ifs)),
                          (std::istreambuf_iterator&lt;char&gt;()));
      content.replace(content.find(&quot;$LOCAL_SITE_HOME&quot;), content.length(), docmsg);
      docmsg = content;
    }

    Moose::out &lt;&lt; docmsg &lt;&lt; &quot;\n&quot;;
    _early_exit_param = &quot;--docs&quot;;
    _ready_to_exit = true;
    return;
  }

  if (showInputs() || copyInputs() || runInputs())
  {
    _early_exit_param = &quot;--show-input, --copy-inputs, or --run&quot;;
    _ready_to_exit = true;
    return;
  }

  try
  {
    TIME_SECTION(&quot;setup&quot;, 2, &quot;Setting Up&quot;);
    setupOptions();
    runInputFile();
  }
  catch (Parser::Error &amp; err)
  {
    mooseAssert(_parser-&gt;getThrowOnError(), &quot;Should be true&quot;);
    throw err;
  }
  catch (MooseRuntimeError &amp; err)
  {
    mooseAssert(Moose::_throw_on_error, &quot;Should be true&quot;);
    throw err;
  }
  catch (std::exception &amp; err)
  {
    mooseError(err.what());
  }

  if (!_check_input)
  {
    TIME_SECTION(&quot;execute&quot;, 2, &quot;Executing&quot;);
    executeExecutioner();
  }
  else
  {
    errorCheck();
    // Output to stderr, so it is easier for peacock to get the result
    Moose::err &lt;&lt; &quot;Syntax OK&quot; &lt;&lt; std::endl;
  }
}

bool
MooseApp::showInputs() const
{
  if (getParam&lt;bool&gt;(&quot;show_inputs&quot;))
  {
    const auto show_inputs_syntax = _pars.getCommandLineMetadata(&quot;show_inputs&quot;).switches;
    std::vector&lt;std::string&gt; dirs;
    const auto installable_inputs = getInstallableInputs();

    if (installable_inputs == &quot;&quot;)
    {
      Moose::out
          &lt;&lt; &quot;Show inputs has not been overriden in this application.\nContact the developers of &quot;
             &quot;this appication and request that they override \&quot;MooseApp::getInstallableInputs\&quot;.\n&quot;;
    }
    else
    {
      mooseAssert(!show_inputs_syntax.empty(), &quot;show_inputs sytnax should not be empty&quot;);

      MooseUtils::tokenize(installable_inputs, dirs, 1, &quot; &quot;);
      Moose::out &lt;&lt; &quot;The following directories are installable into a user-writeable directory:\n\n&quot;
                 &lt;&lt; installable_inputs &lt;&lt; &#x27;\n&#x27;
                 &lt;&lt; &quot;\nTo install one or more directories of inputs, execute the binary with the \&quot;&quot;
                 &lt;&lt; show_inputs_syntax[0] &lt;&lt; &quot;\&quot; flag. e.g.:\n$ &quot;
                 &lt;&lt; _command_line-&gt;getExecutableName() &lt;&lt; &#x27; &#x27; &lt;&lt; show_inputs_syntax[0] &lt;&lt; &#x27; &#x27;
                 &lt;&lt; dirs[0] &lt;&lt; &#x27;\n&#x27;;
    }
    return true;
  }
  return false;
}

std::string
MooseApp::getInstallableInputs() const
{
  return &quot;tests&quot;;
}

bool
MooseApp::copyInputs()
{
  if (isParamSetByUser(&quot;copy_inputs&quot;))
  {
    if (comm().size() &gt; 1)
      mooseError(&quot;The --copy-inputs option should not be ran in parallel&quot;);

    // Get command line argument following --copy-inputs on command line
    auto dir_to_copy = getParam&lt;std::string&gt;(&quot;copy_inputs&quot;);

    if (dir_to_copy.empty())
      mooseError(&quot;Error retrieving directory to copy&quot;);
    if (dir_to_copy.back() != &#x27;/&#x27;)
      dir_to_copy += &#x27;/&#x27;;

    // This binary name is the actual binary. That is, if we called a symlink it&#x27;ll
    // be the name of what the symlink points to
    auto binname = appBinaryName();
    if (binname == &quot;&quot;)
      mooseError(&quot;could not locate installed tests to run (unresolved binary/app name)&quot;);

    auto src_dir = MooseUtils::installedInputsDir(
        binname,
        dir_to_copy,
        &quot;Rerun binary with &quot; + _pars.getCommandLineMetadata(&quot;show_inputs&quot;).switches[0] +
            &quot; to get a list of installable directories.&quot;);

    // Use the command line here because if we have a symlink to another binary,
    // we want to dump into a directory that is named after the symlink not the true binary
    auto dst_dir = _command_line-&gt;getExecutableNameBase() + &quot;/&quot; + dir_to_copy;
    auto cmdname = _command_line-&gt;getExecutableName();
    if (cmdname.find_first_of(&quot;/&quot;) != std::string::npos)
      cmdname = cmdname.substr(cmdname.find_first_of(&quot;/&quot;) + 1, std::string::npos);

    if (MooseUtils::pathExists(dst_dir))
      mooseError(
          &quot;The directory \&quot;./&quot;,
          dst_dir,
          &quot;\&quot; already exists.\nTo update/recopy the contents of this directory, rename (\&quot;mv &quot;,
          dst_dir,
          &quot; new_dir_name\&quot;) or remove (\&quot;rm -r &quot;,
          dst_dir,
          &quot;\&quot;) the existing directory.\nThen re-run \&quot;&quot;,
          cmdname,
          &quot; --copy-inputs &quot;,
          dir_to_copy,
          &quot;\&quot;.&quot;);

    std::string cmd = &quot;mkdir -p &quot; + dst_dir + &quot;; rsync -av &quot; + src_dir + &quot; &quot; + dst_dir;

    TIME_SECTION(&quot;copy_inputs&quot;, 2, &quot;Copying Inputs&quot;);

    mooseAssert(comm().size() == 1, &quot;Should be run in serial&quot;);
    const auto return_value = system(cmd.c_str());
    if (!WIFEXITED(return_value))
      mooseError(&quot;Process exited unexpectedly&quot;);
    setExitCode(WEXITSTATUS(return_value));
    if (exitCode() == 0)
      Moose::out &lt;&lt; &quot;Directory successfully copied into ./&quot; &lt;&lt; dst_dir &lt;&lt; &#x27;\n&#x27;;
    return true;
  }
  return false;
}

bool
MooseApp::runInputs()
{
  if (isParamSetByUser(&quot;run&quot;))
  {
    if (comm().size() &gt; 1)
      mooseError(&quot;The --run option should not be ran in parallel&quot;);

    // Pass everything after --run on the cli to the TestHarness
    const auto find_run_it = std::as_const(*_command_line).findCommandLineParam(&quot;run&quot;);
    const auto &amp; cl_entries = std::as_const(*_command_line).getEntries();
    mooseAssert(find_run_it != cl_entries.end(), &quot;Didn&#x27;t find the option&quot;);
    std::string test_args;
    for (auto it = std::next(find_run_it); it != cl_entries.end(); ++it)
      for (const auto &amp; arg : it-&gt;raw_args)
      {
        test_args += &quot; &quot; + arg;
        libMesh::add_command_line_name(arg);
      }

    auto working_dir = MooseUtils::getCurrentWorkingDir();
    if (MooseUtils::findTestRoot() == &quot;&quot;)
    {
      auto bin_name = appBinaryName();
      if (bin_name == &quot;&quot;)
        mooseError(&quot;Could not locate binary name relative to installed location&quot;);

      auto cmd_name = Moose::getExecutableName();
      mooseError(
          &quot;Could not locate installed tests from the current working directory:&quot;,
          working_dir,
          &quot;.\nMake sure you are executing this command from within a writable installed inputs &quot;,
          &quot;directory.\nRun \&quot;&quot;,
          cmd_name,
          &quot; --copy-inputs &lt;dir&gt;\&quot; to copy the contents of &lt;dir&gt; to a \&quot;./&quot;,
          bin_name,
          &quot;_&lt;dir&gt;\&quot; directory.\nChange into that directory and try \&quot;&quot;,
          cmd_name,
          &quot; --run &lt;dir&gt;\&quot; again.&quot;);
    }

    // Set this application as the app name for the moose_test_runner script that we&#x27;re running
    setenv(&quot;MOOSE_TEST_RUNNER_APP_NAME&quot;, appBinaryName().c_str(), true);

    const std::string cmd = MooseUtils::runTestsExecutable() + test_args;
    Moose::out &lt;&lt; &quot;Working Directory: &quot; &lt;&lt; working_dir &lt;&lt; &quot;\nRunning Command: &quot; &lt;&lt; cmd &lt;&lt; std::endl;
    mooseAssert(comm().size() == 1, &quot;Should be run in serial&quot;);
    const auto return_value = system(cmd.c_str());
    if (!WIFEXITED(return_value))
      mooseError(&quot;Process exited unexpectedly&quot;);
    setExitCode(WEXITSTATUS(return_value));
    return true;
  }

  return false;
}

void
MooseApp::checkReservedCapability(const std::string &amp; capability)
{
  // The list of these capabilities should match those within
  // Tester.checkRunnableBase() in the TestHarness
  static const std::set&lt;std::string&gt; reserved{
      &quot;scale_refine&quot;, &quot;valgrind&quot;, &quot;recover&quot;, &quot;heavy&quot;, &quot;mpi_procs&quot;, &quot;num_threads&quot;, &quot;compute_device&quot;};
  if (reserved.count(capability))
    ::mooseError(&quot;MooseApp::addCapability(): The capability \&quot;&quot;,
                 capability,
                 &quot;\&quot; is reserved and may not be registered by an application.&quot;);
}

void
MooseApp::setOutputPosition(const Point &amp; p)
{
  _output_position_set = true;
  _output_position = p;
  _output_warehouse.meshChanged();

  if (_executioner.get())
    _executioner-&gt;parentOutputPositionChanged();
}

std::list&lt;std::string&gt;
MooseApp::getCheckpointDirectories() const
{
  // Storage for the directory names
  std::list&lt;std::string&gt; checkpoint_dirs;

  // Add the directories added with Outputs/checkpoint=true input syntax
  checkpoint_dirs.push_back(getOutputFileBase() + &quot;_cp&quot;);

  // Add the directories from any existing checkpoint output objects
  const auto &amp; actions = _action_warehouse.getActionListByName(&quot;add_output&quot;);
  for (const auto &amp; action : actions)
  {
    // Get the parameters from the MooseObjectAction
    MooseObjectAction * moose_object_action = dynamic_cast&lt;MooseObjectAction *&gt;(action);
    if (!moose_object_action)
      continue;

    const InputParameters &amp; params = moose_object_action-&gt;getObjectParams();
    if (moose_object_action-&gt;getParam&lt;std::string&gt;(&quot;type&quot;) == &quot;Checkpoint&quot;)
    {
      // Unless file_base was explicitly set by user, we cannot rely on it, as it will be changed
      // later
      const std::string cp_dir =
          _file_base_set_by_user ? params.get&lt;std::string&gt;(&quot;file_base&quot;)
                                 : (getOutputFileBase(true) + &quot;_&quot; + moose_object_action-&gt;name());
      checkpoint_dirs.push_back(cp_dir + &quot;_cp&quot;);
    }
  }
  return checkpoint_dirs;
}

std::list&lt;std::string&gt;
MooseApp::getCheckpointFiles() const
{
  auto checkpoint_dirs = getCheckpointDirectories();
  return MooseUtils::getFilesInDirs(checkpoint_dirs, false);
}

void
MooseApp::setStartTime(Real time)
{
  _start_time_set = true;
  _start_time = time;
}

std::string
MooseApp::getFileName(bool stripLeadingPath) const
{
  return _builder.getPrimaryFileName(stripLeadingPath);
}

OutputWarehouse &amp;
MooseApp::getOutputWarehouse()
{
  return _output_warehouse;
}

const OutputWarehouse &amp;
MooseApp::getOutputWarehouse() const
{
  return _output_warehouse;
}

std::string
MooseApp::appNameToLibName(const std::string &amp; app_name) const
{
  std::string library_name(app_name);

  // Strip off the App part (should always be the last 3 letters of the name)
  size_t pos = library_name.find(&quot;App&quot;);
  if (pos != library_name.length() - 3)
    mooseError(&quot;Invalid application name: &quot;, library_name);
  library_name.erase(pos);

  // Now get rid of the camel case, prepend lib, and append the method and suffix
  return std::string(&quot;lib&quot;) + MooseUtils::camelCaseToUnderscore(library_name) + &#x27;-&#x27; +
         QUOTE(METHOD) + &quot;.la&quot;;
}

std::string
MooseApp::libNameToAppName(const std::string &amp; library_name) const
{
  std::string app_name(library_name);

  // Strip off the leading &quot;lib&quot; and trailing &quot;.la&quot;
  if (pcrecpp::RE(&quot;lib(.+?)(?:-\\w+)?\\.la&quot;).Replace(&quot;\\1&quot;, &amp;app_name) == 0)
    mooseError(&quot;Invalid library name: &quot;, app_name);

  return MooseUtils::underscoreToCamelCase(app_name, true);
}

RestartableDataValue &amp;
MooseApp::registerRestartableData(std::unique_ptr&lt;RestartableDataValue&gt; data,
                                  THREAD_ID tid,
                                  bool read_only,
                                  const RestartableDataMapName &amp; metaname)
{
  if (!metaname.empty() &amp;&amp; tid != 0)
    mooseError(
        &quot;The meta data storage for &#x27;&quot;, metaname, &quot;&#x27; is not threaded, so the tid must be zero.&quot;);

  mooseAssert(metaname.empty() ||
                  _restartable_meta_data.find(metaname) != _restartable_meta_data.end(),
              &quot;The desired meta data name does not exist: &quot; + metaname);

  // Select the data store for saving this piece of restartable data (mesh or everything else)
  auto &amp; data_map =
      metaname.empty() ? _restartable_data[tid] : _restartable_meta_data[metaname].first;

  RestartableDataValue * stored_data = data_map.findData(data-&gt;name());
  if (stored_data)
  {
    if (data-&gt;typeId() != stored_data-&gt;typeId())
      mooseError(&quot;Type mismatch found in RestartableData registration of &#x27;&quot;,
                 data-&gt;name(),
                 &quot;&#x27;\n\n  Stored type: &quot;,
                 stored_data-&gt;type(),
                 &quot;\n  New type: &quot;,
                 data-&gt;type());
  }
  else
    stored_data = &amp;data_map.addData(std::move(data));

  if (!read_only)
    stored_data-&gt;setDeclared({});

  return *stored_data;
}

RestartableDataValue &amp;
MooseApp::registerRestartableData(const std::string &amp; libmesh_dbg_var(name),
                                  std::unique_ptr&lt;RestartableDataValue&gt; data,
                                  THREAD_ID tid,
                                  bool read_only,
                                  const RestartableDataMapName &amp; metaname)
{
  mooseDeprecated(&quot;The use of MooseApp::registerRestartableData with a data name is &quot;
                  &quot;deprecated.\n\nUse the call without a name instead.&quot;);

  mooseAssert(name == data-&gt;name(), &quot;Inconsistent name&quot;);
  return registerRestartableData(std::move(data), tid, read_only, metaname);
}

bool
MooseApp::hasRestartableMetaData(const std::string &amp; name,
                                 const RestartableDataMapName &amp; metaname) const
{
  auto it = _restartable_meta_data.find(metaname);
  if (it == _restartable_meta_data.end())
    return false;
  return it-&gt;second.first.hasData(name);
}

RestartableDataValue &amp;
MooseApp::getRestartableMetaData(const std::string &amp; name,
                                 const RestartableDataMapName &amp; metaname,
                                 THREAD_ID tid)
{
  if (tid != 0)
    mooseError(
        &quot;The meta data storage for &#x27;&quot;, metaname, &quot;&#x27; is not threaded, so the tid must be zero.&quot;);

  // Get metadata reference from RestartableDataMap and return a (non-const) reference to its value
  auto &amp; restartable_data_map = getRestartableDataMap(metaname);
  RestartableDataValue * const data = restartable_data_map.findData(name);
  if (!data)
    mooseError(&quot;Unable to find RestartableDataValue object with name &quot; + name +
               &quot; in RestartableDataMap&quot;);

  return *data;
}

void
MooseApp::possiblyLoadRestartableMetaData(const RestartableDataMapName &amp; name,
                                          const std::filesystem::path &amp; folder_base)
{
  const auto &amp; map_name = getRestartableDataMapName(name);
  const auto meta_data_folder_base = metaDataFolderBase(folder_base, map_name);
  if (RestartableDataReader::isAvailable(meta_data_folder_base))
  {
    RestartableDataReader reader(*this, getRestartableDataMap(name), forceRestart());
    reader.setErrorOnLoadWithDifferentNumberOfProcessors(false);
    reader.setInput(meta_data_folder_base);
    reader.restore();
  }
}

void
MooseApp::loadRestartableMetaData(const std::filesystem::path &amp; folder_base)
{
  for (const auto &amp; name_map_pair : _restartable_meta_data)
    possiblyLoadRestartableMetaData(name_map_pair.first, folder_base);
}

std::vector&lt;std::filesystem::path&gt;
MooseApp::writeRestartableMetaData(const RestartableDataMapName &amp; name,
                                   const std::filesystem::path &amp; folder_base)
{
  if (processor_id() != 0)
    mooseError(&quot;MooseApp::writeRestartableMetaData(): Should only run on processor 0&quot;);

  const auto &amp; map_name = getRestartableDataMapName(name);
  const auto meta_data_folder_base = metaDataFolderBase(folder_base, map_name);

  RestartableDataWriter writer(*this, getRestartableDataMap(name));
  return writer.write(meta_data_folder_base);
}

std::vector&lt;std::filesystem::path&gt;
MooseApp::writeRestartableMetaData(const std::filesystem::path &amp; folder_base)
{
  std::vector&lt;std::filesystem::path&gt; paths;

  if (processor_id() == 0)
    for (const auto &amp; name_map_pair : _restartable_meta_data)
    {
      const auto map_paths = writeRestartableMetaData(name_map_pair.first, folder_base);
      paths.insert(paths.end(), map_paths.begin(), map_paths.end());
    }

  return paths;
}

void
MooseApp::dynamicAppRegistration(const std::string &amp; app_name,
                                 std::string library_path,
                                 const std::string &amp; library_name,
                                 bool lib_load_deps)
{
#ifdef LIBMESH_HAVE_DLOPEN
  Parameters params;
  params.set&lt;std::string&gt;(&quot;app_name&quot;) = app_name;
  params.set&lt;RegistrationType&gt;(&quot;reg_type&quot;) = APPLICATION;
  params.set&lt;std::string&gt;(&quot;registration_method&quot;) = app_name + &quot;__registerApps&quot;;
  params.set&lt;std::string&gt;(&quot;library_path&quot;) = library_path;

  const auto effective_library_name =
      library_name.empty() ? appNameToLibName(app_name) : library_name;
  params.set&lt;std::string&gt;(&quot;library_name&quot;) = effective_library_name;
  params.set&lt;bool&gt;(&quot;library_load_dependencies&quot;) = lib_load_deps;

  const auto paths = getLibrarySearchPaths(library_path);
  std::ostringstream oss;

  auto successfully_loaded = false;
  if (paths.empty())
    oss &lt;&lt; &#x27;&quot;&#x27; &lt;&lt; app_name &lt;&lt; &quot;\&quot; is not a registered application name.\n&quot;
        &lt;&lt; &quot;No search paths were set. We made no attempts to locate the corresponding library &quot;
           &quot;file.\n&quot;;
  else
  {
    dynamicRegistration(params);

    // At this point the application should be registered so check it
    if (!AppFactory::instance().isRegistered(app_name))
    {
      oss &lt;&lt; &#x27;&quot;&#x27; &lt;&lt; app_name &lt;&lt; &quot;\&quot; is not a registered application name.\n&quot;
          &lt;&lt; &quot;Unable to locate library archive for \&quot;&quot; &lt;&lt; app_name
          &lt;&lt; &quot;\&quot;.\nWe attempted to locate the library archive \&quot;&quot; &lt;&lt; effective_library_name
          &lt;&lt; &quot;\&quot; in the following paths:\n\t&quot;;
      std::copy(paths.begin(), paths.end(), infix_ostream_iterator&lt;std::string&gt;(oss, &quot;\n\t&quot;));
    }
    else
      successfully_loaded = true;
  }

  if (!successfully_loaded)
  {
    oss &lt;&lt; &quot;\nMake sure you have compiled the library and either set the \&quot;library_path\&quot; &quot;
           &quot;variable in your input file or exported \&quot;MOOSE_LIBRARY_PATH\&quot;.\n&quot;;

    mooseError(oss.str());
  }

#else
  libmesh_ignore(app_name, library_path, library_name, lib_load_deps);
  mooseError(&quot;Dynamic Loading is either not supported or was not detected by libMesh configure.&quot;);
#endif
}

void
MooseApp::dynamicAllRegistration(const std::string &amp; app_name,
                                 Factory * factory,
                                 ActionFactory * action_factory,
                                 Syntax * syntax,
                                 std::string library_path,
                                 const std::string &amp; library_name)
{
#ifdef LIBMESH_HAVE_DLOPEN
  Parameters params;
  params.set&lt;std::string&gt;(&quot;app_name&quot;) = app_name;
  params.set&lt;RegistrationType&gt;(&quot;reg_type&quot;) = REGALL;
  params.set&lt;std::string&gt;(&quot;registration_method&quot;) = app_name + &quot;__registerAll&quot;;
  params.set&lt;std::string&gt;(&quot;library_path&quot;) = library_path;
  params.set&lt;std::string&gt;(&quot;library_name&quot;) =
      library_name.empty() ? appNameToLibName(app_name) : library_name;

  params.set&lt;Factory *&gt;(&quot;factory&quot;) = factory;
  params.set&lt;Syntax *&gt;(&quot;syntax&quot;) = syntax;
  params.set&lt;ActionFactory *&gt;(&quot;action_factory&quot;) = action_factory;
  params.set&lt;bool&gt;(&quot;library_load_dependencies&quot;) = false;

  dynamicRegistration(params);
#else
  libmesh_ignore(app_name, factory, action_factory, syntax, library_path, library_name);
  mooseError(&quot;Dynamic Loading is either not supported or was not detected by libMesh configure.&quot;);
#endif
}

void
MooseApp::dynamicRegistration(const Parameters &amp; params)
{
  const auto paths = getLibrarySearchPaths(params.get&lt;std::string&gt;(&quot;library_path&quot;));
  const auto library_name = params.get&lt;std::string&gt;(&quot;library_name&quot;);

  // Attempt to dynamically load the library
  for (const auto &amp; path : paths)
    if (MooseUtils::checkFileReadable(path + &#x27;/&#x27; + library_name, false, false))
      loadLibraryAndDependencies(
          path + &#x27;/&#x27; + library_name, params, params.get&lt;bool&gt;(&quot;library_load_dependencies&quot;));
}

void
MooseApp::loadLibraryAndDependencies(const std::string &amp; library_filename,
                                     const Parameters &amp; params,
                                     const bool load_dependencies)
{
  std::string line;
  std::string dl_lib_filename;

  // This RE looks for absolute path libtool filenames (i.e. begins with a slash and ends with a
  // .la)
  pcrecpp::RE re_deps(&quot;(/\\S*\\.la)&quot;);

  std::ifstream la_handle(library_filename.c_str());
  if (la_handle.is_open())
  {
    while (std::getline(la_handle, line))
    {
      // Look for the system dependent dynamic library filename to open
      if (line.find(&quot;dlname=&quot;) != std::string::npos)
        // Magic numbers are computed from length of this string &quot;dlname=&#x27; and line minus that
        // string plus quotes&quot;
        dl_lib_filename = line.substr(8, line.size() - 9);

      if (line.find(&quot;dependency_libs=&quot;) != std::string::npos)
      {
        if (load_dependencies)
        {
          pcrecpp::StringPiece input(line);
          pcrecpp::StringPiece depend_library;
          while (re_deps.FindAndConsume(&amp;input, &amp;depend_library))
            // Recurse here to load dependent libraries in depth-first order
            loadLibraryAndDependencies(depend_library.as_string(), params, load_dependencies);
        }

        // There&#x27;s only one line in the .la file containing the dependency libs so break after
        // finding it
        break;
      }
    }
    la_handle.close();
  }

  // This should only occur if we have static linkage.
  if (dl_lib_filename.empty())
    return;

  const auto &amp; [dir, file_name] = MooseUtils::splitFileName(library_filename);

  // Time to load the library, First see if we&#x27;ve already loaded this particular dynamic library
  //     1) make sure we haven&#x27;t already loaded this library
  // AND 2) make sure we have a library name (we won&#x27;t for static linkage)
  // Note: Here was are going to assume uniqueness based on the filename alone. This has significant
  // implications for applications that have &quot;diamond&quot; inheritance of libraries (usually
  // modules). We will only load one of those libraries, versions be damned.
  auto dyn_lib_it = _lib_handles.find(file_name);
  if (dyn_lib_it == _lib_handles.end())
  {
    // Assemble the actual filename using the base path of the *.la file and the dl_lib_filename
    const auto dl_lib_full_path = MooseUtils::pathjoin(dir, dl_lib_filename);

    MooseUtils::checkFileReadable(dl_lib_full_path, false, /*throw_on_unreadable=*/true);

#ifdef LIBMESH_HAVE_DLOPEN
    void * const lib_handle = dlopen(dl_lib_full_path.c_str(), RTLD_LAZY);
#else
    void * const lib_handle = nullptr;
#endif

    if (!lib_handle)
      mooseError(&quot;The library file \&quot;&quot;,
                 dl_lib_full_path,
                 &quot;\&quot; exists and has proper permissions, but cannot by dynamically loaded.\nThis &quot;
                 &quot;generally means that the loader was unable to load one or more of the &quot;
                 &quot;dependencies listed in the supplied library (see otool or ldd).\n&quot;,
                 dlerror());

    DynamicLibraryInfo lib_info;
    lib_info.library_handle = lib_handle;
    lib_info.full_path = library_filename;

    auto insert_ret = _lib_handles.insert(std::make_pair(file_name, lib_info));
    mooseAssert(insert_ret.second == true, &quot;Error inserting into lib_handles map&quot;);

    dyn_lib_it = insert_ret.first;
  }

  // Library has been loaded, check to see if we&#x27;ve called the requested registration method
  const auto registration_method = params.get&lt;std::string&gt;(&quot;registration_method&quot;);
  auto &amp; entry_sym_from_curr_lib = dyn_lib_it-&gt;second.entry_symbols;

  if (entry_sym_from_curr_lib.find(registration_method) == entry_sym_from_curr_lib.end())
  {
    // get the pointer to the method in the library.  The dlsym()
    // function returns a null pointer if the symbol cannot be found,
    // we also explicitly set the pointer to NULL if dlsym is not
    // available.
#ifdef LIBMESH_HAVE_DLOPEN
    void * registration_handle =
        dlsym(dyn_lib_it-&gt;second.library_handle, registration_method.c_str());
#else
    void * registration_handle = nullptr;
#endif

    if (registration_handle)
    {
      switch (params.get&lt;RegistrationType&gt;(&quot;reg_type&quot;))
      {
        case APPLICATION:
        {
          using register_app_t = void (*)();
          register_app_t * const reg_ptr = reinterpret_cast&lt;register_app_t *&gt;(&amp;registration_handle);
          (*reg_ptr)();
          break;
        }
        case REGALL:
        {
          using register_app_t = void (*)(Factory *, ActionFactory *, Syntax *);
          register_app_t * const reg_ptr = reinterpret_cast&lt;register_app_t *&gt;(&amp;registration_handle);
          (*reg_ptr)(params.get&lt;Factory *&gt;(&quot;factory&quot;),
                     params.get&lt;ActionFactory *&gt;(&quot;action_factory&quot;),
                     params.get&lt;Syntax *&gt;(&quot;syntax&quot;));
          break;
        }
        default:
          mooseError(&quot;Unhandled RegistrationType&quot;);
      }

      entry_sym_from_curr_lib.insert(registration_method);
    }
    else
    {

#if defined(DEBUG) &amp;&amp; defined(LIBMESH_HAVE_DLOPEN)
      // We found a dynamic library that doesn&#x27;t have a dynamic
      // registration method in it. This shouldn&#x27;t be an error, so
      // we&#x27;ll just move on.
      if (!registration_handle)
        mooseWarning(&quot;Unable to find extern \&quot;C\&quot; method \&quot;&quot;,
                     registration_method,
                     &quot;\&quot; in library: &quot;,
                     dyn_lib_it-&gt;first,
                     &quot;.\n&quot;,
                     &quot;This doesn&#x27;t necessarily indicate an error condition unless you believe that &quot;
                     &quot;the method should exist in that library.\n&quot;,
                     dlerror());
#endif
    }
  }
}

std::set&lt;std::string&gt;
MooseApp::getLoadedLibraryPaths() const
{
  // Return the paths but not the open file handles
  std::set&lt;std::string&gt; paths;
  for (const auto &amp; it : _lib_handles)
    paths.insert(it.first);

  return paths;
}

std::set&lt;std::string&gt;
MooseApp::getLibrarySearchPaths(const std::string &amp; library_path) const
{
  std::set&lt;std::string&gt; paths;

  if (!library_path.empty())
  {
    std::vector&lt;std::string&gt; tmp_paths;
    MooseUtils::tokenize(library_path, tmp_paths, 1, &quot;:&quot;);

    paths.insert(tmp_paths.begin(), tmp_paths.end());
  }

  char * moose_lib_path_env = std::getenv(&quot;MOOSE_LIBRARY_PATH&quot;);
  if (moose_lib_path_env)
  {
    std::string moose_lib_path(moose_lib_path_env);
    std::vector&lt;std::string&gt; tmp_paths;
    MooseUtils::tokenize(moose_lib_path, tmp_paths, 1, &quot;:&quot;);

    paths.insert(tmp_paths.begin(), tmp_paths.end());
  }

  return paths;
}

InputParameterWarehouse &amp;
MooseApp::getInputParameterWarehouse()
{
  return *_input_parameter_warehouse;
}

std::string
MooseApp::header() const
{
  return std::string(&quot;&quot;);
}

void
MooseApp::setRestart(bool value)
{
  _restart = value;
}

void
MooseApp::setRecover(bool value)
{
  _recover = value;
}

void
MooseApp::createMinimalApp()
{
  TIME_SECTION(&quot;createMinimalApp&quot;, 3, &quot;Creating Minimal App&quot;);

  // SetupMeshAction
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;SetupMeshAction&quot;);
    action_params.set&lt;std::string&gt;(&quot;type&quot;) = &quot;GeneratedMesh&quot;;

    // Create The Action
    std::shared_ptr&lt;MooseObjectAction&gt; action = std::static_pointer_cast&lt;MooseObjectAction&gt;(
        _action_factory.create(&quot;SetupMeshAction&quot;, &quot;Mesh&quot;, action_params));

    // Set the object parameters
    InputParameters &amp; params = action-&gt;getObjectParams();
    params.set&lt;MooseEnum&gt;(&quot;dim&quot;) = &quot;1&quot;;
    params.set&lt;unsigned int&gt;(&quot;nx&quot;) = 1;

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  // Executioner
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;CreateExecutionerAction&quot;);
    action_params.set&lt;std::string&gt;(&quot;type&quot;) = &quot;Transient&quot;;

    // Create the action
    std::shared_ptr&lt;MooseObjectAction&gt; action = std::static_pointer_cast&lt;MooseObjectAction&gt;(
        _action_factory.create(&quot;CreateExecutionerAction&quot;, &quot;Executioner&quot;, action_params));

    // Set the object parameters
    InputParameters &amp; params = action-&gt;getObjectParams();
    params.set&lt;unsigned int&gt;(&quot;num_steps&quot;) = 1;
    params.set&lt;Real&gt;(&quot;dt&quot;) = 1;

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  // Problem
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;CreateProblemDefaultAction&quot;);
    action_params.set&lt;bool&gt;(&quot;_solve&quot;) = false;

    // Create the action
    std::shared_ptr&lt;Action&gt; action = std::static_pointer_cast&lt;Action&gt;(
        _action_factory.create(&quot;CreateProblemDefaultAction&quot;, &quot;Problem&quot;, action_params));

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  // Outputs
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;CommonOutputAction&quot;);
    action_params.set&lt;bool&gt;(&quot;console&quot;) = false;

    // Create action
    std::shared_ptr&lt;Action&gt; action =
        _action_factory.create(&quot;CommonOutputAction&quot;, &quot;Outputs&quot;, action_params);

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  _action_warehouse.build();
}

bool
MooseApp::hasRelationshipManager(const std::string &amp; name) const
{
  return std::find_if(_relationship_managers.begin(),
                      _relationship_managers.end(),
                      [&amp;name](const std::shared_ptr&lt;RelationshipManager&gt; &amp; rm)
                      { return rm-&gt;name() == name; }) != _relationship_managers.end();
}

namespace
{
void
donateForWhom(const RelationshipManager &amp; donor, RelationshipManager &amp; acceptor)
{
  auto &amp; existing_for_whom = acceptor.forWhom();

  // Take all the for_whoms from the donor, and give them to the acceptor
  for (auto &amp; fw : donor.forWhom())
  {
    if (std::find(existing_for_whom.begin(), existing_for_whom.end(), fw) ==
        existing_for_whom.end())
      acceptor.addForWhom(fw);
  }
}
}

bool
MooseApp::addRelationshipManager(std::shared_ptr&lt;RelationshipManager&gt; new_rm)
{
  // We prefer to always add geometric RMs. There is no hurt to add RMs for replicated mesh
  // since MeshBase::delete_remote_elements{} is a no-op (empty) for replicated mesh.
  // The motivation here is that MooseMesh::_use_distributed_mesh may not be properly set
  // at the time we are adding geometric relationship managers. We deleted the following
  // old logic to add all geometric RMs regardless of there is a distributed mesh or not.
  // Otherwise, all geometric RMs will be improperly ignored for a distributed mesh generator.

  // if (!_action_warehouse.mesh()-&gt;isDistributedMesh() &amp;&amp; !_split_mesh &amp;&amp;
  //    (relationship_manager-&gt;isType(Moose::RelationshipManagerType::GEOMETRIC) &amp;&amp;
  //     !(relationship_manager-&gt;isType(Moose::RelationshipManagerType::ALGEBRAIC) ||
  //       relationship_manager-&gt;isType(Moose::RelationshipManagerType::COUPLING))))
  //  return false;

  bool add = true;

  std::set&lt;std::shared_ptr&lt;RelationshipManager&gt;&gt; rms_to_erase;

  for (const auto &amp; existing_rm : _relationship_managers)
  {
    if (*existing_rm &gt;= *new_rm)
    {
      add = false;
      donateForWhom(*new_rm, *existing_rm);
      break;
    }
    // The new rm did not provide less or the same amount/type of ghosting as the existing rm, but
    // what about the other way around?
    else if (*new_rm &gt;= *existing_rm)
      rms_to_erase.emplace(existing_rm);
  }

  if (add)
  {
    _relationship_managers.emplace(new_rm);
    for (const auto &amp; rm_to_erase : rms_to_erase)
    {
      donateForWhom(*rm_to_erase, *new_rm);
      removeRelationshipManager(rm_to_erase);
    }
  }

  // Inform the caller whether the object was added or not
  return add;
}

const std::string &amp;
MooseApp::checkpointSuffix()
{
  static const std::string suffix = &quot;-mesh.cpa.gz&quot;;
  return suffix;
}

std::filesystem::path
MooseApp::metaDataFolderBase(const std::filesystem::path &amp; folder_base,
                             const std::string &amp; map_suffix)
{
  return RestartableDataIO::restartableDataFolder(folder_base /
                                                  std::filesystem::path(&quot;meta_data&quot; + map_suffix));
}

std::filesystem::path
MooseApp::restartFolderBase(const std::filesystem::path &amp; folder_base) const
{
  auto folder = folder_base;
  folder += &quot;-restart-&quot; + std::to_string(processor_id());
  return RestartableDataIO::restartableDataFolder(folder);
}

const hit::Node *
MooseApp::getCurrentActionHitNode() const
{
  if (const auto action = _action_warehouse.getCurrentAction())
    return action-&gt;parameters().getHitNode();
  return nullptr;
}

bool
MooseApp::hasRMClone(const RelationshipManager &amp; template_rm, const MeshBase &amp; mesh) const
{
  auto it = _template_to_clones.find(&amp;template_rm);
  // C++ does short circuiting so we&#x27;re safe here
  return (it != _template_to_clones.end()) &amp;&amp; (it-&gt;second.find(&amp;mesh) != it-&gt;second.end());
}

RelationshipManager &amp;
MooseApp::getRMClone(const RelationshipManager &amp; template_rm, const MeshBase &amp; mesh) const
{
  auto outer_it = _template_to_clones.find(&amp;template_rm);
  if (outer_it == _template_to_clones.end())
    mooseError(&quot;The template rm does not exist in our _template_to_clones map&quot;);

  auto &amp; mesh_to_clone_map = outer_it-&gt;second;
  auto inner_it = mesh_to_clone_map.find(&amp;mesh);
  if (inner_it == mesh_to_clone_map.end())
    mooseError(&quot;We should have the mesh key in our mesh&quot;);

  return *inner_it-&gt;second;
}

void
MooseApp::removeRelationshipManager(std::shared_ptr&lt;RelationshipManager&gt; rm)
{
  auto * const mesh = _action_warehouse.mesh().get();
  if (!mesh)
    mooseError(&quot;The MooseMesh should exist&quot;);

  const MeshBase * const undisp_lm_mesh = mesh-&gt;getMeshPtr();
  RelationshipManager * undisp_clone = nullptr;
  if (undisp_lm_mesh &amp;&amp; hasRMClone(*rm, *undisp_lm_mesh))
  {
    undisp_clone = &amp;getRMClone(*rm, *undisp_lm_mesh);
    const_cast&lt;MeshBase *&gt;(undisp_lm_mesh)-&gt;remove_ghosting_functor(*undisp_clone);
  }

  auto &amp; displaced_mesh = _action_warehouse.displacedMesh();
  MeshBase * const disp_lm_mesh = displaced_mesh ? &amp;displaced_mesh-&gt;getMesh() : nullptr;
  RelationshipManager * disp_clone = nullptr;
  if (disp_lm_mesh &amp;&amp; hasRMClone(*rm, *disp_lm_mesh))
  {
    disp_clone = &amp;getRMClone(*rm, *disp_lm_mesh);
    disp_lm_mesh-&gt;remove_ghosting_functor(*disp_clone);
  }

  if (_executioner)
  {
    auto &amp; problem = feProblem();
    if (undisp_clone)
    {
      problem.removeAlgebraicGhostingFunctor(*undisp_clone);
      problem.removeCouplingGhostingFunctor(*undisp_clone);
    }

    auto * dp = problem.getDisplacedProblem().get();
    if (dp &amp;&amp; disp_clone)
      dp-&gt;removeAlgebraicGhostingFunctor(*disp_clone);
  }

  _factory.releaseSharedObjects(*rm);
  _relationship_managers.erase(rm);
}

RelationshipManager &amp;
MooseApp::createRMFromTemplateAndInit(const RelationshipManager &amp; template_rm,
                                      MooseMesh &amp; moose_mesh,
                                      MeshBase &amp; mesh,
                                      const DofMap * const dof_map)
{
  auto &amp; mesh_to_clone = _template_to_clones[&amp;template_rm];
  auto it = mesh_to_clone.find(&amp;mesh);
  if (it != mesh_to_clone.end())
  {
    // We&#x27;ve already created a clone for this mesh
    auto &amp; clone_rm = *it-&gt;second;
    if (!clone_rm.dofMap() &amp;&amp; dof_map)
      // We didn&#x27;t have a DofMap before, but now we do, so we should re-init
      clone_rm.init(moose_mesh, mesh, dof_map);
    else if (clone_rm.dofMap() &amp;&amp; dof_map &amp;&amp; (clone_rm.dofMap() != dof_map))
      mooseError(&quot;Attempting to create and initialize an existing clone with a different DofMap. &quot;
                 &quot;This should not happen.&quot;);

    return clone_rm;
  }

  // It&#x27;s possible that this method is going to get called for multiple different MeshBase
  // objects. If that happens, then we *cannot* risk having a MeshBase object with a ghosting
  // functor that is init&#x27;d with another MeshBase object. So the safe thing to do is to make a
  // different RM for every MeshBase object that gets called here. Then the
  // RelationshipManagers stored here in MooseApp are serving as a template only
  auto pr = mesh_to_clone.emplace(
      std::make_pair(&amp;const_cast&lt;const MeshBase &amp;&gt;(mesh),
                     dynamic_pointer_cast&lt;RelationshipManager&gt;(template_rm.clone())));
  mooseAssert(pr.second, &quot;An insertion should have happened&quot;);
  auto &amp; clone_rm = *pr.first-&gt;second;
  clone_rm.init(moose_mesh, mesh, dof_map);
  return clone_rm;
}

void
MooseApp::attachRelationshipManagers(MeshBase &amp; mesh, MooseMesh &amp; moose_mesh)
{
  for (auto &amp; rm : _relationship_managers)
  {
    if (rm-&gt;isType(Moose::RelationshipManagerType::GEOMETRIC))
    {
      if (rm-&gt;attachGeometricEarly())
      {
        mesh.add_ghosting_functor(createRMFromTemplateAndInit(*rm, moose_mesh, mesh));
        _attached_relationship_managers[Moose::RelationshipManagerType::GEOMETRIC].insert(rm.get());
      }
      else
      {
        // If we have a geometric ghosting functor that can&#x27;t be attached early, then we have to
        // prevent the mesh from deleting remote elements
        moose_mesh.allowRemoteElementRemoval(false);

        if (const MeshBase * const moose_mesh_base = moose_mesh.getMeshPtr())
        {
          if (moose_mesh_base != &amp;mesh)
            mooseError(&quot;The MooseMesh MeshBase and the MeshBase we&#x27;re trying to attach &quot;
                       &quot;relationship managers to are different&quot;);
        }
        else
          // The MeshBase isn&#x27;t attached to the MooseMesh yet, so have to tell it not to remove
          // remote elements independently
          mesh.allow_remote_element_removal(false);
      }
    }
  }
}

void
MooseApp::attachRelationshipManagers(Moose::RelationshipManagerType rm_type,
                                     bool attach_geometric_rm_final)
{
  for (auto &amp; rm : _relationship_managers)
  {
    if (!rm-&gt;isType(rm_type))
      continue;

    // RM is already attached (this also handles the geometric early case)
    if (_attached_relationship_managers[rm_type].count(rm.get()))
      continue;

    if (rm_type == Moose::RelationshipManagerType::GEOMETRIC)
    {
      // The problem is not built yet - so the ActionWarehouse currently owns the mesh
      MooseMesh * const mesh = _action_warehouse.mesh().get();

      // &quot;attach_geometric_rm_final = true&quot; inidicate that it is the last chance to attach
      // geometric RMs. Therefore, we need to attach them.
      if (!rm-&gt;attachGeometricEarly() &amp;&amp; !attach_geometric_rm_final)
        // Will attach them later (during algebraic). But also, we need to tell the mesh that we
        // shouldn&#x27;t be deleting remote elements yet
        mesh-&gt;allowRemoteElementRemoval(false);
      else
      {
        MeshBase &amp; undisp_mesh_base = mesh-&gt;getMesh();
        const DofMap * const undisp_sys_dof_map =
            _executioner ? &amp;feProblem().getSolverSystem(0).dofMap() : nullptr;
        undisp_mesh_base.add_ghosting_functor(
            createRMFromTemplateAndInit(*rm, *mesh, undisp_mesh_base, undisp_sys_dof_map));

        // In the final stage, if there is a displaced mesh, we need to
        // clone ghosting functors for displacedMesh
        if (auto &amp; disp_moose_mesh = _action_warehouse.displacedMesh();
            attach_geometric_rm_final &amp;&amp; disp_moose_mesh)
        {
          MeshBase &amp; disp_mesh_base = _action_warehouse.displacedMesh()-&gt;getMesh();
          const DofMap * disp_sys_dof_map = nullptr;
          if (_executioner &amp;&amp; feProblem().getDisplacedProblem())
            disp_sys_dof_map = &amp;feProblem().getDisplacedProblem()-&gt;solverSys(0).dofMap();
          disp_mesh_base.add_ghosting_functor(
              createRMFromTemplateAndInit(*rm, *disp_moose_mesh, disp_mesh_base, disp_sys_dof_map));
        }
        else if (_action_warehouse.displacedMesh())
          mooseError(&quot;The displaced mesh should not yet exist at the time that we are attaching &quot;
                     &quot;early geometric relationship managers.&quot;);

        // Mark this RM as attached
        mooseAssert(!_attached_relationship_managers[rm_type].count(rm.get()), &quot;Already attached&quot;);
        _attached_relationship_managers[rm_type].insert(rm.get());
      }
    }
    else // rm_type is algebraic or coupling
    {
      if (!_executioner &amp;&amp; !_executor)
        mooseError(&quot;We must have an executioner by now or else we do not have to data to add &quot;
                   &quot;algebraic or coupling functors to in MooseApp::attachRelationshipManagers&quot;);

      // Now we&#x27;ve built the problem, so we can use it
      auto &amp; problem = feProblem();
      auto &amp; undisp_moose_mesh = problem.mesh();
      auto &amp; undisp_sys = feProblem().getSolverSystem(0);
      auto &amp; undisp_sys_dof_map = undisp_sys.dofMap();
      auto &amp; undisp_mesh = undisp_moose_mesh.getMesh();

      if (rm-&gt;useDisplacedMesh() &amp;&amp; problem.getDisplacedProblem())
      {
        if (rm_type == Moose::RelationshipManagerType::COUPLING)
          // We actually need to add this to the FEProblemBase NonlinearSystemBase&#x27;s DofMap
          // because the DisplacedProblem &quot;nonlinear&quot; DisplacedSystem doesn&#x27;t have any matrices
          // for which to do coupling. It&#x27;s actually horrifying to me that we are adding a
          // coupling functor, that is going to determine its couplings based on a displaced
          // MeshBase object, to a System associated with the undisplaced MeshBase object (there
          // is only ever one EquationSystems object per MeshBase object and visa versa). So here
          // I&#x27;m left with the choice of whether to pass in a MeshBase object that is *not* the
          // MeshBase object that will actually determine the couplings or to pass in the MeshBase
          // object that is inconsistent with the System DofMap that we are adding the coupling
          // functor for! Let&#x27;s err on the side of *libMesh* consistency and pass properly paired
          // MeshBase-DofMap
          problem.addCouplingGhostingFunctor(
              createRMFromTemplateAndInit(*rm, undisp_moose_mesh, undisp_mesh, &amp;undisp_sys_dof_map),
              /*to_mesh = */ false);

        else if (rm_type == Moose::RelationshipManagerType::ALGEBRAIC)
        {
          auto &amp; displaced_problem = *problem.getDisplacedProblem();
          auto &amp; disp_moose_mesh = displaced_problem.mesh();
          auto &amp; disp_mesh = disp_moose_mesh.getMesh();
          const DofMap * const disp_nl_dof_map = &amp;displaced_problem.solverSys(0).dofMap();
          displaced_problem.addAlgebraicGhostingFunctor(
              createRMFromTemplateAndInit(*rm, disp_moose_mesh, disp_mesh, disp_nl_dof_map),
              /*to_mesh = */ false);
        }
      }
      else // undisplaced
      {
        if (rm_type == Moose::RelationshipManagerType::COUPLING)
          problem.addCouplingGhostingFunctor(
              createRMFromTemplateAndInit(*rm, undisp_moose_mesh, undisp_mesh, &amp;undisp_sys_dof_map),
              /*to_mesh = */ false);

        else if (rm_type == Moose::RelationshipManagerType::ALGEBRAIC)
          problem.addAlgebraicGhostingFunctor(
              createRMFromTemplateAndInit(*rm, undisp_moose_mesh, undisp_mesh, &amp;undisp_sys_dof_map),
              /*to_mesh = */ false);
      }

      // Mark this RM as attached
      mooseAssert(!_attached_relationship_managers[rm_type].count(rm.get()), &quot;Already attached&quot;);
      _attached_relationship_managers[rm_type].insert(rm.get());
    }
  }
}

std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt;
MooseApp::getRelationshipManagerInfo() const
{
  std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; info_strings;
  info_strings.reserve(_relationship_managers.size());

  for (const auto &amp; rm : _relationship_managers)
  {
    std::stringstream oss;
    oss &lt;&lt; rm-&gt;getInfo();

    auto &amp; for_whom = rm-&gt;forWhom();

    if (!for_whom.empty())
    {
      oss &lt;&lt; &quot; for &quot;;

      std::copy(for_whom.begin(), for_whom.end(), infix_ostream_iterator&lt;std::string&gt;(oss, &quot;, &quot;));
    }

    info_strings.emplace_back(std::make_pair(Moose::stringify(rm-&gt;getType()), oss.str()));
  }

  // List the libMesh GhostingFunctors - Not that in libMesh all of the algebraic and coupling
  // Ghosting Functors are also attached to the mesh. This should catch them all.
  const auto &amp; mesh = _action_warehouse.getMesh();
  if (mesh)
  {
    // Let us use an ordered map to avoid stochastic console behaviors.
    // I believe we won&#x27;t have many RMs, and there is no performance issue.
    // Deterministic behaviors are good for setting up regression tests
    std::map&lt;std::string, unsigned int&gt; counts;

    for (auto &amp; gf : as_range(mesh-&gt;getMesh().ghosting_functors_begin(),
                              mesh-&gt;getMesh().ghosting_functors_end()))
    {
      const auto * gf_ptr = dynamic_cast&lt;const RelationshipManager *&gt;(gf);
      if (!gf_ptr)
        // Count how many occurences of the same Ghosting Functor types we are encountering
        counts[demangle(typeid(*gf).name())]++;
    }

    for (const auto &amp; pair : counts)
      info_strings.emplace_back(std::make_pair(
          &quot;Default&quot;, pair.first + (pair.second &gt; 1 ? &quot; x &quot; + std::to_string(pair.second) : &quot;&quot;)));
  }

  // List the libMesh GhostingFunctors - Not that in libMesh all of the algebraic and coupling
  // Ghosting Functors are also attached to the mesh. This should catch them all.
  const auto &amp; d_mesh = _action_warehouse.getDisplacedMesh();
  if (d_mesh)
  {
    // Let us use an ordered map to avoid stochastic console behaviors.
    // I believe we won&#x27;t have many RMs, and there is no performance issue.
    // Deterministic behaviors are good for setting up regression tests
    std::map&lt;std::string, unsigned int&gt; counts;

    for (auto &amp; gf : as_range(d_mesh-&gt;getMesh().ghosting_functors_begin(),
                              d_mesh-&gt;getMesh().ghosting_functors_end()))
    {
      const auto * gf_ptr = dynamic_cast&lt;const RelationshipManager *&gt;(gf);
      if (!gf_ptr)
        // Count how many occurences of the same Ghosting Functor types we are encountering
        counts[demangle(typeid(*gf).name())]++;
    }

    for (const auto &amp; pair : counts)
      info_strings.emplace_back(
          std::make_pair(&quot;Default&quot;,
                         pair.first + (pair.second &gt; 1 ? &quot; x &quot; + std::to_string(pair.second) : &quot;&quot;) +
                             &quot; for DisplacedMesh&quot;));
  }

  return info_strings;
}

void
MooseApp::checkMetaDataIntegrity() const
{
  for (auto map_iter = _restartable_meta_data.begin(); map_iter != _restartable_meta_data.end();
       ++map_iter)
  {
    const RestartableDataMapName &amp; name = map_iter-&gt;first;
    const RestartableDataMap &amp; meta_data = map_iter-&gt;second.first;

    std::vector&lt;std::string&gt; not_declared;

    for (const auto &amp; data : meta_data)
      if (!data.declared())
        not_declared.push_back(data.name());

    if (!not_declared.empty())
    {
      std::ostringstream oss;
      std::copy(
          not_declared.begin(), not_declared.end(), infix_ostream_iterator&lt;std::string&gt;(oss, &quot;, &quot;));

      mooseError(&quot;The following &#x27;&quot;,
                 name,
                 &quot;&#x27; meta-data properties were retrieved but never declared: &quot;,
                 oss.str());
    }
  }
}

const RestartableDataMapName MooseApp::MESH_META_DATA = &quot;MeshMetaData&quot;;
const RestartableDataMapName MooseApp::MESH_META_DATA_SUFFIX = &quot;mesh&quot;;

RestartableDataMap &amp;
MooseApp::getRestartableDataMap(const RestartableDataMapName &amp; name)
{
  auto iter = _restartable_meta_data.find(name);
  if (iter == _restartable_meta_data.end())
    mooseError(&quot;Unable to find RestartableDataMap object for the supplied name &#x27;&quot;,
               name,
               &quot;&#x27;, did you call registerRestartableDataMapName in the application constructor?&quot;);
  return iter-&gt;second.first;
}

bool
MooseApp::hasRestartableDataMap(const RestartableDataMapName &amp; name) const
{
  return _restartable_meta_data.count(name);
}

void
MooseApp::registerRestartableDataMapName(const RestartableDataMapName &amp; name, std::string suffix)
{
  if (!suffix.empty())
    std::transform(suffix.begin(), suffix.end(), suffix.begin(), ::tolower);
  suffix.insert(0, &quot;_&quot;);
  _restartable_meta_data.emplace(
      std::make_pair(name, std::make_pair(RestartableDataMap(), suffix)));
}

const std::string &amp;
MooseApp::getRestartableDataMapName(const RestartableDataMapName &amp; name) const
{
  const auto it = _restartable_meta_data.find(name);
  if (it == _restartable_meta_data.end())
    mooseError(&quot;MooseApp::getRestartableDataMapName: The name &#x27;&quot;, name, &quot;&#x27; is not registered&quot;);
  return it-&gt;second.second;
}

PerfGraph &amp;
MooseApp::createRecoverablePerfGraph()
{
  registerRestartableNameWithFilter(&quot;perf_graph&quot;, Moose::RESTARTABLE_FILTER::RECOVERABLE);

  auto perf_graph =
      std::make_unique&lt;RestartableData&lt;PerfGraph&gt;&gt;(&quot;perf_graph&quot;,
                                                   this,
                                                   type() + &quot; (&quot; + name() + &#x27;)&#x27;,
                                                   *this,
                                                   getParam&lt;bool&gt;(&quot;perf_graph_live_all&quot;),
                                                   !getParam&lt;bool&gt;(&quot;disable_perf_graph_live&quot;));

  return dynamic_cast&lt;RestartableData&lt;PerfGraph&gt; &amp;&gt;(
             registerRestartableData(std::move(perf_graph), 0, false))
      .set();
}

SolutionInvalidity &amp;
MooseApp::createRecoverableSolutionInvalidity()
{
  registerRestartableNameWithFilter(&quot;solution_invalidity&quot;, Moose::RESTARTABLE_FILTER::RECOVERABLE);

  auto solution_invalidity =
      std::make_unique&lt;RestartableData&lt;SolutionInvalidity&gt;&gt;(&quot;solution_invalidity&quot;, nullptr, *this);

  return dynamic_cast&lt;RestartableData&lt;SolutionInvalidity&gt; &amp;&gt;(
             registerRestartableData(std::move(solution_invalidity), 0, false))
      .set();
}

bool
MooseApp::constructingMeshGenerators() const
{
  return _action_warehouse.getCurrentTaskName() == &quot;create_added_mesh_generators&quot; ||
         _mesh_generator_system.appendingMeshGenerators();
}

#ifdef MOOSE_LIBTORCH_ENABLED
torch::DeviceType
MooseApp::determineLibtorchDeviceType(const MooseEnum &amp; device_enum) const
{
  const auto pname = &quot;--compute-device&quot;;
  if (device_enum == &quot;cuda&quot;)
  {
#ifdef __linux__
    if (!torch::cuda::is_available())
      mooseError(pname, &quot;=cuda: CUDA support is not available in the linked libtorch library&quot;);
    return torch::kCUDA;
#else
    mooseError(pname, &quot;=cuda: CUDA is not supported on your platform&quot;);
#endif
  }
  else if (device_enum == &quot;mps&quot;)
  {
#ifdef __APPLE__
    if (!torch::mps::is_available())
      mooseError(pname, &quot;=mps: MPS support is not available in the linked libtorch library&quot;);
    return torch::kMPS;
#else
    mooseError(pname, &quot;=mps: MPS is not supported on your platform&quot;);
#endif
  }

  else if (device_enum != &quot;cpu&quot;)
    mooseError(&quot;The device &#x27;&quot;,
               device_enum,
               &quot;&#x27; is not currently supported by the MOOSE libtorch integration.&quot;);
  return torch::kCPU;
}
#endif

void
MooseApp::outputMachineReadableData(const std::string &amp; param,
                                    const std::string &amp; start_marker,
                                    const std::string &amp; end_marker,
                                    const std::string &amp; data) const
{
  // Bool parameter, just to screen
  if (_pars.have_parameter&lt;bool&gt;(param))
  {
    Moose::out &lt;&lt; start_marker &lt;&lt; data &lt;&lt; end_marker &lt;&lt; std::endl;
    return;
  }

  // String parameter, to file
  const auto &amp; filename = getParam&lt;std::string&gt;(param);
  // write to file
  std::ofstream out(filename.c_str());
  if (out.is_open())
  {
    std::ofstream out(filename.c_str());
    out &lt;&lt; data &lt;&lt; std::flush;
    out.close();
  }
  else
    mooseError(&quot;Unable to open file `&quot;, filename, &quot;` for writing &quot;, param, &quot; data to it.&quot;);
}

void
MooseApp::addCapability(const std::string &amp; capability,
                        CapabilityUtils::Type value,
                        const std::string &amp; doc)
{
  checkReservedCapability(capability);
  Moose::Capabilities::getCapabilityRegistry().add(capability, value, doc);
}

void
MooseApp::addCapability(const std::string &amp; capability, const char * value, const std::string &amp; doc)
{
  checkReservedCapability(capability);
  Moose::Capabilities::getCapabilityRegistry().add(capability, std::string(value), doc);
}

#ifdef MOOSE_MFEM_ENABLED
void
MooseApp::setMFEMDevice(const std::string &amp; device_string, Moose::PassKey&lt;MFEMProblemSolve&gt;)
{
  const auto string_vec = MooseUtils::split(device_string, &quot;,&quot;);
  auto string_set = std::set&lt;std::string&gt;(string_vec.begin(), string_vec.end());
  if (!_mfem_device)
  {
    _mfem_device = std::make_shared&lt;mfem::Device&gt;(device_string);
    _mfem_devices = std::move(string_set);
    _mfem_device-&gt;Print(Moose::out);
  }
  else if (!device_string.empty() &amp;&amp; string_set != _mfem_devices)
    mooseError(&quot;Attempted to configure with MFEM devices &#x27;&quot;,
               MooseUtils::join(string_set, &quot; &quot;),
               &quot;&#x27;, but we have already configured the MFEM device object with the devices &#x27;&quot;,
               MooseUtils::join(_mfem_devices, &quot; &quot;),
               &quot;&#x27;&quot;);
}
#endif
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="2fe3a905-e57f-4bab-9b8e-3390acfb1f5a"><div class="modal-content"><h4>(moose/framework/src/outputs/Output.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Standard includes
#include &lt;cmath&gt;
#include &lt;limits&gt;

// MOOSE includes
#include &quot;Output.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Postprocessor.h&quot;
#include &quot;Restartable.h&quot;
#include &quot;FileMesh.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Console.h&quot;
#include &quot;Function.h&quot;
#include &quot;PiecewiseLinear.h&quot;
#include &quot;Times.h&quot;

#include &quot;libmesh/equation_systems.h&quot;

InputParameters
Output::validParams()
{
  // Get the parameters from the parent object
  InputParameters params = MooseObject::validParams();
  params += SetupInterface::validParams();

  // Displaced Mesh options
  params.addParam&lt;bool&gt;(
      &quot;use_displaced&quot;, false, &quot;Enable/disable the use of the displaced mesh for outputting&quot;);

  // Output intervals and timing
  params.addRangeCheckedParam&lt;unsigned int&gt;(
      &quot;time_step_interval&quot;,
      1,
      &quot;time_step_interval &gt; 0&quot;,
      &quot;The interval (number of time steps) at which output occurs. &quot;
      &quot;Unless explicitly set, the default value of this parameter is set &quot;
      &quot;to infinity if the wall_time_interval is explicitly set.&quot;);
  params.addParam&lt;Real&gt;(
      &quot;min_simulation_time_interval&quot;, 0.0, &quot;The minimum simulation time between output steps&quot;);
  params.addParam&lt;Real&gt;(&quot;simulation_time_interval&quot;,
                        std::numeric_limits&lt;Real&gt;::max(),
                        &quot;The target simulation time interval (in seconds) at which to output&quot;);
  params.addRangeCheckedParam&lt;Real&gt;(
      &quot;wall_time_interval&quot;,
      std::numeric_limits&lt;Real&gt;::max(),
      &quot;wall_time_interval &gt; 0&quot;,
      &quot;The target wall time interval (in seconds) at which to output&quot;);
  params.addParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;sync_times&quot;, {}, &quot;Times at which the output and solution is forced to occur&quot;);
  params.addParam&lt;TimesName&gt;(
      &quot;sync_times_object&quot;,
      &quot;Times object providing the times at which the output and solution is forced to occur&quot;);
  params.addParam&lt;bool&gt;(&quot;sync_only&quot;, false, &quot;Only export results at sync times&quot;);
  params.addParam&lt;Real&gt;(&quot;start_time&quot;, &quot;Time at which this output object begins to operate&quot;);
  params.addParam&lt;Real&gt;(&quot;end_time&quot;, &quot;Time at which this output object stop operating&quot;);
  params.addParam&lt;int&gt;(&quot;start_step&quot;, &quot;Time step at which this output object begins to operate&quot;);
  params.addParam&lt;int&gt;(&quot;end_step&quot;, &quot;Time step at which this output object stop operating&quot;);
  params.addParam&lt;Real&gt;(
      &quot;time_tolerance&quot;, 1e-14, &quot;Time tolerance utilized checking start and end times&quot;);
  params.addDeprecatedParam&lt;FunctionName&gt;(
      &quot;output_limiting_function&quot;,
      &quot;Piecewise base function that sets sync_times&quot;,
      &quot;Replaced by using the Times system with the sync_times_objects parameter&quot;);

  // Update the &#x27;execute_on&#x27; input parameter for output
  ExecFlagEnum &amp; exec_enum = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true);
  exec_enum = Output::getDefaultExecFlagEnum();
  exec_enum = {EXEC_INITIAL, EXEC_TIMESTEP_END};
  params.setDocString(&quot;execute_on&quot;, exec_enum.getDocString());

  // Add ability to append to the &#x27;execute_on&#x27; list
  params.addParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;, exec_enum, exec_enum.getDocString());
  params.set&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;).clearSetValues();
  params.addParamNamesToGroup(&quot;execute_on additional_execute_on&quot;, &quot;Execution scheduling&quot;);

  // &#x27;Timing&#x27; group
  params.addParamNamesToGroup(&quot;time_tolerance time_step_interval sync_times sync_times_object &quot;
                              &quot;sync_only start_time end_time &quot;
                              &quot;start_step end_step min_simulation_time_interval &quot;
                              &quot;simulation_time_interval wall_time_interval&quot;,
                              &quot;Timing and frequency of output&quot;);

  // Add a private parameter for indicating if it was created with short-cut syntax
  params.addPrivateParam&lt;bool&gt;(&quot;_built_by_moose&quot;, false);

  // Register this class as base class
  params.declareControllable(&quot;enable&quot;);
  params.registerBase(&quot;Output&quot;);

  return params;
}

ExecFlagEnum
Output::getDefaultExecFlagEnum()
{
  ExecFlagEnum exec_enum = MooseUtils::getDefaultExecFlagEnum();
  exec_enum.addAvailableFlags(EXEC_FAILED);
  return exec_enum;
}

Output::Output(const InputParameters &amp; parameters)
  : MooseObject(parameters),
    Restartable(this, &quot;Output&quot;),
    MeshChangedInterface(parameters),
    SetupInterface(this),
    FunctionInterface(this),
    PostprocessorInterface(this),
    VectorPostprocessorInterface(this),
    ReporterInterface(this),
    PerfGraphInterface(this),
    _problem_ptr(getParam&lt;FEProblemBase *&gt;(&quot;_fe_problem_base&quot;)),
    _transient(_problem_ptr-&gt;isTransient()),
    _use_displaced(getParam&lt;bool&gt;(&quot;use_displaced&quot;)),
    _es_ptr(nullptr),
    _mesh_ptr(nullptr),
    _execute_on(getParam&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;)),
    _current_execute_flag(EXEC_NONE),
    _time(_problem_ptr-&gt;time()),
    _time_old(_problem_ptr-&gt;timeOld()),
    _t_step(_problem_ptr-&gt;timeStep()),
    _dt(_problem_ptr-&gt;dt()),
    _dt_old(_problem_ptr-&gt;dtOld()),
    _num(0),
    _time_step_interval_set_by_addparam(parameters.isParamSetByAddParam(&quot;time_step_interval&quot;)),
    // If wall_time_interval is user-specified and time_step_interval is not,
    // override default value of time_step_interval so output does not occur
    // after every time step.
    _time_step_interval(
        (parameters.isParamSetByUser(&quot;wall_time_interval&quot;) &amp;&amp; _time_step_interval_set_by_addparam)
            ? std::numeric_limits&lt;unsigned int&gt;::max()
            : getParam&lt;unsigned int&gt;(&quot;time_step_interval&quot;)),
    _min_simulation_time_interval(getParam&lt;Real&gt;(&quot;min_simulation_time_interval&quot;)),
    _simulation_time_interval(getParam&lt;Real&gt;(&quot;simulation_time_interval&quot;)),
    _wall_time_interval(getParam&lt;Real&gt;(&quot;wall_time_interval&quot;)),
    _sync_times(std::set&lt;Real&gt;(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).begin(),
                               getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).end())),
    _sync_times_object(isParamValid(&quot;sync_times_object&quot;)
                           ? static_cast&lt;Times *&gt;(&amp;_problem_ptr-&gt;getUserObject&lt;Times&gt;(
                                 getParam&lt;TimesName&gt;(&quot;sync_times_object&quot;)))
                           : nullptr),
    _start_time(isParamValid(&quot;start_time&quot;) ? getParam&lt;Real&gt;(&quot;start_time&quot;)
                                           : std::numeric_limits&lt;Real&gt;::lowest()),
    _end_time(isParamValid(&quot;end_time&quot;) ? getParam&lt;Real&gt;(&quot;end_time&quot;)
                                       : std::numeric_limits&lt;Real&gt;::max()),
    _start_step(isParamValid(&quot;start_step&quot;) ? getParam&lt;int&gt;(&quot;start_step&quot;)
                                           : std::numeric_limits&lt;int&gt;::lowest()),
    _end_step(isParamValid(&quot;end_step&quot;) ? getParam&lt;int&gt;(&quot;end_step&quot;)
                                       : std::numeric_limits&lt;int&gt;::max()),
    _t_tol(getParam&lt;Real&gt;(&quot;time_tolerance&quot;)),
    _sync_only(getParam&lt;bool&gt;(&quot;sync_only&quot;)),
    _allow_output(true),
    _is_advanced(false),
    _advanced_execute_on(_execute_on, parameters),
    _last_output_simulation_time(declareRestartableData&lt;Real&gt;(&quot;last_output_simulation_time&quot;,
                                                              std::numeric_limits&lt;Real&gt;::lowest())),
    _last_output_wall_time(std::chrono::steady_clock::now())
{
  if (_use_displaced)
  {
    std::shared_ptr&lt;DisplacedProblem&gt; dp = _problem_ptr-&gt;getDisplacedProblem();
    if (dp != nullptr)
    {
      _es_ptr = &amp;dp-&gt;es();
      _mesh_ptr = &amp;dp-&gt;mesh();
    }
    else
    {
      mooseWarning(
          name(),
          &quot;: Parameter &#x27;use_displaced&#x27; ignored, there is no displaced problem in your simulation.&quot;);
      _es_ptr = &amp;_problem_ptr-&gt;es();
      _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
    }
  }
  else
  {
    _es_ptr = &amp;_problem_ptr-&gt;es();
    _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
  }

  // Apply the additional output flags
  if (isParamValid(&quot;additional_execute_on&quot;))
  {
    const ExecFlagEnum &amp; add = getParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;);
    for (auto &amp; me : add)
      _execute_on.setAdditionalValue(me);
  }

  if (isParamValid(&quot;output_limiting_function&quot;))
  {
    const Function &amp; olf = getFunction(&quot;output_limiting_function&quot;);
    const PiecewiseBase * pwb_olf = dynamic_cast&lt;const PiecewiseBase *&gt;(&amp;olf);
    if (pwb_olf == nullptr)
      mooseError(&quot;Function muse have a piecewise base!&quot;);

    for (auto i = 0; i &lt; pwb_olf-&gt;functionSize(); i++)
      _sync_times.insert(pwb_olf-&gt;domain(i));
  }

  // Get sync times from Times object if using
  if (_sync_times_object)
  {
    if (isParamValid(&quot;output_limiting_function&quot;) || isParamSetByUser(&quot;sync_times&quot;))
      paramError(&quot;sync_times_object&quot;,
                 &quot;Only one method of specifying sync times is supported at a time&quot;);
    else
      // Sync times for the time steppers are taken from the output warehouse. The output warehouse
      // takes sync times from the output objects immediately after the object is constructed. Hence
      // we must ensure that we set the `_sync_times` in the constructor
      _sync_times = _sync_times_object-&gt;getUniqueTimes();
  }
}

void
Output::solveSetup()
{
}

void
Output::outputStep(const ExecFlagType &amp; type)
{
  // Output is not allowed
  if (!_allow_output &amp;&amp; type != EXEC_FORCED)
    return;

  // If recovering disable output of initial condition, it was already output
  if (type == EXEC_INITIAL &amp;&amp; _app.isRecovering())
    return;

  // Return if the current output is not on the desired interval and there is
  // no signal to process
  const bool on_interval_or_exec_final = (onInterval() || (type == EXEC_FINAL));
  // Sync across processes and only output one time per signal received.
  comm().max(Moose::interrupt_signal_number);
  const bool signal_received = Moose::interrupt_signal_number;
  if (!(on_interval_or_exec_final || signal_received))
    return;

  // set current type
  _current_execute_flag = type;

  // Check whether we should output, then do it.
  if (shouldOutput())
  {
    // store current simulation time
    _last_output_simulation_time = _time;

    // store current wall time of output
    _last_output_wall_time = std::chrono::steady_clock::now();

    TIME_SECTION(&quot;outputStep&quot;, 2, &quot;Outputting Step&quot;);
    output();
  }

  _current_execute_flag = EXEC_NONE;
}

bool
Output::shouldOutput()
{
  if (_execute_on.isValueSet(_current_execute_flag) || _current_execute_flag == EXEC_FORCED)
    return true;
  return false;
}

bool
Output::onInterval()
{
  // The output flag to return
  bool output = false;

  // Return true if the current step on the current output interval and within the output time range
  // and within the output step range
  if (_time &gt;= _start_time &amp;&amp; _time &lt;= _end_time &amp;&amp; _t_step &gt;= _start_step &amp;&amp;
      _t_step &lt;= _end_step &amp;&amp; (_t_step % _time_step_interval) == 0)
    output = true;

  // Return false if &#x27;sync_only&#x27; is set to true
  if (_sync_only)
    output = false;

  if (_sync_times_object)
  {
    const auto &amp; sync_times = _sync_times_object-&gt;getUniqueTimes();
    if (sync_times != _sync_times)
      mooseError(&quot;The provided sync times object has changing time values. Only static time &quot;
                 &quot;values are supported since time steppers take sync times from the output &quot;
                 &quot;warehouse which determines its sync times at output construction time.&quot;);
  }

  // If sync times are not skipped, return true if the current time is a sync_time
  for (const auto _sync_time : _sync_times)
  {
    if (std::abs(_sync_time - _time) &lt; _t_tol)
      output = true;
  }

  // check if enough simulation time has passed between outputs
  if (_time &gt; _last_output_simulation_time &amp;&amp;
      _last_output_simulation_time + _min_simulation_time_interval &gt; _time + _t_tol)
    output = false;

  // check if enough wall time has passed between outputs
  const auto now = std::chrono::steady_clock::now();
  // count below returns an interger type, so lets express on a millisecond
  // scale and convert to seconds for finer resolution
  _wall_time_since_last_output =
      std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now - _last_output_wall_time).count() /
      1000.0;
  // Take the maximum wall time since last output accross all processors
  _communicator.max(_wall_time_since_last_output);
  if (_wall_time_since_last_output &gt;= _wall_time_interval)
    output = true;

  // Return the output status
  return output;
}

void
Output::setWallTimeIntervalFromCommandLineParam()
{
  if (_app.isParamValid(&quot;output_wall_time_interval&quot;))
  {
    _wall_time_interval = _app.getParam&lt;Real&gt;(&quot;output_wall_time_interval&quot;);

    // If default value of _wall_time_interval was just overriden and user did not
    // explicitly specify _time_step_interval, override default value of
    // _time_step_interval so output does not occur after every time step
    if (_time_step_interval_set_by_addparam)
      _time_step_interval = std::numeric_limits&lt;unsigned int&gt;::max();
  }
}

Real
Output::time()
{
  if (_transient)
    return _time;
  else
    return _t_step;
}

Real
Output::timeOld()
{
  if (_transient)
    return _time_old;
  else
    return _t_step - 1;
}

Real
Output::dt()
{
  if (_transient)
    return _dt;
  else
    return 1;
}

Real
Output::dtOld()
{
  if (_transient)
    return _dt_old;
  else
    return 1;
}

int
Output::timeStep()
{
  return _t_step;
}

const MultiMooseEnum &amp;
Output::executeOn() const
{
  return _execute_on;
}

bool
Output::isAdvanced()
{
  return _is_advanced;
}

const OutputOnWarehouse &amp;
Output::advancedExecuteOn() const
{
  mooseError(&quot;The output object &quot;, name(), &quot; is not an AdvancedOutput, use isAdvanced() to check.&quot;);
  return _advanced_execute_on;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="88f8da31-a8e2-4a06-8ceb-d67705d8c354"><div class="modal-content"><h4>(moose/framework/src/outputs/Output.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Standard includes
#include &lt;cmath&gt;
#include &lt;limits&gt;

// MOOSE includes
#include &quot;Output.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Postprocessor.h&quot;
#include &quot;Restartable.h&quot;
#include &quot;FileMesh.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Console.h&quot;
#include &quot;Function.h&quot;
#include &quot;PiecewiseLinear.h&quot;
#include &quot;Times.h&quot;

#include &quot;libmesh/equation_systems.h&quot;

InputParameters
Output::validParams()
{
  // Get the parameters from the parent object
  InputParameters params = MooseObject::validParams();
  params += SetupInterface::validParams();

  // Displaced Mesh options
  params.addParam&lt;bool&gt;(
      &quot;use_displaced&quot;, false, &quot;Enable/disable the use of the displaced mesh for outputting&quot;);

  // Output intervals and timing
  params.addRangeCheckedParam&lt;unsigned int&gt;(
      &quot;time_step_interval&quot;,
      1,
      &quot;time_step_interval &gt; 0&quot;,
      &quot;The interval (number of time steps) at which output occurs. &quot;
      &quot;Unless explicitly set, the default value of this parameter is set &quot;
      &quot;to infinity if the wall_time_interval is explicitly set.&quot;);
  params.addParam&lt;Real&gt;(
      &quot;min_simulation_time_interval&quot;, 0.0, &quot;The minimum simulation time between output steps&quot;);
  params.addParam&lt;Real&gt;(&quot;simulation_time_interval&quot;,
                        std::numeric_limits&lt;Real&gt;::max(),
                        &quot;The target simulation time interval (in seconds) at which to output&quot;);
  params.addRangeCheckedParam&lt;Real&gt;(
      &quot;wall_time_interval&quot;,
      std::numeric_limits&lt;Real&gt;::max(),
      &quot;wall_time_interval &gt; 0&quot;,
      &quot;The target wall time interval (in seconds) at which to output&quot;);
  params.addParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;sync_times&quot;, {}, &quot;Times at which the output and solution is forced to occur&quot;);
  params.addParam&lt;TimesName&gt;(
      &quot;sync_times_object&quot;,
      &quot;Times object providing the times at which the output and solution is forced to occur&quot;);
  params.addParam&lt;bool&gt;(&quot;sync_only&quot;, false, &quot;Only export results at sync times&quot;);
  params.addParam&lt;Real&gt;(&quot;start_time&quot;, &quot;Time at which this output object begins to operate&quot;);
  params.addParam&lt;Real&gt;(&quot;end_time&quot;, &quot;Time at which this output object stop operating&quot;);
  params.addParam&lt;int&gt;(&quot;start_step&quot;, &quot;Time step at which this output object begins to operate&quot;);
  params.addParam&lt;int&gt;(&quot;end_step&quot;, &quot;Time step at which this output object stop operating&quot;);
  params.addParam&lt;Real&gt;(
      &quot;time_tolerance&quot;, 1e-14, &quot;Time tolerance utilized checking start and end times&quot;);
  params.addDeprecatedParam&lt;FunctionName&gt;(
      &quot;output_limiting_function&quot;,
      &quot;Piecewise base function that sets sync_times&quot;,
      &quot;Replaced by using the Times system with the sync_times_objects parameter&quot;);

  // Update the &#x27;execute_on&#x27; input parameter for output
  ExecFlagEnum &amp; exec_enum = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true);
  exec_enum = Output::getDefaultExecFlagEnum();
  exec_enum = {EXEC_INITIAL, EXEC_TIMESTEP_END};
  params.setDocString(&quot;execute_on&quot;, exec_enum.getDocString());

  // Add ability to append to the &#x27;execute_on&#x27; list
  params.addParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;, exec_enum, exec_enum.getDocString());
  params.set&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;).clearSetValues();
  params.addParamNamesToGroup(&quot;execute_on additional_execute_on&quot;, &quot;Execution scheduling&quot;);

  // &#x27;Timing&#x27; group
  params.addParamNamesToGroup(&quot;time_tolerance time_step_interval sync_times sync_times_object &quot;
                              &quot;sync_only start_time end_time &quot;
                              &quot;start_step end_step min_simulation_time_interval &quot;
                              &quot;simulation_time_interval wall_time_interval&quot;,
                              &quot;Timing and frequency of output&quot;);

  // Add a private parameter for indicating if it was created with short-cut syntax
  params.addPrivateParam&lt;bool&gt;(&quot;_built_by_moose&quot;, false);

  // Register this class as base class
  params.declareControllable(&quot;enable&quot;);
  params.registerBase(&quot;Output&quot;);

  return params;
}

ExecFlagEnum
Output::getDefaultExecFlagEnum()
{
  ExecFlagEnum exec_enum = MooseUtils::getDefaultExecFlagEnum();
  exec_enum.addAvailableFlags(EXEC_FAILED);
  return exec_enum;
}

Output::Output(const InputParameters &amp; parameters)
  : MooseObject(parameters),
    Restartable(this, &quot;Output&quot;),
    MeshChangedInterface(parameters),
    SetupInterface(this),
    FunctionInterface(this),
    PostprocessorInterface(this),
    VectorPostprocessorInterface(this),
    ReporterInterface(this),
    PerfGraphInterface(this),
    _problem_ptr(getParam&lt;FEProblemBase *&gt;(&quot;_fe_problem_base&quot;)),
    _transient(_problem_ptr-&gt;isTransient()),
    _use_displaced(getParam&lt;bool&gt;(&quot;use_displaced&quot;)),
    _es_ptr(nullptr),
    _mesh_ptr(nullptr),
    _execute_on(getParam&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;)),
    _current_execute_flag(EXEC_NONE),
    _time(_problem_ptr-&gt;time()),
    _time_old(_problem_ptr-&gt;timeOld()),
    _t_step(_problem_ptr-&gt;timeStep()),
    _dt(_problem_ptr-&gt;dt()),
    _dt_old(_problem_ptr-&gt;dtOld()),
    _num(0),
    _time_step_interval_set_by_addparam(parameters.isParamSetByAddParam(&quot;time_step_interval&quot;)),
    // If wall_time_interval is user-specified and time_step_interval is not,
    // override default value of time_step_interval so output does not occur
    // after every time step.
    _time_step_interval(
        (parameters.isParamSetByUser(&quot;wall_time_interval&quot;) &amp;&amp; _time_step_interval_set_by_addparam)
            ? std::numeric_limits&lt;unsigned int&gt;::max()
            : getParam&lt;unsigned int&gt;(&quot;time_step_interval&quot;)),
    _min_simulation_time_interval(getParam&lt;Real&gt;(&quot;min_simulation_time_interval&quot;)),
    _simulation_time_interval(getParam&lt;Real&gt;(&quot;simulation_time_interval&quot;)),
    _wall_time_interval(getParam&lt;Real&gt;(&quot;wall_time_interval&quot;)),
    _sync_times(std::set&lt;Real&gt;(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).begin(),
                               getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).end())),
    _sync_times_object(isParamValid(&quot;sync_times_object&quot;)
                           ? static_cast&lt;Times *&gt;(&amp;_problem_ptr-&gt;getUserObject&lt;Times&gt;(
                                 getParam&lt;TimesName&gt;(&quot;sync_times_object&quot;)))
                           : nullptr),
    _start_time(isParamValid(&quot;start_time&quot;) ? getParam&lt;Real&gt;(&quot;start_time&quot;)
                                           : std::numeric_limits&lt;Real&gt;::lowest()),
    _end_time(isParamValid(&quot;end_time&quot;) ? getParam&lt;Real&gt;(&quot;end_time&quot;)
                                       : std::numeric_limits&lt;Real&gt;::max()),
    _start_step(isParamValid(&quot;start_step&quot;) ? getParam&lt;int&gt;(&quot;start_step&quot;)
                                           : std::numeric_limits&lt;int&gt;::lowest()),
    _end_step(isParamValid(&quot;end_step&quot;) ? getParam&lt;int&gt;(&quot;end_step&quot;)
                                       : std::numeric_limits&lt;int&gt;::max()),
    _t_tol(getParam&lt;Real&gt;(&quot;time_tolerance&quot;)),
    _sync_only(getParam&lt;bool&gt;(&quot;sync_only&quot;)),
    _allow_output(true),
    _is_advanced(false),
    _advanced_execute_on(_execute_on, parameters),
    _last_output_simulation_time(declareRestartableData&lt;Real&gt;(&quot;last_output_simulation_time&quot;,
                                                              std::numeric_limits&lt;Real&gt;::lowest())),
    _last_output_wall_time(std::chrono::steady_clock::now())
{
  if (_use_displaced)
  {
    std::shared_ptr&lt;DisplacedProblem&gt; dp = _problem_ptr-&gt;getDisplacedProblem();
    if (dp != nullptr)
    {
      _es_ptr = &amp;dp-&gt;es();
      _mesh_ptr = &amp;dp-&gt;mesh();
    }
    else
    {
      mooseWarning(
          name(),
          &quot;: Parameter &#x27;use_displaced&#x27; ignored, there is no displaced problem in your simulation.&quot;);
      _es_ptr = &amp;_problem_ptr-&gt;es();
      _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
    }
  }
  else
  {
    _es_ptr = &amp;_problem_ptr-&gt;es();
    _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
  }

  // Apply the additional output flags
  if (isParamValid(&quot;additional_execute_on&quot;))
  {
    const ExecFlagEnum &amp; add = getParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;);
    for (auto &amp; me : add)
      _execute_on.setAdditionalValue(me);
  }

  if (isParamValid(&quot;output_limiting_function&quot;))
  {
    const Function &amp; olf = getFunction(&quot;output_limiting_function&quot;);
    const PiecewiseBase * pwb_olf = dynamic_cast&lt;const PiecewiseBase *&gt;(&amp;olf);
    if (pwb_olf == nullptr)
      mooseError(&quot;Function muse have a piecewise base!&quot;);

    for (auto i = 0; i &lt; pwb_olf-&gt;functionSize(); i++)
      _sync_times.insert(pwb_olf-&gt;domain(i));
  }

  // Get sync times from Times object if using
  if (_sync_times_object)
  {
    if (isParamValid(&quot;output_limiting_function&quot;) || isParamSetByUser(&quot;sync_times&quot;))
      paramError(&quot;sync_times_object&quot;,
                 &quot;Only one method of specifying sync times is supported at a time&quot;);
    else
      // Sync times for the time steppers are taken from the output warehouse. The output warehouse
      // takes sync times from the output objects immediately after the object is constructed. Hence
      // we must ensure that we set the `_sync_times` in the constructor
      _sync_times = _sync_times_object-&gt;getUniqueTimes();
  }
}

void
Output::solveSetup()
{
}

void
Output::outputStep(const ExecFlagType &amp; type)
{
  // Output is not allowed
  if (!_allow_output &amp;&amp; type != EXEC_FORCED)
    return;

  // If recovering disable output of initial condition, it was already output
  if (type == EXEC_INITIAL &amp;&amp; _app.isRecovering())
    return;

  // Return if the current output is not on the desired interval and there is
  // no signal to process
  const bool on_interval_or_exec_final = (onInterval() || (type == EXEC_FINAL));
  // Sync across processes and only output one time per signal received.
  comm().max(Moose::interrupt_signal_number);
  const bool signal_received = Moose::interrupt_signal_number;
  if (!(on_interval_or_exec_final || signal_received))
    return;

  // set current type
  _current_execute_flag = type;

  // Check whether we should output, then do it.
  if (shouldOutput())
  {
    // store current simulation time
    _last_output_simulation_time = _time;

    // store current wall time of output
    _last_output_wall_time = std::chrono::steady_clock::now();

    TIME_SECTION(&quot;outputStep&quot;, 2, &quot;Outputting Step&quot;);
    output();
  }

  _current_execute_flag = EXEC_NONE;
}

bool
Output::shouldOutput()
{
  if (_execute_on.isValueSet(_current_execute_flag) || _current_execute_flag == EXEC_FORCED)
    return true;
  return false;
}

bool
Output::onInterval()
{
  // The output flag to return
  bool output = false;

  // Return true if the current step on the current output interval and within the output time range
  // and within the output step range
  if (_time &gt;= _start_time &amp;&amp; _time &lt;= _end_time &amp;&amp; _t_step &gt;= _start_step &amp;&amp;
      _t_step &lt;= _end_step &amp;&amp; (_t_step % _time_step_interval) == 0)
    output = true;

  // Return false if &#x27;sync_only&#x27; is set to true
  if (_sync_only)
    output = false;

  if (_sync_times_object)
  {
    const auto &amp; sync_times = _sync_times_object-&gt;getUniqueTimes();
    if (sync_times != _sync_times)
      mooseError(&quot;The provided sync times object has changing time values. Only static time &quot;
                 &quot;values are supported since time steppers take sync times from the output &quot;
                 &quot;warehouse which determines its sync times at output construction time.&quot;);
  }

  // If sync times are not skipped, return true if the current time is a sync_time
  for (const auto _sync_time : _sync_times)
  {
    if (std::abs(_sync_time - _time) &lt; _t_tol)
      output = true;
  }

  // check if enough simulation time has passed between outputs
  if (_time &gt; _last_output_simulation_time &amp;&amp;
      _last_output_simulation_time + _min_simulation_time_interval &gt; _time + _t_tol)
    output = false;

  // check if enough wall time has passed between outputs
  const auto now = std::chrono::steady_clock::now();
  // count below returns an interger type, so lets express on a millisecond
  // scale and convert to seconds for finer resolution
  _wall_time_since_last_output =
      std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now - _last_output_wall_time).count() /
      1000.0;
  // Take the maximum wall time since last output accross all processors
  _communicator.max(_wall_time_since_last_output);
  if (_wall_time_since_last_output &gt;= _wall_time_interval)
    output = true;

  // Return the output status
  return output;
}

void
Output::setWallTimeIntervalFromCommandLineParam()
{
  if (_app.isParamValid(&quot;output_wall_time_interval&quot;))
  {
    _wall_time_interval = _app.getParam&lt;Real&gt;(&quot;output_wall_time_interval&quot;);

    // If default value of _wall_time_interval was just overriden and user did not
    // explicitly specify _time_step_interval, override default value of
    // _time_step_interval so output does not occur after every time step
    if (_time_step_interval_set_by_addparam)
      _time_step_interval = std::numeric_limits&lt;unsigned int&gt;::max();
  }
}

Real
Output::time()
{
  if (_transient)
    return _time;
  else
    return _t_step;
}

Real
Output::timeOld()
{
  if (_transient)
    return _time_old;
  else
    return _t_step - 1;
}

Real
Output::dt()
{
  if (_transient)
    return _dt;
  else
    return 1;
}

Real
Output::dtOld()
{
  if (_transient)
    return _dt_old;
  else
    return 1;
}

int
Output::timeStep()
{
  return _t_step;
}

const MultiMooseEnum &amp;
Output::executeOn() const
{
  return _execute_on;
}

bool
Output::isAdvanced()
{
  return _is_advanced;
}

const OutputOnWarehouse &amp;
Output::advancedExecuteOn() const
{
  mooseError(&quot;The output object &quot;, name(), &quot; is not an AdvancedOutput, use isAdvanced() to check.&quot;);
  return _advanced_execute_on;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="3d524bb1-7622-451a-9fec-d0ed386e425d"><div class="modal-content"><h4>(moose/framework/include/interfaces/SetupInterface.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;MooseTypes.h&quot;
#include &quot;ExecFlagEnum.h&quot;
#include &quot;MooseEnum.h&quot;
#include &quot;InputParameters.h&quot;

// Forward declarations
class InputParameters;
class MooseObject;
template &lt;typename T&gt;
InputParameters validParams();

class SetupInterface
{
public:
  SetupInterface(const MooseObject * moose_object);

#ifdef MOOSE_KOKKOS_ENABLED
  /**
   * Special constructor used for Kokkos functor copy during parallel dispatch
   */
  SetupInterface(const SetupInterface &amp; object, const Moose::Kokkos::FunctorCopy &amp; key);
#endif

  virtual ~SetupInterface();

  static InputParameters validParams();

  /**
   * Gets called at the beginning of the simulation before this object is asked to do its job
   */
  virtual void initialSetup();

  /**
   * Gets called at the beginning of the timestep before this object is asked to do its job
   */
  virtual void timestepSetup();

  /**
   * Gets called just before the Jacobian is computed and before this object is asked to do its job
   */
  virtual void jacobianSetup();

  /**
   * Gets called just before the residual is computed and before this object is asked to do its job
   */
  virtual void residualSetup();

  /**
   * Gets called when the subdomain changes (i.e. in a Jacobian or residual loop) and before this
   * object is asked to do its job
   */
  virtual void subdomainSetup();

  /**
   * Gets called in FEProblemBase::execute() for execute flags other than initial, timestep_begin,
   * nonlinear, linear and subdomain
   */
  virtual void customSetup(const ExecFlagType &amp; /*exec_type*/) {}

  /**
   * Return the execute on MultiMooseEnum for this object.
   */
  const ExecFlagEnum &amp; getExecuteOnEnum() const;

private:
  /// Empty ExecFlagEnum for the case when the &quot;execute_on&quot; parameter is not included. This
  /// is private because others should not be messing with it.
  ExecFlagEnum _empty_execute_enum;

protected:
  /// Execute settings for this object.
  const ExecFlagEnum &amp; _execute_enum;

  /// Reference to FEProblemBase
  const ExecFlagType &amp; _current_execute_flag;

  // FEProblemBase::addMultiApp needs to reset the execution flags
  friend class FEProblemBase;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="7cc75a4b-ea72-4373-8928-78616f58226e"><div class="modal-content"><h4>(moose/modules/level_set/include/base/LevelSetTypes.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Moose.h&quot;

namespace LevelSet
{
extern const ExecFlagType EXEC_ADAPT_MESH;
extern const ExecFlagType EXEC_COMPUTE_MARKERS;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="c239a6a9-1c86-4781-8769-5a5e368e89eb"><div class="modal-content"><h4>(moose/modules/level_set/src/base/LevelSetTypes.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Level set includes
#include &quot;LevelSetTypes.h&quot;

// MOOSE includes
#include &quot;ExecFlagRegistry.h&quot;

const ExecFlagType LevelSet::EXEC_ADAPT_MESH = registerExecFlag(&quot;ADAPT_MESH&quot;);
const ExecFlagType LevelSet::EXEC_COMPUTE_MARKERS = registerExecFlag(&quot;COMPUTE_MARKERS&quot;);
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="5fcbb03f-136c-4b57-806f-87f80c1938dc"><div class="modal-content"><h4>(moose/modules/level_set/src/transfers/LevelSetMeshRefinementTransfer.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;LevelSetMeshRefinementTransfer.h&quot;

// MOOSE includes
#include &quot;Adaptivity.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;MooseVariable.h&quot;
#include &quot;MultiApp.h&quot;
#include &quot;LevelSetTypes.h&quot;

registerMooseObject(&quot;LevelSetApp&quot;, LevelSetMeshRefinementTransfer);

InputParameters
LevelSetMeshRefinementTransfer::validParams()
{
  InputParameters params = MultiAppCopyTransfer::validParams();
  params.addClassDescription(&quot;Transfers the mesh from the master application to the sub &quot;
                             &quot;application for the purposes of level set reinitialization problems &quot;
                             &quot;with mesh adaptivity.&quot;);
  params.suppressParameter&lt;MultiMooseEnum&gt;(&quot;direction&quot;);

  ExecFlagEnum &amp; exec = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);
  exec.addAvailableFlags(LevelSet::EXEC_ADAPT_MESH, LevelSet::EXEC_COMPUTE_MARKERS);
  exec = {LevelSet::EXEC_COMPUTE_MARKERS, LevelSet::EXEC_ADAPT_MESH};
  params.set&lt;bool&gt;(&quot;check_multiapp_execute_on&quot;) = false;
  params.suppressParameter&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);

  return params;
}

LevelSetMeshRefinementTransfer::LevelSetMeshRefinementTransfer(const InputParameters &amp; parameters)
  : MultiAppCopyTransfer(parameters)
{
  if (hasFromMultiApp())
    paramError(&quot;from_multi_app&quot;, &quot;from_multiapp or between_multiapp transfers are not supported&quot;);
}

void
LevelSetMeshRefinementTransfer::initialSetup()
{
  FEProblemBase &amp; from_problem = getToMultiApp()-&gt;problemBase();
  for (unsigned int i = 0; i &lt; getToMultiApp()-&gt;numGlobalApps(); i++)
    if (getToMultiApp()-&gt;hasLocalApp(i))
    {
      FEProblemBase &amp; to_problem = getToMultiApp()-&gt;appProblemBase(i);
      MooseVariable &amp; to_var = to_problem.getStandardVariable(0, _to_var_name);
      Adaptivity &amp; adapt = to_problem.adaptivity();
      adapt.setMarkerVariableName(to_var.name());
      adapt.setCyclesPerStep(from_problem.adaptivity().getCyclesPerStep());
      adapt.init(1, 0, false);
      adapt.setUseNewSystem();
      adapt.setMaxHLevel(from_problem.adaptivity().getMaxHLevel());
      adapt.setAdaptivityOn(false);
    }
}

void
LevelSetMeshRefinementTransfer::execute()
{
  if (_current_execute_flag == LevelSet::EXEC_COMPUTE_MARKERS)
    MultiAppCopyTransfer::execute();

  else if (_current_execute_flag == LevelSet::EXEC_ADAPT_MESH)
  {
    for (unsigned int i = 0; i &lt; getToMultiApp()-&gt;numGlobalApps(); i++)
      if (getToMultiApp()-&gt;hasLocalApp(i))
      {
        FEProblemBase &amp; to_problem = getToMultiApp()-&gt;appProblemBase(i);
        Adaptivity &amp; adapt = to_problem.adaptivity();
        adapt.setAdaptivityOn(true);
        to_problem.adaptMesh();
        adapt.setAdaptivityOn(false);
      }
  }
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="cb27975b-70b4-45f5-86c9-0893d5174d4c"><div class="modal-content"><h4>(moose/modules/level_set/src/base/LevelSetProblem.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;LevelSetProblem.h&quot;
#include &quot;LevelSetTypes.h&quot;

#include &quot;MultiAppTransfer.h&quot;

registerMooseObject(&quot;LevelSetApp&quot;, LevelSetProblem);

InputParameters
LevelSetProblem::validParams()
{
  InputParameters params = FEProblem::validParams();
  params.addClassDescription(&quot;A specilized problem class that adds a custom call to &quot;
                             &quot;MultiAppTransfer execution to transfer adaptivity for the level set &quot;
                             &quot;reinitialization.&quot;);
  return params;
}

LevelSetProblem::LevelSetProblem(const InputParameters &amp; parameters) : FEProblem(parameters) {}

void
LevelSetProblem::computeMarkers()
{
  FEProblem::computeMarkers();
  setCurrentExecuteOnFlag(LevelSet::EXEC_COMPUTE_MARKERS);
  execMultiAppTransfers(LevelSet::EXEC_COMPUTE_MARKERS, MultiAppTransfer::TO_MULTIAPP);
  setCurrentExecuteOnFlag(EXEC_NONE);
}

bool
LevelSetProblem::adaptMesh()
{
  bool adapt = FEProblem::adaptMesh();
  setCurrentExecuteOnFlag(LevelSet::EXEC_ADAPT_MESH);
  execMultiAppTransfers(LevelSet::EXEC_ADAPT_MESH, MultiAppTransfer::TO_MULTIAPP);
  setCurrentExecuteOnFlag(EXEC_NONE);
  return adapt;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
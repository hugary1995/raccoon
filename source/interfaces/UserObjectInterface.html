<!DOCTYPE html><head><meta charset="UTF-8"><title>UserObjectInterface | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="ea3a5fe8-6216-4135-b8b2-b6fe7a830dfd" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="a327c060-da51-4e62-a67c-3ce950830b01" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="117d8380-e384-4a59-b85a-51750497fa73" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ab6635ee-03d4-4524-9820-958045ba9ffd" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="69b94b66-478d-49f4-8b8b-23dc9fa2be1e"><i class="material-icons">menu</i></a><ul class="sidenav" id="69b94b66-478d-49f4-8b8b-23dc9fa2be1e"><li><a href="#!" class="dropdown-trigger" data-target="b6adf36c-a12d-4336-a6cf-a74859bbdf02" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="e395970e-e62a-4c4d-9446-1326884b48da" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="52cecb0b-9298-456e-b79c-e90e5b04f93a" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ac73f85f-bb44-493c-a16e-d69f1cced4cf" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="ea3a5fe8-6216-4135-b8b2-b6fe7a830dfd"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="a327c060-da51-4e62-a67c-3ce950830b01"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="117d8380-e384-4a59-b85a-51750497fa73"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="ab6635ee-03d4-4524-9820-958045ba9ffd"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="b6adf36c-a12d-4336-a6cf-a74859bbdf02"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="e395970e-e62a-4c4d-9446-1326884b48da"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="52cecb0b-9298-456e-b79c-e90e5b04f93a"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="ac73f85f-bb44-493c-a16e-d69f1cced4cf"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="dd8ab82b-0dc1-47fd-920f-3f3d45ad4ac5" data-section-level="1" data-section-text="UserObjectInterface"><h1 id="userobjectinterface">UserObjectInterface</h1><p>The UserObjectInterface defines the methods used for retrieving const references to the specific types of UserObjects. This is done with templated methods so that use of the UserObject does not require a dynamic cast. Many objects in MOOSE support the retrieval of these references so that custom UserObject APIs may be used in calculations. UserObjects are generally executed after most other systems in MOOSE so these values are often lagged when being used in another calculation.</p><section id="b2cb0520-c71f-4f3f-8a14-b6a9865b99aa" data-section-level="2" data-section-text="End Use API"><h2 id="end-use-api">End Use API</h2><p>Most objects in MOOSE will retrieve UserObjects through special macro functions found here:</p><pre style="max-height:350px;"><code class="language-cpp">
#pragma once

// MOOSE includes
#include &quot;MooseTypes.h&quot;
#include &quot;MooseUtils.h&quot;

// Forward declarations
class UserObject;
class FEProblemBase;
class MooseObject;

/**
 * Interface for objects that need to use UserObjects.
 */
class UserObjectInterface
{
public:
  static InputParameters validParams();

  UserObjectInterface(const MooseObject * moose_object);

#ifdef MOOSE_KOKKOS_ENABLED
  /**
   * Special constructor used for Kokkos functor copy during parallel dispatch
   */
  UserObjectInterface(const UserObjectInterface &amp; object, const Moose::Kokkos::FunctorCopy &amp; key);
#endif

  /**
   * @return The name of the user object associated with the parameter \p param_name
   */
  UserObjectName getUserObjectName(const std::string &amp; param_name) const;

  /**
   * @return Whether or not a UserObject exists with the name given by the parameter \p param_name.
   */
  ///@{
  bool hasUserObject(const std::string &amp; param_name) const;
  template &lt;class T&gt;
  bool hasUserObject(const std::string &amp; param_name) const;
  ///@}

  /*
   * @return Whether or not a UserObject exists with the name \p object_name.
   */
  ///@{
  bool hasUserObjectByName(const UserObjectName &amp; object_name) const;
  template &lt;class T&gt;
  bool hasUserObjectByName(const UserObjectName &amp; object_name) const;
  ///@}

  /**
   * Get an user object with a given parameter \p param_name
   * @param param_name The name of the parameter key of the user object to retrieve
   * @param is_dependency Whether the user object we are retrieving should be viewed as a
   * dependency, e.g. whether the retrieved user object should be sorted and executed before this
   * object (if we are a user object)
   * @return The user object with name associated with the parameter \p param_name
   */
  template &lt;class T&gt;
  const T &amp; getUserObject(const std::string &amp; param_name, bool is_dependency = true) const;

  /**
   * Get an user object with the name \p object_name
   * @param object_name The name of the user object to retrieve
   * @param is_dependency Whether the user object we are retrieving should be viewed as a
   * dependency, e.g. whether the retrieved user object should be sorted and executed before this
   * object (if we are a user object)
   * @return The user object with the name \p object_name
   */
  template &lt;class T&gt;
  const T &amp; getUserObjectByName(const UserObjectName &amp; object_name,
                                bool is_dependency = true) const;

  /**
   * Get an user object with a given parameter \p param_name
   * @param param_name The name of the parameter key of the user object to retrieve
   * @param is_dependency Whether the user object we are retrieving should be viewed as a
   * dependency, e.g. whether the retrieved user object should be sorted and executed before this
   * object (if we are a user object)
   * @return The user object with name associated with the parameter \p param_name
   */
  const UserObject &amp; getUserObjectBase(const std::string &amp; param_name,
                                       bool is_dependency = true) const;

  /**
   * Get an user object with the name \p object_name
   * @param object_name The name of the user object to retrieve
   * @param is_dependency Whether the user object we are retrieving should be viewed as a
   * dependency, e.g. whether the retrieved user object should be sorted and executed before this
   * object (if we are a user object)
   * @return The user object with the name \p object_name
   */
  const UserObject &amp; getUserObjectBaseByName(const UserObjectName &amp; object_name,
                                             bool is_dependency = true) const;

protected:
  /**
   * Helper for deriving classes to override to add dependencies when a UserObject
   * is requested.
   */
  virtual void addUserObjectDependencyHelper(const UserObject &amp; /* uo */) const {}

private:
  /**
   * Go directly to the FEProblem for the requested \p UserObject
   */
  const UserObject &amp; getUserObjectFromFEProblem(const UserObjectName &amp; object_name) const;

  /**
   * Internal helper that casts the UserObject \p uo_base to the requested type. Exits with
   * a useful error if the casting failed. If the parameter \p param_name is provided and
   * is valid, a paramError() will be used instead.
   */
  template &lt;class T&gt;
  const T &amp; castUserObject(const UserObject &amp; uo_base, const std::string &amp; param_name = &quot;&quot;) const;

  /**
   * emit an error for the given parameter
   */
  void mooseObjectError(const std::string &amp; param_name, std::stringstream &amp; oss) const;

  /// Gets a UserObject&#x27;s type; avoids including UserObject.h in the UserObjectInterface
  const std::string &amp; userObjectType(const UserObject &amp; uo) const;
  /// Gets a UserObject&#x27;s name; avoids including UserObject.h in the UserObjectInterface
  const std::string &amp; userObjectName(const UserObject &amp; uo) const;

  /// Moose object using the interface
  const MooseObject &amp; _uoi_moose_object;

  /// Reference to the FEProblemBase instance
  const FEProblemBase &amp; _uoi_feproblem;

  /// Thread ID
  const THREAD_ID _uoi_tid;
};

template &lt;class T&gt;
const T &amp;
UserObjectInterface::castUserObject(const UserObject &amp; uo_base,
                                    const std::string &amp; param_name /* = &quot;&quot; */) const
{
  const T * uo = dynamic_cast&lt;const T *&gt;(&amp;uo_base);

  if (!uo)
  {
    std::stringstream oss;
    oss &lt;&lt; &quot;The provided UserObject \&quot;&quot; &lt;&lt; userObjectName(uo_base) &lt;&lt; &quot;\&quot; of type &quot;
        &lt;&lt; userObjectType(uo_base)
        &lt;&lt; &quot; is not derived from the required type.\n\nThe UserObject must derive from &quot;
        &lt;&lt; MooseUtils::prettyCppType&lt;T&gt;() &lt;&lt; &quot;.&quot;;

    mooseObjectError(param_name, oss);
  }

  return *uo;
}

template &lt;class T&gt;
const T &amp;
UserObjectInterface::getUserObject(const std::string &amp; param_name, const bool is_dependency) const
{
  return castUserObject&lt;T&gt;(getUserObjectBase(param_name, is_dependency), param_name);
}

template &lt;class T&gt;
const T &amp;
UserObjectInterface::getUserObjectByName(const UserObjectName &amp; object_name,
                                         const bool is_dependency) const
{
  return castUserObject&lt;T&gt;(getUserObjectBaseByName(object_name, is_dependency));
}

template &lt;class T&gt;
bool
UserObjectInterface::hasUserObject(const std::string &amp; param_name) const
{
  return hasUserObjectByName&lt;T&gt;(getUserObjectName(param_name));
}

template &lt;class T&gt;
bool
UserObjectInterface::hasUserObjectByName(const UserObjectName &amp; object_name) const
{
  if (!hasUserObjectByName(object_name))
    return false;
  return dynamic_cast&lt;const T *&gt;(&amp;getUserObjectFromFEProblem(object_name));
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#5720e14a-9486-4e52-a0d0-368bc6669313">(moose/framework/include/userobjects/UserObjectInterface.h)</a><p>Typical usage looks like this:</p><pre style="max-height:350px;"><code class="language-cpp">    _elem_uo(getUserObject&lt;ElementUOProvider&gt;(&quot;element_user_object&quot;)),
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#72cdaeef-94bc-4730-ace9-626cb5a21e00">(moose/framework/src/auxkernels/ElementUOAux.C)</a></section></section><div class="moose-modal modal" id="5720e14a-9486-4e52-a0d0-368bc6669313"><div class="modal-content"><h4>(moose/framework/include/userobjects/UserObjectInterface.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

// MOOSE includes
#include &quot;MooseTypes.h&quot;
#include &quot;MooseUtils.h&quot;

// Forward declarations
class UserObject;
class FEProblemBase;
class MooseObject;

/**
 * Interface for objects that need to use UserObjects.
 */
class UserObjectInterface
{
public:
  static InputParameters validParams();

  UserObjectInterface(const MooseObject * moose_object);

#ifdef MOOSE_KOKKOS_ENABLED
  /**
   * Special constructor used for Kokkos functor copy during parallel dispatch
   */
  UserObjectInterface(const UserObjectInterface &amp; object, const Moose::Kokkos::FunctorCopy &amp; key);
#endif

  /**
   * @return The name of the user object associated with the parameter \p param_name
   */
  UserObjectName getUserObjectName(const std::string &amp; param_name) const;

  /**
   * @return Whether or not a UserObject exists with the name given by the parameter \p param_name.
   */
  ///@{
  bool hasUserObject(const std::string &amp; param_name) const;
  template &lt;class T&gt;
  bool hasUserObject(const std::string &amp; param_name) const;
  ///@}

  /*
   * @return Whether or not a UserObject exists with the name \p object_name.
   */
  ///@{
  bool hasUserObjectByName(const UserObjectName &amp; object_name) const;
  template &lt;class T&gt;
  bool hasUserObjectByName(const UserObjectName &amp; object_name) const;
  ///@}

  /**
   * Get an user object with a given parameter \p param_name
   * @param param_name The name of the parameter key of the user object to retrieve
   * @param is_dependency Whether the user object we are retrieving should be viewed as a
   * dependency, e.g. whether the retrieved user object should be sorted and executed before this
   * object (if we are a user object)
   * @return The user object with name associated with the parameter \p param_name
   */
  template &lt;class T&gt;
  const T &amp; getUserObject(const std::string &amp; param_name, bool is_dependency = true) const;

  /**
   * Get an user object with the name \p object_name
   * @param object_name The name of the user object to retrieve
   * @param is_dependency Whether the user object we are retrieving should be viewed as a
   * dependency, e.g. whether the retrieved user object should be sorted and executed before this
   * object (if we are a user object)
   * @return The user object with the name \p object_name
   */
  template &lt;class T&gt;
  const T &amp; getUserObjectByName(const UserObjectName &amp; object_name,
                                bool is_dependency = true) const;

  /**
   * Get an user object with a given parameter \p param_name
   * @param param_name The name of the parameter key of the user object to retrieve
   * @param is_dependency Whether the user object we are retrieving should be viewed as a
   * dependency, e.g. whether the retrieved user object should be sorted and executed before this
   * object (if we are a user object)
   * @return The user object with name associated with the parameter \p param_name
   */
  const UserObject &amp; getUserObjectBase(const std::string &amp; param_name,
                                       bool is_dependency = true) const;

  /**
   * Get an user object with the name \p object_name
   * @param object_name The name of the user object to retrieve
   * @param is_dependency Whether the user object we are retrieving should be viewed as a
   * dependency, e.g. whether the retrieved user object should be sorted and executed before this
   * object (if we are a user object)
   * @return The user object with the name \p object_name
   */
  const UserObject &amp; getUserObjectBaseByName(const UserObjectName &amp; object_name,
                                             bool is_dependency = true) const;

protected:
  /**
   * Helper for deriving classes to override to add dependencies when a UserObject
   * is requested.
   */
  virtual void addUserObjectDependencyHelper(const UserObject &amp; /* uo */) const {}

private:
  /**
   * Go directly to the FEProblem for the requested \p UserObject
   */
  const UserObject &amp; getUserObjectFromFEProblem(const UserObjectName &amp; object_name) const;

  /**
   * Internal helper that casts the UserObject \p uo_base to the requested type. Exits with
   * a useful error if the casting failed. If the parameter \p param_name is provided and
   * is valid, a paramError() will be used instead.
   */
  template &lt;class T&gt;
  const T &amp; castUserObject(const UserObject &amp; uo_base, const std::string &amp; param_name = &quot;&quot;) const;

  /**
   * emit an error for the given parameter
   */
  void mooseObjectError(const std::string &amp; param_name, std::stringstream &amp; oss) const;

  /// Gets a UserObject&#x27;s type; avoids including UserObject.h in the UserObjectInterface
  const std::string &amp; userObjectType(const UserObject &amp; uo) const;
  /// Gets a UserObject&#x27;s name; avoids including UserObject.h in the UserObjectInterface
  const std::string &amp; userObjectName(const UserObject &amp; uo) const;

  /// Moose object using the interface
  const MooseObject &amp; _uoi_moose_object;

  /// Reference to the FEProblemBase instance
  const FEProblemBase &amp; _uoi_feproblem;

  /// Thread ID
  const THREAD_ID _uoi_tid;
};

template &lt;class T&gt;
const T &amp;
UserObjectInterface::castUserObject(const UserObject &amp; uo_base,
                                    const std::string &amp; param_name /* = &quot;&quot; */) const
{
  const T * uo = dynamic_cast&lt;const T *&gt;(&amp;uo_base);

  if (!uo)
  {
    std::stringstream oss;
    oss &lt;&lt; &quot;The provided UserObject \&quot;&quot; &lt;&lt; userObjectName(uo_base) &lt;&lt; &quot;\&quot; of type &quot;
        &lt;&lt; userObjectType(uo_base)
        &lt;&lt; &quot; is not derived from the required type.\n\nThe UserObject must derive from &quot;
        &lt;&lt; MooseUtils::prettyCppType&lt;T&gt;() &lt;&lt; &quot;.&quot;;

    mooseObjectError(param_name, oss);
  }

  return *uo;
}

template &lt;class T&gt;
const T &amp;
UserObjectInterface::getUserObject(const std::string &amp; param_name, const bool is_dependency) const
{
  return castUserObject&lt;T&gt;(getUserObjectBase(param_name, is_dependency), param_name);
}

template &lt;class T&gt;
const T &amp;
UserObjectInterface::getUserObjectByName(const UserObjectName &amp; object_name,
                                         const bool is_dependency) const
{
  return castUserObject&lt;T&gt;(getUserObjectBaseByName(object_name, is_dependency));
}

template &lt;class T&gt;
bool
UserObjectInterface::hasUserObject(const std::string &amp; param_name) const
{
  return hasUserObjectByName&lt;T&gt;(getUserObjectName(param_name));
}

template &lt;class T&gt;
bool
UserObjectInterface::hasUserObjectByName(const UserObjectName &amp; object_name) const
{
  if (!hasUserObjectByName(object_name))
    return false;
  return dynamic_cast&lt;const T *&gt;(&amp;getUserObjectFromFEProblem(object_name));
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="72cdaeef-94bc-4730-ace9-626cb5a21e00"><div class="modal-content"><h4>(moose/framework/src/auxkernels/ElementUOAux.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ElementUOAux.h&quot;
#include &quot;ElementUOProvider.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ElementUOAux);

InputParameters
ElementUOAux::validParams()
{
  InputParameters params = AuxKernel::validParams();
  params.addRequiredParam&lt;UserObjectName&gt;(&quot;element_user_object&quot;,
                                          &quot;The ElementUOProvider where this Aux pulls values from&quot;);

  params.addParam&lt;std::string&gt;(&quot;field_name&quot;,
                               &quot;The field name to retrieve from the ElementUOProvider&quot;);

  MooseEnum field_type(&quot;long Real&quot;, &quot;long&quot;);
  params.addParam&lt;MooseEnum&gt;(&quot;field_type&quot;, field_type, &quot;The type of field to retrieve&quot;);

  params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;) = EXEC_TIMESTEP_BEGIN;
  params.addClassDescription(&quot;Aux Kernel to display generic spatial (elemental) information from a &quot;
                             &quot;UserObject that satisfies the underlying ElementUOProvider &quot;
                             &quot;interface.&quot;);
  return params;
}

ElementUOAux::ElementUOAux(const InputParameters &amp; params)
  : AuxKernel(params),
    // doco-get-user-object-begin
    _elem_uo(getUserObject&lt;ElementUOProvider&gt;(&quot;element_user_object&quot;)),
    // doco-get-user-object-end
    _field_name(isParamValid(&quot;field_name&quot;) ? getParam&lt;std::string&gt;(&quot;field_name&quot;) : &quot;default&quot;),
    _field_type(getParam&lt;MooseEnum&gt;(&quot;field_type&quot;))
{
  if (isNodal())
    mooseError(&quot;This AuxKernel only supports Elemental fields&quot;);
}

Real
ElementUOAux::computeValue()
{
  if (_field_type == &quot;long&quot;)
  {
    auto value = _elem_uo.getElementalValueLong(_current_elem-&gt;id(), _field_name);
    if (value == std::numeric_limits&lt;unsigned long&gt;::max())
      return -1.0;
    else
      return value;
  }
  else
    return _elem_uo.getElementalValueReal(_current_elem-&gt;id(), _field_name);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>
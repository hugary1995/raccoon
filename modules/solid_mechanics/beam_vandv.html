<!DOCTYPE html><head><meta charset="UTF-8"><title>Beams | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="51cc2058-3315-477f-9633-697f300b060c" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1a3b5e5f-47a9-410f-8d52-f953c44eae99" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="92f284c2-285c-4954-9f99-436238fa98c0" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="5d0cee36-503b-4fc7-9257-9dcf3f3f7109" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="ad62fb66-ecb2-4ec8-aaf4-ef7f1149f6ce"><i class="material-icons">menu</i></a><ul class="sidenav" id="ad62fb66-ecb2-4ec8-aaf4-ef7f1149f6ce"><li><a href="#!" class="dropdown-trigger" data-target="4c2a8801-513a-435d-838b-89e499fdc81a" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f4d75aaf-d14b-4aa6-839c-c378338fdbc3" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9b93062c-3d45-40fd-b779-2747bae84f7f" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="72e28f68-6220-458f-8fe4-89c4b7634fde" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="51cc2058-3315-477f-9633-697f300b060c"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="1a3b5e5f-47a9-410f-8d52-f953c44eae99"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="92f284c2-285c-4954-9f99-436238fa98c0"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="5d0cee36-503b-4fc7-9257-9dcf3f3f7109"><li><a href="../index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="4c2a8801-513a-435d-838b-89e499fdc81a"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="f4d75aaf-d14b-4aa6-839c-c378338fdbc3"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="9b93062c-3d45-40fd-b779-2747bae84f7f"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="72e28f68-6220-458f-8fe4-89c4b7634fde"><li><a href="../index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="00d7c19d-8a30-4d73-b21f-5efdfcf051c2" data-section-level="1" data-section-text="Beams"><h1 id="beams">Beams</h1><section id="94d39f0d-a631-4e96-ae8b-e4cda284e9fd" data-section-level="2" data-section-text="Small strain Timoshenko beam bending"><h2 id="small-strain-timoshenko-beam-bending">Small strain Timoshenko beam bending</h2><p>A 1D cantilever beam of 4 m is modeled using beam elements in MOOSE. The beam has a cross section area of 0.554 <span class="moose-katex-inline-equation" id="moose-equation-3c153146-f792-47ff-a8f0-7d57d3a8705d"><script>var element = document.getElementById("moose-equation-3c153146-f792-47ff-a8f0-7d57d3a8705d");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, moment of inertia about Y and Z axis of 0.0142 <span class="moose-katex-inline-equation" id="moose-equation-f2d35220-00b0-46eb-a302-a86f0c4bb9b9"><script>var element = document.getElementById("moose-equation-f2d35220-00b0-46eb-a302-a86f0c4bb9b9");katex.render("{m}^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, Young&#x27;s modulus of elasticity of 2.6 N/<span class="moose-katex-inline-equation" id="moose-equation-48826b77-abb4-44fd-ac3a-b664ca57d5ed"><script>var element = document.getElementById("moose-equation-48826b77-abb4-44fd-ac3a-b664ca57d5ed");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, poisson&#x27;s ratio of 0.3, shear modulus of 1 N/<span class="moose-katex-inline-equation" id="moose-equation-1af60a43-5ef0-43ca-943b-bb91b440d6e7"><script>var element = document.getElementById("moose-equation-1af60a43-5ef0-43ca-943b-bb91b440d6e7");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and shear coefficient of 0.85. A point load of magnitude 1<span class="moose-katex-inline-equation" id="moose-equation-2c6eb8a4-50d0-40fb-af69-b32314b8355a"><script>var element = document.getElementById("moose-equation-2c6eb8a4-50d0-40fb-af69-b32314b8355a");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-80064a2a-68b2-481f-9443-68f5038d3eb2"><script>var element = document.getElementById("moose-equation-80064a2a-68b2-481f-9443-68f5038d3eb2");katex.render("^-", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span><span class="moose-katex-inline-equation" id="moose-equation-c9b6a278-74de-4034-b32f-36e87d05df83"><script>var element = document.getElementById("moose-equation-c9b6a278-74de-4034-b32f-36e87d05df83");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N is applied at the free end of the cantilever beam in Y-direction.</p><pre style="max-height:350px;"><code class="language-moose"># Test for small strain timoshenko beam bending in y direction

# A unit load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 2.60072400269
# Shear modulus (G) = 1.00027846257
# Poisson&#x27;s ratio (nu) = 0.3
# Shear coefficient (k) = 0.85
# Cross-section area (A) = 0.554256
# Iy = 0.0141889 = Iz
# Length = 4 m

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 204.3734

# The small deformation analytical deflection of the beam is given by
# delta = PL^3/3EI * (1 + 3.0 / alpha) = 5.868e-4 m

# Using 10 elements to discretize the beam element, the FEM solution is 5.852e-2m.
# This deflection matches the FEM solution given in Prathap and Bhashyam (1982).

# References:
# Prathap and Bhashyam (1982), International journal for numerical methods in engineering, vol. 18, 195-210.
# Note that the force is scaled by 1e-4 compared to the reference problem.

[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 4.0
  displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The variables corresponding to the x y z displacements of the mesh.  If this is provided then the displacements will be taken into account during the computation. Creation of the displaced mesh can be suppressed even if this is set by setting &#x27;use_displaced_mesh = false&#x27;.&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/index.html&quot;}&gt;&gt;&gt;]
  [./fixx1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixy1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixz1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr2]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr3]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
[]

[NodalKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/NodalKernels/index.html&quot;}&gt;&gt;&gt;]
  [./force_y2]
    type = ConstantRate&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes residual or the rate in a simple ODE of du/dt = rate.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/ConstantRate.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    rate&lt;&lt;&lt;{&quot;description&quot;: &quot;The constant rate in &#x27;du/dt = rate&#x27;&quot;}&gt;&gt;&gt; = 1.0e-4
  [../]
[]

[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [./smp]
    type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
    full&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you want the full set of couplings between variables simply for convenience so you don&#x27;t have to set every off_diag_row and off_diag_column combination.&quot;}&gt;&gt;&gt; = true
  [../]
[]
[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  dt = 1
  dtmin = 1
  end_time = 2
[]

[Kernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/index.html&quot;}&gt;&gt;&gt;]
  [./solid_disp_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 0
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 1
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 2
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 3
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 4
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 5
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
  [../]
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [./elasticity]
    type = ComputeElasticityBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the equivalent of the elasticity tensor for the beam element, which are vectors of material translational and flexural stiffness.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeElasticityBeam.html&quot;}&gt;&gt;&gt;
    youngs_modulus&lt;&lt;&lt;{&quot;description&quot;: &quot;Young&#x27;s modulus of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 2.60072400269
    poissons_ratio&lt;&lt;&lt;{&quot;description&quot;: &quot;Poisson&#x27;s ratio of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.3
    shear_coefficient&lt;&lt;&lt;{&quot;description&quot;: &quot;Scale factor for the shear modulus. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.85
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute a infinitesimal/large strain increment for the beam.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeIncrementalBeamStrain.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Cross-section area of the beam. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.554256
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0141889
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0141889
    y_orientation&lt;&lt;&lt;{&quot;description&quot;: &quot;Orientation of the y direction along with Iyy is provided. This should be perpendicular to the axis of the beam.&quot;}&gt;&gt;&gt; = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute forces and moments using elasticity&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeBeamResultants.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./disp_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_y
  [../]
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#3be03515-6d71-426b-a602-7c0ba3f7bc6b">(moose/modules/solid_mechanics/test/tests/beam/static/timoshenko_small_strain_y.i)</a><section id="1fb77d75-671f-4bc1-a81f-f8cd52e2f138" data-section-level="3" data-section-text="Results"><h3 id="results">Results</h3><p>For this beam, the dimensionless parameter alpha is given by: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-d1c68b5b-4357-45f6-b514-5da4eaf84cb6"></span><script>var element = document.getElementById("moose-equation-d1c68b5b-4357-45f6-b514-5da4eaf84cb6");katex.render("alpha = \\frac {kAGL^2}{EI} = 204.3734", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> The value of alpha is not high  enough for the beam to behave like a thin beam where shear effects are not significant. Hence, the shear effects are considered and the small deformation analytical deflection of a cantilever beam is given by: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-4cda8ad7-e426-4fad-be71-98224c2e047a"></span><script>var element = document.getElementById("moose-equation-4cda8ad7-e426-4fad-be71-98224c2e047a");katex.render("\\Delta = \\frac {PL^3}{3EI} \\; (1 + \\frac {3}{alpha}) = 5.868 \\times 10^{-2} m", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>The deflection obtained from MOOSE using 10 elements is 5.852<span class="moose-katex-inline-equation" id="moose-equation-4bdce0e5-4d0c-49bb-b328-3a2ad19baa19"><script>var element = document.getElementById("moose-equation-4bdce0e5-4d0c-49bb-b328-3a2ad19baa19");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-33a5995c-67ea-4953-9910-55b378a66b9d"><script>var element = document.getElementById("moose-equation-33a5995c-67ea-4953-9910-55b378a66b9d");katex.render("^-", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span><span class="moose-katex-inline-equation" id="moose-equation-1946e030-23ad-48e1-aa89-dfc6130def20"><script>var element = document.getElementById("moose-equation-1946e030-23ad-48e1-aa89-dfc6130def20");katex.render("^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> m shown in <a href="#fig:timoshenko_small_strain2">Figure 1</a>.</p><div class="card moose-float" style="width:450px;margin-left:110px;float:center;" id="fig:timoshenko_small_strain2"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/timoshenko_small_strain2.png" alt="Displacement of the Timoshenko beam in bending."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 1: </span><span class="moose-caption-text" id="fig:timoshenko_small_strain2">Displacement of the Timoshenko beam in bending.</span></p></div></div></section></section><section id="af4af184-2cd8-4afc-a407-824a4150282b" data-section-level="2" data-section-text="Small strain Euler beam bending"><h2 id="small-strain-euler-beam-bending">Small strain Euler beam bending</h2><p>A 1D cantilever beam of 4 m is modeled using beam elements in MOOSE. The beam has a cross section area of 0.554 <span class="moose-katex-inline-equation" id="moose-equation-84719e7d-034a-4975-9c2a-e04f40769759"><script>var element = document.getElementById("moose-equation-84719e7d-034a-4975-9c2a-e04f40769759");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, moment of inertia about Y and Z axis of 0.0142 <span class="moose-katex-inline-equation" id="moose-equation-9357c049-6d67-4edb-a706-83a88b89e1f7"><script>var element = document.getElementById("moose-equation-9357c049-6d67-4edb-a706-83a88b89e1f7");katex.render("{m}^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, Young&#x27;s modulus of elasticity of 2.6 N/<span class="moose-katex-inline-equation" id="moose-equation-cd125789-6765-409b-8da9-283a98569fa1"><script>var element = document.getElementById("moose-equation-cd125789-6765-409b-8da9-283a98569fa1");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, poisson&#x27;s ratio of -0.99, shear modulus of 1<span class="moose-katex-inline-equation" id="moose-equation-64d35b78-b35d-488b-b982-d0b9b95bcb48"><script>var element = document.getElementById("moose-equation-64d35b78-b35d-488b-b982-d0b9b95bcb48");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-9f175d75-21a5-464f-9f54-10b98135cc23"><script>var element = document.getElementById("moose-equation-9f175d75-21a5-464f-9f54-10b98135cc23");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N/<span class="moose-katex-inline-equation" id="moose-equation-ee7b51f6-2b92-4f48-a1c3-2e305f2523b7"><script>var element = document.getElementById("moose-equation-ee7b51f6-2b92-4f48-a1c3-2e305f2523b7");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and shear coefficient of 0.85. A point load of magnitude 1<span class="moose-katex-inline-equation" id="moose-equation-6d472d9b-8187-49bb-abbc-af6fd1b42d6c"><script>var element = document.getElementById("moose-equation-6d472d9b-8187-49bb-abbc-af6fd1b42d6c");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-57739e55-188e-4fe7-a8eb-b465178c3b37"><script>var element = document.getElementById("moose-equation-57739e55-188e-4fe7-a8eb-b465178c3b37");katex.render("^-", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span><span class="moose-katex-inline-equation" id="moose-equation-7b334fb7-9928-450f-8f65-e11c7318d41d"><script>var element = document.getElementById("moose-equation-7b334fb7-9928-450f-8f65-e11c7318d41d");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N is applied at the free end of the cantilever beam in Y-direction.</p><pre style="max-height:350px;"><code class="language-moose"># Test for small strain Euler beam bending in y direction

# A unit load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 2.60072400269
# Shear modulus (G) = 1.0e4
# Poisson&#x27;s ratio (nu) = -0.9998699638
# Shear coefficient (k) = 0.85
# Cross-section area (A) = 0.554256
# Iy = 0.0141889 = Iz
# Length = 4 m

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 2.04e6

# The small deformation analytical deflection of the beam is given by
# delta = PL^3/3EI * (1 + 3.0 / alpha) = PL^3/3EI = 5.78e-2 m

# Using 10 elements to discretize the beam element, the FEM solution is 5.766e-2 m.
# The ratio beam FEM solution and analytical solution is 0.998.

# References:
# Prathap and Bhashyam (1982), International journal for numerical methods in engineering, vol. 18, 195-210.
# Note that the force is scaled by 1e-4 compared to the reference problem.

[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 4.0
  displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The variables corresponding to the x y z displacements of the mesh.  If this is provided then the displacements will be taken into account during the computation. Creation of the displaced mesh can be suppressed even if this is set by setting &#x27;use_displaced_mesh = false&#x27;.&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/index.html&quot;}&gt;&gt;&gt;]
  [./fixx1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixy1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixz1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr2]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr3]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
[]

[NodalKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/NodalKernels/index.html&quot;}&gt;&gt;&gt;]
  [./force_y2]
    type = ConstantRate&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes residual or the rate in a simple ODE of du/dt = rate.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/ConstantRate.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    rate&lt;&lt;&lt;{&quot;description&quot;: &quot;The constant rate in &#x27;du/dt = rate&#x27;&quot;}&gt;&gt;&gt; = 1.0e-4
  [../]
[]

[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [./smp]
    type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
    full&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you want the full set of couplings between variables simply for convenience so you don&#x27;t have to set every off_diag_row and off_diag_column combination.&quot;}&gt;&gt;&gt; = true
  [../]
[]
[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  dt = 1
  dtmin = 1
  end_time = 2
[]

[Kernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/index.html&quot;}&gt;&gt;&gt;]
  [./solid_disp_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 0
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 1
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 2
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 3
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 4
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 5
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
  [../]
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [./elasticity]
    type = ComputeElasticityBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the equivalent of the elasticity tensor for the beam element, which are vectors of material translational and flexural stiffness.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeElasticityBeam.html&quot;}&gt;&gt;&gt;
    youngs_modulus&lt;&lt;&lt;{&quot;description&quot;: &quot;Young&#x27;s modulus of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 2.60072400269
    poissons_ratio&lt;&lt;&lt;{&quot;description&quot;: &quot;Poisson&#x27;s ratio of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = -0.9998699638
    shear_coefficient&lt;&lt;&lt;{&quot;description&quot;: &quot;Scale factor for the shear modulus. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.85
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute a infinitesimal/large strain increment for the beam.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeIncrementalBeamStrain.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Cross-section area of the beam. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.554256
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0141889
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0141889
    y_orientation&lt;&lt;&lt;{&quot;description&quot;: &quot;Orientation of the y direction along with Iyy is provided. This should be perpendicular to the axis of the beam.&quot;}&gt;&gt;&gt; = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute forces and moments using elasticity&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeBeamResultants.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./disp_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_y
  [../]
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#751a0c07-dac3-4da3-8563-cb7afc672a81">(moose/modules/solid_mechanics/test/tests/beam/static/euler_small_strain_y.i)</a><section id="d9673cd5-70b1-4330-b687-57f4ae21ee70" data-section-level="3" data-section-text="Results"><h3 id="results">Results</h3><p>For this beam, the dimensionless parameter alpha is given by: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-f7f58c96-0c3c-4a5b-aad3-acbf6bd36d87"></span><script>var element = document.getElementById("moose-equation-f7f58c96-0c3c-4a5b-aad3-acbf6bd36d87");katex.render("alpha = \\frac {kAGL^2}{EI} = 2.04 \\times 10^6", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> Since the value of alpha is quite high, the beam behaves like a thin beam where shear effects are not significant. Hence, the small deformation analytical deflection of a cantilever beam is given by: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-08f4a27b-47b7-4bd2-8c30-0aeaea745d8d"></span><script>var element = document.getElementById("moose-equation-08f4a27b-47b7-4bd2-8c30-0aeaea745d8d");katex.render("\\Delta = \\frac {PL^3}{3EI} \\; (1 + \\frac {3}{alpha}) = \\frac {PL^3}{3EI} \\; =5.78 \\times 10^{-2} m", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>The deflection obtained from MOOSE using 10 elements is 5.766<span class="moose-katex-inline-equation" id="moose-equation-29e3c3f9-4f59-4afe-8f59-db188c02d5ba"><script>var element = document.getElementById("moose-equation-29e3c3f9-4f59-4afe-8f59-db188c02d5ba");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-8a89bf27-9eed-48c3-947e-95ef2e71ac96"><script>var element = document.getElementById("moose-equation-8a89bf27-9eed-48c3-947e-95ef2e71ac96");katex.render("^-", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span><span class="moose-katex-inline-equation" id="moose-equation-edfa53ab-0ebc-4008-985e-7ac713fcc3db"><script>var element = document.getElementById("moose-equation-edfa53ab-0ebc-4008-985e-7ac713fcc3db");katex.render("^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> m shown in <a href="#fig:euler_small_strain2">Figure 2</a>. The ratio beam FEM solution and analytical solution is 0.998.</p><div class="card moose-float" style="width:450px;margin-left:110px;float:center;" id="fig:euler_small_strain2"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/euler_small_strain2.png" alt="Displacement of the Euler beam in bending."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 2: </span><span class="moose-caption-text" id="fig:euler_small_strain2">Displacement of the Euler beam in bending.</span></p></div></div></section></section><section id="097da137-b75e-4bfb-9b89-95a242eb65a8" data-section-level="2" data-section-text="Small strain Euler beam axial loading"><h2 id="small-strain-euler-beam-axial-loading">Small strain Euler beam axial loading</h2><p>A pipe 5 feet (60 inches) long having an internal diameter of 8 inches and outer diameter of 10 inches is modeled using beam elements in MOOSE. The Young&#x27;s modulus of elasticity of the pipe is 30<span class="moose-katex-inline-equation" id="moose-equation-89b07ac8-4652-401d-aba0-4fc15ddfa5d5"><script>var element = document.getElementById("moose-equation-89b07ac8-4652-401d-aba0-4fc15ddfa5d5");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-8d3434ca-f936-4c9e-868a-1263718de703"><script>var element = document.getElementById("moose-equation-8d3434ca-f936-4c9e-868a-1263718de703");katex.render("^6", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> lb/<span class="moose-katex-inline-equation" id="moose-equation-0a04d5f9-c388-4adf-9072-9ec2914eb121"><script>var element = document.getElementById("moose-equation-0a04d5f9-c388-4adf-9072-9ec2914eb121");katex.render("{in}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, the shear modulus is 11.54<span class="moose-katex-inline-equation" id="moose-equation-30d7a530-3d9c-4556-8b47-33928bb47455"><script>var element = document.getElementById("moose-equation-30d7a530-3d9c-4556-8b47-33928bb47455");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-a5b7ac3c-0033-465a-87fd-5bf680066c83"><script>var element = document.getElementById("moose-equation-a5b7ac3c-0033-465a-87fd-5bf680066c83");katex.render("^6", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> lb/<span class="moose-katex-inline-equation" id="moose-equation-d434c072-d590-4078-b6dc-26aa29dd0876"><script>var element = document.getElementById("moose-equation-d434c072-d590-4078-b6dc-26aa29dd0876");katex.render("{in}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and poisson&#x27;s ratio is 0.3. The pipe is fixed at one end and an axial load of 50000 lb is applied at the other end.</p><pre style="max-height:350px;"><code class="language-moose"># Test for small strain Euler beam axial loading in x direction.

# Modeling a pipe with an OD of 10 inches and ID of 8 inches
# The length of the pipe is 5 feet (60 inches) and E = 30e6
# G = 11.5384615385e6 with nu = 0.3
# The applied axial load is 50000 lb which results in a
# displacement of 3.537e-3 inches at the end

# delta = PL/AE = 50000 * 60 / pi (5^2 - 4^2) * 30e6 = 3.537e-3

# In this analysis the applied force is used as a BC

[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 60.0
  displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The variables corresponding to the x y z displacements of the mesh.  If this is provided then the displacements will be taken into account during the computation. Creation of the displaced mesh can be suppressed even if this is set by setting &#x27;use_displaced_mesh = false&#x27;.&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/index.html&quot;}&gt;&gt;&gt;]
  [disp_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  []
  [disp_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  []
  [disp_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  []
  [rot_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  []
  [rot_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  []
  [rot_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  []
[]

[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/index.html&quot;}&gt;&gt;&gt;]
  [fixx1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  []
  [fixy1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  []
  [fixz1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  []
  [fixr1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  []
  [fixr2]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  []
  [fixr3]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  []
[]

[NodalKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/NodalKernels/index.html&quot;}&gt;&gt;&gt;]
  [force_x2]
    type = ConstantRate&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes residual or the rate in a simple ODE of du/dt = rate.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/ConstantRate.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    rate&lt;&lt;&lt;{&quot;description&quot;: &quot;The constant rate in &#x27;du/dt = rate&#x27;&quot;}&gt;&gt;&gt; = 50000.0
  []
[]

[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [smp]
    type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
    full&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you want the full set of couplings between variables simply for convenience so you don&#x27;t have to set every off_diag_row and off_diag_column combination.&quot;}&gt;&gt;&gt; = true
  []
[]
[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient
  solve_type = PJFNK
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-8

  dt = 1
  dtmin = 1
  end_time = 2
[]

[Kernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/index.html&quot;}&gt;&gt;&gt;]
  [solid_disp_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 0
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
  []
  [solid_disp_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 1
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
  []
  [solid_disp_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 2
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
  []
  [solid_rot_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 3
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
  []
  [solid_rot_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 4
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
  []
  [solid_rot_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 5
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
  []
[]

[AuxVariables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxVariables/index.html&quot;}&gt;&gt;&gt;]
  [forces_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = CONSTANT
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = MONOMIAL
  []
[]

[AuxKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxKernels/index.html&quot;}&gt;&gt;&gt;]
  [forces_x]
    type = MaterialRealVectorValueAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Capture a component of a vector material property in an auxiliary variable.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/MaterialRealVectorValueAux.html&quot;}&gt;&gt;&gt;
    property&lt;&lt;&lt;{&quot;description&quot;: &quot;The material property name.&quot;}&gt;&gt;&gt; = forces
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = forces_x
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  []
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [elasticity]
    type = ComputeElasticityBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the equivalent of the elasticity tensor for the beam element, which are vectors of material translational and flexural stiffness.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeElasticityBeam.html&quot;}&gt;&gt;&gt;
    shear_coefficient&lt;&lt;&lt;{&quot;description&quot;: &quot;Scale factor for the shear modulus. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    youngs_modulus&lt;&lt;&lt;{&quot;description&quot;: &quot;Young&#x27;s modulus of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 30e6
    poissons_ratio&lt;&lt;&lt;{&quot;description&quot;: &quot;Poisson&#x27;s ratio of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.3
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  []
  [strain]
    type = ComputeIncrementalBeamStrain&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute a infinitesimal/large strain increment for the beam.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeIncrementalBeamStrain.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Cross-section area of the beam. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 28.274
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    y_orientation&lt;&lt;&lt;{&quot;description&quot;: &quot;Orientation of the y direction along with Iyy is provided. This should be perpendicular to the axis of the beam.&quot;}&gt;&gt;&gt; = &#x27;0.0 1.0 0.0&#x27;
  []
  [stress]
    type = ComputeBeamResultants&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute forces and moments using elasticity&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeBeamResultants.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  []
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [disp_x]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;60.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_x
  []
  [disp_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;60.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_y
  []
  [forces_x]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;60.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = forces_x
  []
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  csv&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the scalar variable and postprocessors to a *.csv file using the default CSV output.&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#fd632079-bc04-423e-a61e-472953d9f038">(moose/modules/solid_mechanics/test/tests/beam/static/euler_pipe_axial_force.i)</a><section id="5238d6c5-5cf1-47e3-ac08-6bcf29430bad" data-section-level="3" data-section-text="Results"><h3 id="results">Results</h3><p>The analytical displacement at the end is given by: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-a5c48342-431d-4cc8-8748-c50ae210c9b3"></span><script>var element = document.getElementById("moose-equation-a5c48342-431d-4cc8-8748-c50ae210c9b3");katex.render("\\Delta = \\frac {PL}{AE} = 3.537 \\times 10^{-3} in", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>The displacement at the end obtained from the MOOSE using 10 elements is 3.537<span class="moose-katex-inline-equation" id="moose-equation-3ca5d1bb-941a-40d4-aeda-62cf7b16db62"><script>var element = document.getElementById("moose-equation-3ca5d1bb-941a-40d4-aeda-62cf7b16db62");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-99f21fc1-a258-4978-9f1d-425aeac41348"><script>var element = document.getElementById("moose-equation-99f21fc1-a258-4978-9f1d-425aeac41348");katex.render("^-", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span><span class="moose-katex-inline-equation" id="moose-equation-e5a25bed-0396-4a7e-bf38-ba8f5d11f222"><script>var element = document.getElementById("moose-equation-e5a25bed-0396-4a7e-bf38-ba8f5d11f222");katex.render("^3", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> in as shown in <a href="#fig:euler_pipe_axial_force">Figure 3</a>.</p><div class="card moose-float" style="width:450px;margin-left:110px;float:center;" id="fig:euler_pipe_axial_force"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/euler_pipe_axial_force2.png" alt="Displacement of the Euler beam under axial load."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 3: </span><span class="moose-caption-text" id="fig:euler_pipe_axial_force">Displacement of the Euler beam under axial load.</span></p></div></div></section></section><section id="ebcddcf5-2e20-45a3-9be9-c7dc2c8f381d" data-section-level="2" data-section-text="Large strain / large rotation of cantilever beam"><h2 id="large-strain-large-rotation-of-cantilever-beam">Large strain/large rotation of cantilever beam</h2><p>A 1D cantilever beam of 4 m is modeled using beam elements in MOOSE. The beam has a cross section area of 1 <span class="moose-katex-inline-equation" id="moose-equation-3c908f96-b9e9-4a86-8ed4-2b7cb9a8bae1"><script>var element = document.getElementById("moose-equation-3c908f96-b9e9-4a86-8ed4-2b7cb9a8bae1");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, moment of inertia about Y and Z axis of 0.16 <span class="moose-katex-inline-equation" id="moose-equation-0e2eebb2-a98d-49af-87ff-bd7dc0a20659"><script>var element = document.getElementById("moose-equation-0e2eebb2-a98d-49af-87ff-bd7dc0a20659");katex.render("{m}^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, Young&#x27;s modulus of elasticity of 1<span class="moose-katex-inline-equation" id="moose-equation-be7df9a3-02ca-4edc-8b5e-4849876679fe"><script>var element = document.getElementById("moose-equation-be7df9a3-02ca-4edc-8b5e-4849876679fe");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-1c7da326-5a4f-4b02-aa25-2725e182938b"><script>var element = document.getElementById("moose-equation-1c7da326-5a4f-4b02-aa25-2725e182938b");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N/<span class="moose-katex-inline-equation" id="moose-equation-1added34-da23-46ec-9668-83fc5a0616fd"><script>var element = document.getElementById("moose-equation-1added34-da23-46ec-9668-83fc5a0616fd");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, poisson&#x27;s ratio of -0.99, shear modulus of 1<span class="moose-katex-inline-equation" id="moose-equation-b25316a1-6100-4939-9243-f767d0f9045b"><script>var element = document.getElementById("moose-equation-b25316a1-6100-4939-9243-f767d0f9045b");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-23a67fb7-6585-4d4e-8ba4-d6825e5f4121"><script>var element = document.getElementById("moose-equation-23a67fb7-6585-4d4e-8ba4-d6825e5f4121");katex.render("^8", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N/<span class="moose-katex-inline-equation" id="moose-equation-28ed8115-4b78-4a52-95aa-8b8076c34487"><script>var element = document.getElementById("moose-equation-28ed8115-4b78-4a52-95aa-8b8076c34487");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and shear coefficient of 1. A point load of magnitude 300 N is applied at the free end of the cantilever beam in Y-direction.</p><pre style="max-height:350px;"><code class="language-moose"># Large strain/large rotation cantilever beam test

# A 300 N point load is applied at the end of a 4 m long cantilever beam.
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 1e8
# shear coefficient (k) = 1.0
# Poisson&#x27;s ratio (nu) = -0.99995
# Area (A) = 1.0
# Iy = Iz = 0.16

# The dimensionless parameter alpha = kAGL^2/EI = 1e6
# Since the value of alpha is quite high, the beam behaves like
# a thin beam where shear effects are not significant.

# Beam deflection:
# small strain+rot = 3.998 m (exact 4.0)
# large strain + small rotation = -0.05 m in x and 3.74 m in y
# large rotations + small strain = -0.92 m in x and 2.38 m in y
# large rotations + large strain = -0.954 m in x and 2.37 m in y (exact -1.0 m in x and 2.4 m in y)

# References:
# K. E. Bisshopp and D.C. Drucker, Quaterly of Applied Mathematics, Vol 3, No. 3, 1945.

[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  type = FileMesh
  file = beam_finite_rot_test_2.e
  displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The variables corresponding to the x y z displacements of the mesh.  If this is provided then the displacements will be taken into account during the computation. Creation of the displaced mesh can be suppressed even if this is set by setting &#x27;use_displaced_mesh = false&#x27;.&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/index.html&quot;}&gt;&gt;&gt;]
  [./fixx1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = 1
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixy1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = 1
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixz1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = 1
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = 1
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr2]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = 1
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr3]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = 1
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
[]

[NodalKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/NodalKernels/index.html&quot;}&gt;&gt;&gt;]
  [./force_y2]
    type = UserForcingFunctorNodalKernel&lt;&lt;&lt;{&quot;description&quot;: &quot;Residual contribution to an ODE from a source functor acting at nodes.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/UserForcingFunctorNodalKernel.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = 2
    functor&lt;&lt;&lt;{&quot;description&quot;: &quot;The forcing functor. A functor is any of the following: a variable, a functor material property, a function, a postprocessor or a number.&quot;}&gt;&gt;&gt; = force
  [../]
[]

[Functions&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Functions/index.html&quot;}&gt;&gt;&gt;]
  [./force]
    type = PiecewiseLinear&lt;&lt;&lt;{&quot;description&quot;: &quot;Linearly interpolates between pairs of x-y data&quot;, &quot;href&quot;: &quot;../../source/functions/PiecewiseLinear.html&quot;}&gt;&gt;&gt;
    x&lt;&lt;&lt;{&quot;description&quot;: &quot;The abscissa values&quot;}&gt;&gt;&gt; = &#x27;0.0 2.0  8.0&#x27;
    y&lt;&lt;&lt;{&quot;description&quot;: &quot;The ordinate values&quot;}&gt;&gt;&gt; = &#x27;0.0 300.0 300.0&#x27;
  [../]
[]

[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [./smp]
    type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
    full&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you want the full set of couplings between variables simply for convenience so you don&#x27;t have to set every off_diag_row and off_diag_column combination.&quot;}&gt;&gt;&gt; = true
  [../]
[]

[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient
  solve_type = PJFNK
  line_search = &#x27;none&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre     boomeramg     4&#x27;
  nl_max_its = 50
  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-7
  l_max_its = 50
  dt = 0.05
  end_time = 2.1
[]

[Kernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/index.html&quot;}&gt;&gt;&gt;]
  [./solid_disp_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;1&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 0
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;1&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 1
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;1&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 2
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;1&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 3
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;1&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 4
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;1&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 5
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
  [../]
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [./elasticity]
    type = ComputeElasticityBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the equivalent of the elasticity tensor for the beam element, which are vectors of material translational and flexural stiffness.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeElasticityBeam.html&quot;}&gt;&gt;&gt;
    youngs_modulus&lt;&lt;&lt;{&quot;description&quot;: &quot;Young&#x27;s modulus of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1e4
    poissons_ratio&lt;&lt;&lt;{&quot;description&quot;: &quot;Poisson&#x27;s ratio of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = -0.99995
    shear_coefficient&lt;&lt;&lt;{&quot;description&quot;: &quot;Scale factor for the shear modulus. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 1
  [../]
  [./strain]
    type = ComputeFiniteBeamStrain&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute a rotation increment for finite rotations of the beam and computes the small/large strain increments in the current rotated configuration of the beam.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeFiniteBeamStrain.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;1&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Cross-section area of the beam. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.16
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.16
    y_orientation&lt;&lt;&lt;{&quot;description&quot;: &quot;Orientation of the y direction along with Iyy is provided. This should be perpendicular to the axis of the beam.&quot;}&gt;&gt;&gt; = &#x27;0.0 1.0 0.0&#x27;
    large_strain&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if large strain are to be calculated.&quot;}&gt;&gt;&gt; = true
  [../]
  [./stress]
    type = ComputeBeamResultants&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute forces and moments using elasticity&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeBeamResultants.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 1
  [../]
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./disp_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./rot_z]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = rot_z
  [../]
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
  perf_graph&lt;&lt;&lt;{&quot;description&quot;: &quot;Enable printing of the performance graph to the screen (Console)&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#6a307ea0-9b00-4f79-94b5-d3cf3ad575e0">(moose/modules/solid_mechanics/test/tests/beam/static/euler_finite_rot_y.i)</a><section id="b9aeba7d-5ec7-475e-b9ff-705ce68cca58" data-section-level="3" data-section-text="Results"><h3 id="results">Results</h3><p>For this beam, the dimensionless parameter alpha is given by: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-d72a6bb7-3159-4d79-b670-ad51dedc417d"></span><script>var element = document.getElementById("moose-equation-d72a6bb7-3159-4d79-b670-ad51dedc417d");katex.render("alpha = \\frac {kAGL^2}{EI} = 1\\times 10^6", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>  Since, the value of alpha is quite high, the beam behaves like a thin beam where shear effects are not significant. The analytical solution for the displacements due to large rotations and large strain of the cantilever beam in X and Y direction is -1 m and 2.4 m respectively (<a href="#bishopanddrucker1945">BISSHOPP and DRUCKER (1945)</a>).</p><p>The displacement at the free end of the cantilever beam obtained from the MOOSE  is -0.954 m in X direction as shown in <a href="#fig:euler_finite_rot_x">Figure 4</a> and 2.37 m in Y direction as shown in <a href="#fig:euler_finite_rot_y">Figure 5</a>.</p><div class="card moose-float" style="width:450px;margin-left:110px;float:center;" id="fig:euler_finite_rot_x"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/euler_finite_rot_x2.png" alt="Displacement of the cantilever beam with large strain and rotation in X direction"></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 4: </span><span class="moose-caption-text" id="fig:euler_finite_rot_x">Displacement of the cantilever beam with large strain and rotation in X direction</span></p></div></div><div class="card moose-float" style="width:450px;margin-left:110px;float:center;" id="fig:euler_finite_rot_y"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/euler_finite_rot_y2.png" alt="Displacement of the cantilever beam with large strain and rotation in Y direction"></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 5: </span><span class="moose-caption-text" id="fig:euler_finite_rot_y">Displacement of the cantilever beam with large strain and rotation in Y direction</span></p></div></div></section></section><section id="18c994bf-4176-43cc-8f12-2d548bcc8d65" data-section-level="2" data-section-text="Torsion"><h2 id="torsion">Torsion</h2><p>A 1D cantilever beam of 1 m is modeled using beam elements in MOOSE. The beam has a cross section area of 0.5 <span class="moose-katex-inline-equation" id="moose-equation-ea6acbb8-3a5e-444f-b328-5f0bd23aaffd"><script>var element = document.getElementById("moose-equation-ea6acbb8-3a5e-444f-b328-5f0bd23aaffd");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, moment of inertia about Y and Z axis of 1<span class="moose-katex-inline-equation" id="moose-equation-75b2659b-5aaa-4e75-9b36-1043c906f75e"><script>var element = document.getElementById("moose-equation-75b2659b-5aaa-4e75-9b36-1043c906f75e");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-0976b4d3-296b-4186-a144-91248275708a"><script>var element = document.getElementById("moose-equation-0976b4d3-296b-4186-a144-91248275708a");katex.render("^-", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span><span class="moose-katex-inline-equation" id="moose-equation-8b73662c-4bcc-41bb-8da1-b8e6202bf70a"><script>var element = document.getElementById("moose-equation-8b73662c-4bcc-41bb-8da1-b8e6202bf70a");katex.render("^5", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> <span class="moose-katex-inline-equation" id="moose-equation-1e8bdfad-9fa8-4884-9756-10f435ebacf9"><script>var element = document.getElementById("moose-equation-1e8bdfad-9fa8-4884-9756-10f435ebacf9");katex.render("{m}^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, Young&#x27;s modulus of elasticity of 2<span class="moose-katex-inline-equation" id="moose-equation-450a3d13-112c-480d-a948-8fa69c448205"><script>var element = document.getElementById("moose-equation-450a3d13-112c-480d-a948-8fa69c448205");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-1337176b-3cda-4e65-b533-95d9124f89b8"><script>var element = document.getElementById("moose-equation-1337176b-3cda-4e65-b533-95d9124f89b8");katex.render("^9", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N/<span class="moose-katex-inline-equation" id="moose-equation-3df6f0bb-4f97-4841-af7a-cf3253618ae1"><script>var element = document.getElementById("moose-equation-3df6f0bb-4f97-4841-af7a-cf3253618ae1");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, poisson&#x27;s ratio of 0.3 and shear coefficient of 1. A torsion of magnitude 5 N/m is applied at the free end of the cantilever beam.</p><pre style="max-height:350px;"><code class="language-moose"># Torsion test with automatically calculated Ix

# A beam of length 1 m is fixed at one end and a moment  of 5 Nm
# is applied along the axis of the beam.
# G = 7.69e9
# Ix = Iy + Iz = 2e-5
# The axial twist at the free end of the beam is:
# phi = TL/GIx = 3.25e-4

[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 1.0
  displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The variables corresponding to the x y z displacements of the mesh.  If this is provided then the displacements will be taken into account during the computation. Creation of the displaced mesh can be suppressed even if this is set by setting &#x27;use_displaced_mesh = false&#x27;.&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
[]

[Physics&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Physics/index.html&quot;}&gt;&gt;&gt;/SolidMechanics&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Physics/SolidMechanics/index.html&quot;}&gt;&gt;&gt;/LineElement&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Physics/SolidMechanics/LineElement/index.html&quot;}&gt;&gt;&gt;/QuasiStatic&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Physics/SolidMechanics/LineElement/QuasiStatic/index.html&quot;}&gt;&gt;&gt;]
  [./block_all]
    add_variables&lt;&lt;&lt;{&quot;description&quot;: &quot;Add the displacement variables for truss elements and both displacement and rotation variables for beam elements.&quot;}&gt;&gt;&gt; = true
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The nonlinear displacement variables for the problem&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;

    # Geometry parameters
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Cross-section area of the beam. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.5
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1e-5
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1e-5

    y_orientation&lt;&lt;&lt;{&quot;description&quot;: &quot;Orientation of the y direction along which Iyy is provided. This should be perpendicular to the axis of the beam.&quot;}&gt;&gt;&gt; = &#x27;0.0 1.0 0.0&#x27;

    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of ids of the blocks (subdomain) that the stress divergence, inertia kernels and materials will be applied to&quot;}&gt;&gt;&gt; = 0
  [../]
[]

[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/index.html&quot;}&gt;&gt;&gt;]
  [./fixx1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixy1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixz1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr2]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr3]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
[]

[NodalKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/NodalKernels/index.html&quot;}&gt;&gt;&gt;]
  [./force_y2]
    type = ConstantRate&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes residual or the rate in a simple ODE of du/dt = rate.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/ConstantRate.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    rate&lt;&lt;&lt;{&quot;description&quot;: &quot;The constant rate in &#x27;du/dt = rate&#x27;&quot;}&gt;&gt;&gt; = 5.0
  [../]
[]

[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [./smp]
    type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
    full&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you want the full set of couplings between variables simply for convenience so you don&#x27;t have to set every off_diag_row and off_diag_column combination.&quot;}&gt;&gt;&gt; = true
  [../]
[]
[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient
  solve_type = PJFNK
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-8

  dt = 1
  dtmin = 1
  end_time = 2
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [./elasticity]
    type = ComputeElasticityBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the equivalent of the elasticity tensor for the beam element, which are vectors of material translational and flexural stiffness.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeElasticityBeam.html&quot;}&gt;&gt;&gt;
    youngs_modulus&lt;&lt;&lt;{&quot;description&quot;: &quot;Young&#x27;s modulus of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 2.0e9
    poissons_ratio&lt;&lt;&lt;{&quot;description&quot;: &quot;Poisson&#x27;s ratio of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.3
    shear_coefficient&lt;&lt;&lt;{&quot;description&quot;: &quot;Scale factor for the shear modulus. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
  [./stress]
    type = ComputeBeamResultants&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute forces and moments using elasticity&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeBeamResultants.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;1.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = rot_x
  [../]
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  csv&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the scalar variable and postprocessors to a *.csv file using the default CSV output.&quot;}&gt;&gt;&gt; = true
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#032d9239-3573-4ed2-951d-65f32a1dbeb1">(moose/modules/solid_mechanics/test/tests/beam/static/torsion_1.i)</a><section id="d13e52d4-2a19-4846-8c69-e0b390900951" data-section-level="3" data-section-text="Results"><h3 id="results">Results</h3><p>The analytical solution for the axial twist at the free end of the beam is given by: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-1a77eca6-ce34-442a-9ce2-5ed3ae97214c"></span><script>var element = document.getElementById("moose-equation-1a77eca6-ce34-442a-9ce2-5ed3ae97214c");katex.render("\\phi = \\frac {TL}{GI_{x}} = 3.25\\times 10^{-4} rad", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-71a2ef06-f908-4afa-b8fc-3c0c5f2eeeae"></span><script>var element = document.getElementById("moose-equation-71a2ef06-f908-4afa-b8fc-3c0c5f2eeeae");katex.render("where, I_{x} = I_{y} + I_{z} = 2\\times 10^{-5} m^4", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>The rotation at the free end of the beam obtained in MOOSE is 3.2<span class="moose-katex-inline-equation" id="moose-equation-450ae79f-c77c-4572-9974-ec34889be8c1"><script>var element = document.getElementById("moose-equation-450ae79f-c77c-4572-9974-ec34889be8c1");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-7a289515-446f-4197-904f-24427b205d7d"><script>var element = document.getElementById("moose-equation-7a289515-446f-4197-904f-24427b205d7d");katex.render("^-", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span><span class="moose-katex-inline-equation" id="moose-equation-3d2f876e-0f2e-4f8b-81f4-73b57fa5a447"><script>var element = document.getElementById("moose-equation-3d2f876e-0f2e-4f8b-81f4-73b57fa5a447");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> rad, as shown in <a href="#fig:torsion2">Figure 6</a>.</p><div class="card moose-float" style="width:450px;margin-left:110px;float:center;" id="fig:torsion2"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/torsion2.png" alt="Rotation of the beam due to torsion."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 6: </span><span class="moose-caption-text" id="fig:torsion2">Rotation of the beam due to torsion.</span></p></div></div></section></section><section id="9f66524a-71ac-4284-bb84-1946c7a537a1" data-section-level="2" data-section-text="Small strain Euler beam vibration"><h2 id="small-strain-euler-beam-vibration">Small strain Euler beam vibration</h2><p>A 1D cantilever beam of 4 m is modeled using beam elements in MOOSE. The beam has a cross section area of 0.01 <span class="moose-katex-inline-equation" id="moose-equation-db75a852-6edf-4a51-99e3-fdca2f228f36"><script>var element = document.getElementById("moose-equation-db75a852-6edf-4a51-99e3-fdca2f228f36");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, moment of inertia about Y and Z axis of 1<span class="moose-katex-inline-equation" id="moose-equation-f13a5b41-faa6-4008-a42e-c404f17574b4"><script>var element = document.getElementById("moose-equation-f13a5b41-faa6-4008-a42e-c404f17574b4");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-c51377a2-f6c6-4a3b-888e-48286e26bb93"><script>var element = document.getElementById("moose-equation-c51377a2-f6c6-4a3b-888e-48286e26bb93");katex.render("^-", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span><span class="moose-katex-inline-equation" id="moose-equation-c43ae82a-751f-49a7-96f1-2c5f1ec1ac38"><script>var element = document.getElementById("moose-equation-c43ae82a-751f-49a7-96f1-2c5f1ec1ac38");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> <span class="moose-katex-inline-equation" id="moose-equation-2d610e47-45eb-4a0c-aaad-1ecfe6041b76"><script>var element = document.getElementById("moose-equation-2d610e47-45eb-4a0c-aaad-1ecfe6041b76");katex.render("{m}^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, Young&#x27;s modulus of elasticity of 1<span class="moose-katex-inline-equation" id="moose-equation-9bb24256-934e-45bf-8d71-5624adf1ef65"><script>var element = document.getElementById("moose-equation-9bb24256-934e-45bf-8d71-5624adf1ef65");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-2227e4bb-3135-4aad-8a8b-fc689f4d9acb"><script>var element = document.getElementById("moose-equation-2227e4bb-3135-4aad-8a8b-fc689f4d9acb");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N/<span class="moose-katex-inline-equation" id="moose-equation-b01f7f35-e69d-489f-afe4-cc0419968b69"><script>var element = document.getElementById("moose-equation-b01f7f35-e69d-489f-afe4-cc0419968b69");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, poisson&#x27;s ratio of -0.99, density of 1 kg/<span class="moose-katex-inline-equation" id="moose-equation-d0f38d15-1109-405e-9f0f-c80f6f522cc3"><script>var element = document.getElementById("moose-equation-d0f38d15-1109-405e-9f0f-c80f6f522cc3");katex.render("{m}^3", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, shear modulus of 4<span class="moose-katex-inline-equation" id="moose-equation-678b8276-f053-4850-9075-434ae136803f"><script>var element = document.getElementById("moose-equation-678b8276-f053-4850-9075-434ae136803f");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-468595e6-e5a1-4e70-9bc4-10c3fa35a154"><script>var element = document.getElementById("moose-equation-468595e6-e5a1-4e70-9bc4-10c3fa35a154");katex.render("^7", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N/<span class="moose-katex-inline-equation" id="moose-equation-116b0e38-f677-4890-8900-59fdad0a64ec"><script>var element = document.getElementById("moose-equation-116b0e38-f677-4890-8900-59fdad0a64ec");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and shear coefficient of 1. An impulse load with a peak value of 0.01 N at 0.05 s, as shown in <a href="#fig:impulseload">Figure 7</a>, is applied at the free end of the beam in Y direction. The Newmark time integration parameters used in the problem correspond to the Newmark&#x27;s average acceleration method, i.e., <code>beta=0.25</code> and <code>gamma=0.5</code>.</p><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:impulseload"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/euler_small_impulse.png" alt="Impulse load pattern applied at the free end of the beam."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 7: </span><span class="moose-caption-text" id="fig:impulseload">Impulse load pattern applied at the free end of the beam.</span></p></div></div><pre style="max-height:350px;"><code class="language-moose"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# density (rho) = 1.0

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The theoretical first and third frequencies of this beam are:
# f1 = 1/(2 pi) * (3.5156/L^2) * sqrt(EI/rho)
# f2 = 6.268 f1

# This implies that the corresponding time period of this beam are 2.858 s and 0.455s

# The FEM solution for this beam with 10 element gives time periods of 2.856 s and 0.4505s with a time step of 0.01.
# A smaller time step is required to obtain a closer match for the lower time periods/higher frequencies.
# A higher time step of 0.05 is used in this test to reduce testing time.

# The time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time       disp_y            vel_y            accel_y
# 0     0.0                  0.0                0.0
# 0.05  0.0016523559162602   0.066094236650407  2.6437694660163
# 0.1   0.0051691308901533   0.07457676230532  -2.3044684398197
# 0.15  0.0078956772343372   0.03448509146203   4.7008016060883
# 0.2   0.0096592517031463   0.03605788729033  -0.63788977295649
# 0.25  0.011069233444348    0.020341382357756  0.0092295756535376

[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  type = GeneratedMesh
  xmin = 0.0
  xmax = 4.0
  dim = 1
  nx = 10
  displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The variables corresponding to the x y z displacements of the mesh.  If this is provided then the displacements will be taken into account during the computation. Creation of the displaced mesh can be suppressed even if this is set by setting &#x27;use_displaced_mesh = false&#x27;.&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[AuxVariables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxVariables/index.html&quot;}&gt;&gt;&gt;]
  [./vel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./vel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./vel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./accel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./accel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./accel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_vel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_vel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_vel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_accel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_accel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_accel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[AuxKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxKernels/index.html&quot;}&gt;&gt;&gt;]
  [./accel_x]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = accel_x
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = disp_x
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_x
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = vel_x
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_x
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = accel_y
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = disp_y
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_y
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = vel_y
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_y
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = accel_z
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = disp_z
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_z
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = vel_z
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_z
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_accel_x]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_accel_x
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = rot_x
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = rot_vel_x
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_vel_x]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_vel_x
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = rot_accel_x
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_accel_y]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_accel_y
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = rot_y
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = rot_vel_y
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_vel_y]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_vel_y
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = rot_accel_y
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_accel_z]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_accel_z
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = rot_z
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = rot_vel_z
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_vel_z]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_vel_z
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = rot_accel_z
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
[]

[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/index.html&quot;}&gt;&gt;&gt;]
  [./fixx1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixy1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixz1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr2]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr3]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
[]

[NodalKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/NodalKernels/index.html&quot;}&gt;&gt;&gt;]
  [./force_y2]
    type = UserForcingFunctorNodalKernel&lt;&lt;&lt;{&quot;description&quot;: &quot;Residual contribution to an ODE from a source functor acting at nodes.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/UserForcingFunctorNodalKernel.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    functor&lt;&lt;&lt;{&quot;description&quot;: &quot;The forcing functor. A functor is any of the following: a variable, a functor material property, a function, a postprocessor or a number.&quot;}&gt;&gt;&gt; = force
  [../]
[]

[Functions&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Functions/index.html&quot;}&gt;&gt;&gt;]
  [./force]
    type = PiecewiseLinear&lt;&lt;&lt;{&quot;description&quot;: &quot;Linearly interpolates between pairs of x-y data&quot;, &quot;href&quot;: &quot;../../source/functions/PiecewiseLinear.html&quot;}&gt;&gt;&gt;
    x&lt;&lt;&lt;{&quot;description&quot;: &quot;The abscissa values&quot;}&gt;&gt;&gt; = &#x27;0.0 0.05 0.1 10.0&#x27;
    y&lt;&lt;&lt;{&quot;description&quot;: &quot;The ordinate values&quot;}&gt;&gt;&gt; = &#x27;0.0 0.01  0.0  0.0&#x27;
  [../]
[]

[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [./smp]
    type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
    full&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you want the full set of couplings between variables simply for convenience so you don&#x27;t have to set every off_diag_row and off_diag_column combination.&quot;}&gt;&gt;&gt; = true
  [../]
[]

[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient
  solve_type = NEWTON

  dt = 0.05
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Kernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/index.html&quot;}&gt;&gt;&gt;]
  [./solid_disp_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 0
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 1
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 2
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 3
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 4
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 5
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
  [../]
  [./inertial_force_x]
    type = InertialForceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.&quot;, &quot;href&quot;: &quot;../../source/kernels/InertialForceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacement variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotational variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational velocity variables&quot;}&gt;&gt;&gt; = &#x27;vel_x vel_y vel_z&#x27;
    accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing cross-section area&quot;}&gt;&gt;&gt; = 0.01
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about y axis&quot;}&gt;&gt;&gt; = 1e-4
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about z axis&quot;}&gt;&gt;&gt; = 1e-4
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about y axis&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about z axis&quot;}&gt;&gt;&gt; = 0.0
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 0
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./inertial_force_y]
    type = InertialForceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.&quot;, &quot;href&quot;: &quot;../../source/kernels/InertialForceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacement variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotational variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational velocity variables&quot;}&gt;&gt;&gt; = &#x27;vel_x vel_y vel_z&#x27;
    accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing cross-section area&quot;}&gt;&gt;&gt; = 0.01
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about y axis&quot;}&gt;&gt;&gt; = 1e-4
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about z axis&quot;}&gt;&gt;&gt; = 1e-4
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about y axis&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about z axis&quot;}&gt;&gt;&gt; = 0.0
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 1
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./inertial_force_z]
    type = InertialForceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.&quot;, &quot;href&quot;: &quot;../../source/kernels/InertialForceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacement variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotational variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational velocity variables&quot;}&gt;&gt;&gt; = &#x27;vel_x vel_y vel_z&#x27;
    accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing cross-section area&quot;}&gt;&gt;&gt; = 0.01
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about y axis&quot;}&gt;&gt;&gt; = 1e-4
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about z axis&quot;}&gt;&gt;&gt; = 1e-4
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about y axis&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about z axis&quot;}&gt;&gt;&gt; = 0.0
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 2
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
  [../]
  [./inertial_force_rot_x]
    type = InertialForceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.&quot;, &quot;href&quot;: &quot;../../source/kernels/InertialForceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacement variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotational variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational velocity variables&quot;}&gt;&gt;&gt; = &#x27;vel_x vel_y vel_z&#x27;
    accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing cross-section area&quot;}&gt;&gt;&gt; = 0.01
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about y axis&quot;}&gt;&gt;&gt; = 1e-4
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about z axis&quot;}&gt;&gt;&gt; = 1e-4
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about y axis&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about z axis&quot;}&gt;&gt;&gt; = 0.0
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 3
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
  [../]
  [./inertial_force_rot_y]
    type = InertialForceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.&quot;, &quot;href&quot;: &quot;../../source/kernels/InertialForceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacement variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotational variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational velocity variables&quot;}&gt;&gt;&gt; = &#x27;vel_x vel_y vel_z&#x27;
    accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing cross-section area&quot;}&gt;&gt;&gt; = 0.01
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about y axis&quot;}&gt;&gt;&gt; = 1e-4
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about z axis&quot;}&gt;&gt;&gt; = 1e-4
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about y axis&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about z axis&quot;}&gt;&gt;&gt; = 0.0
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 4
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
  [../]
  [./inertial_force_rot_z]
    type = InertialForceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.&quot;, &quot;href&quot;: &quot;../../source/kernels/InertialForceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacement variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotational variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational velocity variables&quot;}&gt;&gt;&gt; = &#x27;vel_x vel_y vel_z&#x27;
    accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing cross-section area&quot;}&gt;&gt;&gt; = 0.01
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about y axis&quot;}&gt;&gt;&gt; = 1e-4
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about z axis&quot;}&gt;&gt;&gt; = 1e-4
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about y axis&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about z axis&quot;}&gt;&gt;&gt; = 0.0
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 5
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
  [../]
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [./elasticity]
    type = ComputeElasticityBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the equivalent of the elasticity tensor for the beam element, which are vectors of material translational and flexural stiffness.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeElasticityBeam.html&quot;}&gt;&gt;&gt;
    youngs_modulus&lt;&lt;&lt;{&quot;description&quot;: &quot;Young&#x27;s modulus of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0e4
    poissons_ratio&lt;&lt;&lt;{&quot;description&quot;: &quot;Poisson&#x27;s ratio of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = -0.999875
    shear_coefficient&lt;&lt;&lt;{&quot;description&quot;: &quot;Scale factor for the shear modulus. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute a infinitesimal/large strain increment for the beam.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeIncrementalBeamStrain.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Cross-section area of the beam. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.01
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0e-4
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0e-4
    y_orientation&lt;&lt;&lt;{&quot;description&quot;: &quot;Orientation of the y direction along with Iyy is provided. This should be perpendicular to the axis of the beam.&quot;}&gt;&gt;&gt; = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute forces and moments using elasticity&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeBeamResultants.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
  [./density]
    type = GenericConstantMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Declares material properties based on names and values prescribed by input parameters.&quot;, &quot;href&quot;: &quot;../../source/materials/GenericConstantMaterial.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    prop_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The names of the properties this material will have&quot;}&gt;&gt;&gt; = &#x27;density&#x27;
    prop_values&lt;&lt;&lt;{&quot;description&quot;: &quot;The values associated with the named properties&quot;}&gt;&gt;&gt; = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./disp_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./vel_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = vel_y
  [../]
  [./accel_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = accel_y
  [../]
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
  csv&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the scalar variable and postprocessors to a *.csv file using the default CSV output.&quot;}&gt;&gt;&gt; = true
  perf_graph&lt;&lt;&lt;{&quot;description&quot;: &quot;Enable printing of the performance graph to the screen (Console)&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#4e4ce71f-b1d1-4c8a-b3e6-5ce692082b9d">(moose/modules/solid_mechanics/test/tests/beam/dynamic/dyn_euler_small.i)</a><section id="103e6355-f939-4d12-9537-ad8bf00fee21" data-section-level="3" data-section-text="Results"><h3 id="results">Results</h3><p>For this beam, the dimensionless parameter alpha is given by: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-b5c99848-6bd1-4123-8c01-1a897acaff13"></span><script>var element = document.getElementById("moose-equation-b5c99848-6bd1-4123-8c01-1a897acaff13");katex.render("alpha = \\frac {kAGL^2}{EI} = 6.4\\times 10^6", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>  Therefore, the beam behaves like an Euler-Bernoulli beam. The displacement, velocity and acceleration, as the function of time, at the free end of the cantilever beam in MOOSE, are compared with the results from ABAQUS using the time step of 0.05 s, as shown in <a href="#fig:euler_vibration_disp">Figure 8</a>, <a href="#fig:euler_vibration_vel">Figure 9</a> and <a href="#fig:euler_vibration_acc">Figure 10</a>.</p><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:euler_vibration_disp"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/euler_small_disp.png" alt="Displacement at the free end of the Euler beam."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 8: </span><span class="moose-caption-text" id="fig:euler_vibration_disp">Displacement at the free end of the Euler beam.</span></p></div></div><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:euler_vibration_vel"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/euler_small_vel.png" alt="Velocity at the free end of the Euler beam."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 9: </span><span class="moose-caption-text" id="fig:euler_vibration_vel">Velocity at the free end of the Euler beam.</span></p></div></div><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:euler_vibration_acc"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/euler_small_acc.png" alt="Acceleration at the free end of the Euler beam."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 10: </span><span class="moose-caption-text" id="fig:euler_vibration_acc">Acceleration at the free end of the Euler beam.</span></p></div></div></section></section><section id="109e2b84-4001-4ebf-b3fa-d79d20741c27" data-section-level="2" data-section-text="Small strain Timoshenko beam vibration"><h2 id="small-strain-timoshenko-beam-vibration">Small strain Timoshenko beam vibration</h2><p>A 1D cantilever beam of 4 m is modeled using beam elements in MOOSE. The beam has a cross section area of 1 <span class="moose-katex-inline-equation" id="moose-equation-6066e180-9fcd-493b-a02a-3dbc8d86010c"><script>var element = document.getElementById("moose-equation-6066e180-9fcd-493b-a02a-3dbc8d86010c");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, moment of inertia about Y and Z axis of 1 <span class="moose-katex-inline-equation" id="moose-equation-524dd7e0-2a56-49b9-8f3f-e8f70865660b"><script>var element = document.getElementById("moose-equation-524dd7e0-2a56-49b9-8f3f-e8f70865660b");katex.render("{m}^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, Young&#x27;s modulus of elasticity of 2<span class="moose-katex-inline-equation" id="moose-equation-af51225a-d2d8-4a1f-96cd-e669038e7bc2"><script>var element = document.getElementById("moose-equation-af51225a-d2d8-4a1f-96cd-e669038e7bc2");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-323dde86-0f31-4efa-986f-ed671b3a1a24"><script>var element = document.getElementById("moose-equation-323dde86-0f31-4efa-986f-ed671b3a1a24");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N/<span class="moose-katex-inline-equation" id="moose-equation-fcba521e-51c8-4b16-b18d-7b9e8dda17aa"><script>var element = document.getElementById("moose-equation-fcba521e-51c8-4b16-b18d-7b9e8dda17aa");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, poisson&#x27;s ratio of -0.99, density of 1 kg/<span class="moose-katex-inline-equation" id="moose-equation-d2f3d8a8-40db-445b-9c17-c6229cfab3a2"><script>var element = document.getElementById("moose-equation-d2f3d8a8-40db-445b-9c17-c6229cfab3a2");katex.render("{m}^3", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, shear modulus of 1<span class="moose-katex-inline-equation" id="moose-equation-e4a31758-be4a-40e9-97e7-fa22da9b7391"><script>var element = document.getElementById("moose-equation-e4a31758-be4a-40e9-97e7-fa22da9b7391");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-89ba1785-0c25-4907-b81c-4e0505e44abd"><script>var element = document.getElementById("moose-equation-89ba1785-0c25-4907-b81c-4e0505e44abd");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N/<span class="moose-katex-inline-equation" id="moose-equation-1ef34883-4cfa-4147-b538-f9487c08be6c"><script>var element = document.getElementById("moose-equation-1ef34883-4cfa-4147-b538-f9487c08be6c");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and shear coefficient of 1. An impulse load with a peak value of 0.01 N at 0.0.005 s, as shown in <a href="#fig:impulseload2">Figure 11</a>, is applied at the free end of the beam in Y direction. The Newmark time integration parameters used in the problem correspond to the Newmark&#x27;s average acceleration method, i.e., <code>beta=0.25</code> and <code>gamma=0.5</code></p><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:impulseload2"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/timo_small_impulse.png" alt="Impulse load pattern applied at the free end of the beam."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 11: </span><span class="moose-caption-text" id="fig:impulseload2">Impulse load pattern applied at the free end of the beam.</span></p></div></div><pre style="max-height:350px;"><code class="language-moose"># Test for small strain Timoshenko beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 2e4
# Shear modulus (G) = 1e4
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 1.0
# Iy = 1.0 = Iz
# Length (L)= 4 m
# density (rho) = 1.0

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 8
# Therefore, the beam behaves like a Timoshenko beam.

# The FEM solution for this beam with 100 elements give first natural period of 0.2731s with a time step of 0.005.
# The acceleration, velocity and displacement time histories obtained from MOOSE matches with those obtained from ABAQUS.

# Values from the first few time steps are as follows:
# time    disp_y                vel_y                 accel_y
# 0.0     0.0                   0.0                   0.0
# 0.005   2.5473249455812e-05   0.010189299782325     4.0757199129299
# 0.01    5.3012872677486e-05   0.00082654950634483  -7.8208200233219
# 0.015   5.8611622914354e-05   0.0014129505884026    8.055380456145
# 0.02    6.766113649781e-05    0.0022068548449798   -7.7378187535141
# 0.025   7.8981810558437e-05   0.0023214147792709    7.7836427272305

# Note that the theoretical first frequency of the beam using Euler-Bernoulli theory is:
# f1 = 1/(2 pi) * (3.5156/L^2) * sqrt(EI/rho) = 4.9455

# This implies that the corresponding time period of this beam (under Euler-Bernoulli assumption) is 0.2022s.

# This shows that Euler-Bernoulli beam theory under-predicts the time period of a thick beam. In other words, the Euler-Bernoulli beam theory predicts a more compliant beam than reality for a thick beam.

[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  type = GeneratedMesh
  xmin = 0
  xmax = 4.0
  nx = 100
  dim = 1
  displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The variables corresponding to the x y z displacements of the mesh.  If this is provided then the displacements will be taken into account during the computation. Creation of the displaced mesh can be suppressed even if this is set by setting &#x27;use_displaced_mesh = false&#x27;.&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[AuxVariables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxVariables/index.html&quot;}&gt;&gt;&gt;]
  [./vel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./vel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./vel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./accel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./accel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./accel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_vel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_vel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_vel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_accel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_accel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_accel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[AuxKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxKernels/index.html&quot;}&gt;&gt;&gt;]
  [./accel_x]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = accel_x
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = disp_x
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_x
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = vel_x
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_x
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = accel_y
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = disp_y
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_y
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = vel_y
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_y
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = accel_z
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = disp_z
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_z
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = vel_z
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_z
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_accel_x]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_accel_x
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = rot_x
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = rot_vel_x
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_vel_x]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_vel_x
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = rot_accel_x
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_accel_y]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_accel_y
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = rot_y
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = rot_vel_y
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_vel_y]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_vel_y
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = rot_accel_y
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_accel_z]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_accel_z
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = rot_z
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = rot_vel_z
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_vel_z]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_vel_z
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = rot_accel_z
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
[]

[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/index.html&quot;}&gt;&gt;&gt;]
  [./fixx1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixy1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixz1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr2]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr3]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
[]

[NodalKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/NodalKernels/index.html&quot;}&gt;&gt;&gt;]
  [./force_y2]
    type = UserForcingFunctorNodalKernel&lt;&lt;&lt;{&quot;description&quot;: &quot;Residual contribution to an ODE from a source functor acting at nodes.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/UserForcingFunctorNodalKernel.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    functor&lt;&lt;&lt;{&quot;description&quot;: &quot;The forcing functor. A functor is any of the following: a variable, a functor material property, a function, a postprocessor or a number.&quot;}&gt;&gt;&gt; = force
  [../]
[]

[Functions&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Functions/index.html&quot;}&gt;&gt;&gt;]
  [./force]
    type = PiecewiseLinear&lt;&lt;&lt;{&quot;description&quot;: &quot;Linearly interpolates between pairs of x-y data&quot;, &quot;href&quot;: &quot;../../source/functions/PiecewiseLinear.html&quot;}&gt;&gt;&gt;
    x&lt;&lt;&lt;{&quot;description&quot;: &quot;The abscissa values&quot;}&gt;&gt;&gt; = &#x27;0.0 0.005 0.01 1.0&#x27;
    y&lt;&lt;&lt;{&quot;description&quot;: &quot;The ordinate values&quot;}&gt;&gt;&gt; = &#x27;0.0 1.0  0.0  0.0&#x27;
  [../]
[]

[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [./smp]
    type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
    full&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you want the full set of couplings between variables simply for convenience so you don&#x27;t have to set every off_diag_row and off_diag_column combination.&quot;}&gt;&gt;&gt; = true
  [../]
[]

[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-11
  nl_abs_tol = 1e-11
  start_time = 0.0
  dt = 0.005
  end_time = 0.5
  timestep_tolerance = 1e-6
[]

[Kernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/index.html&quot;}&gt;&gt;&gt;]
  [./solid_disp_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 0
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 1
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 2
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 3
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 4
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 5
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
  [../]
  [./inertial_force_x]
    type = InertialForceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.&quot;, &quot;href&quot;: &quot;../../source/kernels/InertialForceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacement variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotational variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational velocity variables&quot;}&gt;&gt;&gt; = &#x27;vel_x vel_y vel_z&#x27;
    accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing cross-section area&quot;}&gt;&gt;&gt; = 1.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about y axis&quot;}&gt;&gt;&gt; = 1.0
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about z axis&quot;}&gt;&gt;&gt; = 1.0
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about y axis&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about z axis&quot;}&gt;&gt;&gt; = 0.0
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 0
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./inertial_force_y]
    type = InertialForceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.&quot;, &quot;href&quot;: &quot;../../source/kernels/InertialForceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacement variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotational variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational velocity variables&quot;}&gt;&gt;&gt; = &#x27;vel_x vel_y vel_z&#x27;
    accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing cross-section area&quot;}&gt;&gt;&gt; = 1.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about y axis&quot;}&gt;&gt;&gt; = 1.0
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about z axis&quot;}&gt;&gt;&gt; = 1.0
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about y axis&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about z axis&quot;}&gt;&gt;&gt; = 0.0
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 1
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./inertial_force_z]
    type = InertialForceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.&quot;, &quot;href&quot;: &quot;../../source/kernels/InertialForceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacement variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotational variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational velocity variables&quot;}&gt;&gt;&gt; = &#x27;vel_x vel_y vel_z&#x27;
    accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing cross-section area&quot;}&gt;&gt;&gt; = 1.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about y axis&quot;}&gt;&gt;&gt; = 1.0
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about z axis&quot;}&gt;&gt;&gt; = 1.0
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about y axis&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about z axis&quot;}&gt;&gt;&gt; = 0.0
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 2
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
  [../]
  [./inertial_force_rot_x]
    type = InertialForceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.&quot;, &quot;href&quot;: &quot;../../source/kernels/InertialForceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacement variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotational variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational velocity variables&quot;}&gt;&gt;&gt; = &#x27;vel_x vel_y vel_z&#x27;
    accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing cross-section area&quot;}&gt;&gt;&gt; = 1.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about y axis&quot;}&gt;&gt;&gt; = 1.0
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about z axis&quot;}&gt;&gt;&gt; = 1.0
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about y axis&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about z axis&quot;}&gt;&gt;&gt; = 0.0
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 3
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
  [../]
  [./inertial_force_rot_y]
    type = InertialForceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.&quot;, &quot;href&quot;: &quot;../../source/kernels/InertialForceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacement variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotational variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational velocity variables&quot;}&gt;&gt;&gt; = &#x27;vel_x vel_y vel_z&#x27;
    accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing cross-section area&quot;}&gt;&gt;&gt; = 1.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about y axis&quot;}&gt;&gt;&gt; = 1.0
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about z axis&quot;}&gt;&gt;&gt; = 1.0
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about y axis&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about z axis&quot;}&gt;&gt;&gt; = 0.0
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 4
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
  [../]
  [./inertial_force_rot_z]
    type = InertialForceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.&quot;, &quot;href&quot;: &quot;../../source/kernels/InertialForceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacement variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotational variables appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational velocity variables&quot;}&gt;&gt;&gt; = &#x27;vel_x vel_y vel_z&#x27;
    accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Translational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;Rotational acceleration variables&quot;}&gt;&gt;&gt; = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing cross-section area&quot;}&gt;&gt;&gt; = 1.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about y axis&quot;}&gt;&gt;&gt; = 1.0
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing second moment of area about z axis&quot;}&gt;&gt;&gt; = 1.0
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about y axis&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable containing first moment of area about z axis&quot;}&gt;&gt;&gt; = 0.0
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 5
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
  [../]
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [./elasticity]
    type = ComputeElasticityBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the equivalent of the elasticity tensor for the beam element, which are vectors of material translational and flexural stiffness.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeElasticityBeam.html&quot;}&gt;&gt;&gt;
    youngs_modulus&lt;&lt;&lt;{&quot;description&quot;: &quot;Young&#x27;s modulus of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 2e4
    poissons_ratio&lt;&lt;&lt;{&quot;description&quot;: &quot;Poisson&#x27;s ratio of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    shear_coefficient&lt;&lt;&lt;{&quot;description&quot;: &quot;Scale factor for the shear modulus. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute a infinitesimal/large strain increment for the beam.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeIncrementalBeamStrain.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Cross-section area of the beam. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    y_orientation&lt;&lt;&lt;{&quot;description&quot;: &quot;Orientation of the y direction along with Iyy is provided. This should be perpendicular to the axis of the beam.&quot;}&gt;&gt;&gt; = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute forces and moments using elasticity&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeBeamResultants.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
  [./density]
    type = GenericConstantMaterial&lt;&lt;&lt;{&quot;description&quot;: &quot;Declares material properties based on names and values prescribed by input parameters.&quot;, &quot;href&quot;: &quot;../../source/materials/GenericConstantMaterial.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
    prop_names&lt;&lt;&lt;{&quot;description&quot;: &quot;The names of the properties this material will have&quot;}&gt;&gt;&gt; = &#x27;density&#x27;
    prop_values&lt;&lt;&lt;{&quot;description&quot;: &quot;The values associated with the named properties&quot;}&gt;&gt;&gt; = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./disp_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./vel_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = vel_y
  [../]
  [./accel_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = accel_y
  [../]
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
  csv&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the scalar variable and postprocessors to a *.csv file using the default CSV output.&quot;}&gt;&gt;&gt; = true
  perf_graph&lt;&lt;&lt;{&quot;description&quot;: &quot;Enable printing of the performance graph to the screen (Console)&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#82e6e9f5-aee6-44ec-a67a-3f9dd3b66cf2">(moose/modules/solid_mechanics/test/tests/beam/dynamic/dyn_timoshenko_small.i)</a><section id="a1f50fe4-7d5f-49ff-b6da-2312183732a8" data-section-level="3" data-section-text="Results"><h3 id="results">Results</h3><p>For this beam, the dimensionless parameter alpha is given by: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-b6048060-a8d1-4e58-8089-28ee465c37e9"></span><script>var element = document.getElementById("moose-equation-b6048060-a8d1-4e58-8089-28ee465c37e9");katex.render("alpha = \\frac {kAGL^2}{EI} = 8", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>  Therefore, the beam behaves like a Timoshenko beam. The displacement, velocity and acceleration, as the function of time, at the free end of the cantilever beam in MOOSE, are compared with the results from ABAQUS using the time step of 0.005 s, as shown in <a href="#fig:timo_vibration_disp">Figure 12</a>, <a href="#fig:timo_vibration_vel">Figure 13</a> and <a href="#fig:timo_vibration_acc">Figure 14</a>.</p><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:timo_vibration_disp"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/timoshenko_small_disp.png" alt="Displacement at the free end of the Timoshenko beam."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 12: </span><span class="moose-caption-text" id="fig:timo_vibration_disp">Displacement at the free end of the Timoshenko beam.</span></p></div></div><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:timo_vibration_vel"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/timoshenko_small_vel.png" alt="Velocity at the free end of the Timoshenko beam."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 13: </span><span class="moose-caption-text" id="fig:timo_vibration_vel">Velocity at the free end of the Timoshenko beam.</span></p></div></div><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:timo_vibration_acc"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/timoshenko_small_acc.png" alt="Acceleration at the free end of the Timoshenko beam."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 14: </span><span class="moose-caption-text" id="fig:timo_vibration_acc">Acceleration at the free end of the Timoshenko beam.</span></p></div></div></section></section><section id="68957ccd-a02c-4d99-8d05-2f4529caaba6" data-section-level="2" data-section-text="Small strain massless beam vibration with a lumped mass"><h2 id="small-strain-massless-beam-vibration-with-a-lumped-mass">Small strain massless beam vibration with a lumped mass</h2><p>A 1D cantilever beam of 4 m is modeled using beam elements in MOOSE. The beam is massless with a lumped mass of 0.0189972 kgs at its free end. The beam has a moment of inertia of 1<span class="moose-katex-inline-equation" id="moose-equation-e2f64664-55fa-46a7-a482-6da27d053c94"><script>var element = document.getElementById("moose-equation-e2f64664-55fa-46a7-a482-6da27d053c94");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-78b467a3-d86f-4488-8b42-c4d02c1a361a"><script>var element = document.getElementById("moose-equation-78b467a3-d86f-4488-8b42-c4d02c1a361a");katex.render("^-", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span><span class="moose-katex-inline-equation" id="moose-equation-6e83186e-478e-43c2-b24f-2feb5b0455b6"><script>var element = document.getElementById("moose-equation-6e83186e-478e-43c2-b24f-2feb5b0455b6");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> <span class="moose-katex-inline-equation" id="moose-equation-b745791f-9b2c-4ed4-8243-d23e7dfec0ac"><script>var element = document.getElementById("moose-equation-b745791f-9b2c-4ed4-8243-d23e7dfec0ac");katex.render("{m}^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> about Y and Z axis, Young&#x27;s modulus of elasticity of 1<span class="moose-katex-inline-equation" id="moose-equation-ad0cf14a-bf3a-47a1-ace4-7126c62a2ebd"><script>var element = document.getElementById("moose-equation-ad0cf14a-bf3a-47a1-ace4-7126c62a2ebd");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-bf8e2aa7-90ac-4b6e-aa23-72ae4e128f6e"><script>var element = document.getElementById("moose-equation-bf8e2aa7-90ac-4b6e-aa23-72ae4e128f6e");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N/<span class="moose-katex-inline-equation" id="moose-equation-1e8cd571-95cc-4a1f-8df8-25181dd8b8c9"><script>var element = document.getElementById("moose-equation-1e8cd571-95cc-4a1f-8df8-25181dd8b8c9");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, poisson&#x27;s ratio of -0.99, shear modulus of  4<span class="moose-katex-inline-equation" id="moose-equation-8ce7ad2c-8846-4132-a99b-67ff09cfe2a8"><script>var element = document.getElementById("moose-equation-8ce7ad2c-8846-4132-a99b-67ff09cfe2a8");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-76a27753-5b1f-44a4-bd41-8d8770b6bd44"><script>var element = document.getElementById("moose-equation-76a27753-5b1f-44a4-bd41-8d8770b6bd44");katex.render("^7", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N/<span class="moose-katex-inline-equation" id="moose-equation-aba6651d-97c4-47e8-be2f-82952ba6503e"><script>var element = document.getElementById("moose-equation-aba6651d-97c4-47e8-be2f-82952ba6503e");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and shear coefficient of 1. An impulse load with a peak value of 0.01 N at 0.1 s, as shown in <a href="#fig:impulseload3">Figure 15</a>, is applied at the free end of the beam in Y direction. The Newmark time integration parameters used in the problem correspond to the Newmark&#x27;s average acceleration method, i.e., <code>beta=0.25</code> and <code>gamma=0.5</code>.</p><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:impulseload3"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/massless_small_impulse.png" alt="Impulse load pattern applied at the free end of the beam."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 15: </span><span class="moose-caption-text" id="fig:impulseload3">Impulse load pattern applied at the free end of the beam.</span></p></div></div><pre style="max-height:350px;"><code class="language-moose"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The beam is massless with a lumped mass at the end of the beam
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# mass (m) = 0.01899772

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The theoretical first frequency of this beam is:
# f1 = 1/(2 pi) * sqrt(3EI/(mL^3)) = 0.25

# This implies that the corresponding time period of this beam is 4s.

# The FEM solution for this beam with 10 element gives time periods of 4s with time step of 0.01s.
# A higher time step of 0.1 s is used in the test to reduce computational time.

# The time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time   disp_y                vel_y                accel_y
# 0.0    0.0                   0.0                  0.0
# 0.1    0.0013076435060869    0.026152870121738    0.52305740243477
# 0.2    0.0051984378734383    0.051663017225289   -0.01285446036375
# 0.3    0.010269120909367     0.049750643493289   -0.02539301427625
# 0.4    0.015087433925158     0.046615616822532   -0.037307519138892
# 0.5    0.019534963888307     0.042334982440433   -0.048305168503101

[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  type = GeneratedMesh
  xmin = 0.0
  xmax = 4.0
  nx = 10
  dim = 1
  displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The variables corresponding to the x y z displacements of the mesh.  If this is provided then the displacements will be taken into account during the computation. Creation of the displaced mesh can be suppressed even if this is set by setting &#x27;use_displaced_mesh = false&#x27;.&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[AuxVariables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxVariables/index.html&quot;}&gt;&gt;&gt;]
  [./vel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./vel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./vel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./accel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./accel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./accel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[AuxKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxKernels/index.html&quot;}&gt;&gt;&gt;]
  [./accel_x]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = accel_x
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = disp_x
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_x
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = vel_x
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_x
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = accel_y
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = disp_y
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_y
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = vel_y
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_y
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = accel_z
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = disp_z
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_z
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = vel_z
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_z
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
[]

[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/index.html&quot;}&gt;&gt;&gt;]
  [./fixx1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixy1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixz1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr2]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr3]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
[]

[NodalKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/NodalKernels/index.html&quot;}&gt;&gt;&gt;]
  [./force_y2]
    type = UserForcingFunctorNodalKernel&lt;&lt;&lt;{&quot;description&quot;: &quot;Residual contribution to an ODE from a source functor acting at nodes.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/UserForcingFunctorNodalKernel.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    functor&lt;&lt;&lt;{&quot;description&quot;: &quot;The forcing functor. A functor is any of the following: a variable, a functor material property, a function, a postprocessor or a number.&quot;}&gt;&gt;&gt; = force
  [../]
  [./x_inertial]
    type = NodalTranslationalInertia&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the inertial forces and mass proportional damping terms corresponding to nodal mass.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/NodalTranslationalInertia.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_x
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    mass&lt;&lt;&lt;{&quot;description&quot;: &quot;Mass associated with the node&quot;}&gt;&gt;&gt; = 0.01899772
  [../]
  [./y_inertial]
    type = NodalTranslationalInertia&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the inertial forces and mass proportional damping terms corresponding to nodal mass.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/NodalTranslationalInertia.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_y
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    mass&lt;&lt;&lt;{&quot;description&quot;: &quot;Mass associated with the node&quot;}&gt;&gt;&gt; = 0.01899772
  [../]
  [./z_inertial]
    type = NodalTranslationalInertia&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the inertial forces and mass proportional damping terms corresponding to nodal mass.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/NodalTranslationalInertia.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_z
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    mass&lt;&lt;&lt;{&quot;description&quot;: &quot;Mass associated with the node&quot;}&gt;&gt;&gt; = 0.01899772
  [../]
[]

[Functions&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Functions/index.html&quot;}&gt;&gt;&gt;]
  [./force]
    type = PiecewiseLinear&lt;&lt;&lt;{&quot;description&quot;: &quot;Linearly interpolates between pairs of x-y data&quot;, &quot;href&quot;: &quot;../../source/functions/PiecewiseLinear.html&quot;}&gt;&gt;&gt;
    x&lt;&lt;&lt;{&quot;description&quot;: &quot;The abscissa values&quot;}&gt;&gt;&gt; = &#x27;0.0 0.1 0.2 10.0&#x27;
    y&lt;&lt;&lt;{&quot;description&quot;: &quot;The ordinate values&quot;}&gt;&gt;&gt; = &#x27;0.0 1e-2  0.0  0.0&#x27;
  [../]
[]

[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [./smp]
    type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
    full&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you want the full set of couplings between variables simply for convenience so you don&#x27;t have to set every off_diag_row and off_diag_column combination.&quot;}&gt;&gt;&gt; = true
  [../]
[]

[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-ksp_type -pc_type&#x27;
  petsc_options_value = &#x27;preonly   lu&#x27;

  dt = 0.1
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Kernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/index.html&quot;}&gt;&gt;&gt;]
  [./solid_disp_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 0
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 1
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 2
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 3
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 4
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 5
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
  [../]
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [./elasticity]
    type = ComputeElasticityBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the equivalent of the elasticity tensor for the beam element, which are vectors of material translational and flexural stiffness.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeElasticityBeam.html&quot;}&gt;&gt;&gt;
    youngs_modulus&lt;&lt;&lt;{&quot;description&quot;: &quot;Young&#x27;s modulus of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0e4
    poissons_ratio&lt;&lt;&lt;{&quot;description&quot;: &quot;Poisson&#x27;s ratio of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = -0.999875
    shear_coefficient&lt;&lt;&lt;{&quot;description&quot;: &quot;Scale factor for the shear modulus. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute a infinitesimal/large strain increment for the beam.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeIncrementalBeamStrain.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Cross-section area of the beam. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.01
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0e-4
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0e-4
    y_orientation&lt;&lt;&lt;{&quot;description&quot;: &quot;Orientation of the y direction along with Iyy is provided. This should be perpendicular to the axis of the beam.&quot;}&gt;&gt;&gt; = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute forces and moments using elasticity&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeBeamResultants.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./disp_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./vel_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = vel_y
  [../]
  [./accel_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = accel_y
  [../]
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
  csv&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the scalar variable and postprocessors to a *.csv file using the default CSV output.&quot;}&gt;&gt;&gt; = true
  perf_graph&lt;&lt;&lt;{&quot;description&quot;: &quot;Enable printing of the performance graph to the screen (Console)&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#96343baa-dbe8-453b-a8ca-dc377e83dc32">(moose/modules/solid_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass.i)</a><section id="034ee11d-5b72-40b4-aeb4-d66569d2057a" data-section-level="3" data-section-text="Results"><h3 id="results">Results</h3><p>The displacement, velocity and acceleration, as the function of time, at the free end of the cantilever beam in MOOSE, are compared with the results from ABAQUS using the time step of 0.1 s, as shown in <a href="#fig:added_mass_disp">Figure 16</a>, <a href="#fig:added_mass_vel">Figure 17</a> and <a href="#fig:added_mass_acc">Figure 18</a>.</p><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:added_mass_disp"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/added_mass_disp.png" alt="Displacement at the free end of the massless beam with lumped mass."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 16: </span><span class="moose-caption-text" id="fig:added_mass_disp">Displacement at the free end of the massless beam with lumped mass.</span></p></div></div><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:added_mass_vel"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/added_mass_vel.png" alt="Velocity at the free end of the massless beam with lumped mass."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 17: </span><span class="moose-caption-text" id="fig:added_mass_vel">Velocity at the free end of the massless beam with lumped mass.</span></p></div></div><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:added_mass_acc"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/added_mass_acc.png" alt="Acceleration at the free end of the massless beam with lumped mass."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 18: </span><span class="moose-caption-text" id="fig:added_mass_acc">Acceleration at the free end of the massless beam with lumped mass.</span></p></div></div></section></section><section id="da77cee1-9d6f-497b-91e8-7775ba8a7601" data-section-level="2" data-section-text="Small strain massless beam damped vibration with a lumped mass having rotational moment of inertia"><h2 id="small-strain-massless-beam-damped-vibration-with-a-lumped-mass-having-rotational-moment-of-inertia">Small strain massless beam damped vibration with a lumped mass having rotational moment of inertia</h2><p>A 1D cantilever beam of 4 m is modeled using beam elements in MOOSE. The beam is massless with a lumped mass of 0.01899772 kgs at its free end whose moment of inertia about X, Y and Z axis is 0.2 <span class="moose-katex-inline-equation" id="moose-equation-4cc4b7f1-93af-4f14-beb7-6beddb4a1dcc"><script>var element = document.getElementById("moose-equation-4cc4b7f1-93af-4f14-beb7-6beddb4a1dcc");katex.render("{m}^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>,0.1 <span class="moose-katex-inline-equation" id="moose-equation-8b14b7db-e0c3-4d0b-90fc-ebde429c7c97"><script>var element = document.getElementById("moose-equation-8b14b7db-e0c3-4d0b-90fc-ebde429c7c97");katex.render("{m}^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and 0.1 <span class="moose-katex-inline-equation" id="moose-equation-2f185c5d-724f-42d3-8e9d-9611e9381eef"><script>var element = document.getElementById("moose-equation-2f185c5d-724f-42d3-8e9d-9611e9381eef");katex.render("{m}^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, . The beam has a moment of inertia about Y and Z axis of 1<span class="moose-katex-inline-equation" id="moose-equation-e0ceb7fe-ee7a-4e1e-a3c2-fc91cc552b69"><script>var element = document.getElementById("moose-equation-e0ceb7fe-ee7a-4e1e-a3c2-fc91cc552b69");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-34cb49bf-5d90-451f-9179-6138a2cadb15"><script>var element = document.getElementById("moose-equation-34cb49bf-5d90-451f-9179-6138a2cadb15");katex.render("^-", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span><span class="moose-katex-inline-equation" id="moose-equation-872e923c-3dab-4858-abd3-24397b228473"><script>var element = document.getElementById("moose-equation-872e923c-3dab-4858-abd3-24397b228473");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> <span class="moose-katex-inline-equation" id="moose-equation-c0b4457b-416a-42e5-b959-ce45519a13a7"><script>var element = document.getElementById("moose-equation-c0b4457b-416a-42e5-b959-ce45519a13a7");katex.render("{m}^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, Young&#x27;s modulus of elasticity of 1<span class="moose-katex-inline-equation" id="moose-equation-8caaf2f2-cd53-47ff-b6b5-163b6b6cb865"><script>var element = document.getElementById("moose-equation-8caaf2f2-cd53-47ff-b6b5-163b6b6cb865");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-6dfd78b0-661f-489d-9b30-ca8b3bc13132"><script>var element = document.getElementById("moose-equation-6dfd78b0-661f-489d-9b30-ca8b3bc13132");katex.render("^4", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N/<span class="moose-katex-inline-equation" id="moose-equation-efce46e3-cc2c-4306-aa7b-56bc578092a9"><script>var element = document.getElementById("moose-equation-efce46e3-cc2c-4306-aa7b-56bc578092a9");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, poisson&#x27;s ratio of -0.99, shear modulus of  4<span class="moose-katex-inline-equation" id="moose-equation-cea492f3-05c0-4e57-b453-887d43c2f9af"><script>var element = document.getElementById("moose-equation-cea492f3-05c0-4e57-b453-887d43c2f9af");katex.render("\\times", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>10<span class="moose-katex-inline-equation" id="moose-equation-8af51697-f514-4372-b062-d7149dce2764"><script>var element = document.getElementById("moose-equation-8af51697-f514-4372-b062-d7149dce2764");katex.render("^7", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> N/<span class="moose-katex-inline-equation" id="moose-equation-966d45c8-621c-416c-a701-83a350cbc996"><script>var element = document.getElementById("moose-equation-966d45c8-621c-416c-a701-83a350cbc996");katex.render("{m}^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and shear coefficient of 1. An impulse load with a peak value of 0.01 N at 0.1 s as shown in <a href="#fig:impulseload4">Figure 19</a> is applied at the free end of the beam in Y direction. The Newmark time integration parameters used in the problem correspond to the Newmark&#x27;s average acceleration method, i.e., <code>beta=0.25</code> and <code>gamma=0.5</code> and vibration is damping using the mass proportional coefficient <code>eta=0.1</code>.</p><div class="card moose-float" style="width:450px;margin-left:110px;float:center;" id="fig:impulseload4"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/massless_small_impulse.png" alt="Impulse load pattern applied at the free end of the beam."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 19: </span><span class="moose-caption-text" id="fig:impulseload4">Impulse load pattern applied at the free end of the beam.</span></p></div></div><pre style="max-height:350px;"><code class="language-moose"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The beam is massless with a lumped mass at the end of the beam. The lumped
# mass also has a moment of inertia associated with it.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# mass (m) = 0.01899772
# Moment of inertia of lumped mass:
# Ixx = 0.2
# Iyy = 0.1
# Izz = 0.1
# mass proportional damping coefficient (eta) = 0.1

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The displacement time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time   disp_y              vel_y               accel_y
# 0.0    0.0                 0.0                 0.0
# 0.1    0.001278249649738   0.025564992994761   0.51129985989521
# 0.2    0.0049813090917644  0.048496195845768  -0.052675802875074
# 0.3    0.0094704658873002  0.041286940064947  -0.091509312741339
# 0.4    0.013082280729802   0.03094935678508   -0.115242352856
# 0.5    0.015588313103503   0.019171290688959  -0.12031896906642

[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 4.0
  displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The variables corresponding to the x y z displacements of the mesh.  If this is provided then the displacements will be taken into account during the computation. Creation of the displaced mesh can be suppressed even if this is set by setting &#x27;use_displaced_mesh = false&#x27;.&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./disp_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_x]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_y]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_z]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[AuxVariables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxVariables/index.html&quot;}&gt;&gt;&gt;]
  [./vel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./vel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./vel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./accel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./accel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./accel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_vel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_vel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_vel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_accel_x]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_accel_y]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
  [./rot_accel_z]
  order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
  family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[AuxKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxKernels/index.html&quot;}&gt;&gt;&gt;]
  [./accel_x]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = accel_x
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = disp_x
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_x
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = vel_x
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_x
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = accel_y
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = disp_y
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_y
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = vel_y
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_y
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = accel_z
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = disp_z
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_z
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = vel_z
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_z
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_accel_x]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_accel_x
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = rot_x
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = rot_vel_x
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_vel_x]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_vel_x
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = rot_accel_x
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_accel_y]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_accel_y
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = rot_y
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = rot_vel_y
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_vel_y]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_vel_y
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = rot_accel_y
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_accel_z]
    type = NewmarkAccelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the current acceleration using the Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkAccelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_accel_z
    displacement&lt;&lt;&lt;{&quot;description&quot;: &quot;displacement variable&quot;}&gt;&gt;&gt; = rot_z
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = rot_vel_z
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.25
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
  [./rot_vel_z]
    type = NewmarkVelAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the current velocity using Newmark method.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/NewmarkVelAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = rot_vel_z
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = rot_accel_z
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark method&quot;}&gt;&gt;&gt; = 0.5
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = timestep_end
  [../]
[]

[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/index.html&quot;}&gt;&gt;&gt;]
  [./fixx1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixy1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixz1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr1]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr2]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
  [./fixr3]
    type = DirichletBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Imposes the essential boundary condition $u=g$, where $g$ is a constant, controllable value.&quot;, &quot;href&quot;: &quot;../../source/bcs/DirichletBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = left
    value&lt;&lt;&lt;{&quot;description&quot;: &quot;Value of the BC&quot;}&gt;&gt;&gt; = 0.0
  [../]
[]

[NodalKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/NodalKernels/index.html&quot;}&gt;&gt;&gt;]
  [./force_y2]
    type = UserForcingFunctorNodalKernel&lt;&lt;&lt;{&quot;description&quot;: &quot;Residual contribution to an ODE from a source functor acting at nodes.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/UserForcingFunctorNodalKernel.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    functor&lt;&lt;&lt;{&quot;description&quot;: &quot;The forcing functor. A functor is any of the following: a variable, a functor material property, a function, a postprocessor or a number.&quot;}&gt;&gt;&gt; = force
  [../]
  [./x_inertial]
    type = NodalTranslationalInertia&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the inertial forces and mass proportional damping terms corresponding to nodal mass.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/NodalTranslationalInertia.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_x
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_x
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    mass&lt;&lt;&lt;{&quot;description&quot;: &quot;Mass associated with the node&quot;}&gt;&gt;&gt; = 0.01899772
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Constant real number defining the eta parameter for Rayleigh damping.&quot;}&gt;&gt;&gt; = 0.1
  [../]
  [./y_inertial]
    type = NodalTranslationalInertia&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the inertial forces and mass proportional damping terms corresponding to nodal mass.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/NodalTranslationalInertia.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_y
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_y
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    mass&lt;&lt;&lt;{&quot;description&quot;: &quot;Mass associated with the node&quot;}&gt;&gt;&gt; = 0.01899772
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Constant real number defining the eta parameter for Rayleigh damping.&quot;}&gt;&gt;&gt; = 0.1
  [../]
  [./z_inertial]
    type = NodalTranslationalInertia&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the inertial forces and mass proportional damping terms corresponding to nodal mass.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/NodalTranslationalInertia.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
    velocity&lt;&lt;&lt;{&quot;description&quot;: &quot;velocity variable&quot;}&gt;&gt;&gt; = vel_z
    acceleration&lt;&lt;&lt;{&quot;description&quot;: &quot;acceleration variable&quot;}&gt;&gt;&gt; = accel_z
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    mass&lt;&lt;&lt;{&quot;description&quot;: &quot;Mass associated with the node&quot;}&gt;&gt;&gt; = 0.01899772
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Constant real number defining the eta parameter for Rayleigh damping.&quot;}&gt;&gt;&gt; = 0.1
  [../]
  [./rot_x_inertial]
    type = NodalRotationalInertia&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the inertial torques and inertia proportional damping corresponding to the nodal rotational inertia.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/NodalRotationalInertia.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;rotational displacement variables&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;rotational acceleration variables&quot;}&gt;&gt;&gt;= &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    Ixx&lt;&lt;&lt;{&quot;description&quot;: &quot;Moment of inertia in the x direction.&quot;}&gt;&gt;&gt; = 2e-1
    Iyy&lt;&lt;&lt;{&quot;description&quot;: &quot;Moment of inertia in the y direction.&quot;}&gt;&gt;&gt; = 1e-1
    Izz&lt;&lt;&lt;{&quot;description&quot;: &quot;Moment of inertia in the z direction.&quot;}&gt;&gt;&gt; = 1e-1
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Constant real number defining the eta parameter forRayleigh damping.&quot;}&gt;&gt;&gt; = 0.1
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this nodalkernel acts in. (0 for rot_x, 1 for rot_y, and 2 for rot_z).&quot;}&gt;&gt;&gt; = 0
  [../]
  [./rot_y_inertial]
    type = NodalRotationalInertia&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the inertial torques and inertia proportional damping corresponding to the nodal rotational inertia.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/NodalRotationalInertia.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;rotational displacement variables&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;rotational acceleration variables&quot;}&gt;&gt;&gt;= &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    Ixx&lt;&lt;&lt;{&quot;description&quot;: &quot;Moment of inertia in the x direction.&quot;}&gt;&gt;&gt; = 2e-1
    Iyy&lt;&lt;&lt;{&quot;description&quot;: &quot;Moment of inertia in the y direction.&quot;}&gt;&gt;&gt; = 1e-1
    Izz&lt;&lt;&lt;{&quot;description&quot;: &quot;Moment of inertia in the z direction.&quot;}&gt;&gt;&gt; = 1e-1
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Constant real number defining the eta parameter forRayleigh damping.&quot;}&gt;&gt;&gt; = 0.1
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this nodalkernel acts in. (0 for rot_x, 1 for rot_y, and 2 for rot_z).&quot;}&gt;&gt;&gt; = 1
  [../]
  [./rot_z_inertial]
    type = NodalRotationalInertia&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculates the inertial torques and inertia proportional damping corresponding to the nodal rotational inertia.&quot;, &quot;href&quot;: &quot;../../source/nodalkernels/NodalRotationalInertia.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;rotational displacement variables&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    rotational_velocities&lt;&lt;&lt;{&quot;description&quot;: &quot;rotational velocity variables&quot;}&gt;&gt;&gt; = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations&lt;&lt;&lt;{&quot;description&quot;: &quot;rotational acceleration variables&quot;}&gt;&gt;&gt;= &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundaries (ids or names) from the mesh where this object applies&quot;}&gt;&gt;&gt; = right
    beta&lt;&lt;&lt;{&quot;description&quot;: &quot;beta parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.25
    gamma&lt;&lt;&lt;{&quot;description&quot;: &quot;gamma parameter for Newmark Time integration&quot;}&gt;&gt;&gt; = 0.5
    Ixx&lt;&lt;&lt;{&quot;description&quot;: &quot;Moment of inertia in the x direction.&quot;}&gt;&gt;&gt; = 2e-1
    Iyy&lt;&lt;&lt;{&quot;description&quot;: &quot;Moment of inertia in the y direction.&quot;}&gt;&gt;&gt; = 1e-1
    Izz&lt;&lt;&lt;{&quot;description&quot;: &quot;Moment of inertia in the z direction.&quot;}&gt;&gt;&gt; = 1e-1
    eta&lt;&lt;&lt;{&quot;description&quot;: &quot;Constant real number defining the eta parameter forRayleigh damping.&quot;}&gt;&gt;&gt; = 0.1
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this nodalkernel acts in. (0 for rot_x, 1 for rot_y, and 2 for rot_z).&quot;}&gt;&gt;&gt; = 2
  [../]
[]

[Functions&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Functions/index.html&quot;}&gt;&gt;&gt;]
  [./force]
    type = PiecewiseLinear&lt;&lt;&lt;{&quot;description&quot;: &quot;Linearly interpolates between pairs of x-y data&quot;, &quot;href&quot;: &quot;../../source/functions/PiecewiseLinear.html&quot;}&gt;&gt;&gt;
    x&lt;&lt;&lt;{&quot;description&quot;: &quot;The abscissa values&quot;}&gt;&gt;&gt; = &#x27;0.0 0.1 0.2 10.0&#x27;
    y&lt;&lt;&lt;{&quot;description&quot;: &quot;The ordinate values&quot;}&gt;&gt;&gt; = &#x27;0.0 1e-2  0.0  0.0&#x27;
  [../]
[]

[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [./smp]
    type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
    full&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you want the full set of couplings between variables simply for convenience so you don&#x27;t have to set every off_diag_row and off_diag_column combination.&quot;}&gt;&gt;&gt; = true
  [../]
[]

[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-ksp_type -pc_type&#x27;
  petsc_options_value = &#x27;preonly   lu&#x27;

  dt = 0.1
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Kernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/index.html&quot;}&gt;&gt;&gt;]
  [./solid_disp_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 0
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 1
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 2
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 3
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 4
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Quasi-static and dynamic stress divergence kernel for Beam element&quot;, &quot;href&quot;: &quot;../../source/kernels/StressDivergenceBeam.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    component&lt;&lt;&lt;{&quot;description&quot;: &quot;An integer corresponding to the direction the variable this kernel acts in. (0 for disp_x, 1 for disp_y, 2 for disp_z, 3 for rot_x, 4 for rot_y and 5 for rot_z)&quot;}&gt;&gt;&gt; = 5
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = rot_z
  [../]
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [./elasticity]
    type = ComputeElasticityBeam&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes the equivalent of the elasticity tensor for the beam element, which are vectors of material translational and flexural stiffness.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeElasticityBeam.html&quot;}&gt;&gt;&gt;
    youngs_modulus&lt;&lt;&lt;{&quot;description&quot;: &quot;Young&#x27;s modulus of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0e4
    poissons_ratio&lt;&lt;&lt;{&quot;description&quot;: &quot;Poisson&#x27;s ratio of the material. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = -0.999875
    shear_coefficient&lt;&lt;&lt;{&quot;description&quot;: &quot;Scale factor for the shear modulus. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute a infinitesimal/large strain increment for the beam.&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeIncrementalBeamStrain.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = &#x27;0&#x27;
    displacements&lt;&lt;&lt;{&quot;description&quot;: &quot;The displacements appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;disp_x disp_y disp_z&#x27;
    rotations&lt;&lt;&lt;{&quot;description&quot;: &quot;The rotations appropriate for the simulation geometry and coordinate system&quot;}&gt;&gt;&gt; = &#x27;rot_x rot_y rot_z&#x27;
    area&lt;&lt;&lt;{&quot;description&quot;: &quot;Cross-section area of the beam. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.01
    Ay&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Az&lt;&lt;&lt;{&quot;description&quot;: &quot;First moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 0.0
    Iy&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about y axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0e-4
    Iz&lt;&lt;&lt;{&quot;description&quot;: &quot;Second moment of area of the beam about z axis. Can be supplied as either a number or a variable name.&quot;}&gt;&gt;&gt; = 1.0e-4
    y_orientation&lt;&lt;&lt;{&quot;description&quot;: &quot;Orientation of the y direction along with Iyy is provided. This should be perpendicular to the axis of the beam.&quot;}&gt;&gt;&gt; = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute forces and moments using elasticity&quot;, &quot;href&quot;: &quot;../../source/materials/ComputeBeamResultants.html&quot;}&gt;&gt;&gt;
    block&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of blocks (ids or names) that this object will be applied&quot;}&gt;&gt;&gt; = 0
  [../]
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [./disp_x]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_x
  [../]
  [./disp_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = disp_y
  [../]
  [./vel_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = vel_y
  [../]
  [./accel_y]
    type = PointValue&lt;&lt;&lt;{&quot;description&quot;: &quot;Compute the value of a variable at a specified location&quot;, &quot;href&quot;: &quot;../../source/postprocessors/PointValue.html&quot;}&gt;&gt;&gt;
    point&lt;&lt;&lt;{&quot;description&quot;: &quot;The physical point where the solution will be evaluated.&quot;}&gt;&gt;&gt; = &#x27;4.0 0.0 0.0&#x27;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this postprocessor operates on.&quot;}&gt;&gt;&gt; = accel_y
  [../]
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
  csv&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the scalar variable and postprocessors to a *.csv file using the default CSV output.&quot;}&gt;&gt;&gt; = true
  perf_graph&lt;&lt;&lt;{&quot;description&quot;: &quot;Enable printing of the performance graph to the screen (Console)&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#b0309230-3b50-4e21-b481-0908c6ee6a78">(moose/modules/solid_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_inertia_damping.i)</a><section id="d9108980-e71a-4424-8578-764485d67bb5" data-section-level="3" data-section-text="Results"><h3 id="results">Results</h3><p> The displacement, velocity and acceleration, as the function of time, at the free end of the cantilever beam in MOOSE, are compared with the results from ABAQUS using the time step of 0.1 s, as shown in <a href="#fig:mass_damping_disp">Figure 20</a>, <a href="#fig:mass_damping_vel">Figure 21</a> and <a href="#fig:mass_damping_acc">Figure 22</a>.</p><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:mass_damping_disp"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/mass_damping_disp.png" alt="Displacement at the free end of the massless beam with lumped mass having rotational moment of inertia."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 20: </span><span class="moose-caption-text" id="fig:mass_damping_disp">Displacement at the free end of the massless beam with lumped mass having rotational moment of inertia.</span></p></div></div><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:mass_damping_vel"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/mass_damping_vel.png" alt="Velocity at the free end of the massless beam with lumped mass having rotational moment of inertia."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 21: </span><span class="moose-caption-text" id="fig:mass_damping_vel">Velocity at the free end of the massless beam with lumped mass having rotational moment of inertia.</span></p></div></div><div class="card moose-float" style="width:500px;margin-left:110px;float:center;" id="fig:mass_damping_acc"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/solid_mechanics/vandv/mass_damping_acc.png" alt="Acceleration at the free end of the massless beam with lumped mass having rotational moment of inertia."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 22: </span><span class="moose-caption-text" id="fig:mass_damping_acc">Acceleration at the free end of the massless beam with lumped mass having rotational moment of inertia.</span></p></div></div></section></section><section id="39780222-6401-4bf1-9157-12e8ecdb6610" data-section-level="2" data-section-text="References"><h2 id="references">References</h2><div class="moose-bibliography"><ol><li id="bishopanddrucker1945">K.&nbsp;E. BISSHOPP and D.&nbsp;C. DRUCKER.
Large deflection of cantilever beams.
<em>Quarterly of Applied Mathematics</em>, 3(3):272–275, 1945.
URL: <a href="http://www.jstor.org/stable/43633516">http://www.jstor.org/stable/43633516</a>.<a href="#a1d24605-4c7f-4371-b0d7-12910958433a" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="a1d24605-4c7f-4371-b0d7-12910958433a"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{bishopanddrucker1945,
    author = "BISSHOPP, K. E. and DRUCKER, D. C.",
    issn = "0033569X, 15524485",
    url = "http://www.jstor.org/stable/43633516",
    journal = "Quarterly of Applied Mathematics",
    number = "3",
    pages = "272--275",
    publisher = "Brown University",
    title = "LARGE DEFLECTION OF CANTILEVER BEAMS",
    volume = "3",
    year = "1945"
}
</code></pre></div></div></li></ol></div></section></section><div class="moose-modal modal" id="3be03515-6d71-426b-a602-7c0ba3f7bc6b"><div class="modal-content"><h4>(moose/modules/solid_mechanics/test/tests/beam/static/timoshenko_small_strain_y.i)</h4><pre style="max-height:350px;"><code class="language-moose"># Test for small strain timoshenko beam bending in y direction

# A unit load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 2.60072400269
# Shear modulus (G) = 1.00027846257
# Poisson&#x27;s ratio (nu) = 0.3
# Shear coefficient (k) = 0.85
# Cross-section area (A) = 0.554256
# Iy = 0.0141889 = Iz
# Length = 4 m

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 204.3734

# The small deformation analytical deflection of the beam is given by
# delta = PL^3/3EI * (1 + 3.0 / alpha) = 5.868e-4 m

# Using 10 elements to discretize the beam element, the FEM solution is 5.852e-2m.
# This deflection matches the FEM solution given in Prathap and Bhashyam (1982).

# References:
# Prathap and Bhashyam (1982), International journal for numerical methods in engineering, vol. 18, 195-210.
# Note that the force is scaled by 1e-4 compared to the reference problem.

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 4.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = ConstantRate
    variable = disp_y
    boundary = right
    rate = 1.0e-4
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]
[Executioner]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  dt = 1
  dtmin = 1
  end_time = 2
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 2.60072400269
    poissons_ratio = 0.3
    shear_coefficient = 0.85
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.554256
    Ay = 0.0
    Az = 0.0
    Iy = 0.0141889
    Iz = 0.0141889
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="751a0c07-dac3-4da3-8563-cb7afc672a81"><div class="modal-content"><h4>(moose/modules/solid_mechanics/test/tests/beam/static/euler_small_strain_y.i)</h4><pre style="max-height:350px;"><code class="language-moose"># Test for small strain Euler beam bending in y direction

# A unit load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 2.60072400269
# Shear modulus (G) = 1.0e4
# Poisson&#x27;s ratio (nu) = -0.9998699638
# Shear coefficient (k) = 0.85
# Cross-section area (A) = 0.554256
# Iy = 0.0141889 = Iz
# Length = 4 m

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 2.04e6

# The small deformation analytical deflection of the beam is given by
# delta = PL^3/3EI * (1 + 3.0 / alpha) = PL^3/3EI = 5.78e-2 m

# Using 10 elements to discretize the beam element, the FEM solution is 5.766e-2 m.
# The ratio beam FEM solution and analytical solution is 0.998.

# References:
# Prathap and Bhashyam (1982), International journal for numerical methods in engineering, vol. 18, 195-210.
# Note that the force is scaled by 1e-4 compared to the reference problem.

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 4.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = ConstantRate
    variable = disp_y
    boundary = right
    rate = 1.0e-4
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]
[Executioner]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  dt = 1
  dtmin = 1
  end_time = 2
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 2.60072400269
    poissons_ratio = -0.9998699638
    shear_coefficient = 0.85
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.554256
    Ay = 0.0
    Az = 0.0
    Iy = 0.0141889
    Iz = 0.0141889
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="fd632079-bc04-423e-a61e-472953d9f038"><div class="modal-content"><h4>(moose/modules/solid_mechanics/test/tests/beam/static/euler_pipe_axial_force.i)</h4><pre style="max-height:350px;"><code class="language-moose"># Test for small strain Euler beam axial loading in x direction.

# Modeling a pipe with an OD of 10 inches and ID of 8 inches
# The length of the pipe is 5 feet (60 inches) and E = 30e6
# G = 11.5384615385e6 with nu = 0.3
# The applied axial load is 50000 lb which results in a
# displacement of 3.537e-3 inches at the end

# delta = PL/AE = 50000 * 60 / pi (5^2 - 4^2) * 30e6 = 3.537e-3

# In this analysis the applied force is used as a BC

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 60.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [disp_x]
    order = FIRST
    family = LAGRANGE
  []
  [disp_y]
    order = FIRST
    family = LAGRANGE
  []
  [disp_z]
    order = FIRST
    family = LAGRANGE
  []
  [rot_x]
    order = FIRST
    family = LAGRANGE
  []
  [rot_y]
    order = FIRST
    family = LAGRANGE
  []
  [rot_z]
    order = FIRST
    family = LAGRANGE
  []
[]

[BCs]
  [fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  []
  [fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  []
  [fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  []
  [fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  []
  [fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  []
  [fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  []
[]

[NodalKernels]
  [force_x2]
    type = ConstantRate
    variable = disp_x
    boundary = right
    rate = 50000.0
  []
[]

[Preconditioning]
  [smp]
    type = SMP
    full = true
  []
[]
[Executioner]
  type = Transient
  solve_type = PJFNK
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-8

  dt = 1
  dtmin = 1
  end_time = 2
[]

[Kernels]
  [solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  []
  [solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  []
  [solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  []
  [solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  []
  [solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  []
  [solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  []
[]

[AuxVariables]
  [forces_x]
    order = CONSTANT
    family = MONOMIAL
  []
[]

[AuxKernels]
  [forces_x]
    type = MaterialRealVectorValueAux
    property = forces
    variable = forces_x
    execute_on = timestep_end
  []
[]

[Materials]
  [elasticity]
    type = ComputeElasticityBeam
    shear_coefficient = 1.0
    youngs_modulus = 30e6
    poissons_ratio = 0.3
    block = 0
  []
  [strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 28.274
    Ay = 0.0
    Az = 0.0
    Iy = 1.0
    Iz = 1.0
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  []
  [stress]
    type = ComputeBeamResultants
    block = 0
  []
[]

[Postprocessors]
  [disp_x]
    type = PointValue
    point = &#x27;60.0 0.0 0.0&#x27;
    variable = disp_x
  []
  [disp_y]
    type = PointValue
    point = &#x27;60.0 0.0 0.0&#x27;
    variable = disp_y
  []
  [forces_x]
    type = PointValue
    point = &#x27;60.0 0.0 0.0&#x27;
    variable = forces_x
  []
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="6a307ea0-9b00-4f79-94b5-d3cf3ad575e0"><div class="modal-content"><h4>(moose/modules/solid_mechanics/test/tests/beam/static/euler_finite_rot_y.i)</h4><pre style="max-height:350px;"><code class="language-moose"># Large strain/large rotation cantilever beam test

# A 300 N point load is applied at the end of a 4 m long cantilever beam.
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 1e8
# shear coefficient (k) = 1.0
# Poisson&#x27;s ratio (nu) = -0.99995
# Area (A) = 1.0
# Iy = Iz = 0.16

# The dimensionless parameter alpha = kAGL^2/EI = 1e6
# Since the value of alpha is quite high, the beam behaves like
# a thin beam where shear effects are not significant.

# Beam deflection:
# small strain+rot = 3.998 m (exact 4.0)
# large strain + small rotation = -0.05 m in x and 3.74 m in y
# large rotations + small strain = -0.92 m in x and 2.38 m in y
# large rotations + large strain = -0.954 m in x and 2.37 m in y (exact -1.0 m in x and 2.4 m in y)

# References:
# K. E. Bisshopp and D.C. Drucker, Quaterly of Applied Mathematics, Vol 3, No. 3, 1945.

[Mesh]
  type = FileMesh
  file = beam_finite_rot_test_2.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = 1
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = 1
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = 1
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctorNodalKernel
    variable = disp_y
    boundary = 2
    functor = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 2.0  8.0&#x27;
    y = &#x27;0.0 300.0 300.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  line_search = &#x27;none&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre     boomeramg     4&#x27;
  nl_max_its = 50
  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-7
  l_max_its = 50
  dt = 0.05
  end_time = 2.1
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1e4
    poissons_ratio = -0.99995
    shear_coefficient = 1.0
    block = 1
  [../]
  [./strain]
    type = ComputeFiniteBeamStrain
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 1.0
    Ay = 0.0
    Az = 0.0
    Iy = 0.16
    Iz = 0.16
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
    large_strain = true
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 1
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./rot_z]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = rot_z
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="032d9239-3573-4ed2-951d-65f32a1dbeb1"><div class="modal-content"><h4>(moose/modules/solid_mechanics/test/tests/beam/static/torsion_1.i)</h4><pre style="max-height:350px;"><code class="language-moose"># Torsion test with automatically calculated Ix

# A beam of length 1 m is fixed at one end and a moment  of 5 Nm
# is applied along the axis of the beam.
# G = 7.69e9
# Ix = Iy + Iz = 2e-5
# The axial twist at the free end of the beam is:
# phi = TL/GIx = 3.25e-4

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 1.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Physics/SolidMechanics/LineElement/QuasiStatic]
  [./block_all]
    add_variables = true
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;

    # Geometry parameters
    area = 0.5
    Iy = 1e-5
    Iz = 1e-5

    y_orientation = &#x27;0.0 1.0 0.0&#x27;

    block = 0
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = ConstantRate
    variable = rot_x
    boundary = right
    rate = 5.0
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]
[Executioner]
  type = Transient
  solve_type = PJFNK
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-8

  dt = 1
  dtmin = 1
  end_time = 2
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 2.0e9
    poissons_ratio = 0.3
    shear_coefficient = 1.0
    block = 0
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;1.0 0.0 0.0&#x27;
    variable = rot_x
  [../]
[]

[Outputs]
  csv = true
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="4e4ce71f-b1d1-4c8a-b3e6-5ce692082b9d"><div class="modal-content"><h4>(moose/modules/solid_mechanics/test/tests/beam/dynamic/dyn_euler_small.i)</h4><pre style="max-height:350px;"><code class="language-moose"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# density (rho) = 1.0

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The theoretical first and third frequencies of this beam are:
# f1 = 1/(2 pi) * (3.5156/L^2) * sqrt(EI/rho)
# f2 = 6.268 f1

# This implies that the corresponding time period of this beam are 2.858 s and 0.455s

# The FEM solution for this beam with 10 element gives time periods of 2.856 s and 0.4505s with a time step of 0.01.
# A smaller time step is required to obtain a closer match for the lower time periods/higher frequencies.
# A higher time step of 0.05 is used in this test to reduce testing time.

# The time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time       disp_y            vel_y            accel_y
# 0     0.0                  0.0                0.0
# 0.05  0.0016523559162602   0.066094236650407  2.6437694660163
# 0.1   0.0051691308901533   0.07457676230532  -2.3044684398197
# 0.15  0.0078956772343372   0.03448509146203   4.7008016060883
# 0.2   0.0096592517031463   0.03605788729033  -0.63788977295649
# 0.25  0.011069233444348    0.020341382357756  0.0092295756535376

[Mesh]
  type = GeneratedMesh
  xmin = 0.0
  xmax = 4.0
  dim = 1
  nx = 10
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_x]
    type = NewmarkAccelAux
    variable = rot_accel_x
    displacement = rot_x
    velocity = rot_vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_x]
    type = NewmarkVelAux
    variable = rot_vel_x
    acceleration = rot_accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_y]
    type = NewmarkAccelAux
    variable = rot_accel_y
    displacement = rot_y
    velocity = rot_vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_y]
    type = NewmarkVelAux
    variable = rot_vel_y
    acceleration = rot_accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_z]
    type = NewmarkAccelAux
    variable = rot_accel_z
    displacement = rot_z
    velocity = rot_vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_z]
    type = NewmarkVelAux
    variable = rot_vel_z
    acceleration = rot_accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctorNodalKernel
    variable = disp_y
    boundary = right
    functor = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.05 0.1 10.0&#x27;
    y = &#x27;0.0 0.01  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  dt = 0.05
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
  [./inertial_force_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 0
    variable = disp_x
  [../]
  [./inertial_force_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 1
    variable = disp_y
  [../]
  [./inertial_force_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 2
    variable = disp_z
  [../]
  [./inertial_force_rot_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 3
    variable = rot_x
  [../]
  [./inertial_force_rot_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 4
    variable = rot_y
  [../]
  [./inertial_force_rot_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.01
    Ay = 0.0
    Az = 0.0
    Iy = 1.0e-4
    Iz = 1.0e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="82e6e9f5-aee6-44ec-a67a-3f9dd3b66cf2"><div class="modal-content"><h4>(moose/modules/solid_mechanics/test/tests/beam/dynamic/dyn_timoshenko_small.i)</h4><pre style="max-height:350px;"><code class="language-moose"># Test for small strain Timoshenko beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 2e4
# Shear modulus (G) = 1e4
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 1.0
# Iy = 1.0 = Iz
# Length (L)= 4 m
# density (rho) = 1.0

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 8
# Therefore, the beam behaves like a Timoshenko beam.

# The FEM solution for this beam with 100 elements give first natural period of 0.2731s with a time step of 0.005.
# The acceleration, velocity and displacement time histories obtained from MOOSE matches with those obtained from ABAQUS.

# Values from the first few time steps are as follows:
# time    disp_y                vel_y                 accel_y
# 0.0     0.0                   0.0                   0.0
# 0.005   2.5473249455812e-05   0.010189299782325     4.0757199129299
# 0.01    5.3012872677486e-05   0.00082654950634483  -7.8208200233219
# 0.015   5.8611622914354e-05   0.0014129505884026    8.055380456145
# 0.02    6.766113649781e-05    0.0022068548449798   -7.7378187535141
# 0.025   7.8981810558437e-05   0.0023214147792709    7.7836427272305

# Note that the theoretical first frequency of the beam using Euler-Bernoulli theory is:
# f1 = 1/(2 pi) * (3.5156/L^2) * sqrt(EI/rho) = 4.9455

# This implies that the corresponding time period of this beam (under Euler-Bernoulli assumption) is 0.2022s.

# This shows that Euler-Bernoulli beam theory under-predicts the time period of a thick beam. In other words, the Euler-Bernoulli beam theory predicts a more compliant beam than reality for a thick beam.

[Mesh]
  type = GeneratedMesh
  xmin = 0
  xmax = 4.0
  nx = 100
  dim = 1
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_x]
    type = NewmarkAccelAux
    variable = rot_accel_x
    displacement = rot_x
    velocity = rot_vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_x]
    type = NewmarkVelAux
    variable = rot_vel_x
    acceleration = rot_accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_y]
    type = NewmarkAccelAux
    variable = rot_accel_y
    displacement = rot_y
    velocity = rot_vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_y]
    type = NewmarkVelAux
    variable = rot_vel_y
    acceleration = rot_accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_z]
    type = NewmarkAccelAux
    variable = rot_accel_z
    displacement = rot_z
    velocity = rot_vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_z]
    type = NewmarkVelAux
    variable = rot_vel_z
    acceleration = rot_accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctorNodalKernel
    variable = disp_y
    boundary = right
    functor = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.005 0.01 1.0&#x27;
    y = &#x27;0.0 1.0  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-11
  nl_abs_tol = 1e-11
  start_time = 0.0
  dt = 0.005
  end_time = 0.5
  timestep_tolerance = 1e-6
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
  [./inertial_force_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 1.0
    Iy = 1.0
    Iz = 1.0
    Ay = 0.0
    Az = 0.0
    component = 0
    variable = disp_x
  [../]
  [./inertial_force_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 1.0
    Iy = 1.0
    Iz = 1.0
    Ay = 0.0
    Az = 0.0
    component = 1
    variable = disp_y
  [../]
  [./inertial_force_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 1.0
    Iy = 1.0
    Iz = 1.0
    Ay = 0.0
    Az = 0.0
    component = 2
    variable = disp_z
  [../]
  [./inertial_force_rot_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 1.0
    Iy = 1.0
    Iz = 1.0
    Ay = 0.0
    Az = 0.0
    component = 3
    variable = rot_x
  [../]
  [./inertial_force_rot_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 1.0
    Iy = 1.0
    Iz = 1.0
    Ay = 0.0
    Az = 0.0
    component = 4
    variable = rot_y
  [../]
  [./inertial_force_rot_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 1.0
    Iy = 1.0
    Iz = 1.0
    Ay = 0.0
    Az = 0.0
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 2e4
    poissons_ratio = 0.0
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 1.0
    Ay = 0.0
    Az = 0.0
    Iy = 1.0
    Iz = 1.0
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="96343baa-dbe8-453b-a8ca-dc377e83dc32"><div class="modal-content"><h4>(moose/modules/solid_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass.i)</h4><pre style="max-height:350px;"><code class="language-moose"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The beam is massless with a lumped mass at the end of the beam
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# mass (m) = 0.01899772

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The theoretical first frequency of this beam is:
# f1 = 1/(2 pi) * sqrt(3EI/(mL^3)) = 0.25

# This implies that the corresponding time period of this beam is 4s.

# The FEM solution for this beam with 10 element gives time periods of 4s with time step of 0.01s.
# A higher time step of 0.1 s is used in the test to reduce computational time.

# The time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time   disp_y                vel_y                accel_y
# 0.0    0.0                   0.0                  0.0
# 0.1    0.0013076435060869    0.026152870121738    0.52305740243477
# 0.2    0.0051984378734383    0.051663017225289   -0.01285446036375
# 0.3    0.010269120909367     0.049750643493289   -0.02539301427625
# 0.4    0.015087433925158     0.046615616822532   -0.037307519138892
# 0.5    0.019534963888307     0.042334982440433   -0.048305168503101

[Mesh]
  type = GeneratedMesh
  xmin = 0.0
  xmax = 4.0
  nx = 10
  dim = 1
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctorNodalKernel
    variable = disp_y
    boundary = right
    functor = force
  [../]
  [./x_inertial]
    type = NodalTranslationalInertia
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
  [../]
  [./y_inertial]
    type = NodalTranslationalInertia
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
  [../]
  [./z_inertial]
    type = NodalTranslationalInertia
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 10.0&#x27;
    y = &#x27;0.0 1e-2  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-ksp_type -pc_type&#x27;
  petsc_options_value = &#x27;preonly   lu&#x27;

  dt = 0.1
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.01
    Ay = 0.0
    Az = 0.0
    Iy = 1.0e-4
    Iz = 1.0e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="b0309230-3b50-4e21-b481-0908c6ee6a78"><div class="modal-content"><h4>(moose/modules/solid_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_inertia_damping.i)</h4><pre style="max-height:350px;"><code class="language-moose"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The beam is massless with a lumped mass at the end of the beam. The lumped
# mass also has a moment of inertia associated with it.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# mass (m) = 0.01899772
# Moment of inertia of lumped mass:
# Ixx = 0.2
# Iyy = 0.1
# Izz = 0.1
# mass proportional damping coefficient (eta) = 0.1

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The displacement time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time   disp_y              vel_y               accel_y
# 0.0    0.0                 0.0                 0.0
# 0.1    0.001278249649738   0.025564992994761   0.51129985989521
# 0.2    0.0049813090917644  0.048496195845768  -0.052675802875074
# 0.3    0.0094704658873002  0.041286940064947  -0.091509312741339
# 0.4    0.013082280729802   0.03094935678508   -0.115242352856
# 0.5    0.015588313103503   0.019171290688959  -0.12031896906642

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 4.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_x]
    type = NewmarkAccelAux
    variable = rot_accel_x
    displacement = rot_x
    velocity = rot_vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_x]
    type = NewmarkVelAux
    variable = rot_vel_x
    acceleration = rot_accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_y]
    type = NewmarkAccelAux
    variable = rot_accel_y
    displacement = rot_y
    velocity = rot_vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_y]
    type = NewmarkVelAux
    variable = rot_vel_y
    acceleration = rot_accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_z]
    type = NewmarkAccelAux
    variable = rot_accel_z
    displacement = rot_z
    velocity = rot_vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_z]
    type = NewmarkVelAux
    variable = rot_vel_z
    acceleration = rot_accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctorNodalKernel
    variable = disp_y
    boundary = right
    functor = force
  [../]
  [./x_inertial]
    type = NodalTranslationalInertia
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
    eta = 0.1
  [../]
  [./y_inertial]
    type = NodalTranslationalInertia
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
    eta = 0.1
  [../]
  [./z_inertial]
    type = NodalTranslationalInertia
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
    eta = 0.1
  [../]
  [./rot_x_inertial]
    type = NodalRotationalInertia
    variable = rot_x
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations= &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    boundary = right
    beta = 0.25
    gamma = 0.5
    Ixx = 2e-1
    Iyy = 1e-1
    Izz = 1e-1
    eta = 0.1
    component = 0
  [../]
  [./rot_y_inertial]
    type = NodalRotationalInertia
    variable = rot_y
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations= &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    boundary = right
    beta = 0.25
    gamma = 0.5
    Ixx = 2e-1
    Iyy = 1e-1
    Izz = 1e-1
    eta = 0.1
    component = 1
  [../]
  [./rot_z_inertial]
    type = NodalRotationalInertia
    variable = rot_z
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations= &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    boundary = right
    beta = 0.25
    gamma = 0.5
    Ixx = 2e-1
    Iyy = 1e-1
    Izz = 1e-1
    eta = 0.1
    component = 2
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 10.0&#x27;
    y = &#x27;0.0 1e-2  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-ksp_type -pc_type&#x27;
  petsc_options_value = &#x27;preonly   lu&#x27;

  dt = 0.1
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.01
    Ay = 0.0
    Az = 0.0
    Iy = 1.0e-4
    Iz = 1.0e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>
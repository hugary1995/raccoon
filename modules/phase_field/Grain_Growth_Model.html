<!DOCTYPE html><head><meta charset="UTF-8"><title>Grain Growth Model | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="61541ae9-2c1d-4277-900d-6e1753925144" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="7b138693-1bd5-46d6-a909-a127a6a66847" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="3c6d3cd5-63bb-49de-9ddc-10ab2b370d48" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="c3a6abc9-f867-4425-877c-7b6e5fa457c8" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="66499a79-a37c-4678-86d2-cd5555212400"><i class="material-icons">menu</i></a><ul class="sidenav" id="66499a79-a37c-4678-86d2-cd5555212400"><li><a href="#!" class="dropdown-trigger" data-target="c14815ff-bd30-41d8-a825-ca628b175aeb" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="3cad8a6b-0e69-43ae-b9d5-725d6edfc8e6" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="cacc0587-3377-47be-8238-4a447c5af339" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d9733257-78d5-49f3-a883-71835f528131" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="61541ae9-2c1d-4277-900d-6e1753925144"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="7b138693-1bd5-46d6-a909-a127a6a66847"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="3c6d3cd5-63bb-49de-9ddc-10ab2b370d48"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="c3a6abc9-f867-4425-877c-7b6e5fa457c8"><li><a href="../index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="c14815ff-bd30-41d8-a825-ca628b175aeb"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="3cad8a6b-0e69-43ae-b9d5-725d6edfc8e6"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li><li><a href="../../tutorials/12_nucleation.html">12. Crack nucleation</a></li><li><a href="../../tutorials/13_traction_separation.html">13. Traction separation law</a></li><li><a href="../../tutorials/14_klexpansion.html">14. Random field generation</a></li><li><a href="../../tutorials/15_mosaic_patches.html">15. Mosaic field generation</a></li></ul><ul class="dropdown-content" id="cacc0587-3377-47be-8238-4a447c5af339"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="d9733257-78d5-49f3-a883-71835f528131"><li><a href="../index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/solid_mechanics.html">Solid mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_transfer.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="9ff56530-1436-4ef1-adfc-f87b203e0d6f" data-section-level="1" data-section-text="Grain Growth Model"><h1 id="grain-growth-model">Grain Growth Model</h1><p>Grain boundaries (GBs) migrate to reduce the total free energy of the system. Various sources of free energy drive the GB migration, including stored defect energy, deformation energy, and GB energy. Various modeling approaches have been applied to model GB migration. While all of the various methods predict similar behavior, the phase-field method has emerged as one of the more popular due to its flexibility.</p><p>In MOOSE, we have implemented the multiphase grain growth model originally developed in <a href="#ChenYang1994">Chen and Yang (1994)</a> and <a href="#Chen1995">Chen (1995)</a> and further developed in <a href="#moelans_quantitative_2008">Moelans et al. (2008)</a>. The variables evolve to reduce the overall free energy of the system, representing GB migration. The evolution of each grain&#x27;s order parameter is defined with the Allen-Cahn equation: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-8869866d-92bb-4b02-8c4e-63bf3e09d7cc"></span><script>var element = document.getElementById("moose-equation-8869866d-92bb-4b02-8c4e-63bf3e09d7cc");katex.render("  \\frac{\\partial \\eta_i}{\\partial t} = - L \\frac{\\delta F}{\\delta \\eta_i},", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-2340a60f-d96b-4540-b099-01a47a8899e6"><script>var element = document.getElementById("moose-equation-2340a60f-d96b-4540-b099-01a47a8899e6");katex.render("F", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the free energy functional, <span class="moose-katex-inline-equation" id="moose-equation-833daec0-9050-4dd4-adcc-e36e0e63cbe5"><script>var element = document.getElementById("moose-equation-833daec0-9050-4dd4-adcc-e36e0e63cbe5");katex.render("L", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the order parameter mobility, and the <span class="moose-katex-inline-equation" id="moose-equation-3adc55e1-63d1-492e-afb6-419917adb9bc"><script>var element = document.getElementById("moose-equation-3adc55e1-63d1-492e-afb6-419917adb9bc");katex.render("\\delta", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> operator represents a variational derivative. The free energy for this problem is <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-a51ae52b-7312-4759-a8c4-9260f53d23fd"></span><script>var element = document.getElementById("moose-equation-a51ae52b-7312-4759-a8c4-9260f53d23fd");katex.render("  F = \\int_V f_{loc}(\\eta_0, \\eta_1, \\ldots, \\eta_N) + f_{add} (\\eta_0, \\eta_1, \\ldots, \\eta_N) + \\kappa \\sum^N_i |\\nabla \\eta_i|^2,", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-6a5fce85-22de-4c49-9bbe-e210ea387cbe"><script>var element = document.getElementById("moose-equation-6a5fce85-22de-4c49-9bbe-e210ea387cbe");katex.render("N", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the total number of order parameters, <span class="moose-katex-inline-equation" id="moose-equation-d275200b-8644-4381-8e3d-c1290f3053eb"><script>var element = document.getElementById("moose-equation-d275200b-8644-4381-8e3d-c1290f3053eb");katex.render("f_{loc}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> represents the local free energy density, and <span class="moose-katex-inline-equation" id="moose-equation-c5261cd2-e828-48c4-8199-9a23e0b6b090"><script>var element = document.getElementById("moose-equation-c5261cd2-e828-48c4-8199-9a23e0b6b090");katex.render("f_{add}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> represents any additional sources of energy density. For the grain growth model, <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-7df3384c-534a-4f71-8561-9aa9f131a45e"></span><script>var element = document.getElementById("moose-equation-7df3384c-534a-4f71-8561-9aa9f131a45e");katex.render("  f_{loc} = \\mu \\left( \\sum_i^N \\left(\\frac{\\eta_i^4}{4} - \\frac{\\eta_i^2}{2} \\right)  + \\gamma \\sum_{i=1}^N \\sum_{j>i}^N \\eta_i^2 \\eta_j^2 + \\frac{1}{4} \\right),", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-958f32a6-41cd-452f-9168-a39d33001b06"><script>var element = document.getElementById("moose-equation-958f32a6-41cd-452f-9168-a39d33001b06");katex.render("\\mu", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the free energy weight and <span class="moose-katex-inline-equation" id="moose-equation-0fe6d659-c0b4-4d77-8918-aacee1252509"><script>var element = document.getElementById("moose-equation-0fe6d659-c0b4-4d77-8918-aacee1252509");katex.render("\\gamma=1.5", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> for symmetric interfacial profiles.</p><p>The model parameters <span class="moose-katex-inline-equation" id="moose-equation-b0d11778-297a-40c5-a60c-2e81d9a3a86d"><script>var element = document.getElementById("moose-equation-b0d11778-297a-40c5-a60c-2e81d9a3a86d");katex.render("L", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-94fe127f-bcbb-41d0-b499-6779d6f24802"><script>var element = document.getElementById("moose-equation-94fe127f-bcbb-41d0-b499-6779d6f24802");katex.render("\\mu", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-d8946825-2ffa-4bf5-a609-ebb1c7cff62f"><script>var element = document.getElementById("moose-equation-d8946825-2ffa-4bf5-a609-ebb1c7cff62f");katex.render("\\kappa", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> are defined in terms of the GB energy <span class="moose-katex-inline-equation" id="moose-equation-ceff611d-0493-4572-8aa0-f37f6f3b7f51"><script>var element = document.getElementById("moose-equation-ceff611d-0493-4572-8aa0-f37f6f3b7f51");katex.render("\\sigma", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, the diffuse GB width <span class="moose-katex-inline-equation" id="moose-equation-323d3bcd-ca69-499a-b59c-83af7b4f0f1a"><script>var element = document.getElementById("moose-equation-323d3bcd-ca69-499a-b59c-83af7b4f0f1a");katex.render("w_{GB}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, and the GB mobility <span class="moose-katex-inline-equation" id="moose-equation-9798900a-0c95-4878-a5a6-497c7839a254"><script>var element = document.getElementById("moose-equation-9798900a-0c95-4878-a5a6-497c7839a254");katex.render("M_{GB}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>. In reality, the GB energy and mobility are anisotropic, depending on both the misorientation and inclination of the GB. However, it is common to assume that the GB properties are isotropic. In the case of isotropic GB energy and mobility and symmetric interfacial profiles (<span class="moose-katex-inline-equation" id="moose-equation-0e3e29ee-4091-42f8-9c6c-17b47104f7b2"><script>var element = document.getElementById("moose-equation-0e3e29ee-4091-42f8-9c6c-17b47104f7b2");katex.render("\\gamma = 1.5", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>), <a href="#moelans_quantitative_2008">Moelans et al. (2008)</a> defined expressions for the model parameters in terms of <span class="moose-katex-inline-equation" id="moose-equation-4715871c-3416-4118-b720-10449d7e7267"><script>var element = document.getElementById("moose-equation-4715871c-3416-4118-b720-10449d7e7267");katex.render("\\sigma", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-fd0ec81c-ae0c-436a-9820-08fa73e31a7e"><script>var element = document.getElementById("moose-equation-fd0ec81c-ae0c-436a-9820-08fa73e31a7e");katex.render("w_{GB}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, and <span class="moose-katex-inline-equation" id="moose-equation-0102af3b-7488-459f-9f1c-5e50d4a4fffd"><script>var element = document.getElementById("moose-equation-0102af3b-7488-459f-9f1c-5e50d4a4fffd");katex.render("M_{GB}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-8df37972-1cbe-4958-a633-6a04b006a2e3"></span><script>var element = document.getElementById("moose-equation-8df37972-1cbe-4958-a633-6a04b006a2e3");katex.render("L = \\frac{4}{3} \\frac{M_{GB}}{w_{GB}}", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-ed6b75fa-9f73-4b50-b15c-c1d2156252e2"></span><script>var element = document.getElementById("moose-equation-ed6b75fa-9f73-4b50-b15c-c1d2156252e2");katex.render("\\mu = 6 \\frac{\\sigma}{w_{GB}}", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-5f909e07-7e43-4048-a64e-277a89ce0cbe"></span><script>var element = document.getElementById("moose-equation-5f909e07-7e43-4048-a64e-277a89ce0cbe");katex.render("\\kappa = \\frac{3}{4} \\sigma w_{GB}", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><section id="279c9339-ae94-4cbd-b70b-9fe151fe8929" data-section-level="2" data-section-text="MOOSE Implementation"><h2 id="moose-implementation">MOOSE Implementation</h2><p>The grain growth model implementation in MOOSE can simulate grain growth in 2D and 3D, and can model large polycrystals with thousands of grains. A system of Allen-Cahn equations is solved to define the grain boundary migration. In MOOSE, we solve them in residual weak form: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-2c7c53c1-97df-4d20-95c6-9cfd8815b0d0"></span><script>var element = document.getElementById("moose-equation-2c7c53c1-97df-4d20-95c6-9cfd8815b0d0");katex.render("  \\mathcal{R}_{\\eta_i} = \\left( \\frac{\\partial \\eta_i}{\\partial t},\\psi_m \\right) + \\left( L \\frac{\\partial f_{loc}}{\\partial \\eta_i}, \\psi_m \\right) - \\left(\\kappa \\nabla \\eta_i, L \\nabla \\psi_m \\right)  = 0,", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-63daf61f-67cd-4408-a618-f63bdd1fbb54"><script>var element = document.getElementById("moose-equation-63daf61f-67cd-4408-a618-f63bdd1fbb54");katex.render("\\psi_m", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the test function. In standard MOOSE fashion, the various terms in the Allen-Cahn equation have been implemented in separate kernels. The MOOSE objects that are used in the grain growth model are summarized, below:</p><p><strong>Materials</strong></p><ul class="browser-default"><li><p><a href="../../source/materials/GBEvolution.html"><code>GBEvolution</code></a> - Defines the model parameters <span class="moose-katex-inline-equation" id="moose-equation-76de1c5a-7fd7-4135-87b5-e5062e93cdf3"><script>var element = document.getElementById("moose-equation-76de1c5a-7fd7-4135-87b5-e5062e93cdf3");katex.render("L", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-02ed32ec-c4d9-4217-94f5-698a25e4c834"><script>var element = document.getElementById("moose-equation-02ed32ec-c4d9-4217-94f5-698a25e4c834");katex.render("\\mu", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, and <span class="moose-katex-inline-equation" id="moose-equation-22638d91-0c28-4597-805a-14935d5e0981"><script>var element = document.getElementById("moose-equation-22638d91-0c28-4597-805a-14935d5e0981");katex.render("\\kappa", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> using the equations assuming isotropic properties. </p></li><li><p><a href="Grain_Boundary_Anisotropy.html"><code>GBAnistropy</code></a> - Defines parameters <span class="moose-katex-inline-equation" id="moose-equation-58a53ebc-32e8-4a67-a386-52f5eb9d7532"><script>var element = document.getElementById("moose-equation-58a53ebc-32e8-4a67-a386-52f5eb9d7532");katex.render("L", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-2933772e-d382-47d0-a6e0-e1889caf4c83"><script>var element = document.getElementById("moose-equation-2933772e-d382-47d0-a6e0-e1889caf4c83");katex.render("\\mu", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, and <span class="moose-katex-inline-equation" id="moose-equation-7c1f2338-c781-4cfc-8a34-30b04f398f9b"><script>var element = document.getElementById("moose-equation-7c1f2338-c781-4cfc-8a34-30b04f398f9b");katex.render("\\kappa", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> considering misorientation dependence for the GB energy.</p></li></ul><p><strong>Kernels</strong></p><ul class="browser-default"><li><p><a href="../../source/kernels/TimeDerivative.html"><code>TimeDerivative</code></a> - Defines the <span class="moose-katex-inline-equation" id="moose-equation-b9216d31-132f-4229-860e-89a2cd4ef173"><script>var element = document.getElementById("moose-equation-b9216d31-132f-4229-860e-89a2cd4ef173");katex.render("\\left( \\frac{\\partial \\eta_i}{\\partial t},\\psi_m \\right)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> term. </p></li><li><p><a href="../../source/kernels/ACGrGrPoly.html"><code>ACGrGrPoly</code></a> - Defines the <span class="moose-katex-inline-equation" id="moose-equation-a7e14480-48bb-4a1d-b6fd-85c868665ff7"><script>var element = document.getElementById("moose-equation-a7e14480-48bb-4a1d-b6fd-85c868665ff7");katex.render("\\left( L \\frac{\\partial f_{loc}}{\\partial \\eta_i}, \\psi_m \\right)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> term. </p></li><li><p><a href="../../source/kernels/ACInterface.html"><code>ACInterface</code></a> - Defines the <span class="moose-katex-inline-equation" id="moose-equation-ebdf8362-4f54-4ce9-bf12-8cc19a5d1278"><script>var element = document.getElementById("moose-equation-ebdf8362-4f54-4ce9-bf12-8cc19a5d1278");katex.render("\\left(\\kappa \\nabla \\eta_i, L \\nabla \\psi_m \\right)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> term.</p></li></ul><p><strong>AuxKernels</strong></p><ul class="browser-default"><li><p><a href="../../source/auxkernels/BndsCalcAux.html"><code>BndsCalcAux</code></a> - To visualize the GB, it is convenient to use <span class="moose-katex-inline-equation" id="moose-equation-5616b37e-f4d9-4143-a1ab-0c6d1fcddc76"><script>var element = document.getElementById("moose-equation-5616b37e-f4d9-4143-a1ab-0c6d1fcddc76");katex.render("\\mathrm{bnds} = \\sum_i^N \\eta_i^2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</p></li></ul></section><section id="17ea9967-2959-4d1e-a2f2-a9c7cf2a8cce" data-section-level="2" data-section-text="Simplified MOOSE syntax"><h2 id="simplified-moose-syntax">Simplified MOOSE syntax</h2><p>The default input file for MOOSE, in which each variable and kernel needed for each variable are added individually, would be very cumbersome for the grain growth model which can have many variables.  Therefore, Actions have been created that automate the creation of the various order parameters and their kernels.</p><ul class="browser-default"><li><p><a href="../../source/actions/GrainGrowthAction.html"><code>GrainGrowthAction</code></a> has the simplest syntax. It creates all of the variables and kernels needed for a basic grain growth model. </p></li><li><p><a href="../../source/actions/PolycrystalVariablesAction.html"><code>PolycrystalVariablesAction</code></a> just creates the variables. It can also be used for other models besides grain growth to create a series of variables with standard naming syntax. </p></li><li><p><a href="../../source/actions/PolycrystalKernelAction.html"><code>PolycrystalKernelAction</code></a> just creates the kernels needed for each of the order parameter variables.</p></li></ul></section><section id="dadc9c24-fb66-46d6-a5f4-9aa05b429d81" data-section-level="2" data-section-text="Initial Conditions"><h2 id="initial-conditions">Initial Conditions</h2><p>The initial conditions (ICs) for the polycrystal models are created using the ICs block in the input file. Under the ICs block, there is an additional block called <code>PolycrystalICs</code>. Under this block, there are various options to create initial conditions for bicrystals, tricrystals and polycrystals. These options are shown in the Table, below.</p><div recursive form="['center', 'center']" class="moose-table-div"><table><thead><tr><th style=";text-align:center">IC Action name</th><th style=";text-align:center">Description</th></tr></thead><tbody><tr><td style=";text-align:center"><a href="../../source/actions/BicrystalBoundingBoxICAction.html"><code>BicrystalBoundingBoxIC</code></a></td><td style=";text-align:center">Two grains defined by a bounding box</td></tr></tbody><tbody><tr><td style=";text-align:center"><a href="../../source/actions/BicrystalCircleGrainICAction.html"><code>BicrystalCircleGrainIC</code></a></td><td style=";text-align:center">Circle grain and matrix grain</td></tr></tbody><tbody><tr><td style=";text-align:center"><a href="../../source/actions/Tricrystal2CircleGrainsICAction.html"><code>Tricrystal2CircleGrainsIC</code></a></td><td style=";text-align:center">Two circle grains and a matrix grain</td></tr></tbody><tbody><tr><td style=";text-align:center"><a href="../../source/actions/PolycrystalRandomICAction.html"><code>PolycrystalRandomIC</code></a></td><td style=";text-align:center">Randomly seeds grain order parameters</td></tr></tbody><tbody><tr><td style=";text-align:center"><a href="../../source/actions/PolycrystalColoringICAction.html"><code>PolycrystalColoringIC</code></a></td><td style=";text-align:center"><a href="ICs/PolycrystalICs.html">Polycrystal initial conditions</a>. Grain shapes are specified by a polycrystal UserObject (see below).</td></tr></tbody></table></div><p>The polycrystal UserObjects available for use with <a href="../../source/actions/PolycrystalColoringICAction.html"><code>PolycrystalColoringIC</code></a> are:</p><ul class="browser-default"><li><p><a href="../../source/userobjects/PolycrystalVoronoi.html"><code>PolycrystalVoronoi</code></a> - Creates polycrystal grain structure using a Voronoi tessellation. </p></li><li><p><a href="../../source/userobjects/PolycrystalHex.html"><code>PolycrystalHex</code></a> - Creates a hexagonal polycrystal grain structure. </p></li><li><p><a href="../../source/userobjects/PolycrystalCircles.html"><code>PolycrystalCircles</code></a> - Creates circular/spherical grains from a file defining center coordinates and radii. </p></li><li><p><a href="../../source/userobjects/PolycrystalEBSD.html"><code>PolycrystalEBSD</code></a> - Reconstructs grain structures from EBSD data in a specific file format. Used in conjunction with the <a href="ICs/EBSD.html"><code>EBSD Reader</code></a>.</p></li></ul><p>There is also one tricrystal IC without an associated action: <a href="../../source/ics/TricrystalTripleJunctionIC.html"><code>TricrystalTripleJunctionIC</code></a>.</p></section><section id="1eab4179-e0bb-407b-84c2-e18964d06182" data-section-level="2" data-section-text="Variable Remapping"><h2 id="variable-remapping">Variable Remapping</h2><p>If each order parameter is used to represent one grain, the computational cost gets very high to model polycrystal grain growth. However, if each order parameter is used to represent more than one grain, unphysical grain coalescence occurs when grains represented by the same variable come in contact. MOOSE uses the remapping algorithm <a href="../../source/postprocessors/GrainTracker.html">GrainTracker</a> to overcome this issue. Order parameters are used to represent multiple grains and grains are then remapped to other variables when needed to avoid coalescence.</p></section><section id="450d5181-4f97-4a92-a157-917a9fae4123" data-section-level="2" data-section-text="Model Verification"><h2 id="model-verification">Model Verification</h2><p>The grain growth model has been verified against analytical solutions for two cases, a circular grain imbedded in a larger grain and a half loop grain imbedded in a larger grain.</p><section id="52bda455-a856-44ed-918b-0b257e9f702c" data-section-level="3" data-section-text="Circular Grain"><h3 id="circular-grain">Circular Grain</h3><p>For a circular grain, the grain boundary velocity is calculated according to <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-cb7479ac-f95d-4c18-808b-e9d7e9f207f2"></span><script>var element = document.getElementById("moose-equation-cb7479ac-f95d-4c18-808b-e9d7e9f207f2");katex.render("v = M F,", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-58972f7f-2a01-4194-a7ce-caf0f965da38"><script>var element = document.getElementById("moose-equation-58972f7f-2a01-4194-a7ce-caf0f965da38");katex.render("F", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the driving force. In our simple verification cases, the driving force depends only on the curvature of the grain boundary and can be written as <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-5707bb9e-8fa5-46f7-856f-2f469654efc9"></span><script>var element = document.getElementById("moose-equation-5707bb9e-8fa5-46f7-856f-2f469654efc9");katex.render("F = \\frac{\\gamma}{R},", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-fd4f6d5e-666c-4953-a8eb-154bf67c8341"><script>var element = document.getElementById("moose-equation-fd4f6d5e-666c-4953-a8eb-154bf67c8341");katex.render("\\gamma", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the GB energy and <span class="moose-katex-inline-equation" id="moose-equation-2dded410-0ece-4c00-b33f-6db20b03c6cd"><script>var element = document.getElementById("moose-equation-2dded410-0ece-4c00-b33f-6db20b03c6cd");katex.render("R", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the radius of curvature. The change in area with time is equal to <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-f4980dbd-1c4a-4a63-b972-e4395ac36940"></span><script>var element = document.getElementById("moose-equation-f4980dbd-1c4a-4a63-b972-e4395ac36940");katex.render("\\begin{array}{rl} \\frac{\\partial A}{\\partial t} &= 2 \\pi R \\frac{\\partial R}{\\partial t} = 2 \\pi R v\\\\ &= 2 \\pi M \\gamma. \\end{array}", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> Thus, the area at any time <span class="moose-katex-inline-equation" id="moose-equation-9ccdc816-757d-4d38-8db5-ea8c9ac8f9c7"><script>var element = document.getElementById("moose-equation-9ccdc816-757d-4d38-8db5-ea8c9ac8f9c7");katex.render("t", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> can be calculated with <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-6e76ecff-9aa0-4a9f-8e8a-ddae8fd9d82a"></span><script>var element = document.getElementById("moose-equation-6e76ecff-9aa0-4a9f-8e8a-ddae8fd9d82a");katex.render("A = A_0 - 2 \\pi M \\gamma t,", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-1935f492-9157-4b26-ba9a-a12647ae4161"><script>var element = document.getElementById("moose-equation-1935f492-9157-4b26-ba9a-a12647ae4161");katex.render("A_0", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the initial radius of the circular grain.</p><p>This case can be easily implemented using MOOSE, and the change in the area with time is outputted using a Postprocessor, as shown in the below input which leverages data from (<a href="#schonfelder1997molecular">Schönfelder et al., 1997</a>).</p><pre style="max-height:350px;"><code class="language-moose">[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  xmin = 0
  xmax = 400
  ymin = 0
  ymax = 400
  zmin = 0
  zmax = 0
  elem_type = QUAD4
  uniform_refine&lt;&lt;&lt;{&quot;description&quot;: &quot;Specify the level of uniform refinement applied to the initial mesh&quot;}&gt;&gt;&gt; = 1
[]

[GlobalParams&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/GlobalParams/index.html&quot;}&gt;&gt;&gt;]
  op_num = 2
  var_name_base = gr
[]

[Variables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/index.html&quot;}&gt;&gt;&gt;]
  [./PolycrystalVariables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/PolycrystalVariables/index.html&quot;}&gt;&gt;&gt;]
  [../]
[]

[ICs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/ICs/index.html&quot;}&gt;&gt;&gt;]
  [./PolycrystalICs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/ICs/PolycrystalICs/index.html&quot;}&gt;&gt;&gt;]
    [./BicrystalCircleGrainIC&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/ICs/PolycrystalICs/BicrystalCircleGrainIC/index.html&quot;}&gt;&gt;&gt;]
      radius&lt;&lt;&lt;{&quot;description&quot;: &quot;Void radius&quot;}&gt;&gt;&gt; = 300
      x&lt;&lt;&lt;{&quot;description&quot;: &quot;The x coordinate of the circle grain center&quot;}&gt;&gt;&gt; = 400
      y&lt;&lt;&lt;{&quot;description&quot;: &quot;The y coordinate of the circle grain center&quot;}&gt;&gt;&gt; = 0
    [../]
  [../]
[]

[AuxVariables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxVariables/index.html&quot;}&gt;&gt;&gt;]
  [./bnds]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[Kernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/index.html&quot;}&gt;&gt;&gt;]
  [./PolycrystalKernel&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/PolycrystalKernel/index.html&quot;}&gt;&gt;&gt;]
  [../]
[]

[AuxKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxKernels/index.html&quot;}&gt;&gt;&gt;]
  [./BndsCalc]
    type = BndsCalcAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculate location of grain boundaries in a polycrystalline sample&quot;, &quot;href&quot;: &quot;../../source/auxkernels/BndsCalcAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = bnds
  [../]
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [./Copper]
    type = GBEvolution&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes necessary material properties for the isotropic grain growth model&quot;, &quot;href&quot;: &quot;../../source/materials/GBEvolution.html&quot;}&gt;&gt;&gt;
    T&lt;&lt;&lt;{&quot;description&quot;: &quot;Temperature in Kelvin&quot;}&gt;&gt;&gt; = 500 # K
    wGB&lt;&lt;&lt;{&quot;description&quot;: &quot;Diffuse GB width in the length scale of the model&quot;}&gt;&gt;&gt; = 60 # nm
    GBmob0&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary mobility prefactor in m^4/(J*s)&quot;}&gt;&gt;&gt; = 2.5e-6 #m^4/(Js) from Schoenfelder 1997
    Q&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary migration activation energy in eV&quot;}&gt;&gt;&gt; = 0.23 #Migration energy in eV
    GBenergy&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary energy in J/m^2&quot;}&gt;&gt;&gt; = 0.708 #GB energy in J/m^2
  [../]
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [./gr1area]
    type = ElementIntegralVariablePostprocessor&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes a volume integral of the specified variable&quot;, &quot;href&quot;: &quot;../../source/postprocessors/ElementIntegralVariablePostprocessor.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object operates on&quot;}&gt;&gt;&gt; = gr1
  [../]
[]

[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [./SMP]
    type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
    full&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you want the full set of couplings between variables simply for convenience so you don&#x27;t have to set every off_diag_row and off_diag_column combination.&quot;}&gt;&gt;&gt; = true
  [../]
[]

[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient
  scheme = bdf2
  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre boomeramg 31&#x27;

  l_tol = 1.0e-4
  l_max_its = 30
  nl_max_its = 20
  nl_rel_tol = 1.0e-9
  start_time = 0.0
  num_steps = 5
  dt = 80.0

  [./Adaptivity&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/Adaptivity/index.html&quot;}&gt;&gt;&gt;]
    initial_adaptivity&lt;&lt;&lt;{&quot;description&quot;: &quot;The number of adaptivity steps to perform using the initial conditions&quot;}&gt;&gt;&gt; = 2
    refine_fraction&lt;&lt;&lt;{&quot;description&quot;: &quot;The fraction of elements or error to refine. Should be between 0 and 1.&quot;}&gt;&gt;&gt; = 0.8
    coarsen_fraction&lt;&lt;&lt;{&quot;description&quot;: &quot;The fraction of elements or error to coarsen. Should be between 0 and 1.&quot;}&gt;&gt;&gt; = 0.05
    max_h_level&lt;&lt;&lt;{&quot;description&quot;: &quot;Maximum number of times a single element can be refined. If 0 then infinite.&quot;}&gt;&gt;&gt; = 2
  [../]
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;timestep_end&#x27;
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#3f707b0f-382e-4970-8f7e-c136c5c12266">(moose/modules/phase_field/test/tests/grain_growth/test.i)</a></section><section id="97c125f6-8617-4034-84c4-af980e37e44f" data-section-level="3" data-section-text="Half Loop Grain"><h3 id="half-loop-grain">Half Loop Grain</h3><p>Following the same approach from the circle grain but for the half loop geometry gives the expression <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-f2e04ebf-ae90-4cdf-b40c-af8d1d152758"></span><script>var element = document.getElementById("moose-equation-f2e04ebf-ae90-4cdf-b40c-af8d1d152758");katex.render("A = A_0 - \\pi M \\gamma t.", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>This case can also be easily implemented in MOOSE, with the area outputted using a Postprocessor:</p><pre style="max-height:350px;"><code class="language-moose">[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  xmin = 0
  xmax = 1000
  ymin = 0
  ymax = 1000
  zmin = 0
  zmax = 0
  elem_type = QUAD4

  uniform_refine&lt;&lt;&lt;{&quot;description&quot;: &quot;Specify the level of uniform refinement applied to the initial mesh&quot;}&gt;&gt;&gt; = 2
[]

[GlobalParams&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/GlobalParams/index.html&quot;}&gt;&gt;&gt;]
  op_num = 2
  var_name_base = gr
  v = &#x27;gr0 gr1&#x27;
[]

[Variables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/index.html&quot;}&gt;&gt;&gt;]
  [./gr0]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
    [./InitialCondition]
      type = ThumbIC
      xcoord = 500.0
      height = 600.0
      width = 400.0
      invalue = 0.0
      outvalue = 1.0
    [../]
  [../]

  [./gr1]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
    [./InitialCondition]
      type = ThumbIC
      xcoord = 500.0
      height = 600.0
      width = 400.0
      invalue = 1.0
      outvalue = 0.0
    [../]
  [../]
[]

[AuxVariables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxVariables/index.html&quot;}&gt;&gt;&gt;]
  [./bnds]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = FIRST
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = LAGRANGE
  [../]
[]

[Kernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/index.html&quot;}&gt;&gt;&gt;]
  [./PolycrystalKernel&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/PolycrystalKernel/index.html&quot;}&gt;&gt;&gt;]
  [../]
[]

[AuxKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxKernels/index.html&quot;}&gt;&gt;&gt;]
  [./BndsCalc]
    type = BndsCalcAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculate location of grain boundaries in a polycrystalline sample&quot;, &quot;href&quot;: &quot;../../source/auxkernels/BndsCalcAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = bnds
  [../]
[]

[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/index.html&quot;}&gt;&gt;&gt;]
  active&lt;&lt;&lt;{&quot;description&quot;: &quot;If specified only the blocks named will be visited and made active&quot;}&gt;&gt;&gt; = &#x27; &#x27;

  [./Periodic&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/Periodic/index.html&quot;}&gt;&gt;&gt;]
    [./left_right]
      primary&lt;&lt;&lt;{&quot;description&quot;: &quot;Boundary ID associated with the primary boundary.&quot;}&gt;&gt;&gt; = 0
      secondary&lt;&lt;&lt;{&quot;description&quot;: &quot;Boundary ID associated with the secondary boundary.&quot;}&gt;&gt;&gt; = 2
      translation&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector that translates coordinates on the primary boundary to coordinates on the secondary boundary.&quot;}&gt;&gt;&gt; = &#x27;0 1000 0&#x27;
    [../]

    [./top_bottom]
      primary&lt;&lt;&lt;{&quot;description&quot;: &quot;Boundary ID associated with the primary boundary.&quot;}&gt;&gt;&gt; = 1
      secondary&lt;&lt;&lt;{&quot;description&quot;: &quot;Boundary ID associated with the secondary boundary.&quot;}&gt;&gt;&gt; = 3
      translation&lt;&lt;&lt;{&quot;description&quot;: &quot;Vector that translates coordinates on the primary boundary to coordinates on the secondary boundary.&quot;}&gt;&gt;&gt; = &#x27;-1000 0 0&#x27;
    [../]
  [../]
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [./Copper]
    type = GBEvolution&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes necessary material properties for the isotropic grain growth model&quot;, &quot;href&quot;: &quot;../../source/materials/GBEvolution.html&quot;}&gt;&gt;&gt;
    T&lt;&lt;&lt;{&quot;description&quot;: &quot;Temperature in Kelvin&quot;}&gt;&gt;&gt; = 500 # K
    wGB&lt;&lt;&lt;{&quot;description&quot;: &quot;Diffuse GB width in the length scale of the model&quot;}&gt;&gt;&gt; = 60 # nm
    GBmob0&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary mobility prefactor in m^4/(J*s)&quot;}&gt;&gt;&gt; = 2.5e-6 #m^4/(Js) from Schoenfelder 1997
    Q&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary migration activation energy in eV&quot;}&gt;&gt;&gt; = 0.23 #Migration energy in eV
    GBenergy&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary energy in J/m^2&quot;}&gt;&gt;&gt; = 0.708 #GB energy in J/m^2
  [../]
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [./gr_area]
    type = ElementIntegralVariablePostprocessor&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes a volume integral of the specified variable&quot;, &quot;href&quot;: &quot;../../source/postprocessors/ElementIntegralVariablePostprocessor.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object operates on&quot;}&gt;&gt;&gt; = gr1
  [../]
[]

[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [./SMP]
   type = SMP&lt;&lt;&lt;{&quot;description&quot;: &quot;Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.&quot;, &quot;href&quot;: &quot;../../source/preconditioners/SingleMatrixPreconditioner.html&quot;}&gt;&gt;&gt;
   full&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you want the full set of couplings between variables simply for convenience so you don&#x27;t have to set every off_diag_row and off_diag_column combination.&quot;}&gt;&gt;&gt; = true
  [../]
[]

[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient
  scheme = &#x27;bdf2&#x27;

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre boomeramg 31&#x27;

  l_tol = 1.0e-4
  l_max_its = 30

  nl_max_its = 20
  nl_rel_tol = 1.0e-9

  start_time = 0.0
  num_steps = 10
  dt = 80.0

  [./Adaptivity&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/Adaptivity/index.html&quot;}&gt;&gt;&gt;]
    initial_adaptivity&lt;&lt;&lt;{&quot;description&quot;: &quot;The number of adaptivity steps to perform using the initial conditions&quot;}&gt;&gt;&gt; = 2
    refine_fraction&lt;&lt;&lt;{&quot;description&quot;: &quot;The fraction of elements or error to refine. Should be between 0 and 1.&quot;}&gt;&gt;&gt; = 0.8
    coarsen_fraction&lt;&lt;&lt;{&quot;description&quot;: &quot;The fraction of elements or error to coarsen. Should be between 0 and 1.&quot;}&gt;&gt;&gt; = 0.05
    max_h_level&lt;&lt;&lt;{&quot;description&quot;: &quot;Maximum number of times a single element can be refined. If 0 then infinite.&quot;}&gt;&gt;&gt; = 2
  [../]
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;timestep_end&#x27;
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#7ff4bc7f-19fe-4928-9664-d574a50c4d02">(moose/modules/phase_field/test/tests/grain_growth/thumb.i)</a></section></section><section id="914af285-f01d-4e91-8728-49e583a6e922" data-section-level="2" data-section-text="Example Input Files"><h2 id="example-input-files">Example Input Files</h2><p>An example 2D input file for a polycrystal simulation using <code>GrainTracker</code> is available. It should be run on at least 4 processors:</p><pre style="max-height:350px;"><code class="language-moose"># This simulation predicts GB migration of a 2D copper polycrystal with 100 grains represented with 8 order parameters
# Mesh adaptivity and time step adaptivity are used
# An AuxVariable is used to calculate the grain boundary locations
# Postprocessors are used to record time step and the number of grains

[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  # Mesh block.  Meshes can be read in or automatically generated
  type = GeneratedMesh
  dim = 2 # Problem dimension
  nx = 44 # Number of elements in the x-direction
  ny = 44 # Number of elements in the y-direction
  xmax = 1000 # maximum x-coordinate of the mesh
  ymax = 1000 # maximum y-coordinate of the mesh
  elem_type = QUAD4 # Type of elements used in the mesh
  uniform_refine&lt;&lt;&lt;{&quot;description&quot;: &quot;Specify the level of uniform refinement applied to the initial mesh&quot;}&gt;&gt;&gt; = 2 # Initial uniform refinement of the mesh
[]

[GlobalParams&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/GlobalParams/index.html&quot;}&gt;&gt;&gt;]
  # Parameters used by several kernels that are defined globally to simplify input file
  op_num = 8 # Number of order parameters used
  var_name_base = gr # Base name of grains
[]

[Modules&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Modules/index.html&quot;}&gt;&gt;&gt;]
  [PhaseField&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Modules/PhaseField/index.html&quot;}&gt;&gt;&gt;]
    [GrainGrowth&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Modules/PhaseField/GrainGrowth/index.html&quot;}&gt;&gt;&gt;]
    []
  []
[]

[UserObjects&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/UserObjects/index.html&quot;}&gt;&gt;&gt;]
  [voronoi]
    type = PolycrystalVoronoi&lt;&lt;&lt;{&quot;description&quot;: &quot;Random Voronoi tessellation polycrystal (used by PolycrystalVoronoiAction)&quot;, &quot;href&quot;: &quot;../../source/userobjects/PolycrystalVoronoi.html&quot;}&gt;&gt;&gt;
    grain_num&lt;&lt;&lt;{&quot;description&quot;: &quot;Number of grains being represented by the order parameters&quot;}&gt;&gt;&gt; = 100 # Number of grains
    rand_seed&lt;&lt;&lt;{&quot;description&quot;: &quot;The random seed&quot;}&gt;&gt;&gt; = 10
    int_width&lt;&lt;&lt;{&quot;description&quot;: &quot;Width of diffuse interfaces&quot;}&gt;&gt;&gt; = 7
  []
  [grain_tracker]
    type = GrainTracker&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain Tracker object for running reduced order parameter simulations without grain coalescence.&quot;, &quot;href&quot;: &quot;../../source/postprocessors/GrainTracker.html&quot;}&gt;&gt;&gt;
  []
[]

[ICs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/ICs/index.html&quot;}&gt;&gt;&gt;]
  [PolycrystalICs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/ICs/PolycrystalICs/index.html&quot;}&gt;&gt;&gt;]
    [PolycrystalColoringIC&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/ICs/PolycrystalICs/PolycrystalColoringIC/index.html&quot;}&gt;&gt;&gt;]
      polycrystal_ic_uo&lt;&lt;&lt;{&quot;description&quot;: &quot;Optional: TODO&quot;}&gt;&gt;&gt; = voronoi
    []
  []
[]

[AuxVariables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxVariables/index.html&quot;}&gt;&gt;&gt;]
  # Dependent variables
  [unique_grains]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = CONSTANT
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = MONOMIAL
  []
  [var_indices]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = CONSTANT
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = MONOMIAL
  []
[]

[AuxKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxKernels/index.html&quot;}&gt;&gt;&gt;]
  # AuxKernel block, defining the equations used to calculate the auxvars
  [bnds_aux]
    # AuxKernel that calculates the GB term
    type = BndsCalcAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculate location of grain boundaries in a polycrystalline sample&quot;, &quot;href&quot;: &quot;../../source/auxkernels/BndsCalcAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = bnds
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []
  [unique_grains]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = unique_grains
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = UNIQUE_REGION
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []
  [var_indices]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = var_indices
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = VARIABLE_COLORING
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []
[]

[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/index.html&quot;}&gt;&gt;&gt;]
  # Boundary Condition block
  [Periodic&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/Periodic/index.html&quot;}&gt;&gt;&gt;]
    [All]
      auto_direction&lt;&lt;&lt;{&quot;description&quot;: &quot;If using a generated mesh, you can specify just the dimension(s) you want to mark as periodic&quot;}&gt;&gt;&gt; = &#x27;x y&#x27; # Makes problem periodic in the x and y directions
    []
  []
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [CuGrGr]
    # Material properties
    type = GBEvolution&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes necessary material properties for the isotropic grain growth model&quot;, &quot;href&quot;: &quot;../../source/materials/GBEvolution.html&quot;}&gt;&gt;&gt;
    T&lt;&lt;&lt;{&quot;description&quot;: &quot;Temperature in Kelvin&quot;}&gt;&gt;&gt; = 450 # Constant temperature of the simulation (for mobility calculation)
    wGB&lt;&lt;&lt;{&quot;description&quot;: &quot;Diffuse GB width in the length scale of the model&quot;}&gt;&gt;&gt; = 14 # Width of the diffuse GB
    GBmob0&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary mobility prefactor in m^4/(J*s)&quot;}&gt;&gt;&gt; = 2.5e-6 #m^4(Js) for copper from schonfelder1997molecular bibtex entry
    Q&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary migration activation energy in eV&quot;}&gt;&gt;&gt; = 0.23 #eV for copper from schonfelder1997molecular bibtex entry
    GBenergy&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary energy in J/m^2&quot;}&gt;&gt;&gt; = 0.708 #J/m^2 from schonfelder1997molecular bibtex entry
  []
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  # Scalar postprocessors
  [dt]
    # Outputs the current time step
    type = TimestepSize&lt;&lt;&lt;{&quot;description&quot;: &quot;Reports the timestep size&quot;, &quot;href&quot;: &quot;../../source/postprocessors/TimestepSize.html&quot;}&gt;&gt;&gt;
  []
[]

[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient # Type of executioner, here it is transient with an adaptive time step
  scheme = bdf2 # Type of time integration (2nd order backward euler), defaults to 1st order backward euler

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  # Uses newton iteration to solve the problem.
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;

  l_max_its = 50 # Max number of linear iterations
  l_tol = 1e-4 # Relative tolerance for linear solves
  nl_max_its = 10 # Max number of nonlinear iterations

  end_time = 4000

  [TimeStepper&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/TimeStepper/index.html&quot;}&gt;&gt;&gt;]
    type = IterationAdaptiveDT
    dt = 20 # Initial time step.  In this simulation it changes.
    optimal_iterations = 6 # Time step will adapt to maintain this number of nonlinear iterations
  []

  [Adaptivity&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/Adaptivity/index.html&quot;}&gt;&gt;&gt;]
    # Block that turns on mesh adaptivity. Note that mesh will never coarsen beyond initial mesh (before uniform refinement)
    initial_adaptivity&lt;&lt;&lt;{&quot;description&quot;: &quot;The number of adaptivity steps to perform using the initial conditions&quot;}&gt;&gt;&gt; = 2 # Number of times mesh is adapted to initial condition
    refine_fraction&lt;&lt;&lt;{&quot;description&quot;: &quot;The fraction of elements or error to refine. Should be between 0 and 1.&quot;}&gt;&gt;&gt; = 0.8 # Fraction of high error that will be refined
    coarsen_fraction&lt;&lt;&lt;{&quot;description&quot;: &quot;The fraction of elements or error to coarsen. Should be between 0 and 1.&quot;}&gt;&gt;&gt; = 0.05 # Fraction of low error that will coarsened
    max_h_level&lt;&lt;&lt;{&quot;description&quot;: &quot;Maximum number of times a single element can be refined. If 0 then infinite.&quot;}&gt;&gt;&gt; = 2 # Max number of refinements used, starting from initial mesh (before uniform refinement)
  []
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true # Exodus file will be outputted
  csv&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the scalar variable and postprocessors to a *.csv file using the default CSV output.&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#0197d842-c565-491e-9bd9-d38d76e76885">(moose/modules/phase_field/examples/grain_growth/grain_growth_2D_graintracker.i)</a><p>An example 3D input file is also available. It should be run on at least 2 processors:</p><pre style="max-height:350px;"><code class="language-moose"># This simulation predicts GB migration of a 3D copper polycrystal with 25 grains represented with 15 order parameters
# Time step adaptivity are used
# An AuxVariable is used to calculate the grain boundary locations
# Postprocessors are used to record time step and the number of grains

[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  # Mesh block.  Meshes can be read in or automatically generated
  type = GeneratedMesh
  dim = 3 # Problem dimension
  nx = 10 # Number of elements in the x-direction
  ny = 10 # Number of elements in the y-direction
  nz = 10
  xmax = 1000 # maximum x-coordinate of the mesh
  ymax = 1000 # maximum y-coordinate of the mesh
  zmax = 1000
  uniform_refine&lt;&lt;&lt;{&quot;description&quot;: &quot;Specify the level of uniform refinement applied to the initial mesh&quot;}&gt;&gt;&gt; = 1 # Initial uniform refinement of the mesh

  parallel_type = distributed
[]

[GlobalParams&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/GlobalParams/index.html&quot;}&gt;&gt;&gt;]
  # Parameters used by several kernels that are defined globally to simplify input file
  op_num = 15 # Number of order parameters used
  var_name_base = gr # Base name of grains
  order = CONSTANT
  family = MONOMIAL
[]

[Modules&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Modules/index.html&quot;}&gt;&gt;&gt;]
  [PhaseField&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Modules/PhaseField/index.html&quot;}&gt;&gt;&gt;]
    [GrainGrowth&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Modules/PhaseField/GrainGrowth/index.html&quot;}&gt;&gt;&gt;]
      family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape function to use for the order parameters&quot;}&gt;&gt;&gt; = LAGRANGE
      order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for the order parameters&quot;}&gt;&gt;&gt; = FIRST
    []
  []
[]

[UserObjects&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/UserObjects/index.html&quot;}&gt;&gt;&gt;]
  [voronoi]
    type = PolycrystalVoronoi&lt;&lt;&lt;{&quot;description&quot;: &quot;Random Voronoi tessellation polycrystal (used by PolycrystalVoronoiAction)&quot;, &quot;href&quot;: &quot;../../source/userobjects/PolycrystalVoronoi.html&quot;}&gt;&gt;&gt;
    grain_num&lt;&lt;&lt;{&quot;description&quot;: &quot;Number of grains being represented by the order parameters&quot;}&gt;&gt;&gt; = 25 # Number of grains
    rand_seed&lt;&lt;&lt;{&quot;description&quot;: &quot;The random seed&quot;}&gt;&gt;&gt; = 10
    coloring_algorithm&lt;&lt;&lt;{&quot;description&quot;: &quot;The grain neighbor graph coloring algorithm to use: \&quot;jp\&quot; (DEFAULT) Jones and Plassmann, an efficient coloring algorithm, \&quot;power\&quot; an alternative stochastic algorithm, \&quot;greedy\&quot;, a greedy assignment algorithm with stochastic updates to guarantee a valid coloring, \&quot;bt\&quot;, a back tracking algorithm that produces good distributions but may experience exponential run time in the worst case scenario (works well on medium to large 2D problems)&quot;}&gt;&gt;&gt; = jp
  []
  [grain_tracker]
    type = GrainTracker&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain Tracker object for running reduced order parameter simulations without grain coalescence.&quot;, &quot;href&quot;: &quot;../../source/postprocessors/GrainTracker.html&quot;}&gt;&gt;&gt;
    threshold&lt;&lt;&lt;{&quot;description&quot;: &quot;The threshold value for which a new feature may be started&quot;}&gt;&gt;&gt; = 0.2
    connecting_threshold&lt;&lt;&lt;{&quot;description&quot;: &quot;The threshold for which an existing feature may be extended (defaults to \&quot;threshold\&quot;)&quot;}&gt;&gt;&gt; = 0.08
    compute_halo_maps&lt;&lt;&lt;{&quot;description&quot;: &quot;Instruct the Postprocessor to communicate proper halo information to all ranks&quot;}&gt;&gt;&gt; = true # Only necessary for displaying HALOS
    polycrystal_ic_uo&lt;&lt;&lt;{&quot;description&quot;: &quot;Optional: Polycrystal IC object&quot;}&gt;&gt;&gt; = voronoi
  []
[]

[ICs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/ICs/index.html&quot;}&gt;&gt;&gt;]
  [PolycrystalICs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/ICs/PolycrystalICs/index.html&quot;}&gt;&gt;&gt;]
    [PolycrystalColoringIC&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/ICs/PolycrystalICs/PolycrystalColoringIC/index.html&quot;}&gt;&gt;&gt;]
      polycrystal_ic_uo&lt;&lt;&lt;{&quot;description&quot;: &quot;Optional: TODO&quot;}&gt;&gt;&gt; = voronoi
    []
  []
[]

[AuxVariables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxVariables/index.html&quot;}&gt;&gt;&gt;]
  # Dependent variables
  [unique_grains]
  []

  [var_indices]
  []

  [ghost_regions]
  []

  [halos]
  []

  [halo0]
  []

  [halo1]
  []

  [halo2]
  []

  [halo3]
  []

  [halo4]
  []

  [halo5]
  []

  [halo6]
  []

  [halo7]
  []

  [halo8]
  []

  [halo9]
  []

  [halo10]
  []

  [halo11]
  []

  [halo12]
  []

  [halo13]
  []

  [halo14]
  []

  [proc]
  []
[]

[AuxKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxKernels/index.html&quot;}&gt;&gt;&gt;]
  # AuxKernel block, defining the equations used to calculate the auxvars
  [unique_grains]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = unique_grains
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = UNIQUE_REGION
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []
  [var_indices]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = var_indices
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = VARIABLE_COLORING
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []
  [ghosted_entities]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = ghost_regions
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = GHOSTED_ENTITIES
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []
  [halos]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halos
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = voronoi
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []
  [halo0]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo0
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 0
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []
  [halo1]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo1
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 1
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo2]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo2
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 2
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo3]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo3
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 3
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo4]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo4
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 4
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo5]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo5
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 5
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo6]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo6
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 6
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo7]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo7
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 7
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo8]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo8
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 8
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo9]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo9
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 9
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo10]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo10
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 10
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo11]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo11
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 11
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo12]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo12
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 12
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo13]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo13
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 13
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halo14]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halo14
    map_index&lt;&lt;&lt;{&quot;description&quot;: &quot;The index of which map to retrieve values from when using FeatureFloodCount with multiple maps.&quot;}&gt;&gt;&gt; = 14
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [proc]
    type = ProcessorIDAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Creates a field showing the processors and partitioning.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/ProcessorIDAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = proc
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []

[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [CuGrGr]
    # Material properties
    type = GBEvolution&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes necessary material properties for the isotropic grain growth model&quot;, &quot;href&quot;: &quot;../../source/materials/GBEvolution.html&quot;}&gt;&gt;&gt;
    T&lt;&lt;&lt;{&quot;description&quot;: &quot;Temperature in Kelvin&quot;}&gt;&gt;&gt; = 450 # Constant temperature of the simulation (for mobility calculation)
    wGB&lt;&lt;&lt;{&quot;description&quot;: &quot;Diffuse GB width in the length scale of the model&quot;}&gt;&gt;&gt; = 125 # Width of the diffuse GB
    GBmob0&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary mobility prefactor in m^4/(J*s)&quot;}&gt;&gt;&gt; = 2.5e-6 #m^4(Js) for copper from schonfelder1997molecular bibtex entry
    Q&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary migration activation energy in eV&quot;}&gt;&gt;&gt; = 0.23 #eV for copper from schonfelder1997molecular bibtex entry
    GBenergy&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary energy in J/m^2&quot;}&gt;&gt;&gt; = 0.708 #J/m^2 from schonfelder1997molecular bibtex entry
  []
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  # Scalar postprocessors
  [dt]
    # Outputs the current time step
    type = TimestepSize&lt;&lt;&lt;{&quot;description&quot;: &quot;Reports the timestep size&quot;, &quot;href&quot;: &quot;../../source/postprocessors/TimestepSize.html&quot;}&gt;&gt;&gt;
  []
[]

[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient # Type of executioner, here it is transient with an adaptive time step
  scheme = bdf2 # Type of time integration (2nd order backward euler), defaults to 1st order backward euler

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  # Uses newton iteration to solve the problem.
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;asm&#x27;

  l_max_its = 30 # Max number of linear iterations
  l_tol = 1e-4 # Relative tolerance for linear solves
  nl_max_its = 20 # Max number of nonlinear iterations

  start_time = 0.0
  end_time = 4000

  [TimeStepper&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/TimeStepper/index.html&quot;}&gt;&gt;&gt;]
    type = IterationAdaptiveDT
    dt = 25 # Initial time step.  In this simulation it changes.
    optimal_iterations = 6 # Time step will adapt to maintain this number of nonlinear iterations
  []
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
  csv&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the scalar variable and postprocessors to a *.csv file using the default CSV output.&quot;}&gt;&gt;&gt; = true
  [pg]
    type = PerfGraphOutput&lt;&lt;&lt;{&quot;description&quot;: &quot;Controls output of the PerfGraph: the performance log for MOOSE&quot;, &quot;href&quot;: &quot;../../source/outputs/PerfGraphOutput.html&quot;}&gt;&gt;&gt;
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial final&#x27; # Default is &quot;final&quot;
    level&lt;&lt;&lt;{&quot;description&quot;: &quot;The level of detail to output.  Higher levels will yield more detail.&quot;}&gt;&gt;&gt; = 2 # Default is 1
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#682372d1-a05f-4465-a1a5-ddef8d616cff">(moose/modules/phase_field/examples/grain_growth/grain_growth_3D.i)</a><p>There is also an example reconstructing the initial grain structure from EBSD data. It should be run on at least 4 processors:</p><pre style="max-height:350px;"><code class="language-moose">[Mesh&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Mesh/index.html&quot;}&gt;&gt;&gt;]
  [ebsd_mesh]
    type = EBSDMeshGenerator&lt;&lt;&lt;{&quot;description&quot;: &quot;Mesh generated from a specified DREAM.3D EBSD data file.&quot;, &quot;href&quot;: &quot;../../source/meshgenerators/EBSDMeshGenerator.html&quot;}&gt;&gt;&gt;
    filename&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the file containing the EBSD data&quot;}&gt;&gt;&gt; = IN100_120x120.txt
    pre_refine&lt;&lt;&lt;{&quot;description&quot;: &quot;Number of coarsening levels available in adaptive mesh refinement. The resulting mesh will have one mesh element per EBSD data cell, but will be based on a refined coarser mesh with &#x27;pre_refine&#x27; levels of refinement. This requires all dimension of the EBSD data to be divisible by 2^pre_refine.(this parameter was formerly called &#x27;uniform_refine&#x27;)&quot;}&gt;&gt;&gt; = 2
  []
[]

[GlobalParams&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/GlobalParams/index.html&quot;}&gt;&gt;&gt;]
  op_num = 8
  var_name_base = gr
[]

[UserObjects&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/UserObjects/index.html&quot;}&gt;&gt;&gt;]
  [ebsd_reader]
    type = EBSDReader&lt;&lt;&lt;{&quot;description&quot;: &quot;Load and manage DREAM.3D EBSD data files for running simulations on reconstructed microstructures.&quot;, &quot;href&quot;: &quot;../../source/userobjects/EBSDReader.html&quot;}&gt;&gt;&gt;
  []
  [ebsd]
    type = PolycrystalEBSD&lt;&lt;&lt;{&quot;description&quot;: &quot;Object for setting up a polycrystal structure from an EBSD Datafile&quot;, &quot;href&quot;: &quot;../../source/userobjects/PolycrystalEBSD.html&quot;}&gt;&gt;&gt;
    coloring_algorithm&lt;&lt;&lt;{&quot;description&quot;: &quot;The grain neighbor graph coloring algorithm to use: \&quot;jp\&quot; (DEFAULT) Jones and Plassmann, an efficient coloring algorithm, \&quot;power\&quot; an alternative stochastic algorithm, \&quot;greedy\&quot;, a greedy assignment algorithm with stochastic updates to guarantee a valid coloring, \&quot;bt\&quot;, a back tracking algorithm that produces good distributions but may experience exponential run time in the worst case scenario (works well on medium to large 2D problems)&quot;}&gt;&gt;&gt; = bt
    ebsd_reader&lt;&lt;&lt;{&quot;description&quot;: &quot;EBSD Reader for initial condition&quot;}&gt;&gt;&gt; = ebsd_reader
    enable_var_coloring&lt;&lt;&lt;{&quot;description&quot;: &quot;Instruct the Postprocessor to populate the variable index map.&quot;}&gt;&gt;&gt; = true
  []
  [grain_tracker]
    type = GrainTracker&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain Tracker object for running reduced order parameter simulations without grain coalescence.&quot;, &quot;href&quot;: &quot;../../source/postprocessors/GrainTracker.html&quot;}&gt;&gt;&gt;
    flood_entity_type&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines whether the flood algorithm runs on nodes or elements&quot;}&gt;&gt;&gt; = ELEMENTAL
    compute_halo_maps&lt;&lt;&lt;{&quot;description&quot;: &quot;Instruct the Postprocessor to communicate proper halo information to all ranks&quot;}&gt;&gt;&gt; = true # For displaying HALO fields
    polycrystal_ic_uo&lt;&lt;&lt;{&quot;description&quot;: &quot;Optional: Polycrystal IC object&quot;}&gt;&gt;&gt; = ebsd
  []
[]

[ICs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/ICs/index.html&quot;}&gt;&gt;&gt;]
  [PolycrystalICs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/ICs/PolycrystalICs/index.html&quot;}&gt;&gt;&gt;]
    [PolycrystalColoringIC&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/ICs/PolycrystalICs/PolycrystalColoringIC/index.html&quot;}&gt;&gt;&gt;]
      polycrystal_ic_uo&lt;&lt;&lt;{&quot;description&quot;: &quot;Optional: TODO&quot;}&gt;&gt;&gt; = ebsd
    []
  []
[]

[Variables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/index.html&quot;}&gt;&gt;&gt;]
  [PolycrystalVariables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Variables/PolycrystalVariables/index.html&quot;}&gt;&gt;&gt;]
  []
[]

[AuxVariables&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxVariables/index.html&quot;}&gt;&gt;&gt;]
  [bnds]
  []
  [unique_grains_ic]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = CONSTANT
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = MONOMIAL
  []
  [unique_grains]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = CONSTANT
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = MONOMIAL
  []
  [ghost_elements]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = CONSTANT
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = MONOMIAL
  []
  [halos]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = CONSTANT
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = MONOMIAL
  []
  [var_indices_ic]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = CONSTANT
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = MONOMIAL
  []
  [var_indices]
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = CONSTANT
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = MONOMIAL
  []
  [ebsd_grains]
    family&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the family of FE shape functions to use for this variable&quot;}&gt;&gt;&gt; = MONOMIAL
    order&lt;&lt;&lt;{&quot;description&quot;: &quot;Specifies the order of the FE shape function to use for this variable (additional orders not listed are allowed)&quot;}&gt;&gt;&gt; = CONSTANT
  []
[]

[Kernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/index.html&quot;}&gt;&gt;&gt;]
  [PolycrystalKernel&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Kernels/PolycrystalKernel/index.html&quot;}&gt;&gt;&gt;]
  []
[]

[AuxKernels&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/AuxKernels/index.html&quot;}&gt;&gt;&gt;]
  [BndsCalc]
    type = BndsCalcAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Calculate location of grain boundaries in a polycrystalline sample&quot;, &quot;href&quot;: &quot;../../source/auxkernels/BndsCalcAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = bnds
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []
  [ghost_elements]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = ghost_elements
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = GHOSTED_ENTITIES
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [halos]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = halos
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = HALOS
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
  []
  [var_indices_ic]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = var_indices_ic
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial&#x27;
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = ebsd
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = VARIABLE_COLORING
  []
  [unique_grains_ic]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = unique_grains_ic
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial&#x27;
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = ebsd
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = UNIQUE_REGION
  []
  [var_indices]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = var_indices
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = VARIABLE_COLORING
  []
  [unique_grains]
    type = FeatureFloodCountAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Feature detection by connectivity analysis&quot;, &quot;href&quot;: &quot;../../source/auxkernels/FeatureFloodCountAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = unique_grains
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
    flood_counter&lt;&lt;&lt;{&quot;description&quot;: &quot;The FeatureFloodCount UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
    field_display&lt;&lt;&lt;{&quot;description&quot;: &quot;Determines how the auxilary field should be colored. (UNIQUE_REGION and VARIABLE_COLORING are nodal, CENTROID is elemental, default: UNIQUE_REGION)&quot;}&gt;&gt;&gt; = UNIQUE_REGION
  []
  [grain_aux]
    type = EBSDReaderPointDataAux&lt;&lt;&lt;{&quot;description&quot;: &quot;Outputs the requested EBSD reader point data.&quot;, &quot;href&quot;: &quot;../../source/auxkernels/EBSDReaderPointDataAux.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this object applies to&quot;}&gt;&gt;&gt; = ebsd_grains
    ebsd_reader&lt;&lt;&lt;{&quot;description&quot;: &quot;The EBSDReader GeneralUserObject&quot;}&gt;&gt;&gt; = ebsd_reader
    data_name&lt;&lt;&lt;{&quot;description&quot;: &quot;The data to be extracted from the EBSD data by this AuxKernel&quot;}&gt;&gt;&gt; = &#x27;feature_id&#x27;
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []
[]

[Modules&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Modules/index.html&quot;}&gt;&gt;&gt;]
  [PhaseField&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Modules/PhaseField/index.html&quot;}&gt;&gt;&gt;]
    [EulerAngles2RGB&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Modules/PhaseField/EulerAngles2RGB/index.html&quot;}&gt;&gt;&gt;]
      crystal_structure&lt;&lt;&lt;{&quot;description&quot;: &quot;Crystal structure of the material&quot;}&gt;&gt;&gt; = cubic
      euler_angle_provider&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of Euler angle provider user object&quot;}&gt;&gt;&gt; = ebsd_reader
      grain_tracker&lt;&lt;&lt;{&quot;description&quot;: &quot;The GrainTracker UserObject to get values from.&quot;}&gt;&gt;&gt; = grain_tracker
    []
  []
[]

[Materials&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Materials/index.html&quot;}&gt;&gt;&gt;]
  [Copper]
    # T = 500 # K
    type = GBEvolution&lt;&lt;&lt;{&quot;description&quot;: &quot;Computes necessary material properties for the isotropic grain growth model&quot;, &quot;href&quot;: &quot;../../source/materials/GBEvolution.html&quot;}&gt;&gt;&gt;
    T&lt;&lt;&lt;{&quot;description&quot;: &quot;Temperature in Kelvin&quot;}&gt;&gt;&gt; = 500
    wGB&lt;&lt;&lt;{&quot;description&quot;: &quot;Diffuse GB width in the length scale of the model&quot;}&gt;&gt;&gt; = 0.6 # um
    GBmob0&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary mobility prefactor in m^4/(J*s)&quot;}&gt;&gt;&gt; = 2.5e-6 # m^4/(Js) from Schoenfelder 1997
    Q&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary migration activation energy in eV&quot;}&gt;&gt;&gt; = 0.23 # Migration energy in eV
    GBenergy&lt;&lt;&lt;{&quot;description&quot;: &quot;Grain boundary energy in J/m^2&quot;}&gt;&gt;&gt; = 0.708 # GB energy in J/m^2
    molar_volume&lt;&lt;&lt;{&quot;description&quot;: &quot;Molar volume in m^3/mol, needed for temperature gradient driving force&quot;}&gt;&gt;&gt; = 7.11e-6 # Molar volume in m^3/mol
    length_scale&lt;&lt;&lt;{&quot;description&quot;: &quot;Length scale in m, where default is nm&quot;}&gt;&gt;&gt; = 1.0e-6
    time_scale&lt;&lt;&lt;{&quot;description&quot;: &quot;Time scale in s, where default is ns&quot;}&gt;&gt;&gt; = 1.0e-6
  []
[]

[Postprocessors&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Postprocessors/index.html&quot;}&gt;&gt;&gt;]
  [dt]
    type = TimestepSize&lt;&lt;&lt;{&quot;description&quot;: &quot;Reports the timestep size&quot;, &quot;href&quot;: &quot;../../source/postprocessors/TimestepSize.html&quot;}&gt;&gt;&gt;
  []
  [n_elements]
    type = NumElements&lt;&lt;&lt;{&quot;description&quot;: &quot;Return the number of active or total elements in the simulation.&quot;, &quot;href&quot;: &quot;../../source/postprocessors/NumElements.html&quot;}&gt;&gt;&gt;
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []
  [n_nodes]
    type = NumNodes&lt;&lt;&lt;{&quot;description&quot;: &quot;Returns the total number of nodes in a simulation (works with DistributedMesh)&quot;, &quot;href&quot;: &quot;../../source/postprocessors/NumNodes.html&quot;}&gt;&gt;&gt;
    execute_on&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of flag(s) indicating when this object should be executed. For a description of each flag, see https://mooseframework.inl.gov/source/interfaces/SetupInterface.html.&quot;}&gt;&gt;&gt; = &#x27;initial timestep_end&#x27;
  []
  [DOFs]
    type = NumDOFs&lt;&lt;&lt;{&quot;description&quot;: &quot;Return the number of Degrees of freedom from either the NL, Aux or both systems.&quot;, &quot;href&quot;: &quot;../../source/postprocessors/NumDOFs.html&quot;}&gt;&gt;&gt;
  []
[]

[Executioner&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/index.html&quot;}&gt;&gt;&gt;]
  type = Transient
  scheme = bdf2
  solve_type = PJFNK

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -pc_hypre_boomeramg_strong_threshold&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      0.7&#x27;

  l_tol = 1.0e-4
  l_max_its = 20
  nl_max_its = 20
  nl_rel_tol = 1.0e-8

  start_time = 0.0
  num_steps = 30

  [TimeStepper&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/TimeStepper/index.html&quot;}&gt;&gt;&gt;]
    type = IterationAdaptiveDT
    cutback_factor = 0.9
    dt = 10.0
    growth_factor = 1.1
    optimal_iterations = 7
  []

  [Adaptivity&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Executioner/Adaptivity/index.html&quot;}&gt;&gt;&gt;]
    initial_adaptivity&lt;&lt;&lt;{&quot;description&quot;: &quot;The number of adaptivity steps to perform using the initial conditions&quot;}&gt;&gt;&gt; = 2
    refine_fraction&lt;&lt;&lt;{&quot;description&quot;: &quot;The fraction of elements or error to refine. Should be between 0 and 1.&quot;}&gt;&gt;&gt; = 0.7
    coarsen_fraction&lt;&lt;&lt;{&quot;description&quot;: &quot;The fraction of elements or error to coarsen. Should be between 0 and 1.&quot;}&gt;&gt;&gt; = 0.1
    max_h_level&lt;&lt;&lt;{&quot;description&quot;: &quot;Maximum number of times a single element can be refined. If 0 then infinite.&quot;}&gt;&gt;&gt; = 2
  []
[]

[Outputs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Outputs/index.html&quot;}&gt;&gt;&gt;]
  exodus&lt;&lt;&lt;{&quot;description&quot;: &quot;Output the results using the default settings for Exodus output.&quot;}&gt;&gt;&gt; = true
  checkpoint&lt;&lt;&lt;{&quot;description&quot;: &quot;Create checkpoint files using the default options.&quot;}&gt;&gt;&gt; = true
  perf_graph&lt;&lt;&lt;{&quot;description&quot;: &quot;Enable printing of the performance graph to the screen (Console)&quot;}&gt;&gt;&gt; = true
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#24d13b46-a9c7-446b-801e-fe97c667aeec">(moose/modules/phase_field/examples/ebsd_reconstruction/IN100-111grn.i)</a></section><section id="2799208b-69f9-423a-a69a-b9e1e5de3825" data-section-level="2" data-section-text="References"><h2 id="references">References</h2><div class="moose-bibliography"><ol><li id="Chen1995">Long-Qing Chen.
A novel computer simulation technique for modeling grain growth.
<em>Scripta Metallurgica et Materialia</em>, 32:115–120, 1995.
URL: <a href="https://www.sciencedirect.com/science/article/pii/S0956716X99800223">https://www.sciencedirect.com/science/article/pii/S0956716X99800223</a>, <a href="https://doi.org/10.1016/S0956-716X(99)80022-3">doi:10.1016/S0956-716X(99)80022-3</a>.<a href="#8848d70f-ea4a-4893-92bd-2e9a68ff7bfa" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="8848d70f-ea4a-4893-92bd-2e9a68ff7bfa"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{Chen1995,
    author = "Chen, Long-Qing",
    title = "A novel computer simulation technique for modeling grain growth",
    journal = "Scripta Metallurgica et Materialia",
    volume = "32",
    issue = "1",
    pages = "115--120",
    year = "1995",
    publisher = "Elsevier Pergamon",
    doi = "10.1016/S0956-716X(99)80022-3",
    url = "https://www.sciencedirect.com/science/article/pii/S0956716X99800223"
}
</code></pre></div></div></li><li id="ChenYang1994">Long-Qing Chen and Wei Yang.
Computer simulation of the domain dynamics of a quenched system with a large number of nonconserved order parameters: the grain-growth kinetics.
<em>Phys. Rev. B</em>, 50:15752–15756, Dec 1994.
URL: <a href="https://link.aps.org/doi/10.1103/PhysRevB.50.15752">https://link.aps.org/doi/10.1103/PhysRevB.50.15752</a>, <a href="https://doi.org/10.1103/PhysRevB.50.15752">doi:10.1103/PhysRevB.50.15752</a>.<a href="#81e513d9-f0eb-4f90-9dfc-fc4939836a58" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="81e513d9-f0eb-4f90-9dfc-fc4939836a58"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{ChenYang1994,
    author = "Chen, Long-Qing and Yang, Wei",
    title = "Computer simulation of the domain dynamics of a quenched system with a large number of nonconserved order parameters: The grain-growth kinetics",
    journal = "Phys. Rev. B",
    volume = "50",
    issue = "21",
    pages = "15752--15756",
    year = "1994",
    month = "Dec",
    publisher = "American Physical Society",
    doi = "10.1103/PhysRevB.50.15752",
    url = "https://link.aps.org/doi/10.1103/PhysRevB.50.15752"
}
</code></pre></div></div></li><li id="moelans_quantitative_2008">N.&nbsp;Moelans, B.&nbsp;Blanpain, and P.&nbsp;Wollants.
Quantitative analysis of grain boundary properties in a generalized phase field model for grain growth in anisotropic systems.
<em>Physical Review B</em>, 78(2):024113, Jul 2008.
URL: <a href="http://link.aps.org/doi/10.1103/PhysRevB.78.024113">http://link.aps.org/doi/10.1103/PhysRevB.78.024113</a> (visited on 2016-06-02), <a href="https://doi.org/10.1103/PhysRevB.78.024113">doi:10.1103/PhysRevB.78.024113</a>.<a href="#c6795489-cf1e-4674-9e53-3c34a555593d" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="c6795489-cf1e-4674-9e53-3c34a555593d"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{moelans_quantitative_2008,
    author = "Moelans, N. and Blanpain, B. and Wollants, P.",
    title = "Quantitative analysis of grain boundary properties in a generalized phase field model for grain growth in anisotropic systems",
    volume = "78",
    url = "http://link.aps.org/doi/10.1103/PhysRevB.78.024113",
    doi = "10.1103/PhysRevB.78.024113",
    number = "2",
    urldate = "2016-06-02",
    journal = "Physical Review B",
    month = "Jul",
    year = "2008",
    pages = "024113",
    file = "APS Snapshot:/Users/i.greenquist/Zotero/storage/Q8854BXX/PhysRevB.78.html:text/html;PhysRevB.78.024113.pdf:/Users/i.greenquist/Zotero/storage/VSMEC28A/PhysRevB.78.024113.pdf:application/pdf;PhysRevB.78.pdf:/Users/i.greenquist/Zotero/storage/VEU7AATJ/PhysRevB.78.pdf:application/pdf"
}
</code></pre></div></div></li><li id="schonfelder1997molecular">B&nbsp;Sch<span class="bibtex-protected">ö</span>nfelder, D&nbsp;Wolf, SR&nbsp;Phillpot, and M&nbsp;Furtkamp.
Molecular-dynamics method for the simulation of grain-boundary migration.
<em>Interface Science</em>, 5:245–262, 1997.<a href="#fd1f7b0e-1302-4988-8c4d-8ea9e45cefbb" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="fd1f7b0e-1302-4988-8c4d-8ea9e45cefbb"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{schonfelder1997molecular,
    author = {Sch{\"o}nfelder, B and Wolf, D and Phillpot, SR and Furtkamp, M},
    title = "Molecular-dynamics method for the simulation of grain-boundary migration",
    journal = "Interface Science",
    volume = "5",
    pages = "245--262",
    year = "1997",
    publisher = "Springer"
}
</code></pre></div></div></li></ol></div></section></section><div class="moose-modal modal" id="3f707b0f-382e-4970-8f7e-c136c5c12266"><div class="modal-content"><h4>(moose/modules/phase_field/test/tests/grain_growth/test.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  xmin = 0
  xmax = 400
  ymin = 0
  ymax = 400
  zmin = 0
  zmax = 0
  elem_type = QUAD4
  uniform_refine = 1
[]

[GlobalParams]
  op_num = 2
  var_name_base = gr
[]

[Variables]
  [./PolycrystalVariables]
  [../]
[]

[ICs]
  [./PolycrystalICs]
    [./BicrystalCircleGrainIC]
      radius = 300
      x = 400
      y = 0
    [../]
  [../]
[]

[AuxVariables]
  [./bnds]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./PolycrystalKernel]
  [../]
[]

[AuxKernels]
  [./BndsCalc]
    type = BndsCalcAux
    variable = bnds
  [../]
[]

[Materials]
  [./Copper]
    type = GBEvolution
    T = 500 # K
    wGB = 60 # nm
    GBmob0 = 2.5e-6 #m^4/(Js) from Schoenfelder 1997
    Q = 0.23 #Migration energy in eV
    GBenergy = 0.708 #GB energy in J/m^2
  [../]
[]

[Postprocessors]
  [./gr1area]
    type = ElementIntegralVariablePostprocessor
    variable = gr1
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2
  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre boomeramg 31&#x27;

  l_tol = 1.0e-4
  l_max_its = 30
  nl_max_its = 20
  nl_rel_tol = 1.0e-9
  start_time = 0.0
  num_steps = 5
  dt = 80.0

  [./Adaptivity]
    initial_adaptivity = 2
    refine_fraction = 0.8
    coarsen_fraction = 0.05
    max_h_level = 2
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="7ff4bc7f-19fe-4928-9664-d574a50c4d02"><div class="modal-content"><h4>(moose/modules/phase_field/test/tests/grain_growth/thumb.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  xmin = 0
  xmax = 1000
  ymin = 0
  ymax = 1000
  zmin = 0
  zmax = 0
  elem_type = QUAD4

  uniform_refine = 2
[]

[GlobalParams]
  op_num = 2
  var_name_base = gr
  v = &#x27;gr0 gr1&#x27;
[]

[Variables]
  [./gr0]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = ThumbIC
      xcoord = 500.0
      height = 600.0
      width = 400.0
      invalue = 0.0
      outvalue = 1.0
    [../]
  [../]

  [./gr1]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = ThumbIC
      xcoord = 500.0
      height = 600.0
      width = 400.0
      invalue = 1.0
      outvalue = 0.0
    [../]
  [../]
[]

[AuxVariables]
  [./bnds]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./PolycrystalKernel]
  [../]
[]

[AuxKernels]
  [./BndsCalc]
    type = BndsCalcAux
    variable = bnds
  [../]
[]

[BCs]
  active = &#x27; &#x27;

  [./Periodic]
    [./left_right]
      primary = 0
      secondary = 2
      translation = &#x27;0 1000 0&#x27;
    [../]

    [./top_bottom]
      primary = 1
      secondary = 3
      translation = &#x27;-1000 0 0&#x27;
    [../]
  [../]
[]

[Materials]
  [./Copper]
    type = GBEvolution
    T = 500 # K
    wGB = 60 # nm
    GBmob0 = 2.5e-6 #m^4/(Js) from Schoenfelder 1997
    Q = 0.23 #Migration energy in eV
    GBenergy = 0.708 #GB energy in J/m^2
  [../]
[]

[Postprocessors]
  [./gr_area]
    type = ElementIntegralVariablePostprocessor
    variable = gr1
  [../]
[]

[Preconditioning]
  [./SMP]
   type = SMP
   full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;bdf2&#x27;

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre boomeramg 31&#x27;

  l_tol = 1.0e-4
  l_max_its = 30

  nl_max_its = 20
  nl_rel_tol = 1.0e-9

  start_time = 0.0
  num_steps = 10
  dt = 80.0

  [./Adaptivity]
    initial_adaptivity = 2
    refine_fraction = 0.8
    coarsen_fraction = 0.05
    max_h_level = 2
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="0197d842-c565-491e-9bd9-d38d76e76885"><div class="modal-content"><h4>(moose/modules/phase_field/examples/grain_growth/grain_growth_2D_graintracker.i)</h4><pre style="max-height:350px;"><code class="language-moose"># This simulation predicts GB migration of a 2D copper polycrystal with 100 grains represented with 8 order parameters
# Mesh adaptivity and time step adaptivity are used
# An AuxVariable is used to calculate the grain boundary locations
# Postprocessors are used to record time step and the number of grains

[Mesh]
  # Mesh block.  Meshes can be read in or automatically generated
  type = GeneratedMesh
  dim = 2 # Problem dimension
  nx = 44 # Number of elements in the x-direction
  ny = 44 # Number of elements in the y-direction
  xmax = 1000 # maximum x-coordinate of the mesh
  ymax = 1000 # maximum y-coordinate of the mesh
  elem_type = QUAD4 # Type of elements used in the mesh
  uniform_refine = 2 # Initial uniform refinement of the mesh
[]

[GlobalParams]
  # Parameters used by several kernels that are defined globally to simplify input file
  op_num = 8 # Number of order parameters used
  var_name_base = gr # Base name of grains
[]

[Modules]
  [PhaseField]
    [GrainGrowth]
    []
  []
[]

[UserObjects]
  [voronoi]
    type = PolycrystalVoronoi
    grain_num = 100 # Number of grains
    rand_seed = 10
    int_width = 7
  []
  [grain_tracker]
    type = GrainTracker
  []
[]

[ICs]
  [PolycrystalICs]
    [PolycrystalColoringIC]
      polycrystal_ic_uo = voronoi
    []
  []
[]

[AuxVariables]
  # Dependent variables
  [unique_grains]
    order = CONSTANT
    family = MONOMIAL
  []
  [var_indices]
    order = CONSTANT
    family = MONOMIAL
  []
[]

[AuxKernels]
  # AuxKernel block, defining the equations used to calculate the auxvars
  [bnds_aux]
    # AuxKernel that calculates the GB term
    type = BndsCalcAux
    variable = bnds
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [unique_grains]
    type = FeatureFloodCountAux
    variable = unique_grains
    flood_counter = grain_tracker
    field_display = UNIQUE_REGION
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [var_indices]
    type = FeatureFloodCountAux
    variable = var_indices
    flood_counter = grain_tracker
    field_display = VARIABLE_COLORING
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[BCs]
  # Boundary Condition block
  [Periodic]
    [All]
      auto_direction = &#x27;x y&#x27; # Makes problem periodic in the x and y directions
    []
  []
[]

[Materials]
  [CuGrGr]
    # Material properties
    type = GBEvolution
    T = 450 # Constant temperature of the simulation (for mobility calculation)
    wGB = 14 # Width of the diffuse GB
    GBmob0 = 2.5e-6 #m^4(Js) for copper from schonfelder1997molecular bibtex entry
    Q = 0.23 #eV for copper from schonfelder1997molecular bibtex entry
    GBenergy = 0.708 #J/m^2 from schonfelder1997molecular bibtex entry
  []
[]

[Postprocessors]
  # Scalar postprocessors
  [dt]
    # Outputs the current time step
    type = TimestepSize
  []
[]

[Executioner]
  type = Transient # Type of executioner, here it is transient with an adaptive time step
  scheme = bdf2 # Type of time integration (2nd order backward euler), defaults to 1st order backward euler

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  # Uses newton iteration to solve the problem.
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;

  l_max_its = 50 # Max number of linear iterations
  l_tol = 1e-4 # Relative tolerance for linear solves
  nl_max_its = 10 # Max number of nonlinear iterations

  end_time = 4000

  [TimeStepper]
    type = IterationAdaptiveDT
    dt = 20 # Initial time step.  In this simulation it changes.
    optimal_iterations = 6 # Time step will adapt to maintain this number of nonlinear iterations
  []

  [Adaptivity]
    # Block that turns on mesh adaptivity. Note that mesh will never coarsen beyond initial mesh (before uniform refinement)
    initial_adaptivity = 2 # Number of times mesh is adapted to initial condition
    refine_fraction = 0.8 # Fraction of high error that will be refined
    coarsen_fraction = 0.05 # Fraction of low error that will coarsened
    max_h_level = 2 # Max number of refinements used, starting from initial mesh (before uniform refinement)
  []
[]

[Outputs]
  exodus = true # Exodus file will be outputted
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="682372d1-a05f-4465-a1a5-ddef8d616cff"><div class="modal-content"><h4>(moose/modules/phase_field/examples/grain_growth/grain_growth_3D.i)</h4><pre style="max-height:350px;"><code class="language-moose"># This simulation predicts GB migration of a 3D copper polycrystal with 25 grains represented with 15 order parameters
# Time step adaptivity are used
# An AuxVariable is used to calculate the grain boundary locations
# Postprocessors are used to record time step and the number of grains

[Mesh]
  # Mesh block.  Meshes can be read in or automatically generated
  type = GeneratedMesh
  dim = 3 # Problem dimension
  nx = 10 # Number of elements in the x-direction
  ny = 10 # Number of elements in the y-direction
  nz = 10
  xmax = 1000 # maximum x-coordinate of the mesh
  ymax = 1000 # maximum y-coordinate of the mesh
  zmax = 1000
  uniform_refine = 1 # Initial uniform refinement of the mesh

  parallel_type = distributed
[]

[GlobalParams]
  # Parameters used by several kernels that are defined globally to simplify input file
  op_num = 15 # Number of order parameters used
  var_name_base = gr # Base name of grains
  order = CONSTANT
  family = MONOMIAL
[]

[Modules]
  [PhaseField]
    [GrainGrowth]
      family = LAGRANGE
      order = FIRST
    []
  []
[]

[UserObjects]
  [voronoi]
    type = PolycrystalVoronoi
    grain_num = 25 # Number of grains
    rand_seed = 10
    coloring_algorithm = jp
  []
  [grain_tracker]
    type = GrainTracker
    threshold = 0.2
    connecting_threshold = 0.08
    compute_halo_maps = true # Only necessary for displaying HALOS
    polycrystal_ic_uo = voronoi
  []
[]

[ICs]
  [PolycrystalICs]
    [PolycrystalColoringIC]
      polycrystal_ic_uo = voronoi
    []
  []
[]

[AuxVariables]
  # Dependent variables
  [unique_grains]
  []

  [var_indices]
  []

  [ghost_regions]
  []

  [halos]
  []

  [halo0]
  []

  [halo1]
  []

  [halo2]
  []

  [halo3]
  []

  [halo4]
  []

  [halo5]
  []

  [halo6]
  []

  [halo7]
  []

  [halo8]
  []

  [halo9]
  []

  [halo10]
  []

  [halo11]
  []

  [halo12]
  []

  [halo13]
  []

  [halo14]
  []

  [proc]
  []
[]

[AuxKernels]
  # AuxKernel block, defining the equations used to calculate the auxvars
  [unique_grains]
    type = FeatureFloodCountAux
    variable = unique_grains
    flood_counter = grain_tracker
    field_display = UNIQUE_REGION
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [var_indices]
    type = FeatureFloodCountAux
    variable = var_indices
    flood_counter = grain_tracker
    field_display = VARIABLE_COLORING
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [ghosted_entities]
    type = FeatureFloodCountAux
    variable = ghost_regions
    flood_counter = grain_tracker
    field_display = GHOSTED_ENTITIES
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [halos]
    type = FeatureFloodCountAux
    variable = halos
    flood_counter = voronoi
    field_display = HALOS
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [halo0]
    type = FeatureFloodCountAux
    variable = halo0
    map_index = 0
    field_display = HALOS
    flood_counter = grain_tracker
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [halo1]
    type = FeatureFloodCountAux
    variable = halo1
    map_index = 1
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo2]
    type = FeatureFloodCountAux
    variable = halo2
    map_index = 2
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo3]
    type = FeatureFloodCountAux
    variable = halo3
    map_index = 3
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo4]
    type = FeatureFloodCountAux
    variable = halo4
    map_index = 4
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo5]
    type = FeatureFloodCountAux
    variable = halo5
    map_index = 5
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo6]
    type = FeatureFloodCountAux
    variable = halo6
    map_index = 6
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo7]
    type = FeatureFloodCountAux
    variable = halo7
    map_index = 7
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo8]
    type = FeatureFloodCountAux
    variable = halo8
    map_index = 8
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo9]
    type = FeatureFloodCountAux
    variable = halo9
    map_index = 9
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo10]
    type = FeatureFloodCountAux
    variable = halo10
    map_index = 10
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo11]
    type = FeatureFloodCountAux
    variable = halo11
    map_index = 11
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo12]
    type = FeatureFloodCountAux
    variable = halo12
    map_index = 12
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo13]
    type = FeatureFloodCountAux
    variable = halo13
    map_index = 13
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [halo14]
    type = FeatureFloodCountAux
    variable = halo14
    map_index = 14
    field_display = HALOS
    flood_counter = grain_tracker
  []
  [proc]
    type = ProcessorIDAux
    variable = proc
    execute_on = &#x27;initial timestep_end&#x27;
  []

[]

[Materials]
  [CuGrGr]
    # Material properties
    type = GBEvolution
    T = 450 # Constant temperature of the simulation (for mobility calculation)
    wGB = 125 # Width of the diffuse GB
    GBmob0 = 2.5e-6 #m^4(Js) for copper from schonfelder1997molecular bibtex entry
    Q = 0.23 #eV for copper from schonfelder1997molecular bibtex entry
    GBenergy = 0.708 #J/m^2 from schonfelder1997molecular bibtex entry
  []
[]

[Postprocessors]
  # Scalar postprocessors
  [dt]
    # Outputs the current time step
    type = TimestepSize
  []
[]

[Executioner]
  type = Transient # Type of executioner, here it is transient with an adaptive time step
  scheme = bdf2 # Type of time integration (2nd order backward euler), defaults to 1st order backward euler

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  # Uses newton iteration to solve the problem.
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;asm&#x27;

  l_max_its = 30 # Max number of linear iterations
  l_tol = 1e-4 # Relative tolerance for linear solves
  nl_max_its = 20 # Max number of nonlinear iterations

  start_time = 0.0
  end_time = 4000

  [TimeStepper]
    type = IterationAdaptiveDT
    dt = 25 # Initial time step.  In this simulation it changes.
    optimal_iterations = 6 # Time step will adapt to maintain this number of nonlinear iterations
  []
[]

[Outputs]
  exodus = true
  csv = true
  [pg]
    type = PerfGraphOutput
    execute_on = &#x27;initial final&#x27; # Default is &quot;final&quot;
    level = 2 # Default is 1
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="24d13b46-a9c7-446b-801e-fe97c667aeec"><div class="modal-content"><h4>(moose/modules/phase_field/examples/ebsd_reconstruction/IN100-111grn.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  [ebsd_mesh]
    type = EBSDMeshGenerator
    filename = IN100_120x120.txt
    pre_refine = 2
  []
[]

[GlobalParams]
  op_num = 8
  var_name_base = gr
[]

[UserObjects]
  [ebsd_reader]
    type = EBSDReader
  []
  [ebsd]
    type = PolycrystalEBSD
    coloring_algorithm = bt
    ebsd_reader = ebsd_reader
    enable_var_coloring = true
  []
  [grain_tracker]
    type = GrainTracker
    flood_entity_type = ELEMENTAL
    compute_halo_maps = true # For displaying HALO fields
    polycrystal_ic_uo = ebsd
  []
[]

[ICs]
  [PolycrystalICs]
    [PolycrystalColoringIC]
      polycrystal_ic_uo = ebsd
    []
  []
[]

[Variables]
  [PolycrystalVariables]
  []
[]

[AuxVariables]
  [bnds]
  []
  [unique_grains_ic]
    order = CONSTANT
    family = MONOMIAL
  []
  [unique_grains]
    order = CONSTANT
    family = MONOMIAL
  []
  [ghost_elements]
    order = CONSTANT
    family = MONOMIAL
  []
  [halos]
    order = CONSTANT
    family = MONOMIAL
  []
  [var_indices_ic]
    order = CONSTANT
    family = MONOMIAL
  []
  [var_indices]
    order = CONSTANT
    family = MONOMIAL
  []
  [ebsd_grains]
    family = MONOMIAL
    order = CONSTANT
  []
[]

[Kernels]
  [PolycrystalKernel]
  []
[]

[AuxKernels]
  [BndsCalc]
    type = BndsCalcAux
    variable = bnds
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [ghost_elements]
    type = FeatureFloodCountAux
    variable = ghost_elements
    field_display = GHOSTED_ENTITIES
    execute_on = &#x27;initial timestep_end&#x27;
    flood_counter = grain_tracker
  []
  [halos]
    type = FeatureFloodCountAux
    variable = halos
    field_display = HALOS
    execute_on = &#x27;initial timestep_end&#x27;
    flood_counter = grain_tracker
  []
  [var_indices_ic]
    type = FeatureFloodCountAux
    variable = var_indices_ic
    execute_on = &#x27;initial&#x27;
    flood_counter = ebsd
    field_display = VARIABLE_COLORING
  []
  [unique_grains_ic]
    type = FeatureFloodCountAux
    variable = unique_grains_ic
    execute_on = &#x27;initial&#x27;
    flood_counter = ebsd
    field_display = UNIQUE_REGION
  []
  [var_indices]
    type = FeatureFloodCountAux
    variable = var_indices
    execute_on = &#x27;initial timestep_end&#x27;
    flood_counter = grain_tracker
    field_display = VARIABLE_COLORING
  []
  [unique_grains]
    type = FeatureFloodCountAux
    variable = unique_grains
    execute_on = &#x27;initial timestep_end&#x27;
    flood_counter = grain_tracker
    field_display = UNIQUE_REGION
  []
  [grain_aux]
    type = EBSDReaderPointDataAux
    variable = ebsd_grains
    ebsd_reader = ebsd_reader
    data_name = &#x27;feature_id&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Modules]
  [PhaseField]
    [EulerAngles2RGB]
      crystal_structure = cubic
      euler_angle_provider = ebsd_reader
      grain_tracker = grain_tracker
    []
  []
[]

[Materials]
  [Copper]
    # T = 500 # K
    type = GBEvolution
    T = 500
    wGB = 0.6 # um
    GBmob0 = 2.5e-6 # m^4/(Js) from Schoenfelder 1997
    Q = 0.23 # Migration energy in eV
    GBenergy = 0.708 # GB energy in J/m^2
    molar_volume = 7.11e-6 # Molar volume in m^3/mol
    length_scale = 1.0e-6
    time_scale = 1.0e-6
  []
[]

[Postprocessors]
  [dt]
    type = TimestepSize
  []
  [n_elements]
    type = NumElements
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [n_nodes]
    type = NumNodes
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [DOFs]
    type = NumDOFs
  []
[]

[Executioner]
  type = Transient
  scheme = bdf2
  solve_type = PJFNK

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -pc_hypre_boomeramg_strong_threshold&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      0.7&#x27;

  l_tol = 1.0e-4
  l_max_its = 20
  nl_max_its = 20
  nl_rel_tol = 1.0e-8

  start_time = 0.0
  num_steps = 30

  [TimeStepper]
    type = IterationAdaptiveDT
    cutback_factor = 0.9
    dt = 10.0
    growth_factor = 1.1
    optimal_iterations = 7
  []

  [Adaptivity]
    initial_adaptivity = 2
    refine_fraction = 0.7
    coarsen_fraction = 0.1
    max_h_level = 2
  []
[]

[Outputs]
  exodus = true
  checkpoint = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>